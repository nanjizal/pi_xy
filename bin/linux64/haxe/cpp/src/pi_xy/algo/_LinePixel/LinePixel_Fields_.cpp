// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__LinePixel_LinePixel_Fields_
#include <pi_xy/algo/_LinePixel/LinePixel_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_15_rotateLine,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateLine",0x974d596b,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateLine","pi_xy/algo/LinePixel.hx",15,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_69_rotateSoftLine,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateSoftLine",0x33e3e6f5,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateSoftLine","pi_xy/algo/LinePixel.hx",69,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_123_rotateSoftLineLuxury,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateSoftLineLuxury",0xe58b1de2,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateSoftLineLuxury","pi_xy/algo/LinePixel.hx",123,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_177_rotateSoftLinePartial,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateSoftLinePartial",0x264a110c,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateSoftLinePartial","pi_xy/algo/LinePixel.hx",177,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_226_rotateLineFlare,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateLineFlare",0xf2994763,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateLineFlare","pi_xy/algo/LinePixel.hx",226,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_274_rotateSoftLineFlare,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateSoftLineFlare",0x75636599,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateSoftLineFlare","pi_xy/algo/LinePixel.hx",274,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_322_rotateSoftLineFlarePartial,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateSoftLineFlarePartial",0x1b276ee8,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateSoftLineFlarePartial","pi_xy/algo/LinePixel.hx",322,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_367_rotateTileLine,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateTileLine",0x36b70739,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateTileLine","pi_xy/algo/LinePixel.hx",367,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_416_rotateTileLineFlare,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateTileLineFlare",0xf180ced5,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateTileLineFlare","pi_xy/algo/LinePixel.hx",416,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_461_rotateGradLine,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateGradLine",0xcc14dbd9,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateGradLine","pi_xy/algo/LinePixel.hx",461,0xac4362a0)
HX_LOCAL_STACK_FRAME(_hx_pos_03666c1473745a8e_511_rotateGradLineFlare,"pi_xy.algo._LinePixel.LinePixel_Fields_","rotateGradLineFlare",0x6c9c3635,"pi_xy.algo._LinePixel.LinePixel_Fields_.rotateGradLineFlare","pi_xy/algo/LinePixel.hx",511,0xac4362a0)
namespace pi_xy{
namespace algo{
namespace _LinePixel{

void LinePixel_Fields__obj::__construct() { }

Dynamic LinePixel_Fields__obj::__CreateEmpty() { return new LinePixel_Fields__obj; }

void *LinePixel_Fields__obj::_hx_vtable = 0;

Dynamic LinePixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LinePixel_Fields__obj > _hx_result = new LinePixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool LinePixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x22c71790;
}

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateLine( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta,int color,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_15_rotateLine)
HXLINE(  16)		Float sin = ::Math_obj::sin(theta);
HXLINE(  17)		Float cos = ::Math_obj::cos(theta);
HXLINE(  18)		Float radius = (thick / ( (Float)(2) ));
HXLINE(  19)		Float dx = ((Float)0.1);
HXLINE(  20)		Float dy = radius;
HXLINE(  21)		Float cx = h;
HXLINE(  22)		Float cy = radius;
HXLINE(  23)		Float bx = h;
HXLINE(  24)		Float by = -(radius);
HXLINE(  25)		Float ax = ((Float)0.1);
HXLINE(  26)		Float ay = -(radius);
HXLINE(  27)		Float temp = ((Float)0.);
HXLINE(  28)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  29)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  30)		ax = temp;
HXLINE(  32)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  33)		by = (py + ((by * cos) + (bx * sin)));
HXLINE(  34)		bx = temp;
HXLINE(  36)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  37)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  38)		cx = temp;
HXLINE(  40)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  41)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  42)		dx = temp;
HXLINE(  49)		if (( (bool)(debugCorners) )) {
HXLINE(  50)			{
HXLINE(  50)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN(  50)				{
HXLINE(  50)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN(  50)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN(  50)					int r_w = 12;
HXDLIN(  50)					int r_h = 12;
HXDLIN(  50)					int xmax = ((r_x + r_w) + 1);
HXDLIN(  50)					int ymax = ((r_y + r_h) + 1);
HXDLIN(  50)					int ii_min = r_x;
HXDLIN(  50)					int ii_max = xmax;
HXDLIN(  50)					int xRange__start = ii_min;
HXDLIN(  50)					int xRange__max = ii_max;
HXDLIN(  50)					int ii_min1 = r_y;
HXDLIN(  50)					int ii_max1 = ymax;
HXDLIN(  50)					int yRange__start = ii_min1;
HXDLIN(  50)					int yRange__max = ii_max1;
HXDLIN(  50)					int range_x = xRange__start;
HXDLIN(  50)					int range_y = (yRange__start - 1);
HXDLIN(  50)					int range_xReset = range_x;
HXDLIN(  50)					int range_yReset = range_y;
HXDLIN(  50)					int range_xMax = (xRange__max - 2);
HXDLIN(  50)					int range_yMax = (yRange__max - 2);
HXDLIN(  50)					int _this_min = 0;
HXDLIN(  50)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  50)					while((_this_min < _this_max)){
HXLINE(  50)						_this_min = (_this_min + 1);
HXDLIN(  50)						int i = (_this_min - 1);
HXDLIN(  50)						if ((range_y > range_yMax)) {
HXLINE(  50)							range_y = range_yReset;
HXDLIN(  50)							range_x = (range_x + 1);
            						}
HXDLIN(  50)						range_y = (range_y + 1);
HXDLIN(  50)						int i1 = i;
HXDLIN(  50)						{
HXLINE(  50)							int x = range_x;
HXDLIN(  50)							int y = range_y;
HXDLIN(  50)							int c = -65536;
HXDLIN(  50)							bool _hx_tmp;
HXDLIN(  50)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  50)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  50)								_hx_tmp = false;
            							}
HXDLIN(  50)							if (_hx_tmp) {
HXLINE(  50)								int location;
HXDLIN(  50)								if (this1->useVirtualPos) {
HXLINE(  50)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  50)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN(  50)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN(  50)								int this3;
HXDLIN(  50)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  50)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE(  50)									this3 = this2;
            								}
HXDLIN(  50)								Float a1;
HXDLIN(  50)								int this4 = ((this3 >> 24) & 255);
HXDLIN(  50)								if ((this4 == 0)) {
HXLINE(  50)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float r1;
HXDLIN(  50)								int this5 = ((this3 >> 16) & 255);
HXDLIN(  50)								if ((this5 == 0)) {
HXLINE(  50)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float g1;
HXDLIN(  50)								int this6 = ((this3 >> 8) & 255);
HXDLIN(  50)								if ((this6 == 0)) {
HXLINE(  50)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float b1;
HXDLIN(  50)								int this7 = (this3 & 255);
HXDLIN(  50)								if ((this7 == 0)) {
HXLINE(  50)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float a2;
HXDLIN(  50)								int this8 = ((-65536 >> 24) & 255);
HXDLIN(  50)								if ((this8 == 0)) {
HXLINE(  50)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float r2;
HXDLIN(  50)								int this9 = ((-65536 >> 16) & 255);
HXDLIN(  50)								if ((this9 == 0)) {
HXLINE(  50)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float g2;
HXDLIN(  50)								int this10 = ((-65536 >> 8) & 255);
HXDLIN(  50)								if ((this10 == 0)) {
HXLINE(  50)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float b2;
HXDLIN(  50)								int this11 = (-65536 & 255);
HXDLIN(  50)								if ((this11 == 0)) {
HXLINE(  50)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  50)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  50)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  50)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  50)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  50)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  50)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  50)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  50)								{
HXLINE(  50)									int _hx_tmp1;
HXDLIN(  50)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  50)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  50)										_hx_tmp1 = blended;
            									}
HXDLIN(  50)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE(  50)								::Dynamic this12 = this1->image;
HXDLIN(  50)								int index;
HXDLIN(  50)								if (this1->useVirtualPos) {
HXLINE(  50)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  50)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN(  50)								int _hx_tmp2;
HXDLIN(  50)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  50)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  50)									_hx_tmp2 = c;
            								}
HXDLIN(  50)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE(  51)			{
HXLINE(  51)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN(  51)				{
HXLINE(  51)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN(  51)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN(  51)					int r_w1 = 12;
HXDLIN(  51)					int r_h1 = 12;
HXDLIN(  51)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  51)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  51)					int ii_min2 = r_x1;
HXDLIN(  51)					int ii_max2 = xmax1;
HXDLIN(  51)					int xRange__start1 = ii_min2;
HXDLIN(  51)					int xRange__max1 = ii_max2;
HXDLIN(  51)					int ii_min3 = r_y1;
HXDLIN(  51)					int ii_max3 = ymax1;
HXDLIN(  51)					int yRange__start1 = ii_min3;
HXDLIN(  51)					int yRange__max1 = ii_max3;
HXDLIN(  51)					int range_x1 = xRange__start1;
HXDLIN(  51)					int range_y1 = (yRange__start1 - 1);
HXDLIN(  51)					int range_xReset1 = range_x1;
HXDLIN(  51)					int range_yReset1 = range_y1;
HXDLIN(  51)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  51)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  51)					int _this_min1 = 0;
HXDLIN(  51)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  51)					while((_this_min1 < _this_max1)){
HXLINE(  51)						_this_min1 = (_this_min1 + 1);
HXDLIN(  51)						int i2 = (_this_min1 - 1);
HXDLIN(  51)						if ((range_y1 > range_yMax1)) {
HXLINE(  51)							range_y1 = range_yReset1;
HXDLIN(  51)							range_x1 = (range_x1 + 1);
            						}
HXDLIN(  51)						range_y1 = (range_y1 + 1);
HXDLIN(  51)						int i3 = i2;
HXDLIN(  51)						{
HXLINE(  51)							int x1 = range_x1;
HXDLIN(  51)							int y1 = range_y1;
HXDLIN(  51)							int c1 = -16711936;
HXDLIN(  51)							bool _hx_tmp3;
HXDLIN(  51)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  51)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE(  51)								_hx_tmp3 = false;
            							}
HXDLIN(  51)							if (_hx_tmp3) {
HXLINE(  51)								int location1;
HXDLIN(  51)								if (this13->useVirtualPos) {
HXLINE(  51)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE(  51)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN(  51)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN(  51)								int this15;
HXDLIN(  51)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE(  51)									this15 = this14;
            								}
HXDLIN(  51)								Float a11;
HXDLIN(  51)								int this16 = ((this15 >> 24) & 255);
HXDLIN(  51)								if ((this16 == 0)) {
HXLINE(  51)									a11 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float r11;
HXDLIN(  51)								int this17 = ((this15 >> 16) & 255);
HXDLIN(  51)								if ((this17 == 0)) {
HXLINE(  51)									r11 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float g11;
HXDLIN(  51)								int this18 = ((this15 >> 8) & 255);
HXDLIN(  51)								if ((this18 == 0)) {
HXLINE(  51)									g11 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float b11;
HXDLIN(  51)								int this19 = (this15 & 255);
HXDLIN(  51)								if ((this19 == 0)) {
HXLINE(  51)									b11 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float a21;
HXDLIN(  51)								int this20 = ((-16711936 >> 24) & 255);
HXDLIN(  51)								if ((this20 == 0)) {
HXLINE(  51)									a21 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float r21;
HXDLIN(  51)								int this21 = ((-16711936 >> 16) & 255);
HXDLIN(  51)								if ((this21 == 0)) {
HXLINE(  51)									r21 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float g21;
HXDLIN(  51)								int this22 = ((-16711936 >> 8) & 255);
HXDLIN(  51)								if ((this22 == 0)) {
HXLINE(  51)									g21 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float b21;
HXDLIN(  51)								int this23 = (-16711936 & 255);
HXDLIN(  51)								if ((this23 == 0)) {
HXLINE(  51)									b21 = ((Float)0.);
            								}
            								else {
HXLINE(  51)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN(  51)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  51)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  51)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  51)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  51)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  51)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  51)								{
HXLINE(  51)									int _hx_tmp4;
HXDLIN(  51)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE(  51)										_hx_tmp4 = blended1;
            									}
HXDLIN(  51)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE(  51)								::Dynamic this24 = this13->image;
HXDLIN(  51)								int index1;
HXDLIN(  51)								if (this13->useVirtualPos) {
HXLINE(  51)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE(  51)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN(  51)								int _hx_tmp5;
HXDLIN(  51)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  51)									_hx_tmp5 = c1;
            								}
HXDLIN(  51)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE(  52)			{
HXLINE(  52)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN(  52)				{
HXLINE(  52)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN(  52)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN(  52)					int r_w2 = 12;
HXDLIN(  52)					int r_h2 = 12;
HXDLIN(  52)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  52)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  52)					int ii_min4 = r_x2;
HXDLIN(  52)					int ii_max4 = xmax2;
HXDLIN(  52)					int xRange__start2 = ii_min4;
HXDLIN(  52)					int xRange__max2 = ii_max4;
HXDLIN(  52)					int ii_min5 = r_y2;
HXDLIN(  52)					int ii_max5 = ymax2;
HXDLIN(  52)					int yRange__start2 = ii_min5;
HXDLIN(  52)					int yRange__max2 = ii_max5;
HXDLIN(  52)					int range_x2 = xRange__start2;
HXDLIN(  52)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  52)					int range_xReset2 = range_x2;
HXDLIN(  52)					int range_yReset2 = range_y2;
HXDLIN(  52)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  52)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  52)					int _this_min2 = 0;
HXDLIN(  52)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  52)					while((_this_min2 < _this_max2)){
HXLINE(  52)						_this_min2 = (_this_min2 + 1);
HXDLIN(  52)						int i4 = (_this_min2 - 1);
HXDLIN(  52)						if ((range_y2 > range_yMax2)) {
HXLINE(  52)							range_y2 = range_yReset2;
HXDLIN(  52)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  52)						range_y2 = (range_y2 + 1);
HXDLIN(  52)						int i5 = i4;
HXDLIN(  52)						{
HXLINE(  52)							int x2 = range_x2;
HXDLIN(  52)							int y2 = range_y2;
HXDLIN(  52)							int c2 = -16776961;
HXDLIN(  52)							bool _hx_tmp6;
HXDLIN(  52)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  52)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE(  52)								_hx_tmp6 = false;
            							}
HXDLIN(  52)							if (_hx_tmp6) {
HXLINE(  52)								int location2;
HXDLIN(  52)								if (this25->useVirtualPos) {
HXLINE(  52)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE(  52)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN(  52)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN(  52)								int this27;
HXDLIN(  52)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE(  52)									this27 = this26;
            								}
HXDLIN(  52)								Float a12;
HXDLIN(  52)								int this28 = ((this27 >> 24) & 255);
HXDLIN(  52)								if ((this28 == 0)) {
HXLINE(  52)									a12 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float r12;
HXDLIN(  52)								int this29 = ((this27 >> 16) & 255);
HXDLIN(  52)								if ((this29 == 0)) {
HXLINE(  52)									r12 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float g12;
HXDLIN(  52)								int this30 = ((this27 >> 8) & 255);
HXDLIN(  52)								if ((this30 == 0)) {
HXLINE(  52)									g12 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float b12;
HXDLIN(  52)								int this31 = (this27 & 255);
HXDLIN(  52)								if ((this31 == 0)) {
HXLINE(  52)									b12 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float a22;
HXDLIN(  52)								int this32 = ((-16776961 >> 24) & 255);
HXDLIN(  52)								if ((this32 == 0)) {
HXLINE(  52)									a22 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float r22;
HXDLIN(  52)								int this33 = ((-16776961 >> 16) & 255);
HXDLIN(  52)								if ((this33 == 0)) {
HXLINE(  52)									r22 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float g22;
HXDLIN(  52)								int this34 = ((-16776961 >> 8) & 255);
HXDLIN(  52)								if ((this34 == 0)) {
HXLINE(  52)									g22 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float b22;
HXDLIN(  52)								int this35 = (-16776961 & 255);
HXDLIN(  52)								if ((this35 == 0)) {
HXLINE(  52)									b22 = ((Float)0.);
            								}
            								else {
HXLINE(  52)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  52)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  52)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  52)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  52)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  52)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  52)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN(  52)								{
HXLINE(  52)									int _hx_tmp7;
HXDLIN(  52)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE(  52)										_hx_tmp7 = blended2;
            									}
HXDLIN(  52)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE(  52)								::Dynamic this36 = this25->image;
HXDLIN(  52)								int index2;
HXDLIN(  52)								if (this25->useVirtualPos) {
HXLINE(  52)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE(  52)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN(  52)								int _hx_tmp8;
HXDLIN(  52)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE(  52)									_hx_tmp8 = c2;
            								}
HXDLIN(  52)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE(  53)			{
HXLINE(  53)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN(  53)				{
HXLINE(  53)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN(  53)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN(  53)					int r_w3 = 12;
HXDLIN(  53)					int r_h3 = 12;
HXDLIN(  53)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  53)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  53)					int ii_min6 = r_x3;
HXDLIN(  53)					int ii_max6 = xmax3;
HXDLIN(  53)					int xRange__start3 = ii_min6;
HXDLIN(  53)					int xRange__max3 = ii_max6;
HXDLIN(  53)					int ii_min7 = r_y3;
HXDLIN(  53)					int ii_max7 = ymax3;
HXDLIN(  53)					int yRange__start3 = ii_min7;
HXDLIN(  53)					int yRange__max3 = ii_max7;
HXDLIN(  53)					int range_x3 = xRange__start3;
HXDLIN(  53)					int range_y3 = (yRange__start3 - 1);
HXDLIN(  53)					int range_xReset3 = range_x3;
HXDLIN(  53)					int range_yReset3 = range_y3;
HXDLIN(  53)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  53)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  53)					int _this_min3 = 0;
HXDLIN(  53)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  53)					while((_this_min3 < _this_max3)){
HXLINE(  53)						_this_min3 = (_this_min3 + 1);
HXDLIN(  53)						int i6 = (_this_min3 - 1);
HXDLIN(  53)						if ((range_y3 > range_yMax3)) {
HXLINE(  53)							range_y3 = range_yReset3;
HXDLIN(  53)							range_x3 = (range_x3 + 1);
            						}
HXDLIN(  53)						range_y3 = (range_y3 + 1);
HXDLIN(  53)						int i7 = i6;
HXDLIN(  53)						{
HXLINE(  53)							int x3 = range_x3;
HXDLIN(  53)							int y3 = range_y3;
HXDLIN(  53)							int c3 = -1048336;
HXDLIN(  53)							bool _hx_tmp9;
HXDLIN(  53)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  53)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE(  53)								_hx_tmp9 = false;
            							}
HXDLIN(  53)							if (_hx_tmp9) {
HXLINE(  53)								int location3;
HXDLIN(  53)								if (this37->useVirtualPos) {
HXLINE(  53)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE(  53)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN(  53)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN(  53)								int this39;
HXDLIN(  53)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE(  53)									this39 = this38;
            								}
HXDLIN(  53)								Float a13;
HXDLIN(  53)								int this40 = ((this39 >> 24) & 255);
HXDLIN(  53)								if ((this40 == 0)) {
HXLINE(  53)									a13 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float r13;
HXDLIN(  53)								int this41 = ((this39 >> 16) & 255);
HXDLIN(  53)								if ((this41 == 0)) {
HXLINE(  53)									r13 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float g13;
HXDLIN(  53)								int this42 = ((this39 >> 8) & 255);
HXDLIN(  53)								if ((this42 == 0)) {
HXLINE(  53)									g13 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float b13;
HXDLIN(  53)								int this43 = (this39 & 255);
HXDLIN(  53)								if ((this43 == 0)) {
HXLINE(  53)									b13 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float a23;
HXDLIN(  53)								int this44 = ((-1048336 >> 24) & 255);
HXDLIN(  53)								if ((this44 == 0)) {
HXLINE(  53)									a23 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float r23;
HXDLIN(  53)								int this45 = ((-1048336 >> 16) & 255);
HXDLIN(  53)								if ((this45 == 0)) {
HXLINE(  53)									r23 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float g23;
HXDLIN(  53)								int this46 = ((-1048336 >> 8) & 255);
HXDLIN(  53)								if ((this46 == 0)) {
HXLINE(  53)									g23 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float b23;
HXDLIN(  53)								int this47 = (-1048336 & 255);
HXDLIN(  53)								if ((this47 == 0)) {
HXLINE(  53)									b23 = ((Float)0.);
            								}
            								else {
HXLINE(  53)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN(  53)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  53)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  53)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  53)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  53)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  53)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN(  53)								{
HXLINE(  53)									int _hx_tmp10;
HXDLIN(  53)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE(  53)										_hx_tmp10 = blended3;
            									}
HXDLIN(  53)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE(  53)								::Dynamic this48 = this37->image;
HXDLIN(  53)								int index3;
HXDLIN(  53)								if (this37->useVirtualPos) {
HXLINE(  53)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE(  53)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN(  53)								int _hx_tmp11;
HXDLIN(  53)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE(  53)									_hx_tmp11 = c3;
            								}
HXDLIN(  53)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  55)		{
HXLINE(  55)			Float bx1 = bx;
HXDLIN(  55)			Float by1 = by;
HXDLIN(  55)			Float cx1 = dx;
HXDLIN(  55)			Float cy1 = dy;
HXDLIN(  55)			bool hasUndo = false;
HXDLIN(  55)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  55)			if (!(adjustWinding)) {
HXLINE(  55)				Float bx_ = bx1;
HXDLIN(  55)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE(  55)			{
HXLINE(  55)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  55)				Float sx = (cy1 - ay);
HXDLIN(  55)				Float sy = (ax - cx1);
HXDLIN(  55)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  55)				Float tx = (ay - by1);
HXDLIN(  55)				Float ty = (bx1 - ax);
HXDLIN(  55)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  55)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  55)				if ((ax > bx1)) {
HXLINE(  55)					if ((ax > cx1)) {
HXLINE(  55)						int min;
HXDLIN(  55)						if ((bx1 > cx1)) {
HXLINE(  55)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  55)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  55)						int ii_min8 = min;
HXDLIN(  55)						int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  55)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  55)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  55)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN(  55)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  55)					if ((bx1 > cx1)) {
HXLINE(  55)						int min1;
HXDLIN(  55)						if ((ax > cx1)) {
HXLINE(  55)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  55)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  55)						int ii_min10 = min1;
HXDLIN(  55)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  55)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  55)						int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  55)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN(  55)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  55)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  55)				if ((ay > by1)) {
HXLINE(  55)					if ((ay > cy1)) {
HXLINE(  55)						int min2;
HXDLIN(  55)						if ((by1 > cy1)) {
HXLINE(  55)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  55)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  55)						int ii_min12 = min2;
HXDLIN(  55)						int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  55)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  55)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  55)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN(  55)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  55)					if ((by1 > cy1)) {
HXLINE(  55)						int min3;
HXDLIN(  55)						if ((ay > cy1)) {
HXLINE(  55)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  55)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  55)						int ii_min14 = min3;
HXDLIN(  55)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  55)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  55)						int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  55)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN(  55)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  55)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  55)				if (hasUndo) {
HXLINE(  55)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  55)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  55)					 ::Dynamic imageType = null();
HXDLIN(  55)					 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  55)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  55)					::Dynamic undoImage1;
HXDLIN(  55)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE(  55)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::BytesImg b6 = byt;
HXDLIN(  55)							{
HXLINE(  55)								b6->width = width;
HXDLIN(  55)								b6->height = height;
HXDLIN(  55)								b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  55)								{
HXLINE(  55)									int len = b6->length;
HXDLIN(  55)									int w = 0;
HXDLIN(  55)									{
HXLINE(  55)										int _g = 0;
HXDLIN(  55)										int _g1 = b6->height;
HXDLIN(  55)										while((_g < _g1)){
HXLINE(  55)											_g = (_g + 1);
HXDLIN(  55)											int y4 = (_g - 1);
HXDLIN(  55)											{
HXLINE(  55)												int _g2 = 0;
HXDLIN(  55)												int _g3 = b6->width;
HXDLIN(  55)												while((_g2 < _g3)){
HXLINE(  55)													_g2 = (_g2 + 1);
HXDLIN(  55)													int x4 = (_g2 - 1);
HXDLIN(  55)													{
HXLINE(  55)														w = (w + 1);
HXDLIN(  55)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w = (w + 1);
HXDLIN(  55)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w = (w + 1);
HXDLIN(  55)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w = (w + 1);
HXDLIN(  55)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage1 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE(  55)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN(  55)							{
HXLINE(  55)								a7->width = width;
HXDLIN(  55)								a7->height = height;
HXDLIN(  55)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  55)								a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)								{
HXLINE(  55)									int _g4 = 0;
HXDLIN(  55)									int _g5 = a7->length;
HXDLIN(  55)									while((_g4 < _g5)){
HXLINE(  55)										_g4 = (_g4 + 1);
HXDLIN(  55)										int i8 = (_g4 - 1);
HXDLIN(  55)										a7->data[i8] = 0;
            									}
            								}
            							}
HXDLIN(  55)							undoImage1 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE(  55)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN(  55)							{
HXLINE(  55)								b7->width = width;
HXDLIN(  55)								b7->height = height;
HXDLIN(  55)								b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)								int size = (b7->length * 4);
HXDLIN(  55)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  55)								{
HXLINE(  55)									int _g6 = 0;
HXDLIN(  55)									int _g7 = b7->length;
HXDLIN(  55)									while((_g6 < _g7)){
HXLINE(  55)										_g6 = (_g6 + 1);
HXDLIN(  55)										int i9 = (_g6 - 1);
HXDLIN(  55)										{
HXLINE(  55)											 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN(  55)											bool undoImage2;
HXDLIN(  55)											if ((i9 >= 0)) {
HXLINE(  55)												undoImage2 = (i9 < (this50->byteLength >> 2));
            											}
            											else {
HXLINE(  55)												undoImage2 = false;
            											}
HXDLIN(  55)											if (undoImage2) {
HXLINE(  55)												 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN(  55)												int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN(  55)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  55)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  55)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  55)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage1 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE(  55)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  55)							{
HXLINE(  55)								v->width = width;
HXDLIN(  55)								v->height = height;
HXDLIN(  55)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  55)								{
HXLINE(  55)									int _g8 = 0;
HXDLIN(  55)									int _g9 = v->length;
HXDLIN(  55)									while((_g8 < _g9)){
HXLINE(  55)										_g8 = (_g8 + 1);
HXDLIN(  55)										int i10 = (_g8 - 1);
HXDLIN(  55)										v->data->__unsafe_set(i10,0);
            									}
            								}
            							}
HXDLIN(  55)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE(  55)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN(  55)							{
HXLINE(  55)								b8->width = width;
HXDLIN(  55)								b8->height = height;
HXDLIN(  55)								b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  55)								{
HXLINE(  55)									int len1 = b8->length;
HXDLIN(  55)									 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN(  55)									if (::hx::IsNull( d->head )) {
HXLINE(  55)										int _g10 = 0;
HXDLIN(  55)										int _g11 = len1;
HXDLIN(  55)										while((_g10 < _g11)){
HXLINE(  55)											_g10 = (_g10 + 1);
HXDLIN(  55)											int i11 = (_g10 - 1);
HXDLIN(  55)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE(  55)										int _g12 = 0;
HXDLIN(  55)										int _g13 = len1;
HXDLIN(  55)										while((_g12 < _g13)){
HXLINE(  55)											_g12 = (_g12 + 1);
HXDLIN(  55)											int i12 = (_g12 - 1);
HXDLIN(  55)											{
HXLINE(  55)												 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN(  55)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  55)												{
HXLINE(  55)													int _g14 = 0;
HXDLIN(  55)													int _g15 = i12;
HXDLIN(  55)													while((_g14 < _g15)){
HXLINE(  55)														_g14 = (_g14 + 1);
HXDLIN(  55)														int i13 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  55)												if (::hx::IsNull( prev )) {
HXLINE(  55)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)													l = null();
            												}
            												else {
HXLINE(  55)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage1 = b8;
            						}
            						break;
            					}
HXDLIN(  55)					this49->image = undoImage1;
HXDLIN(  55)					this49->width = width;
HXDLIN(  55)					this49->height = height;
HXDLIN(  55)					this49->imageType = ( (int)(imageType) );
HXDLIN(  55)					undoImage = this49;
HXDLIN(  55)					{
HXLINE(  55)						int rectLeft = xIter3->start;
HXDLIN(  55)						int rectTop = yIter3->start;
HXDLIN(  55)						int rectRight = xIter3->max;
HXDLIN(  55)						bool forceClear = false;
HXDLIN(  55)						{
HXLINE(  55)							int _g16 = rectTop;
HXDLIN(  55)							int _g17 = yIter3->max;
HXDLIN(  55)							while((_g16 < _g17)){
HXLINE(  55)								_g16 = (_g16 + 1);
HXDLIN(  55)								int dy1 = (_g16 - 1);
HXDLIN(  55)								{
HXLINE(  55)									int _g18 = rectLeft;
HXDLIN(  55)									int _g19 = rectRight;
HXDLIN(  55)									while((_g18 < _g19)){
HXLINE(  55)										_g18 = (_g18 + 1);
HXDLIN(  55)										int dx1 = (_g18 - 1);
HXDLIN(  55)										::Dynamic this51 = pixelImage->image;
HXDLIN(  55)										int index4;
HXDLIN(  55)										if (pixelImage->useVirtualPos) {
HXLINE(  55)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  55)											index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN(  55)										int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN(  55)										int col;
HXDLIN(  55)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)											col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  55)											col = c4;
            										}
HXDLIN(  55)										bool _hx_tmp12;
HXDLIN(  55)										if (pixelImage->useMask) {
HXLINE(  55)											_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE(  55)											_hx_tmp12 = false;
            										}
HXDLIN(  55)										if (_hx_tmp12) {
HXLINE(  55)											 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN(  55)											::Dynamic this53 = this52->image;
HXDLIN(  55)											int index5;
HXDLIN(  55)											if (this52->useVirtualPos) {
HXLINE(  55)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            											}
            											else {
HXLINE(  55)												index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            											}
HXDLIN(  55)											int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN(  55)											int v1;
HXDLIN(  55)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)												v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  55)												v1 = c5;
            											}
HXDLIN(  55)											int maskPixel = v1;
HXDLIN(  55)											int this54 = col;
HXDLIN(  55)											if ((maskPixel == 0)) {
HXLINE(  55)												col = this54;
            											}
            											else {
HXLINE(  55)												Float m0;
HXDLIN(  55)												int this55 = ((maskPixel >> 24) & 255);
HXDLIN(  55)												if ((this55 == 0)) {
HXLINE(  55)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m1;
HXDLIN(  55)												int this56 = ((maskPixel >> 16) & 255);
HXDLIN(  55)												if ((this56 == 0)) {
HXLINE(  55)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m2;
HXDLIN(  55)												int this57 = ((maskPixel >> 8) & 255);
HXDLIN(  55)												if ((this57 == 0)) {
HXLINE(  55)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m3;
HXDLIN(  55)												int this58 = (maskPixel & 255);
HXDLIN(  55)												if ((this58 == 0)) {
HXLINE(  55)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN(  55)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN(  55)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN(  55)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN(  55)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  55)										if ((col != 0)) {
HXLINE(  55)											int x5 = (dx1 - rectLeft);
HXDLIN(  55)											int y5 = (dy1 - rectTop);
HXDLIN(  55)											int c6 = col;
HXDLIN(  55)											bool _hx_tmp13;
HXDLIN(  55)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  55)												_hx_tmp13 = undoImage->transparent;
            											}
            											else {
HXLINE(  55)												_hx_tmp13 = false;
            											}
HXDLIN(  55)											if (_hx_tmp13) {
HXLINE(  55)												int location4;
HXDLIN(  55)												if (undoImage->useVirtualPos) {
HXLINE(  55)													location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  55)													location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  55)												int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  55)												int this60;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													this60 = this59;
            												}
HXDLIN(  55)												Float a14;
HXDLIN(  55)												int this61 = ((this60 >> 24) & 255);
HXDLIN(  55)												if ((this61 == 0)) {
HXLINE(  55)													a14 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r14;
HXDLIN(  55)												int this62 = ((this60 >> 16) & 255);
HXDLIN(  55)												if ((this62 == 0)) {
HXLINE(  55)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g14;
HXDLIN(  55)												int this63 = ((this60 >> 8) & 255);
HXDLIN(  55)												if ((this63 == 0)) {
HXLINE(  55)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b14;
HXDLIN(  55)												int this64 = (this60 & 255);
HXDLIN(  55)												if ((this64 == 0)) {
HXLINE(  55)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a24;
HXDLIN(  55)												int this65 = ((col >> 24) & 255);
HXDLIN(  55)												if ((this65 == 0)) {
HXLINE(  55)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r24;
HXDLIN(  55)												int this66 = ((col >> 16) & 255);
HXDLIN(  55)												if ((this66 == 0)) {
HXLINE(  55)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g24;
HXDLIN(  55)												int this67 = ((col >> 8) & 255);
HXDLIN(  55)												if ((this67 == 0)) {
HXLINE(  55)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b24;
HXDLIN(  55)												int this68 = (col & 255);
HXDLIN(  55)												if ((this68 == 0)) {
HXLINE(  55)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  55)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  55)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  55)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN(  55)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  55)												int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  55)												{
HXLINE(  55)													int _hx_tmp14;
HXDLIN(  55)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)														_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  55)														_hx_tmp14 = blended4;
            													}
HXDLIN(  55)													::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            												}
            											}
            											else {
HXLINE(  55)												::Dynamic this69 = undoImage->image;
HXDLIN(  55)												int index6;
HXDLIN(  55)												if (undoImage->useVirtualPos) {
HXLINE(  55)													index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  55)													index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  55)												int _hx_tmp15;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													_hx_tmp15 = c6;
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            											}
            										}
            										else {
HXLINE(  55)											if (forceClear) {
HXLINE(  55)												::Dynamic this70 = undoImage->image;
HXDLIN(  55)												int x6 = (dx1 - rectLeft);
HXDLIN(  55)												int y6 = (dy1 - rectTop);
HXDLIN(  55)												int index7;
HXDLIN(  55)												if (undoImage->useVirtualPos) {
HXLINE(  55)													index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            												}
            												else {
HXLINE(  55)													index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this70,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				bool found = false;
HXDLIN(  55)				Float s = ((Float)0.);
HXDLIN(  55)				Float t = ((Float)0.);
HXDLIN(  55)				Float sxx = ((Float)0.);
HXDLIN(  55)				Float txx = ((Float)0.);
HXDLIN(  55)				{
HXLINE(  55)					int _g_min = xIter3->start;
HXDLIN(  55)					int _g_max = xIter3->max;
HXDLIN(  55)					while((_g_min < _g_max)){
HXLINE(  55)						_g_min = (_g_min + 1);
HXDLIN(  55)						int x7 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x7) ));
HXLINE(  61)						txx = (tx * ( (Float)(x7) ));
HXLINE(  62)						found = false;
HXLINE(  55)						{
HXLINE(  55)							int _g_min1 = yIter3->start;
HXDLIN(  55)							int _g_max1 = yIter3->max;
HXDLIN(  55)							while((_g_min1 < _g_max1)){
HXLINE(  55)								_g_min1 = (_g_min1 + 1);
HXDLIN(  55)								int y7 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y7) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y7) )));
HXLINE(  55)								bool _hx_tmp16;
HXDLIN(  55)								if (!((s <= 0))) {
HXLINE(  55)									_hx_tmp16 = (t <= 0);
            								}
            								else {
HXLINE(  55)									_hx_tmp16 = true;
            								}
HXDLIN(  55)								if (_hx_tmp16) {
HXLINE(  55)									if (found) {
HXLINE(  55)										goto _hx_goto_15;
            									}
            								}
            								else {
HXLINE(  55)									if (((s + t) < A)) {
HXLINE(  55)										{
HXLINE(  55)											int c7 = color;
HXDLIN(  55)											bool _hx_tmp17;
HXDLIN(  55)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  55)												_hx_tmp17 = pixelImage->transparent;
            											}
            											else {
HXLINE(  55)												_hx_tmp17 = false;
            											}
HXDLIN(  55)											if (_hx_tmp17) {
HXLINE(  55)												int location5;
HXDLIN(  55)												if (pixelImage->useVirtualPos) {
HXLINE(  55)													location5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  55)													location5 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN(  55)												int this71 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN(  55)												int this72;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													this72 = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													this72 = this71;
            												}
HXDLIN(  55)												Float a15;
HXDLIN(  55)												int this73 = ((this72 >> 24) & 255);
HXDLIN(  55)												if ((this73 == 0)) {
HXLINE(  55)													a15 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a15 = (( (Float)(this73) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r15;
HXDLIN(  55)												int this74 = ((this72 >> 16) & 255);
HXDLIN(  55)												if ((this74 == 0)) {
HXLINE(  55)													r15 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r15 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g15;
HXDLIN(  55)												int this75 = ((this72 >> 8) & 255);
HXDLIN(  55)												if ((this75 == 0)) {
HXLINE(  55)													g15 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g15 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b15;
HXDLIN(  55)												int this76 = (this72 & 255);
HXDLIN(  55)												if ((this76 == 0)) {
HXLINE(  55)													b15 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b15 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a25;
HXDLIN(  55)												int this77 = ((color >> 24) & 255);
HXDLIN(  55)												if ((this77 == 0)) {
HXLINE(  55)													a25 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a25 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r25;
HXDLIN(  55)												int this78 = ((color >> 16) & 255);
HXDLIN(  55)												if ((this78 == 0)) {
HXLINE(  55)													r25 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r25 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g25;
HXDLIN(  55)												int this79 = ((color >> 8) & 255);
HXDLIN(  55)												if ((this79 == 0)) {
HXLINE(  55)													g25 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g25 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b25;
HXDLIN(  55)												int this80 = (color & 255);
HXDLIN(  55)												if ((this80 == 0)) {
HXLINE(  55)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b25 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  55)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  55)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  55)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN(  55)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  55)												int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN(  55)												{
HXLINE(  55)													int _hx_tmp18;
HXDLIN(  55)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)														_hx_tmp18 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE(  55)														_hx_tmp18 = blended5;
            													}
HXDLIN(  55)													::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp18);
            												}
            											}
            											else {
HXLINE(  55)												::Dynamic this81 = pixelImage->image;
HXDLIN(  55)												int index8;
HXDLIN(  55)												if (pixelImage->useVirtualPos) {
HXLINE(  55)													index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  55)													index8 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN(  55)												int _hx_tmp19;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													_hx_tmp19 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													_hx_tmp19 = c7;
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this81,index8,_hx_tmp19);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXLINE(  55)										if (found) {
HXLINE(  55)											goto _hx_goto_15;
            										}
            									}
            								}
            							}
            							_hx_goto_15:;
            						}
            					}
            				}
HXDLIN(  55)				if ((hasHit == true)) {
HXLINE(  55)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  55)					if (hasUndo) {
HXLINE(  55)						v2->undoImage = undoImage;
HXDLIN(  55)						v2->undoX = xIter3->start;
HXDLIN(  55)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  55)		{
HXLINE(  55)			Float bx2 = cx;
HXDLIN(  55)			Float by2 = cy;
HXDLIN(  55)			Float cx2 = dx;
HXDLIN(  55)			Float cy2 = dy;
HXDLIN(  55)			bool hasUndo1 = false;
HXDLIN(  55)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  55)			if (!(adjustWinding1)) {
HXLINE(  55)				Float bx_1 = bx2;
HXDLIN(  55)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE(  55)			{
HXLINE(  55)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  55)				Float sx1 = (cy2 - by);
HXDLIN(  55)				Float sy1 = (bx - cx2);
HXDLIN(  55)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  55)				Float tx1 = (by - by2);
HXDLIN(  55)				Float ty1 = (bx2 - bx);
HXDLIN(  55)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  55)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  55)				if ((bx > bx2)) {
HXLINE(  55)					if ((bx > cx2)) {
HXLINE(  55)						int min4;
HXDLIN(  55)						if ((bx2 > cx2)) {
HXLINE(  55)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  55)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  55)						int ii_min16 = min4;
HXDLIN(  55)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  55)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE(  55)						int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN(  55)						int ii_max17 = ::Math_obj::ceil(cx2);
HXDLIN(  55)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE(  55)					if ((bx2 > cx2)) {
HXLINE(  55)						int min5;
HXDLIN(  55)						if ((bx > cx2)) {
HXLINE(  55)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  55)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  55)						int ii_min18 = min5;
HXDLIN(  55)						int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN(  55)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE(  55)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  55)						int ii_max19 = ::Math_obj::ceil(cx2);
HXDLIN(  55)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN(  55)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  55)				if ((by > by2)) {
HXLINE(  55)					if ((by > cy2)) {
HXLINE(  55)						int min6;
HXDLIN(  55)						if ((by2 > cy2)) {
HXLINE(  55)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  55)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  55)						int ii_min20 = min6;
HXDLIN(  55)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  55)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE(  55)						int ii_min21 = ::Math_obj::floor(by2);
HXDLIN(  55)						int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN(  55)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE(  55)					if ((by2 > cy2)) {
HXLINE(  55)						int min7;
HXDLIN(  55)						if ((by > cy2)) {
HXLINE(  55)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  55)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  55)						int ii_min22 = min7;
HXDLIN(  55)						int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN(  55)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE(  55)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  55)						int ii_max23 = ::Math_obj::ceil(cy2);
HXDLIN(  55)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN(  55)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  55)				if (hasUndo1) {
HXLINE(  55)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  55)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  55)					 ::Dynamic imageType1 = null();
HXDLIN(  55)					 ::pi_xy::ImageStruct this82 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  55)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  55)					::Dynamic undoImage4;
HXDLIN(  55)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  55)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::BytesImg b16 = byt1;
HXDLIN(  55)							{
HXLINE(  55)								b16->width = width1;
HXDLIN(  55)								b16->height = height1;
HXDLIN(  55)								b16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  55)								b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN(  55)								{
HXLINE(  55)									int len2 = b16->length;
HXDLIN(  55)									int w1 = 0;
HXDLIN(  55)									{
HXLINE(  55)										int _g20 = 0;
HXDLIN(  55)										int _g21 = b16->height;
HXDLIN(  55)										while((_g20 < _g21)){
HXLINE(  55)											_g20 = (_g20 + 1);
HXDLIN(  55)											int y8 = (_g20 - 1);
HXDLIN(  55)											{
HXLINE(  55)												int _g22 = 0;
HXDLIN(  55)												int _g23 = b16->width;
HXDLIN(  55)												while((_g22 < _g23)){
HXLINE(  55)													_g22 = (_g22 + 1);
HXDLIN(  55)													int x8 = (_g22 - 1);
HXDLIN(  55)													{
HXLINE(  55)														w1 = (w1 + 1);
HXDLIN(  55)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w1 = (w1 + 1);
HXDLIN(  55)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w1 = (w1 + 1);
HXDLIN(  55)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  55)													{
HXLINE(  55)														w1 = (w1 + 1);
HXDLIN(  55)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage4 = b16;
            						}
            						break;
            						case (int)1: {
HXLINE(  55)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::ArrIntImg a10 = arrI1;
HXDLIN(  55)							{
HXLINE(  55)								a10->width = width1;
HXDLIN(  55)								a10->height = height1;
HXDLIN(  55)								a10->data = ::Array_obj< int >::__new(0);
HXDLIN(  55)								a10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  55)								{
HXLINE(  55)									int _g24 = 0;
HXDLIN(  55)									int _g25 = a10->length;
HXDLIN(  55)									while((_g24 < _g25)){
HXLINE(  55)										_g24 = (_g24 + 1);
HXDLIN(  55)										int i14 = (_g24 - 1);
HXDLIN(  55)										a10->data[i14] = 0;
            									}
            								}
            							}
HXDLIN(  55)							undoImage4 = a10;
            						}
            						break;
            						case (int)2: {
HXLINE(  55)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::U32ArrImg b17 = u32a1;
HXDLIN(  55)							{
HXLINE(  55)								b17->width = width1;
HXDLIN(  55)								b17->height = height1;
HXDLIN(  55)								b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  55)								int size1 = (b17->length * 4);
HXDLIN(  55)								b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  55)								{
HXLINE(  55)									int _g26 = 0;
HXDLIN(  55)									int _g27 = b17->length;
HXDLIN(  55)									while((_g26 < _g27)){
HXLINE(  55)										_g26 = (_g26 + 1);
HXDLIN(  55)										int i15 = (_g26 - 1);
HXDLIN(  55)										{
HXLINE(  55)											 ::haxe::io::ArrayBufferViewImpl this83 = b17->data;
HXDLIN(  55)											bool undoImage5;
HXDLIN(  55)											if ((i15 >= 0)) {
HXLINE(  55)												undoImage5 = (i15 < (this83->byteLength >> 2));
            											}
            											else {
HXLINE(  55)												undoImage5 = false;
            											}
HXDLIN(  55)											if (undoImage5) {
HXLINE(  55)												 ::haxe::io::Bytes _this1 = this83->bytes;
HXDLIN(  55)												int pos1 = ((i15 << 2) + this83->byteOffset);
HXDLIN(  55)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  55)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  55)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  55)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage4 = b17;
            						}
            						break;
            						case (int)3: {
HXLINE(  55)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  55)							{
HXLINE(  55)								v3->width = width1;
HXDLIN(  55)								v3->height = height1;
HXDLIN(  55)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  55)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  55)								{
HXLINE(  55)									int _g28 = 0;
HXDLIN(  55)									int _g29 = v3->length;
HXDLIN(  55)									while((_g28 < _g29)){
HXLINE(  55)										_g28 = (_g28 + 1);
HXDLIN(  55)										int i16 = (_g28 - 1);
HXDLIN(  55)										v3->data->__unsafe_set(i16,0);
            									}
            								}
            							}
HXDLIN(  55)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE(  55)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)							 ::iterMagic::StackIntImg b18 = sInt1;
HXDLIN(  55)							{
HXLINE(  55)								b18->width = width1;
HXDLIN(  55)								b18->height = height1;
HXDLIN(  55)								b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  55)								b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  55)								{
HXLINE(  55)									int len3 = b18->length;
HXDLIN(  55)									 ::haxe::ds::GenericStack_Int d1 = b18->data;
HXDLIN(  55)									if (::hx::IsNull( d1->head )) {
HXLINE(  55)										int _g30 = 0;
HXDLIN(  55)										int _g31 = len3;
HXDLIN(  55)										while((_g30 < _g31)){
HXLINE(  55)											_g30 = (_g30 + 1);
HXDLIN(  55)											int i17 = (_g30 - 1);
HXDLIN(  55)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  55)										int _g32 = 0;
HXDLIN(  55)										int _g33 = len3;
HXDLIN(  55)										while((_g32 < _g33)){
HXLINE(  55)											_g32 = (_g32 + 1);
HXDLIN(  55)											int i18 = (_g32 - 1);
HXDLIN(  55)											{
HXLINE(  55)												 ::haxe::ds::GenericCell_Int l1 = b18->data->head;
HXDLIN(  55)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  55)												{
HXLINE(  55)													int _g34 = 0;
HXDLIN(  55)													int _g35 = i18;
HXDLIN(  55)													while((_g34 < _g35)){
HXLINE(  55)														_g34 = (_g34 + 1);
HXDLIN(  55)														int i19 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  55)												if (::hx::IsNull( prev1 )) {
HXLINE(  55)													b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  55)													l1 = null();
            												}
            												else {
HXLINE(  55)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  55)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  55)							undoImage4 = b18;
            						}
            						break;
            					}
HXDLIN(  55)					this82->image = undoImage4;
HXDLIN(  55)					this82->width = width1;
HXDLIN(  55)					this82->height = height1;
HXDLIN(  55)					this82->imageType = ( (int)(imageType1) );
HXDLIN(  55)					undoImage3 = this82;
HXDLIN(  55)					{
HXLINE(  55)						int rectLeft1 = xIter31->start;
HXDLIN(  55)						int rectTop1 = yIter31->start;
HXDLIN(  55)						int rectRight1 = xIter31->max;
HXDLIN(  55)						bool forceClear1 = false;
HXDLIN(  55)						{
HXLINE(  55)							int _g36 = rectTop1;
HXDLIN(  55)							int _g37 = yIter31->max;
HXDLIN(  55)							while((_g36 < _g37)){
HXLINE(  55)								_g36 = (_g36 + 1);
HXDLIN(  55)								int dy2 = (_g36 - 1);
HXDLIN(  55)								{
HXLINE(  55)									int _g38 = rectLeft1;
HXDLIN(  55)									int _g39 = rectRight1;
HXDLIN(  55)									while((_g38 < _g39)){
HXLINE(  55)										_g38 = (_g38 + 1);
HXDLIN(  55)										int dx2 = (_g38 - 1);
HXDLIN(  55)										::Dynamic this84 = pixelImage->image;
HXDLIN(  55)										int index9;
HXDLIN(  55)										if (pixelImage->useVirtualPos) {
HXLINE(  55)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  55)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN(  55)										int c8 = ::iterMagic::Iimg_obj::get(this84,index9);
HXDLIN(  55)										int col1;
HXDLIN(  55)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)											col1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE(  55)											col1 = c8;
            										}
HXDLIN(  55)										bool _hx_tmp20;
HXDLIN(  55)										if (pixelImage->useMask) {
HXLINE(  55)											_hx_tmp20 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE(  55)											_hx_tmp20 = false;
            										}
HXDLIN(  55)										if (_hx_tmp20) {
HXLINE(  55)											 ::pi_xy::ImageStruct this85 = pixelImage->mask;
HXDLIN(  55)											::Dynamic this86 = this85->image;
HXDLIN(  55)											int index10;
HXDLIN(  55)											if (this85->useVirtualPos) {
HXLINE(  55)												index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this85->virtualY) * ( (Float)(this85->width) )) + dx2) - this85->virtualX));
            											}
            											else {
HXLINE(  55)												index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this85->width) + dx2)) ));
            											}
HXDLIN(  55)											int c9 = ::iterMagic::Iimg_obj::get(this86,index10);
HXDLIN(  55)											int v4;
HXDLIN(  55)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)												v4 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE(  55)												v4 = c9;
            											}
HXDLIN(  55)											int maskPixel1 = v4;
HXDLIN(  55)											int this87 = col1;
HXDLIN(  55)											if ((maskPixel1 == 0)) {
HXLINE(  55)												col1 = this87;
            											}
            											else {
HXLINE(  55)												Float m01;
HXDLIN(  55)												int this88 = ((maskPixel1 >> 24) & 255);
HXDLIN(  55)												if ((this88 == 0)) {
HXLINE(  55)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m01 = (( (Float)(this88) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m11;
HXDLIN(  55)												int this89 = ((maskPixel1 >> 16) & 255);
HXDLIN(  55)												if ((this89 == 0)) {
HXLINE(  55)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m11 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m21;
HXDLIN(  55)												int this90 = ((maskPixel1 >> 8) & 255);
HXDLIN(  55)												if ((this90 == 0)) {
HXLINE(  55)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m21 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float m31;
HXDLIN(  55)												int this91 = (maskPixel1 & 255);
HXDLIN(  55)												if ((this91 == 0)) {
HXLINE(  55)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													m31 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this87 >> 24) & 255)) )));
HXDLIN(  55)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this87 >> 16) & 255)) )));
HXDLIN(  55)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this87 >> 8) & 255)) )));
HXDLIN(  55)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this87 & 255)) )));
HXDLIN(  55)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  55)										if ((col1 != 0)) {
HXLINE(  55)											int x9 = (dx2 - rectLeft1);
HXDLIN(  55)											int y9 = (dy2 - rectTop1);
HXDLIN(  55)											int c10 = col1;
HXDLIN(  55)											bool _hx_tmp21;
HXDLIN(  55)											if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  55)												_hx_tmp21 = undoImage3->transparent;
            											}
            											else {
HXLINE(  55)												_hx_tmp21 = false;
            											}
HXDLIN(  55)											if (_hx_tmp21) {
HXLINE(  55)												int location6;
HXDLIN(  55)												if (undoImage3->useVirtualPos) {
HXLINE(  55)													location6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  55)													location6 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN(  55)												int this92 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  55)												int this93;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													this93 = ((((((this92 >> 24) & 255) << 24) | ((this92 & 255) << 16)) | (((this92 >> 8) & 255) << 8)) | ((this92 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													this93 = this92;
            												}
HXDLIN(  55)												Float a16;
HXDLIN(  55)												int this94 = ((this93 >> 24) & 255);
HXDLIN(  55)												if ((this94 == 0)) {
HXLINE(  55)													a16 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a16 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r16;
HXDLIN(  55)												int this95 = ((this93 >> 16) & 255);
HXDLIN(  55)												if ((this95 == 0)) {
HXLINE(  55)													r16 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r16 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g16;
HXDLIN(  55)												int this96 = ((this93 >> 8) & 255);
HXDLIN(  55)												if ((this96 == 0)) {
HXLINE(  55)													g16 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g16 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b19;
HXDLIN(  55)												int this97 = (this93 & 255);
HXDLIN(  55)												if ((this97 == 0)) {
HXLINE(  55)													b19 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b19 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a26;
HXDLIN(  55)												int this98 = ((col1 >> 24) & 255);
HXDLIN(  55)												if ((this98 == 0)) {
HXLINE(  55)													a26 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a26 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r26;
HXDLIN(  55)												int this99 = ((col1 >> 16) & 255);
HXDLIN(  55)												if ((this99 == 0)) {
HXLINE(  55)													r26 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r26 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g26;
HXDLIN(  55)												int this100 = ((col1 >> 8) & 255);
HXDLIN(  55)												if ((this100 == 0)) {
HXLINE(  55)													g26 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g26 = (( (Float)(this100) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b26;
HXDLIN(  55)												int this101 = (col1 & 255);
HXDLIN(  55)												if ((this101 == 0)) {
HXLINE(  55)													b26 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b26 = (( (Float)(this101) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN(  55)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  55)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  55)												int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a36) + (b26 * a26))));
HXDLIN(  55)												int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  55)												int blended6 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN(  55)												{
HXLINE(  55)													int _hx_tmp22;
HXDLIN(  55)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)														_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE(  55)														_hx_tmp22 = blended6;
            													}
HXDLIN(  55)													::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            												}
            											}
            											else {
HXLINE(  55)												::Dynamic this102 = undoImage3->image;
HXDLIN(  55)												int index11;
HXDLIN(  55)												if (undoImage3->useVirtualPos) {
HXLINE(  55)													index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  55)													index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN(  55)												int _hx_tmp23;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													_hx_tmp23 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													_hx_tmp23 = c10;
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this102,index11,_hx_tmp23);
            											}
            										}
            										else {
HXLINE(  55)											if (forceClear1) {
HXLINE(  55)												::Dynamic this103 = undoImage3->image;
HXDLIN(  55)												int x10 = (dx2 - rectLeft1);
HXDLIN(  55)												int y10 = (dy2 - rectTop1);
HXDLIN(  55)												int index12;
HXDLIN(  55)												if (undoImage3->useVirtualPos) {
HXLINE(  55)													index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  55)													index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this103,index12,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				bool found1 = false;
HXDLIN(  55)				Float s1 = ((Float)0.);
HXDLIN(  55)				Float t1 = ((Float)0.);
HXDLIN(  55)				Float sxx1 = ((Float)0.);
HXDLIN(  55)				Float txx1 = ((Float)0.);
HXDLIN(  55)				{
HXLINE(  55)					int _g_min2 = xIter31->start;
HXDLIN(  55)					int _g_max2 = xIter31->max;
HXDLIN(  55)					while((_g_min2 < _g_max2)){
HXLINE(  55)						_g_min2 = (_g_min2 + 1);
HXDLIN(  55)						int x11 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x11) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x11) ));
HXLINE(  62)						found1 = false;
HXLINE(  55)						{
HXLINE(  55)							int _g_min3 = yIter31->start;
HXDLIN(  55)							int _g_max3 = yIter31->max;
HXDLIN(  55)							while((_g_min3 < _g_max3)){
HXLINE(  55)								_g_min3 = (_g_min3 + 1);
HXDLIN(  55)								int y11 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y11) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y11) )));
HXLINE(  55)								bool _hx_tmp24;
HXDLIN(  55)								if (!((s1 <= 0))) {
HXLINE(  55)									_hx_tmp24 = (t1 <= 0);
            								}
            								else {
HXLINE(  55)									_hx_tmp24 = true;
            								}
HXDLIN(  55)								if (_hx_tmp24) {
HXLINE(  55)									if (found1) {
HXLINE(  55)										goto _hx_goto_27;
            									}
            								}
            								else {
HXLINE(  55)									if (((s1 + t1) < A1)) {
HXLINE(  55)										{
HXLINE(  55)											int c11 = color;
HXDLIN(  55)											bool _hx_tmp25;
HXDLIN(  55)											if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  55)												_hx_tmp25 = pixelImage->transparent;
            											}
            											else {
HXLINE(  55)												_hx_tmp25 = false;
            											}
HXDLIN(  55)											if (_hx_tmp25) {
HXLINE(  55)												int location7;
HXDLIN(  55)												if (pixelImage->useVirtualPos) {
HXLINE(  55)													location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x11) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  55)													location7 = ::Std_obj::_hx_int(( (Float)(((y11 * pixelImage->width) + x11)) ));
            												}
HXDLIN(  55)												int this104 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN(  55)												int this105;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													this105 = ((((((this104 >> 24) & 255) << 24) | ((this104 & 255) << 16)) | (((this104 >> 8) & 255) << 8)) | ((this104 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													this105 = this104;
            												}
HXDLIN(  55)												Float a18;
HXDLIN(  55)												int this106 = ((this105 >> 24) & 255);
HXDLIN(  55)												if ((this106 == 0)) {
HXLINE(  55)													a18 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a18 = (( (Float)(this106) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r17;
HXDLIN(  55)												int this107 = ((this105 >> 16) & 255);
HXDLIN(  55)												if ((this107 == 0)) {
HXLINE(  55)													r17 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r17 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g17;
HXDLIN(  55)												int this108 = ((this105 >> 8) & 255);
HXDLIN(  55)												if ((this108 == 0)) {
HXLINE(  55)													g17 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g17 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b110;
HXDLIN(  55)												int this109 = (this105 & 255);
HXDLIN(  55)												if ((this109 == 0)) {
HXLINE(  55)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b110 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a27;
HXDLIN(  55)												int this110 = ((color >> 24) & 255);
HXDLIN(  55)												if ((this110 == 0)) {
HXLINE(  55)													a27 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													a27 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float r27;
HXDLIN(  55)												int this111 = ((color >> 16) & 255);
HXDLIN(  55)												if ((this111 == 0)) {
HXLINE(  55)													r27 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													r27 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float g27;
HXDLIN(  55)												int this112 = ((color >> 8) & 255);
HXDLIN(  55)												if ((this112 == 0)) {
HXLINE(  55)													g27 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													g27 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float b27;
HXDLIN(  55)												int this113 = (color & 255);
HXDLIN(  55)												if ((this113 == 0)) {
HXLINE(  55)													b27 = ((Float)0.);
            												}
            												else {
HXLINE(  55)													b27 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN(  55)												Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN(  55)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  55)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  55)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b27 * a27))));
HXDLIN(  55)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  55)												int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b28);
HXDLIN(  55)												{
HXLINE(  55)													int _hx_tmp26;
HXDLIN(  55)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)														_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE(  55)														_hx_tmp26 = blended7;
            													}
HXDLIN(  55)													::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp26);
            												}
            											}
            											else {
HXLINE(  55)												::Dynamic this114 = pixelImage->image;
HXDLIN(  55)												int index13;
HXDLIN(  55)												if (pixelImage->useVirtualPos) {
HXLINE(  55)													index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x11) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  55)													index13 = ::Std_obj::_hx_int(( (Float)(((y11 * pixelImage->width) + x11)) ));
            												}
HXDLIN(  55)												int _hx_tmp27;
HXDLIN(  55)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  55)													_hx_tmp27 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            												}
            												else {
HXLINE(  55)													_hx_tmp27 = c11;
            												}
HXDLIN(  55)												::iterMagic::Iimg_obj::set(this114,index13,_hx_tmp27);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE(  55)										if (found1) {
HXLINE(  55)											goto _hx_goto_27;
            										}
            									}
            								}
            							}
            							_hx_goto_27:;
            						}
            					}
            				}
HXDLIN(  55)				if ((hasHit == true)) {
HXLINE(  55)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  55)					if (hasUndo1) {
HXLINE(  55)						v5->undoImage = undoImage3;
HXDLIN(  55)						v5->undoX = xIter31->start;
HXDLIN(  55)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  55)		if ((hasHit == true)) {
HXLINE(  55)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  55)			return v6;
            		}
            		else {
HXLINE(  55)			return null();
            		}
HXDLIN(  55)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(LinePixel_Fields__obj,rotateLine,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateSoftLine( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta,int color,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCD,::hx::Null< bool >  __o_softDA,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		Float soft = __o_soft.Default(((Float)40.));
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCD = __o_softCD.Default(true);
            		bool softDA = __o_softDA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_69_rotateSoftLine)
HXLINE(  70)		Float sin = ::Math_obj::sin(theta);
HXLINE(  71)		Float cos = ::Math_obj::cos(theta);
HXLINE(  72)		Float radius = (thick / ( (Float)(2) ));
HXLINE(  73)		Float dx = ((Float)0.1);
HXLINE(  74)		Float dy = radius;
HXLINE(  75)		Float cx = h;
HXLINE(  76)		Float cy = radius;
HXLINE(  77)		Float bx = h;
HXLINE(  78)		Float by = -(radius);
HXLINE(  79)		Float ax = ((Float)0.1);
HXLINE(  80)		Float ay = -(radius);
HXLINE(  81)		Float temp = ((Float)0.);
HXLINE(  82)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)		ax = temp;
HXLINE(  86)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)		by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)		bx = temp;
HXLINE(  90)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)		cx = temp;
HXLINE(  94)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)		dx = temp;
HXLINE( 103)		if (( (bool)(debugCorners) )) {
HXLINE( 104)			{
HXLINE( 104)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN( 104)				{
HXLINE( 104)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN( 104)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN( 104)					int r_w = 12;
HXDLIN( 104)					int r_h = 12;
HXDLIN( 104)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 104)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 104)					int ii_min = r_x;
HXDLIN( 104)					int ii_max = xmax;
HXDLIN( 104)					int xRange__start = ii_min;
HXDLIN( 104)					int xRange__max = ii_max;
HXDLIN( 104)					int ii_min1 = r_y;
HXDLIN( 104)					int ii_max1 = ymax;
HXDLIN( 104)					int yRange__start = ii_min1;
HXDLIN( 104)					int yRange__max = ii_max1;
HXDLIN( 104)					int range_x = xRange__start;
HXDLIN( 104)					int range_y = (yRange__start - 1);
HXDLIN( 104)					int range_xReset = range_x;
HXDLIN( 104)					int range_yReset = range_y;
HXDLIN( 104)					int range_xMax = (xRange__max - 2);
HXDLIN( 104)					int range_yMax = (yRange__max - 2);
HXDLIN( 104)					int _this_min = 0;
HXDLIN( 104)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 104)					while((_this_min < _this_max)){
HXLINE( 104)						_this_min = (_this_min + 1);
HXDLIN( 104)						int i = (_this_min - 1);
HXDLIN( 104)						if ((range_y > range_yMax)) {
HXLINE( 104)							range_y = range_yReset;
HXDLIN( 104)							range_x = (range_x + 1);
            						}
HXDLIN( 104)						range_y = (range_y + 1);
HXDLIN( 104)						int i1 = i;
HXDLIN( 104)						{
HXLINE( 104)							int x = range_x;
HXDLIN( 104)							int y = range_y;
HXDLIN( 104)							int c = -65536;
HXDLIN( 104)							bool _hx_tmp;
HXDLIN( 104)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 104)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 104)								_hx_tmp = false;
            							}
HXDLIN( 104)							if (_hx_tmp) {
HXLINE( 104)								int location;
HXDLIN( 104)								if (this1->useVirtualPos) {
HXLINE( 104)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 104)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 104)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 104)								int this3;
HXDLIN( 104)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 104)									this3 = this2;
            								}
HXDLIN( 104)								Float a1;
HXDLIN( 104)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 104)								if ((this4 == 0)) {
HXLINE( 104)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float r1;
HXDLIN( 104)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 104)								if ((this5 == 0)) {
HXLINE( 104)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float g1;
HXDLIN( 104)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 104)								if ((this6 == 0)) {
HXLINE( 104)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float b1;
HXDLIN( 104)								int this7 = (this3 & 255);
HXDLIN( 104)								if ((this7 == 0)) {
HXLINE( 104)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float a2;
HXDLIN( 104)								int this8 = ((-65536 >> 24) & 255);
HXDLIN( 104)								if ((this8 == 0)) {
HXLINE( 104)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float r2;
HXDLIN( 104)								int this9 = ((-65536 >> 16) & 255);
HXDLIN( 104)								if ((this9 == 0)) {
HXLINE( 104)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float g2;
HXDLIN( 104)								int this10 = ((-65536 >> 8) & 255);
HXDLIN( 104)								if ((this10 == 0)) {
HXLINE( 104)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float b2;
HXDLIN( 104)								int this11 = (-65536 & 255);
HXDLIN( 104)								if ((this11 == 0)) {
HXLINE( 104)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 104)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 104)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 104)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 104)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 104)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 104)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 104)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 104)								{
HXLINE( 104)									int _hx_tmp1;
HXDLIN( 104)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 104)										_hx_tmp1 = blended;
            									}
HXDLIN( 104)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 104)								::Dynamic this12 = this1->image;
HXDLIN( 104)								int index;
HXDLIN( 104)								if (this1->useVirtualPos) {
HXLINE( 104)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 104)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 104)								int _hx_tmp2;
HXDLIN( 104)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 104)									_hx_tmp2 = c;
            								}
HXDLIN( 104)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE( 105)			{
HXLINE( 105)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN( 105)				{
HXLINE( 105)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN( 105)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN( 105)					int r_w1 = 12;
HXDLIN( 105)					int r_h1 = 12;
HXDLIN( 105)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 105)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 105)					int ii_min2 = r_x1;
HXDLIN( 105)					int ii_max2 = xmax1;
HXDLIN( 105)					int xRange__start1 = ii_min2;
HXDLIN( 105)					int xRange__max1 = ii_max2;
HXDLIN( 105)					int ii_min3 = r_y1;
HXDLIN( 105)					int ii_max3 = ymax1;
HXDLIN( 105)					int yRange__start1 = ii_min3;
HXDLIN( 105)					int yRange__max1 = ii_max3;
HXDLIN( 105)					int range_x1 = xRange__start1;
HXDLIN( 105)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 105)					int range_xReset1 = range_x1;
HXDLIN( 105)					int range_yReset1 = range_y1;
HXDLIN( 105)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 105)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 105)					int _this_min1 = 0;
HXDLIN( 105)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 105)					while((_this_min1 < _this_max1)){
HXLINE( 105)						_this_min1 = (_this_min1 + 1);
HXDLIN( 105)						int i2 = (_this_min1 - 1);
HXDLIN( 105)						if ((range_y1 > range_yMax1)) {
HXLINE( 105)							range_y1 = range_yReset1;
HXDLIN( 105)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 105)						range_y1 = (range_y1 + 1);
HXDLIN( 105)						int i3 = i2;
HXDLIN( 105)						{
HXLINE( 105)							int x1 = range_x1;
HXDLIN( 105)							int y1 = range_y1;
HXDLIN( 105)							int c1 = -16711936;
HXDLIN( 105)							bool _hx_tmp3;
HXDLIN( 105)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 105)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE( 105)								_hx_tmp3 = false;
            							}
HXDLIN( 105)							if (_hx_tmp3) {
HXLINE( 105)								int location1;
HXDLIN( 105)								if (this13->useVirtualPos) {
HXLINE( 105)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 105)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 105)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN( 105)								int this15;
HXDLIN( 105)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE( 105)									this15 = this14;
            								}
HXDLIN( 105)								Float a11;
HXDLIN( 105)								int this16 = ((this15 >> 24) & 255);
HXDLIN( 105)								if ((this16 == 0)) {
HXLINE( 105)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float r11;
HXDLIN( 105)								int this17 = ((this15 >> 16) & 255);
HXDLIN( 105)								if ((this17 == 0)) {
HXLINE( 105)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float g11;
HXDLIN( 105)								int this18 = ((this15 >> 8) & 255);
HXDLIN( 105)								if ((this18 == 0)) {
HXLINE( 105)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float b11;
HXDLIN( 105)								int this19 = (this15 & 255);
HXDLIN( 105)								if ((this19 == 0)) {
HXLINE( 105)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float a21;
HXDLIN( 105)								int this20 = ((-16711936 >> 24) & 255);
HXDLIN( 105)								if ((this20 == 0)) {
HXLINE( 105)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float r21;
HXDLIN( 105)								int this21 = ((-16711936 >> 16) & 255);
HXDLIN( 105)								if ((this21 == 0)) {
HXLINE( 105)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float g21;
HXDLIN( 105)								int this22 = ((-16711936 >> 8) & 255);
HXDLIN( 105)								if ((this22 == 0)) {
HXLINE( 105)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float b21;
HXDLIN( 105)								int this23 = (-16711936 & 255);
HXDLIN( 105)								if ((this23 == 0)) {
HXLINE( 105)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 105)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN( 105)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 105)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 105)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 105)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 105)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 105)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 105)								{
HXLINE( 105)									int _hx_tmp4;
HXDLIN( 105)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 105)										_hx_tmp4 = blended1;
            									}
HXDLIN( 105)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 105)								::Dynamic this24 = this13->image;
HXDLIN( 105)								int index1;
HXDLIN( 105)								if (this13->useVirtualPos) {
HXLINE( 105)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 105)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 105)								int _hx_tmp5;
HXDLIN( 105)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 105)									_hx_tmp5 = c1;
            								}
HXDLIN( 105)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE( 106)			{
HXLINE( 106)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN( 106)				{
HXLINE( 106)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN( 106)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN( 106)					int r_w2 = 12;
HXDLIN( 106)					int r_h2 = 12;
HXDLIN( 106)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 106)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 106)					int ii_min4 = r_x2;
HXDLIN( 106)					int ii_max4 = xmax2;
HXDLIN( 106)					int xRange__start2 = ii_min4;
HXDLIN( 106)					int xRange__max2 = ii_max4;
HXDLIN( 106)					int ii_min5 = r_y2;
HXDLIN( 106)					int ii_max5 = ymax2;
HXDLIN( 106)					int yRange__start2 = ii_min5;
HXDLIN( 106)					int yRange__max2 = ii_max5;
HXDLIN( 106)					int range_x2 = xRange__start2;
HXDLIN( 106)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 106)					int range_xReset2 = range_x2;
HXDLIN( 106)					int range_yReset2 = range_y2;
HXDLIN( 106)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 106)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 106)					int _this_min2 = 0;
HXDLIN( 106)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 106)					while((_this_min2 < _this_max2)){
HXLINE( 106)						_this_min2 = (_this_min2 + 1);
HXDLIN( 106)						int i4 = (_this_min2 - 1);
HXDLIN( 106)						if ((range_y2 > range_yMax2)) {
HXLINE( 106)							range_y2 = range_yReset2;
HXDLIN( 106)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 106)						range_y2 = (range_y2 + 1);
HXDLIN( 106)						int i5 = i4;
HXDLIN( 106)						{
HXLINE( 106)							int x2 = range_x2;
HXDLIN( 106)							int y2 = range_y2;
HXDLIN( 106)							int c2 = -16776961;
HXDLIN( 106)							bool _hx_tmp6;
HXDLIN( 106)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 106)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE( 106)								_hx_tmp6 = false;
            							}
HXDLIN( 106)							if (_hx_tmp6) {
HXLINE( 106)								int location2;
HXDLIN( 106)								if (this25->useVirtualPos) {
HXLINE( 106)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 106)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 106)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN( 106)								int this27;
HXDLIN( 106)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE( 106)									this27 = this26;
            								}
HXDLIN( 106)								Float a12;
HXDLIN( 106)								int this28 = ((this27 >> 24) & 255);
HXDLIN( 106)								if ((this28 == 0)) {
HXLINE( 106)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r12;
HXDLIN( 106)								int this29 = ((this27 >> 16) & 255);
HXDLIN( 106)								if ((this29 == 0)) {
HXLINE( 106)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g12;
HXDLIN( 106)								int this30 = ((this27 >> 8) & 255);
HXDLIN( 106)								if ((this30 == 0)) {
HXLINE( 106)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b12;
HXDLIN( 106)								int this31 = (this27 & 255);
HXDLIN( 106)								if ((this31 == 0)) {
HXLINE( 106)									b12 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a22;
HXDLIN( 106)								int this32 = ((-16776961 >> 24) & 255);
HXDLIN( 106)								if ((this32 == 0)) {
HXLINE( 106)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r22;
HXDLIN( 106)								int this33 = ((-16776961 >> 16) & 255);
HXDLIN( 106)								if ((this33 == 0)) {
HXLINE( 106)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g22;
HXDLIN( 106)								int this34 = ((-16776961 >> 8) & 255);
HXDLIN( 106)								if ((this34 == 0)) {
HXLINE( 106)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b22;
HXDLIN( 106)								int this35 = (-16776961 & 255);
HXDLIN( 106)								if ((this35 == 0)) {
HXLINE( 106)									b22 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 106)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 106)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 106)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN( 106)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 106)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN( 106)								{
HXLINE( 106)									int _hx_tmp7;
HXDLIN( 106)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 106)										_hx_tmp7 = blended2;
            									}
HXDLIN( 106)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE( 106)								::Dynamic this36 = this25->image;
HXDLIN( 106)								int index2;
HXDLIN( 106)								if (this25->useVirtualPos) {
HXLINE( 106)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 106)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 106)								int _hx_tmp8;
HXDLIN( 106)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE( 106)									_hx_tmp8 = c2;
            								}
HXDLIN( 106)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE( 107)			{
HXLINE( 107)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN( 107)				{
HXLINE( 107)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN( 107)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN( 107)					int r_w3 = 12;
HXDLIN( 107)					int r_h3 = 12;
HXDLIN( 107)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN( 107)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN( 107)					int ii_min6 = r_x3;
HXDLIN( 107)					int ii_max6 = xmax3;
HXDLIN( 107)					int xRange__start3 = ii_min6;
HXDLIN( 107)					int xRange__max3 = ii_max6;
HXDLIN( 107)					int ii_min7 = r_y3;
HXDLIN( 107)					int ii_max7 = ymax3;
HXDLIN( 107)					int yRange__start3 = ii_min7;
HXDLIN( 107)					int yRange__max3 = ii_max7;
HXDLIN( 107)					int range_x3 = xRange__start3;
HXDLIN( 107)					int range_y3 = (yRange__start3 - 1);
HXDLIN( 107)					int range_xReset3 = range_x3;
HXDLIN( 107)					int range_yReset3 = range_y3;
HXDLIN( 107)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN( 107)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN( 107)					int _this_min3 = 0;
HXDLIN( 107)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN( 107)					while((_this_min3 < _this_max3)){
HXLINE( 107)						_this_min3 = (_this_min3 + 1);
HXDLIN( 107)						int i6 = (_this_min3 - 1);
HXDLIN( 107)						if ((range_y3 > range_yMax3)) {
HXLINE( 107)							range_y3 = range_yReset3;
HXDLIN( 107)							range_x3 = (range_x3 + 1);
            						}
HXDLIN( 107)						range_y3 = (range_y3 + 1);
HXDLIN( 107)						int i7 = i6;
HXDLIN( 107)						{
HXLINE( 107)							int x3 = range_x3;
HXDLIN( 107)							int y3 = range_y3;
HXDLIN( 107)							int c3 = -1048336;
HXDLIN( 107)							bool _hx_tmp9;
HXDLIN( 107)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 107)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE( 107)								_hx_tmp9 = false;
            							}
HXDLIN( 107)							if (_hx_tmp9) {
HXLINE( 107)								int location3;
HXDLIN( 107)								if (this37->useVirtualPos) {
HXLINE( 107)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 107)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 107)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 107)								int this39;
HXDLIN( 107)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 107)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE( 107)									this39 = this38;
            								}
HXDLIN( 107)								Float a13;
HXDLIN( 107)								int this40 = ((this39 >> 24) & 255);
HXDLIN( 107)								if ((this40 == 0)) {
HXLINE( 107)									a13 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float r13;
HXDLIN( 107)								int this41 = ((this39 >> 16) & 255);
HXDLIN( 107)								if ((this41 == 0)) {
HXLINE( 107)									r13 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float g13;
HXDLIN( 107)								int this42 = ((this39 >> 8) & 255);
HXDLIN( 107)								if ((this42 == 0)) {
HXLINE( 107)									g13 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float b13;
HXDLIN( 107)								int this43 = (this39 & 255);
HXDLIN( 107)								if ((this43 == 0)) {
HXLINE( 107)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float a23;
HXDLIN( 107)								int this44 = ((-1048336 >> 24) & 255);
HXDLIN( 107)								if ((this44 == 0)) {
HXLINE( 107)									a23 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float r23;
HXDLIN( 107)								int this45 = ((-1048336 >> 16) & 255);
HXDLIN( 107)								if ((this45 == 0)) {
HXLINE( 107)									r23 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float g23;
HXDLIN( 107)								int this46 = ((-1048336 >> 8) & 255);
HXDLIN( 107)								if ((this46 == 0)) {
HXLINE( 107)									g23 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float b23;
HXDLIN( 107)								int this47 = (-1048336 & 255);
HXDLIN( 107)								if ((this47 == 0)) {
HXLINE( 107)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 107)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN( 107)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 107)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 107)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 107)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN( 107)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 107)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN( 107)								{
HXLINE( 107)									int _hx_tmp10;
HXDLIN( 107)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 107)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE( 107)										_hx_tmp10 = blended3;
            									}
HXDLIN( 107)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE( 107)								::Dynamic this48 = this37->image;
HXDLIN( 107)								int index3;
HXDLIN( 107)								if (this37->useVirtualPos) {
HXLINE( 107)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 107)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 107)								int _hx_tmp11;
HXDLIN( 107)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 107)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 107)									_hx_tmp11 = c3;
            								}
HXDLIN( 107)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 109)		{
HXLINE( 109)			bool hasUndo = true;
HXDLIN( 109)			int aA = ((color >> 24) & 255);
HXDLIN( 109)			int rA = ((color >> 16) & 255);
HXDLIN( 109)			int gA = ((color >> 8) & 255);
HXDLIN( 109)			int bA = (color & 255);
HXDLIN( 109)			Float bcx = (bx - dx);
HXDLIN( 109)			Float bcy = (by - dy);
HXDLIN( 109)			Float acx = (ax - dx);
HXDLIN( 109)			Float acy = (ay - dy);
HXDLIN( 109)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 109)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 109)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 109)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 109)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 109)			if ((ax > bx)) {
HXLINE( 109)				if ((ax > dx)) {
HXLINE( 109)					int min;
HXDLIN( 109)					if ((bx > dx)) {
HXLINE( 109)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 109)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 109)					int ii_min8 = min;
HXDLIN( 109)					int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 109)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 109)					int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 109)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 109)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 109)				if ((bx > dx)) {
HXLINE( 109)					int min1;
HXDLIN( 109)					if ((ax > dx)) {
HXLINE( 109)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 109)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 109)					int ii_min10 = min1;
HXDLIN( 109)					int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 109)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 109)					int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 109)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 109)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 109)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 109)			if ((ay > by)) {
HXLINE( 109)				if ((ay > dy)) {
HXLINE( 109)					int min2;
HXDLIN( 109)					if ((by > dy)) {
HXLINE( 109)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 109)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 109)					int ii_min12 = min2;
HXDLIN( 109)					int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 109)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 109)					int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 109)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 109)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 109)				if ((by > dy)) {
HXLINE( 109)					int min3;
HXDLIN( 109)					if ((ay > dy)) {
HXLINE( 109)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 109)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 109)					int ii_min14 = min3;
HXDLIN( 109)					int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 109)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 109)					int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 109)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 109)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 109)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 109)			if (hasUndo) {
HXLINE( 109)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 109)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 109)				 ::Dynamic imageType = null();
HXDLIN( 109)				 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 109)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 109)				::Dynamic undoImage1;
HXDLIN( 109)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 109)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::BytesImg b6 = byt;
HXDLIN( 109)						{
HXLINE( 109)							b6->width = width;
HXDLIN( 109)							b6->height = height;
HXDLIN( 109)							b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 109)							{
HXLINE( 109)								int len = b6->length;
HXDLIN( 109)								int w = 0;
HXDLIN( 109)								{
HXLINE( 109)									int _g = 0;
HXDLIN( 109)									int _g1 = b6->height;
HXDLIN( 109)									while((_g < _g1)){
HXLINE( 109)										_g = (_g + 1);
HXDLIN( 109)										int y4 = (_g - 1);
HXDLIN( 109)										{
HXLINE( 109)											int _g2 = 0;
HXDLIN( 109)											int _g3 = b6->width;
HXDLIN( 109)											while((_g2 < _g3)){
HXLINE( 109)												_g2 = (_g2 + 1);
HXDLIN( 109)												int x4 = (_g2 - 1);
HXDLIN( 109)												{
HXLINE( 109)													w = (w + 1);
HXDLIN( 109)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w = (w + 1);
HXDLIN( 109)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w = (w + 1);
HXDLIN( 109)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w = (w + 1);
HXDLIN( 109)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage1 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 109)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN( 109)						{
HXLINE( 109)							a7->width = width;
HXDLIN( 109)							a7->height = height;
HXDLIN( 109)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 109)							a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)							{
HXLINE( 109)								int _g4 = 0;
HXDLIN( 109)								int _g5 = a7->length;
HXDLIN( 109)								while((_g4 < _g5)){
HXLINE( 109)									_g4 = (_g4 + 1);
HXDLIN( 109)									int i8 = (_g4 - 1);
HXDLIN( 109)									a7->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 109)						undoImage1 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 109)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN( 109)						{
HXLINE( 109)							b7->width = width;
HXDLIN( 109)							b7->height = height;
HXDLIN( 109)							b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)							int size = (b7->length * 4);
HXDLIN( 109)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 109)							{
HXLINE( 109)								int _g6 = 0;
HXDLIN( 109)								int _g7 = b7->length;
HXDLIN( 109)								while((_g6 < _g7)){
HXLINE( 109)									_g6 = (_g6 + 1);
HXDLIN( 109)									int i9 = (_g6 - 1);
HXDLIN( 109)									{
HXLINE( 109)										 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN( 109)										bool undoImage2;
HXDLIN( 109)										if ((i9 >= 0)) {
HXLINE( 109)											undoImage2 = (i9 < (this50->byteLength >> 2));
            										}
            										else {
HXLINE( 109)											undoImage2 = false;
            										}
HXDLIN( 109)										if (undoImage2) {
HXLINE( 109)											 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN( 109)											int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN( 109)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 109)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 109)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 109)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage1 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 109)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 109)						{
HXLINE( 109)							v->width = width;
HXDLIN( 109)							v->height = height;
HXDLIN( 109)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 109)							{
HXLINE( 109)								int _g8 = 0;
HXDLIN( 109)								int _g9 = v->length;
HXDLIN( 109)								while((_g8 < _g9)){
HXLINE( 109)									_g8 = (_g8 + 1);
HXDLIN( 109)									int i10 = (_g8 - 1);
HXDLIN( 109)									v->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 109)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 109)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN( 109)						{
HXLINE( 109)							b8->width = width;
HXDLIN( 109)							b8->height = height;
HXDLIN( 109)							b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 109)							{
HXLINE( 109)								int len1 = b8->length;
HXDLIN( 109)								 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN( 109)								if (::hx::IsNull( d->head )) {
HXLINE( 109)									int _g10 = 0;
HXDLIN( 109)									int _g11 = len1;
HXDLIN( 109)									while((_g10 < _g11)){
HXLINE( 109)										_g10 = (_g10 + 1);
HXDLIN( 109)										int i11 = (_g10 - 1);
HXDLIN( 109)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 109)									int _g12 = 0;
HXDLIN( 109)									int _g13 = len1;
HXDLIN( 109)									while((_g12 < _g13)){
HXLINE( 109)										_g12 = (_g12 + 1);
HXDLIN( 109)										int i12 = (_g12 - 1);
HXDLIN( 109)										{
HXLINE( 109)											 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN( 109)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 109)											{
HXLINE( 109)												int _g14 = 0;
HXDLIN( 109)												int _g15 = i12;
HXDLIN( 109)												while((_g14 < _g15)){
HXLINE( 109)													_g14 = (_g14 + 1);
HXDLIN( 109)													int i13 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 109)											if (::hx::IsNull( prev )) {
HXLINE( 109)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 109)												l = null();
            											}
            											else {
HXLINE( 109)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 109)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage1 = b8;
            					}
            					break;
            				}
HXDLIN( 109)				this49->image = undoImage1;
HXDLIN( 109)				this49->width = width;
HXDLIN( 109)				this49->height = height;
HXDLIN( 109)				this49->imageType = ( (int)(imageType) );
HXDLIN( 109)				undoImage = this49;
HXDLIN( 109)				{
HXLINE( 109)					int rectLeft = xIter3->start;
HXDLIN( 109)					int rectTop = yIter3->start;
HXDLIN( 109)					int rectRight = xIter3->max;
HXDLIN( 109)					bool forceClear = false;
HXDLIN( 109)					{
HXLINE( 109)						int _g16 = rectTop;
HXDLIN( 109)						int _g17 = yIter3->max;
HXDLIN( 109)						while((_g16 < _g17)){
HXLINE( 109)							_g16 = (_g16 + 1);
HXDLIN( 109)							int dy1 = (_g16 - 1);
HXDLIN( 109)							{
HXLINE( 109)								int _g18 = rectLeft;
HXDLIN( 109)								int _g19 = rectRight;
HXDLIN( 109)								while((_g18 < _g19)){
HXLINE( 109)									_g18 = (_g18 + 1);
HXDLIN( 109)									int dx1 = (_g18 - 1);
HXDLIN( 109)									::Dynamic this51 = pixelImage->image;
HXDLIN( 109)									int index4;
HXDLIN( 109)									if (pixelImage->useVirtualPos) {
HXLINE( 109)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 109)										index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 109)									int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN( 109)									int col;
HXDLIN( 109)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)										col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 109)										col = c4;
            									}
HXDLIN( 109)									bool _hx_tmp12;
HXDLIN( 109)									if (pixelImage->useMask) {
HXLINE( 109)										_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 109)										_hx_tmp12 = false;
            									}
HXDLIN( 109)									if (_hx_tmp12) {
HXLINE( 109)										 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN( 109)										::Dynamic this53 = this52->image;
HXDLIN( 109)										int index5;
HXDLIN( 109)										if (this52->useVirtualPos) {
HXLINE( 109)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            										}
            										else {
HXLINE( 109)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            										}
HXDLIN( 109)										int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN( 109)										int v1;
HXDLIN( 109)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)											v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 109)											v1 = c5;
            										}
HXDLIN( 109)										int maskPixel = v1;
HXDLIN( 109)										int this54 = col;
HXDLIN( 109)										if ((maskPixel == 0)) {
HXLINE( 109)											col = this54;
            										}
            										else {
HXLINE( 109)											Float m0;
HXDLIN( 109)											int this55 = ((maskPixel >> 24) & 255);
HXDLIN( 109)											if ((this55 == 0)) {
HXLINE( 109)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m1;
HXDLIN( 109)											int this56 = ((maskPixel >> 16) & 255);
HXDLIN( 109)											if ((this56 == 0)) {
HXLINE( 109)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m2;
HXDLIN( 109)											int this57 = ((maskPixel >> 8) & 255);
HXDLIN( 109)											if ((this57 == 0)) {
HXLINE( 109)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m3;
HXDLIN( 109)											int this58 = (maskPixel & 255);
HXDLIN( 109)											if ((this58 == 0)) {
HXLINE( 109)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 109)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 109)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 109)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN( 109)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 109)									if ((col != 0)) {
HXLINE( 109)										int x5 = (dx1 - rectLeft);
HXDLIN( 109)										int y5 = (dy1 - rectTop);
HXDLIN( 109)										int c6 = col;
HXDLIN( 109)										bool _hx_tmp13;
HXDLIN( 109)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 109)											_hx_tmp13 = undoImage->transparent;
            										}
            										else {
HXLINE( 109)											_hx_tmp13 = false;
            										}
HXDLIN( 109)										if (_hx_tmp13) {
HXLINE( 109)											int location4;
HXDLIN( 109)											if (undoImage->useVirtualPos) {
HXLINE( 109)												location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 109)												location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 109)											int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN( 109)											int this60;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												this60 = this59;
            											}
HXDLIN( 109)											Float a14;
HXDLIN( 109)											int this61 = ((this60 >> 24) & 255);
HXDLIN( 109)											if ((this61 == 0)) {
HXLINE( 109)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float r14;
HXDLIN( 109)											int this62 = ((this60 >> 16) & 255);
HXDLIN( 109)											if ((this62 == 0)) {
HXLINE( 109)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float g14;
HXDLIN( 109)											int this63 = ((this60 >> 8) & 255);
HXDLIN( 109)											if ((this63 == 0)) {
HXLINE( 109)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float b14;
HXDLIN( 109)											int this64 = (this60 & 255);
HXDLIN( 109)											if ((this64 == 0)) {
HXLINE( 109)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float a24;
HXDLIN( 109)											int this65 = ((col >> 24) & 255);
HXDLIN( 109)											if ((this65 == 0)) {
HXLINE( 109)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float r24;
HXDLIN( 109)											int this66 = ((col >> 16) & 255);
HXDLIN( 109)											if ((this66 == 0)) {
HXLINE( 109)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float g24;
HXDLIN( 109)											int this67 = ((col >> 8) & 255);
HXDLIN( 109)											if ((this67 == 0)) {
HXLINE( 109)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float b24;
HXDLIN( 109)											int this68 = (col & 255);
HXDLIN( 109)											if ((this68 == 0)) {
HXLINE( 109)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 109)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 109)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 109)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN( 109)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 109)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN( 109)											{
HXLINE( 109)												int _hx_tmp14;
HXDLIN( 109)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)													_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 109)													_hx_tmp14 = blended4;
            												}
HXDLIN( 109)												::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            											}
            										}
            										else {
HXLINE( 109)											::Dynamic this69 = undoImage->image;
HXDLIN( 109)											int index6;
HXDLIN( 109)											if (undoImage->useVirtualPos) {
HXLINE( 109)												index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 109)												index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 109)											int _hx_tmp15;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												_hx_tmp15 = c6;
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 109)										if (forceClear) {
HXLINE( 109)											::Dynamic this70 = undoImage->image;
HXDLIN( 109)											int x6 = (dx1 - rectLeft);
HXDLIN( 109)											int y6 = (dy1 - rectTop);
HXDLIN( 109)											int index7;
HXDLIN( 109)											if (undoImage->useVirtualPos) {
HXLINE( 109)												index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            											}
            											else {
HXLINE( 109)												index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(this70,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 109)			bool found = false;
HXDLIN( 109)			Float min4 = ( (Float)(0) );
HXDLIN( 109)			Float max = ( (Float)(0) );
HXDLIN( 109)			int a9 = 0;
HXDLIN( 109)			int r7 = 0;
HXDLIN( 109)			int g7 = 0;
HXDLIN( 109)			int b10 = 0;
HXDLIN( 109)			{
HXLINE( 109)				int _g_min = xIter3->start;
HXDLIN( 109)				int _g_max = xIter3->max;
HXDLIN( 109)				while((_g_min < _g_max)){
HXLINE( 109)					_g_min = (_g_min + 1);
HXDLIN( 109)					int px1 = (_g_min - 1);
HXDLIN( 109)					Float pcx = (( (Float)(px1) ) - dx);
HXLINE( 695)					found = false;
HXLINE( 109)					{
HXLINE( 109)						int _g_min1 = yIter3->start;
HXDLIN( 109)						int _g_max1 = yIter3->max;
HXDLIN( 109)						while((_g_min1 < _g_max1)){
HXLINE( 109)							_g_min1 = (_g_min1 + 1);
HXDLIN( 109)							int py1 = (_g_min1 - 1);
HXDLIN( 109)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 109)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 109)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 109)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 109)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 109)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 109)							bool _hx_tmp16;
HXDLIN( 109)							bool _hx_tmp17;
HXDLIN( 109)							if ((ratioA >= 0)) {
HXLINE( 109)								_hx_tmp17 = (ratioB >= 0);
            							}
            							else {
HXLINE( 109)								_hx_tmp17 = false;
            							}
HXDLIN( 109)							if (_hx_tmp17) {
HXLINE( 109)								_hx_tmp16 = (ratioC >= 0);
            							}
            							else {
HXLINE( 109)								_hx_tmp16 = false;
            							}
HXDLIN( 109)							if (_hx_tmp16) {
HXLINE( 109)								if (softAB) {
HXLINE( 109)									if (softDA) {
HXLINE( 109)										if ((ratioA < ratioC)) {
HXLINE( 109)											min4 = ratioA;
            										}
            										else {
HXLINE( 109)											min4 = ratioC;
            										}
HXDLIN( 109)										if ((ratioA > ratioB)) {
HXLINE( 109)											max = ratioA;
            										}
            										else {
HXLINE( 109)											max = ratioB;
            										}
HXDLIN( 109)										if (!((max > ratioC))) {
HXLINE( 109)											max = ratioC;
            										}
HXLINE( 728)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 109)										if (!((min4 < max))) {
HXLINE( 109)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXDLIN( 109)										int i14 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 109)										if ((i14 > 255)) {
HXLINE(  24)											i14 = 255;
            										}
HXLINE( 109)										if ((i14 < 0)) {
HXLINE(  25)											i14 = 0;
            										}
HXLINE( 109)										a9 = i14;
            									}
            									else {
HXLINE( 722)										min4 = ratioC;
HXLINE( 109)										int i15 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 109)										if ((i15 > 255)) {
HXLINE(  24)											i15 = 255;
            										}
HXLINE( 109)										if ((i15 < 0)) {
HXLINE(  25)											i15 = 0;
            										}
HXLINE( 109)										a9 = i15;
            									}
            								}
            								else {
HXLINE( 109)									if (softDA) {
HXLINE( 709)										min4 = ratioA;
HXLINE( 109)										int i16 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 109)										if ((i16 > 255)) {
HXLINE(  24)											i16 = 255;
            										}
HXLINE( 109)										if ((i16 < 0)) {
HXLINE(  25)											i16 = 0;
            										}
HXLINE( 109)										a9 = i16;
            									}
            									else {
HXLINE( 109)										int i17 = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN( 109)										if ((i17 > 255)) {
HXLINE(  24)											i17 = 255;
            										}
HXLINE( 109)										if ((i17 < 0)) {
HXLINE(  25)											i17 = 0;
            										}
HXLINE( 109)										a9 = i17;
            									}
            								}
HXDLIN( 109)								int i18 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 109)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 109)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 747)								r7 = i18;
HXLINE( 109)								int i19 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 109)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 109)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 748)								g7 = i19;
HXLINE( 109)								int i20 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 109)								if ((i20 > 255)) {
HXLINE(  24)									i20 = 255;
            								}
HXLINE( 109)								if ((i20 < 0)) {
HXLINE(  25)									i20 = 0;
            								}
HXLINE( 749)								b10 = i20;
HXLINE( 109)								{
HXLINE( 109)									int location5;
HXDLIN( 109)									if (pixelImage->useVirtualPos) {
HXLINE( 109)										location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 109)										location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 109)									bool _hx_tmp18;
HXDLIN( 109)									if (pixelImage->transparent) {
HXLINE( 109)										_hx_tmp18 = (a9 < 254);
            									}
            									else {
HXLINE( 109)										_hx_tmp18 = false;
            									}
HXDLIN( 109)									if (_hx_tmp18) {
HXLINE( 109)										int this71 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 109)										int old;
HXDLIN( 109)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)											old = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            										}
            										else {
HXLINE( 109)											old = this71;
            										}
HXDLIN( 109)										int rhs = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 109)										Float a15;
HXDLIN( 109)										int this72 = ((old >> 24) & 255);
HXDLIN( 109)										if ((this72 == 0)) {
HXLINE( 109)											a15 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float r15;
HXDLIN( 109)										int this73 = ((old >> 16) & 255);
HXDLIN( 109)										if ((this73 == 0)) {
HXLINE( 109)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											r15 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float g15;
HXDLIN( 109)										int this74 = ((old >> 8) & 255);
HXDLIN( 109)										if ((this74 == 0)) {
HXLINE( 109)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											g15 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float b15;
HXDLIN( 109)										int this75 = (old & 255);
HXDLIN( 109)										if ((this75 == 0)) {
HXLINE( 109)											b15 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											b15 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float a25;
HXDLIN( 109)										int this76 = ((rhs >> 24) & 255);
HXDLIN( 109)										if ((this76 == 0)) {
HXLINE( 109)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											a25 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float r25;
HXDLIN( 109)										int this77 = ((rhs >> 16) & 255);
HXDLIN( 109)										if ((this77 == 0)) {
HXLINE( 109)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											r25 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float g25;
HXDLIN( 109)										int this78 = ((rhs >> 8) & 255);
HXDLIN( 109)										if ((this78 == 0)) {
HXLINE( 109)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											g25 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float b25;
HXDLIN( 109)										int this79 = (rhs & 255);
HXDLIN( 109)										if ((this79 == 0)) {
HXLINE( 109)											b25 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 109)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 109)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 109)										int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN( 109)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 109)										int blended5 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b16);
HXDLIN( 109)										{
HXLINE( 109)											int _hx_tmp19;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												_hx_tmp19 = blended5;
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp19);
            										}
            									}
            									else {
HXLINE( 109)										int value;
HXDLIN( 109)										if (pixelImage->isLittle) {
HXLINE( 109)											value = ((((a9 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            										}
            										else {
HXLINE( 109)											value = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            										}
HXDLIN( 109)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,value);
            									}
            								}
HXLINE( 751)								found = true;
            							}
            							else {
HXLINE( 109)								if (found) {
HXLINE( 109)									goto _hx_goto_44;
            								}
            							}
            						}
            						_hx_goto_44:;
            					}
            				}
            			}
HXDLIN( 109)			if ((hasHit == false)) {
HXLINE( 109)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 109)				if (hasUndo) {
HXLINE( 109)					v2->undoImage = undoImage;
HXDLIN( 109)					v2->undoX = xIter3->start;
HXDLIN( 109)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN( 109)		{
HXLINE( 109)			bool hasUndo1 = true;
HXDLIN( 109)			int aA1 = ((color >> 24) & 255);
HXDLIN( 109)			int rA1 = ((color >> 16) & 255);
HXDLIN( 109)			int gA1 = ((color >> 8) & 255);
HXDLIN( 109)			int bA1 = (color & 255);
HXDLIN( 109)			Float bcx1 = (cx - dx);
HXDLIN( 109)			Float bcy1 = (cy - dy);
HXDLIN( 109)			Float acx1 = (bx - dx);
HXDLIN( 109)			Float acy1 = (by - dy);
HXDLIN( 109)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 109)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 109)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 109)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 109)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 109)			if ((bx > cx)) {
HXLINE( 109)				if ((bx > dx)) {
HXLINE( 109)					int min5;
HXDLIN( 109)					if ((cx > dx)) {
HXLINE( 109)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 109)						min5 = ::Math_obj::floor(cx);
            					}
HXDLIN( 109)					int ii_min16 = min5;
HXDLIN( 109)					int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 109)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 109)					int ii_min17 = ::Math_obj::floor(cx);
HXDLIN( 109)					int ii_max17 = ::Math_obj::ceil(dx);
HXDLIN( 109)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 109)				if ((cx > dx)) {
HXLINE( 109)					int min6;
HXDLIN( 109)					if ((bx > dx)) {
HXLINE( 109)						min6 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 109)						min6 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 109)					int ii_min18 = min6;
HXDLIN( 109)					int ii_max18 = ::Math_obj::ceil(cx);
HXDLIN( 109)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 109)					int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 109)					int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN( 109)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 109)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 109)			if ((by > cy)) {
HXLINE( 109)				if ((by > dy)) {
HXLINE( 109)					int min7;
HXDLIN( 109)					if ((cy > dy)) {
HXLINE( 109)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 109)						min7 = ::Math_obj::floor(cy);
            					}
HXDLIN( 109)					int ii_min20 = min7;
HXDLIN( 109)					int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 109)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 109)					int ii_min21 = ::Math_obj::floor(cy);
HXDLIN( 109)					int ii_max21 = ::Math_obj::ceil(dy);
HXDLIN( 109)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 109)				if ((cy > dy)) {
HXLINE( 109)					int min8;
HXDLIN( 109)					if ((by > dy)) {
HXLINE( 109)						min8 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 109)						min8 = ::Math_obj::ceil(by);
            					}
HXDLIN( 109)					int ii_min22 = min8;
HXDLIN( 109)					int ii_max22 = ::Math_obj::ceil(cy);
HXDLIN( 109)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 109)					int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 109)					int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN( 109)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 109)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 109)			if (hasUndo1) {
HXLINE( 109)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 109)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 109)				 ::Dynamic imageType1 = null();
HXDLIN( 109)				 ::pi_xy::ImageStruct this80 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 109)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 109)				::Dynamic undoImage4;
HXDLIN( 109)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 109)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::BytesImg b17 = byt1;
HXDLIN( 109)						{
HXLINE( 109)							b17->width = width1;
HXDLIN( 109)							b17->height = height1;
HXDLIN( 109)							b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 109)							b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 109)							{
HXLINE( 109)								int len2 = b17->length;
HXDLIN( 109)								int w1 = 0;
HXDLIN( 109)								{
HXLINE( 109)									int _g20 = 0;
HXDLIN( 109)									int _g21 = b17->height;
HXDLIN( 109)									while((_g20 < _g21)){
HXLINE( 109)										_g20 = (_g20 + 1);
HXDLIN( 109)										int y7 = (_g20 - 1);
HXDLIN( 109)										{
HXLINE( 109)											int _g22 = 0;
HXDLIN( 109)											int _g23 = b17->width;
HXDLIN( 109)											while((_g22 < _g23)){
HXLINE( 109)												_g22 = (_g22 + 1);
HXDLIN( 109)												int x7 = (_g22 - 1);
HXDLIN( 109)												{
HXLINE( 109)													w1 = (w1 + 1);
HXDLIN( 109)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w1 = (w1 + 1);
HXDLIN( 109)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w1 = (w1 + 1);
HXDLIN( 109)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 109)												{
HXLINE( 109)													w1 = (w1 + 1);
HXDLIN( 109)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage4 = b17;
            					}
            					break;
            					case (int)1: {
HXLINE( 109)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN( 109)						{
HXLINE( 109)							a16->width = width1;
HXDLIN( 109)							a16->height = height1;
HXDLIN( 109)							a16->data = ::Array_obj< int >::__new(0);
HXDLIN( 109)							a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 109)							{
HXLINE( 109)								int _g24 = 0;
HXDLIN( 109)								int _g25 = a16->length;
HXDLIN( 109)								while((_g24 < _g25)){
HXLINE( 109)									_g24 = (_g24 + 1);
HXDLIN( 109)									int i21 = (_g24 - 1);
HXDLIN( 109)									a16->data[i21] = 0;
            								}
            							}
            						}
HXDLIN( 109)						undoImage4 = a16;
            					}
            					break;
            					case (int)2: {
HXLINE( 109)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::U32ArrImg b18 = u32a1;
HXDLIN( 109)						{
HXLINE( 109)							b18->width = width1;
HXDLIN( 109)							b18->height = height1;
HXDLIN( 109)							b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 109)							int size1 = (b18->length * 4);
HXDLIN( 109)							b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 109)							{
HXLINE( 109)								int _g26 = 0;
HXDLIN( 109)								int _g27 = b18->length;
HXDLIN( 109)								while((_g26 < _g27)){
HXLINE( 109)									_g26 = (_g26 + 1);
HXDLIN( 109)									int i22 = (_g26 - 1);
HXDLIN( 109)									{
HXLINE( 109)										 ::haxe::io::ArrayBufferViewImpl this81 = b18->data;
HXDLIN( 109)										bool undoImage5;
HXDLIN( 109)										if ((i22 >= 0)) {
HXLINE( 109)											undoImage5 = (i22 < (this81->byteLength >> 2));
            										}
            										else {
HXLINE( 109)											undoImage5 = false;
            										}
HXDLIN( 109)										if (undoImage5) {
HXLINE( 109)											 ::haxe::io::Bytes _this1 = this81->bytes;
HXDLIN( 109)											int pos1 = ((i22 << 2) + this81->byteOffset);
HXDLIN( 109)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 109)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 109)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 109)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage4 = b18;
            					}
            					break;
            					case (int)3: {
HXLINE( 109)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 109)						{
HXLINE( 109)							v3->width = width1;
HXDLIN( 109)							v3->height = height1;
HXDLIN( 109)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 109)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 109)							{
HXLINE( 109)								int _g28 = 0;
HXDLIN( 109)								int _g29 = v3->length;
HXDLIN( 109)								while((_g28 < _g29)){
HXLINE( 109)									_g28 = (_g28 + 1);
HXDLIN( 109)									int i23 = (_g28 - 1);
HXDLIN( 109)									v3->data->__unsafe_set(i23,0);
            								}
            							}
            						}
HXDLIN( 109)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 109)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)						 ::iterMagic::StackIntImg b19 = sInt1;
HXDLIN( 109)						{
HXLINE( 109)							b19->width = width1;
HXDLIN( 109)							b19->height = height1;
HXDLIN( 109)							b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 109)							b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 109)							{
HXLINE( 109)								int len3 = b19->length;
HXDLIN( 109)								 ::haxe::ds::GenericStack_Int d1 = b19->data;
HXDLIN( 109)								if (::hx::IsNull( d1->head )) {
HXLINE( 109)									int _g30 = 0;
HXDLIN( 109)									int _g31 = len3;
HXDLIN( 109)									while((_g30 < _g31)){
HXLINE( 109)										_g30 = (_g30 + 1);
HXDLIN( 109)										int i24 = (_g30 - 1);
HXDLIN( 109)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 109)									int _g32 = 0;
HXDLIN( 109)									int _g33 = len3;
HXDLIN( 109)									while((_g32 < _g33)){
HXLINE( 109)										_g32 = (_g32 + 1);
HXDLIN( 109)										int i25 = (_g32 - 1);
HXDLIN( 109)										{
HXLINE( 109)											 ::haxe::ds::GenericCell_Int l1 = b19->data->head;
HXDLIN( 109)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 109)											{
HXLINE( 109)												int _g34 = 0;
HXDLIN( 109)												int _g35 = i25;
HXDLIN( 109)												while((_g34 < _g35)){
HXLINE( 109)													_g34 = (_g34 + 1);
HXDLIN( 109)													int i26 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 109)											if (::hx::IsNull( prev1 )) {
HXLINE( 109)												b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 109)												l1 = null();
            											}
            											else {
HXLINE( 109)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 109)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						undoImage4 = b19;
            					}
            					break;
            				}
HXDLIN( 109)				this80->image = undoImage4;
HXDLIN( 109)				this80->width = width1;
HXDLIN( 109)				this80->height = height1;
HXDLIN( 109)				this80->imageType = ( (int)(imageType1) );
HXDLIN( 109)				undoImage3 = this80;
HXDLIN( 109)				{
HXLINE( 109)					int rectLeft1 = xIter31->start;
HXDLIN( 109)					int rectTop1 = yIter31->start;
HXDLIN( 109)					int rectRight1 = xIter31->max;
HXDLIN( 109)					bool forceClear1 = false;
HXDLIN( 109)					{
HXLINE( 109)						int _g36 = rectTop1;
HXDLIN( 109)						int _g37 = yIter31->max;
HXDLIN( 109)						while((_g36 < _g37)){
HXLINE( 109)							_g36 = (_g36 + 1);
HXDLIN( 109)							int dy2 = (_g36 - 1);
HXDLIN( 109)							{
HXLINE( 109)								int _g38 = rectLeft1;
HXDLIN( 109)								int _g39 = rectRight1;
HXDLIN( 109)								while((_g38 < _g39)){
HXLINE( 109)									_g38 = (_g38 + 1);
HXDLIN( 109)									int dx2 = (_g38 - 1);
HXDLIN( 109)									::Dynamic this82 = pixelImage->image;
HXDLIN( 109)									int index8;
HXDLIN( 109)									if (pixelImage->useVirtualPos) {
HXLINE( 109)										index8 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 109)										index8 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 109)									int c7 = ::iterMagic::Iimg_obj::get(this82,index8);
HXDLIN( 109)									int col1;
HXDLIN( 109)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)										col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 109)										col1 = c7;
            									}
HXDLIN( 109)									bool _hx_tmp20;
HXDLIN( 109)									if (pixelImage->useMask) {
HXLINE( 109)										_hx_tmp20 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 109)										_hx_tmp20 = false;
            									}
HXDLIN( 109)									if (_hx_tmp20) {
HXLINE( 109)										 ::pi_xy::ImageStruct this83 = pixelImage->mask;
HXDLIN( 109)										::Dynamic this84 = this83->image;
HXDLIN( 109)										int index9;
HXDLIN( 109)										if (this83->useVirtualPos) {
HXLINE( 109)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this83->virtualY) * ( (Float)(this83->width) )) + dx2) - this83->virtualX));
            										}
            										else {
HXLINE( 109)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this83->width) + dx2)) ));
            										}
HXDLIN( 109)										int c8 = ::iterMagic::Iimg_obj::get(this84,index9);
HXDLIN( 109)										int v4;
HXDLIN( 109)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)											v4 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 109)											v4 = c8;
            										}
HXDLIN( 109)										int maskPixel1 = v4;
HXDLIN( 109)										int this85 = col1;
HXDLIN( 109)										if ((maskPixel1 == 0)) {
HXLINE( 109)											col1 = this85;
            										}
            										else {
HXLINE( 109)											Float m01;
HXDLIN( 109)											int this86 = ((maskPixel1 >> 24) & 255);
HXDLIN( 109)											if ((this86 == 0)) {
HXLINE( 109)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m01 = (( (Float)(this86) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m11;
HXDLIN( 109)											int this87 = ((maskPixel1 >> 16) & 255);
HXDLIN( 109)											if ((this87 == 0)) {
HXLINE( 109)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m11 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m21;
HXDLIN( 109)											int this88 = ((maskPixel1 >> 8) & 255);
HXDLIN( 109)											if ((this88 == 0)) {
HXLINE( 109)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m21 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float m31;
HXDLIN( 109)											int this89 = (maskPixel1 & 255);
HXDLIN( 109)											if ((this89 == 0)) {
HXLINE( 109)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												m31 = (( (Float)(this89) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this85 >> 24) & 255)) )));
HXDLIN( 109)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this85 >> 16) & 255)) )));
HXDLIN( 109)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this85 >> 8) & 255)) )));
HXDLIN( 109)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this85 & 255)) )));
HXDLIN( 109)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 109)									if ((col1 != 0)) {
HXLINE( 109)										int x8 = (dx2 - rectLeft1);
HXDLIN( 109)										int y8 = (dy2 - rectTop1);
HXDLIN( 109)										int c9 = col1;
HXDLIN( 109)										bool _hx_tmp21;
HXDLIN( 109)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 109)											_hx_tmp21 = undoImage3->transparent;
            										}
            										else {
HXLINE( 109)											_hx_tmp21 = false;
            										}
HXDLIN( 109)										if (_hx_tmp21) {
HXLINE( 109)											int location6;
HXDLIN( 109)											if (undoImage3->useVirtualPos) {
HXLINE( 109)												location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 109)												location6 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 109)											int this90 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN( 109)											int this91;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												this91 = this90;
            											}
HXDLIN( 109)											Float a17;
HXDLIN( 109)											int this92 = ((this91 >> 24) & 255);
HXDLIN( 109)											if ((this92 == 0)) {
HXLINE( 109)												a17 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float r16;
HXDLIN( 109)											int this93 = ((this91 >> 16) & 255);
HXDLIN( 109)											if ((this93 == 0)) {
HXLINE( 109)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												r16 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float g16;
HXDLIN( 109)											int this94 = ((this91 >> 8) & 255);
HXDLIN( 109)											if ((this94 == 0)) {
HXLINE( 109)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												g16 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float b110;
HXDLIN( 109)											int this95 = (this91 & 255);
HXDLIN( 109)											if ((this95 == 0)) {
HXLINE( 109)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												b110 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float a26;
HXDLIN( 109)											int this96 = ((col1 >> 24) & 255);
HXDLIN( 109)											if ((this96 == 0)) {
HXLINE( 109)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												a26 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float r26;
HXDLIN( 109)											int this97 = ((col1 >> 16) & 255);
HXDLIN( 109)											if ((this97 == 0)) {
HXLINE( 109)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												r26 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float g26;
HXDLIN( 109)											int this98 = ((col1 >> 8) & 255);
HXDLIN( 109)											if ((this98 == 0)) {
HXLINE( 109)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												g26 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float b26;
HXDLIN( 109)											int this99 = (col1 & 255);
HXDLIN( 109)											if ((this99 == 0)) {
HXLINE( 109)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 109)												b26 = (( (Float)(this99) ) / ( (Float)(255) ));
            											}
HXDLIN( 109)											Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 109)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 109)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 109)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b26 * a26))));
HXDLIN( 109)											int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 109)											int blended6 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 109)											{
HXLINE( 109)												int _hx_tmp22;
HXDLIN( 109)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)													_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 109)													_hx_tmp22 = blended6;
            												}
HXDLIN( 109)												::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            											}
            										}
            										else {
HXLINE( 109)											::Dynamic this100 = undoImage3->image;
HXDLIN( 109)											int index10;
HXDLIN( 109)											if (undoImage3->useVirtualPos) {
HXLINE( 109)												index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 109)												index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 109)											int _hx_tmp23;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												_hx_tmp23 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												_hx_tmp23 = c9;
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp23);
            										}
            									}
            									else {
HXLINE( 109)										if (forceClear1) {
HXLINE( 109)											::Dynamic this101 = undoImage3->image;
HXDLIN( 109)											int x9 = (dx2 - rectLeft1);
HXDLIN( 109)											int y9 = (dy2 - rectTop1);
HXDLIN( 109)											int index11;
HXDLIN( 109)											if (undoImage3->useVirtualPos) {
HXLINE( 109)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 109)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(this101,index11,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 109)			bool found1 = false;
HXDLIN( 109)			Float min9 = ( (Float)(0) );
HXDLIN( 109)			Float max1 = ( (Float)(0) );
HXDLIN( 109)			int a19 = 0;
HXDLIN( 109)			int r10 = 0;
HXDLIN( 109)			int g10 = 0;
HXDLIN( 109)			int b27 = 0;
HXDLIN( 109)			{
HXLINE( 109)				int _g_min2 = xIter31->start;
HXDLIN( 109)				int _g_max2 = xIter31->max;
HXDLIN( 109)				while((_g_min2 < _g_max2)){
HXLINE( 109)					_g_min2 = (_g_min2 + 1);
HXDLIN( 109)					int px2 = (_g_min2 - 1);
HXDLIN( 109)					Float pcx1 = (( (Float)(px2) ) - dx);
HXLINE( 695)					found1 = false;
HXLINE( 109)					{
HXLINE( 109)						int _g_min3 = yIter31->start;
HXDLIN( 109)						int _g_max3 = yIter31->max;
HXDLIN( 109)						while((_g_min3 < _g_max3)){
HXLINE( 109)							_g_min3 = (_g_min3 + 1);
HXDLIN( 109)							int py2 = (_g_min3 - 1);
HXDLIN( 109)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 109)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 109)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 109)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 109)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 109)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 109)							bool _hx_tmp24;
HXDLIN( 109)							bool _hx_tmp25;
HXDLIN( 109)							if ((ratioA1 >= 0)) {
HXLINE( 109)								_hx_tmp25 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 109)								_hx_tmp25 = false;
            							}
HXDLIN( 109)							if (_hx_tmp25) {
HXLINE( 109)								_hx_tmp24 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 109)								_hx_tmp24 = false;
            							}
HXDLIN( 109)							if (_hx_tmp24) {
HXLINE( 109)								if (softBC) {
HXLINE( 109)									if (softCD) {
HXLINE( 109)										if ((ratioB1 < ratioC1)) {
HXLINE( 109)											min9 = ratioB1;
            										}
            										else {
HXLINE( 109)											min9 = ratioC1;
            										}
HXDLIN( 109)										if ((ratioA1 > ratioB1)) {
HXLINE( 109)											max1 = ratioA1;
            										}
            										else {
HXLINE( 109)											max1 = ratioB1;
            										}
HXDLIN( 109)										if (!((max1 > ratioC1))) {
HXLINE( 109)											max1 = ratioC1;
            										}
HXLINE( 735)										max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 109)										if (!((min9 < max1))) {
HXLINE( 109)											min9 = ((max1 + min9) / ( (Float)(2) ));
            										}
HXDLIN( 109)										int i27 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 109)										if ((i27 > 255)) {
HXLINE(  24)											i27 = 255;
            										}
HXLINE( 109)										if ((i27 < 0)) {
HXLINE(  25)											i27 = 0;
            										}
HXLINE( 109)										a19 = i27;
            									}
            									else {
HXLINE( 722)										min9 = ratioC1;
HXLINE( 109)										int i28 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 109)										if ((i28 > 255)) {
HXLINE(  24)											i28 = 255;
            										}
HXLINE( 109)										if ((i28 < 0)) {
HXLINE(  25)											i28 = 0;
            										}
HXLINE( 109)										a19 = i28;
            									}
            								}
            								else {
HXLINE( 109)									if (softCD) {
HXLINE( 712)										min9 = ratioB1;
HXLINE( 109)										int i29 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 109)										if ((i29 > 255)) {
HXLINE(  24)											i29 = 255;
            										}
HXLINE( 109)										if ((i29 < 0)) {
HXLINE(  25)											i29 = 0;
            										}
HXLINE( 109)										a19 = i29;
            									}
            									else {
HXLINE( 109)										int i30 = ::Std_obj::_hx_int(( (Float)(aA1) ));
HXDLIN( 109)										if ((i30 > 255)) {
HXLINE(  24)											i30 = 255;
            										}
HXLINE( 109)										if ((i30 < 0)) {
HXLINE(  25)											i30 = 0;
            										}
HXLINE( 109)										a19 = i30;
            									}
            								}
HXDLIN( 109)								int i31 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 109)								if ((i31 > 255)) {
HXLINE(  24)									i31 = 255;
            								}
HXLINE( 109)								if ((i31 < 0)) {
HXLINE(  25)									i31 = 0;
            								}
HXLINE( 747)								r10 = i31;
HXLINE( 109)								int i32 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 109)								if ((i32 > 255)) {
HXLINE(  24)									i32 = 255;
            								}
HXLINE( 109)								if ((i32 < 0)) {
HXLINE(  25)									i32 = 0;
            								}
HXLINE( 748)								g10 = i32;
HXLINE( 109)								int i33 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 109)								if ((i33 > 255)) {
HXLINE(  24)									i33 = 255;
            								}
HXLINE( 109)								if ((i33 < 0)) {
HXLINE(  25)									i33 = 0;
            								}
HXLINE( 749)								b27 = i33;
HXLINE( 109)								{
HXLINE( 109)									int location7;
HXDLIN( 109)									if (pixelImage->useVirtualPos) {
HXLINE( 109)										location7 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 109)										location7 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 109)									bool _hx_tmp26;
HXDLIN( 109)									if (pixelImage->transparent) {
HXLINE( 109)										_hx_tmp26 = (a19 < 254);
            									}
            									else {
HXLINE( 109)										_hx_tmp26 = false;
            									}
HXDLIN( 109)									if (_hx_tmp26) {
HXLINE( 109)										int this102 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 109)										int old1;
HXDLIN( 109)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)											old1 = ((((((this102 >> 24) & 255) << 24) | ((this102 & 255) << 16)) | (((this102 >> 8) & 255) << 8)) | ((this102 >> 16) & 255));
            										}
            										else {
HXLINE( 109)											old1 = this102;
            										}
HXDLIN( 109)										int rhs1 = ((((a19 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
HXDLIN( 109)										Float a110;
HXDLIN( 109)										int this103 = ((old1 >> 24) & 255);
HXDLIN( 109)										if ((this103 == 0)) {
HXLINE( 109)											a110 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											a110 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float r17;
HXDLIN( 109)										int this104 = ((old1 >> 16) & 255);
HXDLIN( 109)										if ((this104 == 0)) {
HXLINE( 109)											r17 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											r17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float g17;
HXDLIN( 109)										int this105 = ((old1 >> 8) & 255);
HXDLIN( 109)										if ((this105 == 0)) {
HXLINE( 109)											g17 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											g17 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float b111;
HXDLIN( 109)										int this106 = (old1 & 255);
HXDLIN( 109)										if ((this106 == 0)) {
HXLINE( 109)											b111 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											b111 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float a27;
HXDLIN( 109)										int this107 = ((rhs1 >> 24) & 255);
HXDLIN( 109)										if ((this107 == 0)) {
HXLINE( 109)											a27 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											a27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float r27;
HXDLIN( 109)										int this108 = ((rhs1 >> 16) & 255);
HXDLIN( 109)										if ((this108 == 0)) {
HXLINE( 109)											r27 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											r27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float g27;
HXDLIN( 109)										int this109 = ((rhs1 >> 8) & 255);
HXDLIN( 109)										if ((this109 == 0)) {
HXLINE( 109)											g27 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											g27 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float b28;
HXDLIN( 109)										int this110 = (rhs1 & 255);
HXDLIN( 109)										if ((this110 == 0)) {
HXLINE( 109)											b28 = ((Float)0.);
            										}
            										else {
HXLINE( 109)											b28 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 109)										Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 109)										int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 109)										int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 109)										int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b28 * a27))));
HXDLIN( 109)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 109)										int blended7 = ((((a20 << 24) | (r18 << 16)) | (g18 << 8)) | b29);
HXDLIN( 109)										{
HXLINE( 109)											int _hx_tmp27;
HXDLIN( 109)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												_hx_tmp27 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXLINE( 109)												_hx_tmp27 = blended7;
            											}
HXDLIN( 109)											::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp27);
            										}
            									}
            									else {
HXLINE( 109)										int value1;
HXDLIN( 109)										if (pixelImage->isLittle) {
HXLINE( 109)											value1 = ((((a19 << 24) | (b27 << 16)) | (g10 << 8)) | r10);
            										}
            										else {
HXLINE( 109)											value1 = ((((a19 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
            										}
HXDLIN( 109)										::iterMagic::Iimg_obj::set(pixelImage->image,location7,value1);
            									}
            								}
HXLINE( 751)								found1 = true;
            							}
            							else {
HXLINE( 109)								if (found1) {
HXLINE( 109)									goto _hx_goto_56;
            								}
            							}
            						}
            						_hx_goto_56:;
            					}
            				}
            			}
HXDLIN( 109)			if ((hasHit == false)) {
HXLINE( 109)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 109)				if (hasUndo1) {
HXLINE( 109)					v5->undoImage = undoImage3;
HXDLIN( 109)					v5->undoX = xIter31->start;
HXDLIN( 109)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 109)		if ((hasHit == true)) {
HXLINE( 109)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 109)			return v6;
            		}
            		else {
HXLINE( 109)			return null();
            		}
HXDLIN( 109)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(LinePixel_Fields__obj,rotateSoftLine,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateSoftLineLuxury( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta,int color,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCD,::hx::Null< bool >  __o_softDA,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		Float soft = __o_soft.Default(((Float)40.));
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCD = __o_softCD.Default(true);
            		bool softDA = __o_softDA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_123_rotateSoftLineLuxury)
HXLINE( 124)		Float sin = ::Math_obj::sin(theta);
HXLINE( 125)		Float cos = ::Math_obj::cos(theta);
HXLINE( 126)		Float radius = (thick / ( (Float)(2) ));
HXLINE( 127)		Float dx = ((Float)0.1);
HXLINE( 128)		Float dy = radius;
HXLINE( 129)		Float cx = h;
HXLINE( 130)		Float cy = radius;
HXLINE( 131)		Float bx = h;
HXLINE( 132)		Float by = -(radius);
HXLINE( 133)		Float ax = ((Float)0.1);
HXLINE( 134)		Float ay = -(radius);
HXLINE( 135)		Float temp = ((Float)0.);
HXLINE( 136)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 137)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 138)		ax = temp;
HXLINE( 140)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 141)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 142)		bx = temp;
HXLINE( 144)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 145)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 146)		cx = temp;
HXLINE( 148)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 149)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 150)		dx = temp;
HXLINE( 157)		if (( (bool)(debugCorners) )) {
HXLINE( 158)			{
HXLINE( 158)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN( 158)				{
HXLINE( 158)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN( 158)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN( 158)					int r_w = 12;
HXDLIN( 158)					int r_h = 12;
HXDLIN( 158)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 158)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 158)					int ii_min = r_x;
HXDLIN( 158)					int ii_max = xmax;
HXDLIN( 158)					int xRange__start = ii_min;
HXDLIN( 158)					int xRange__max = ii_max;
HXDLIN( 158)					int ii_min1 = r_y;
HXDLIN( 158)					int ii_max1 = ymax;
HXDLIN( 158)					int yRange__start = ii_min1;
HXDLIN( 158)					int yRange__max = ii_max1;
HXDLIN( 158)					int range_x = xRange__start;
HXDLIN( 158)					int range_y = (yRange__start - 1);
HXDLIN( 158)					int range_xReset = range_x;
HXDLIN( 158)					int range_yReset = range_y;
HXDLIN( 158)					int range_xMax = (xRange__max - 2);
HXDLIN( 158)					int range_yMax = (yRange__max - 2);
HXDLIN( 158)					int _this_min = 0;
HXDLIN( 158)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 158)					while((_this_min < _this_max)){
HXLINE( 158)						_this_min = (_this_min + 1);
HXDLIN( 158)						int i = (_this_min - 1);
HXDLIN( 158)						if ((range_y > range_yMax)) {
HXLINE( 158)							range_y = range_yReset;
HXDLIN( 158)							range_x = (range_x + 1);
            						}
HXDLIN( 158)						range_y = (range_y + 1);
HXDLIN( 158)						int i1 = i;
HXDLIN( 158)						{
HXLINE( 158)							int x = range_x;
HXDLIN( 158)							int y = range_y;
HXDLIN( 158)							int c = -65536;
HXDLIN( 158)							bool _hx_tmp;
HXDLIN( 158)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 158)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 158)								_hx_tmp = false;
            							}
HXDLIN( 158)							if (_hx_tmp) {
HXLINE( 158)								int location;
HXDLIN( 158)								if (this1->useVirtualPos) {
HXLINE( 158)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 158)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 158)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 158)								int this3;
HXDLIN( 158)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 158)									this3 = this2;
            								}
HXDLIN( 158)								Float a1;
HXDLIN( 158)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 158)								if ((this4 == 0)) {
HXLINE( 158)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float r1;
HXDLIN( 158)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 158)								if ((this5 == 0)) {
HXLINE( 158)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float g1;
HXDLIN( 158)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 158)								if ((this6 == 0)) {
HXLINE( 158)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float b1;
HXDLIN( 158)								int this7 = (this3 & 255);
HXDLIN( 158)								if ((this7 == 0)) {
HXLINE( 158)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float a2;
HXDLIN( 158)								int this8 = ((-65536 >> 24) & 255);
HXDLIN( 158)								if ((this8 == 0)) {
HXLINE( 158)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float r2;
HXDLIN( 158)								int this9 = ((-65536 >> 16) & 255);
HXDLIN( 158)								if ((this9 == 0)) {
HXLINE( 158)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float g2;
HXDLIN( 158)								int this10 = ((-65536 >> 8) & 255);
HXDLIN( 158)								if ((this10 == 0)) {
HXLINE( 158)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float b2;
HXDLIN( 158)								int this11 = (-65536 & 255);
HXDLIN( 158)								if ((this11 == 0)) {
HXLINE( 158)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 158)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 158)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 158)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 158)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 158)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 158)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 158)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 158)								{
HXLINE( 158)									int _hx_tmp1;
HXDLIN( 158)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 158)										_hx_tmp1 = blended;
            									}
HXDLIN( 158)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 158)								::Dynamic this12 = this1->image;
HXDLIN( 158)								int index;
HXDLIN( 158)								if (this1->useVirtualPos) {
HXLINE( 158)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 158)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 158)								int _hx_tmp2;
HXDLIN( 158)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 158)									_hx_tmp2 = c;
            								}
HXDLIN( 158)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE( 159)			{
HXLINE( 159)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN( 159)				{
HXLINE( 159)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN( 159)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN( 159)					int r_w1 = 12;
HXDLIN( 159)					int r_h1 = 12;
HXDLIN( 159)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 159)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 159)					int ii_min2 = r_x1;
HXDLIN( 159)					int ii_max2 = xmax1;
HXDLIN( 159)					int xRange__start1 = ii_min2;
HXDLIN( 159)					int xRange__max1 = ii_max2;
HXDLIN( 159)					int ii_min3 = r_y1;
HXDLIN( 159)					int ii_max3 = ymax1;
HXDLIN( 159)					int yRange__start1 = ii_min3;
HXDLIN( 159)					int yRange__max1 = ii_max3;
HXDLIN( 159)					int range_x1 = xRange__start1;
HXDLIN( 159)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 159)					int range_xReset1 = range_x1;
HXDLIN( 159)					int range_yReset1 = range_y1;
HXDLIN( 159)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 159)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 159)					int _this_min1 = 0;
HXDLIN( 159)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 159)					while((_this_min1 < _this_max1)){
HXLINE( 159)						_this_min1 = (_this_min1 + 1);
HXDLIN( 159)						int i2 = (_this_min1 - 1);
HXDLIN( 159)						if ((range_y1 > range_yMax1)) {
HXLINE( 159)							range_y1 = range_yReset1;
HXDLIN( 159)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 159)						range_y1 = (range_y1 + 1);
HXDLIN( 159)						int i3 = i2;
HXDLIN( 159)						{
HXLINE( 159)							int x1 = range_x1;
HXDLIN( 159)							int y1 = range_y1;
HXDLIN( 159)							int c1 = -16711936;
HXDLIN( 159)							bool _hx_tmp3;
HXDLIN( 159)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 159)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE( 159)								_hx_tmp3 = false;
            							}
HXDLIN( 159)							if (_hx_tmp3) {
HXLINE( 159)								int location1;
HXDLIN( 159)								if (this13->useVirtualPos) {
HXLINE( 159)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 159)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 159)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN( 159)								int this15;
HXDLIN( 159)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 159)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE( 159)									this15 = this14;
            								}
HXDLIN( 159)								Float a11;
HXDLIN( 159)								int this16 = ((this15 >> 24) & 255);
HXDLIN( 159)								if ((this16 == 0)) {
HXLINE( 159)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float r11;
HXDLIN( 159)								int this17 = ((this15 >> 16) & 255);
HXDLIN( 159)								if ((this17 == 0)) {
HXLINE( 159)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float g11;
HXDLIN( 159)								int this18 = ((this15 >> 8) & 255);
HXDLIN( 159)								if ((this18 == 0)) {
HXLINE( 159)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float b11;
HXDLIN( 159)								int this19 = (this15 & 255);
HXDLIN( 159)								if ((this19 == 0)) {
HXLINE( 159)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float a21;
HXDLIN( 159)								int this20 = ((-16711936 >> 24) & 255);
HXDLIN( 159)								if ((this20 == 0)) {
HXLINE( 159)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float r21;
HXDLIN( 159)								int this21 = ((-16711936 >> 16) & 255);
HXDLIN( 159)								if ((this21 == 0)) {
HXLINE( 159)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float g21;
HXDLIN( 159)								int this22 = ((-16711936 >> 8) & 255);
HXDLIN( 159)								if ((this22 == 0)) {
HXLINE( 159)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float b21;
HXDLIN( 159)								int this23 = (-16711936 & 255);
HXDLIN( 159)								if ((this23 == 0)) {
HXLINE( 159)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 159)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN( 159)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 159)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 159)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 159)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 159)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 159)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 159)								{
HXLINE( 159)									int _hx_tmp4;
HXDLIN( 159)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 159)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 159)										_hx_tmp4 = blended1;
            									}
HXDLIN( 159)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 159)								::Dynamic this24 = this13->image;
HXDLIN( 159)								int index1;
HXDLIN( 159)								if (this13->useVirtualPos) {
HXLINE( 159)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 159)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 159)								int _hx_tmp5;
HXDLIN( 159)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 159)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 159)									_hx_tmp5 = c1;
            								}
HXDLIN( 159)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE( 160)			{
HXLINE( 160)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN( 160)				{
HXLINE( 160)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN( 160)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN( 160)					int r_w2 = 12;
HXDLIN( 160)					int r_h2 = 12;
HXDLIN( 160)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 160)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 160)					int ii_min4 = r_x2;
HXDLIN( 160)					int ii_max4 = xmax2;
HXDLIN( 160)					int xRange__start2 = ii_min4;
HXDLIN( 160)					int xRange__max2 = ii_max4;
HXDLIN( 160)					int ii_min5 = r_y2;
HXDLIN( 160)					int ii_max5 = ymax2;
HXDLIN( 160)					int yRange__start2 = ii_min5;
HXDLIN( 160)					int yRange__max2 = ii_max5;
HXDLIN( 160)					int range_x2 = xRange__start2;
HXDLIN( 160)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 160)					int range_xReset2 = range_x2;
HXDLIN( 160)					int range_yReset2 = range_y2;
HXDLIN( 160)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 160)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 160)					int _this_min2 = 0;
HXDLIN( 160)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 160)					while((_this_min2 < _this_max2)){
HXLINE( 160)						_this_min2 = (_this_min2 + 1);
HXDLIN( 160)						int i4 = (_this_min2 - 1);
HXDLIN( 160)						if ((range_y2 > range_yMax2)) {
HXLINE( 160)							range_y2 = range_yReset2;
HXDLIN( 160)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 160)						range_y2 = (range_y2 + 1);
HXDLIN( 160)						int i5 = i4;
HXDLIN( 160)						{
HXLINE( 160)							int x2 = range_x2;
HXDLIN( 160)							int y2 = range_y2;
HXDLIN( 160)							int c2 = -16776961;
HXDLIN( 160)							bool _hx_tmp6;
HXDLIN( 160)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 160)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE( 160)								_hx_tmp6 = false;
            							}
HXDLIN( 160)							if (_hx_tmp6) {
HXLINE( 160)								int location2;
HXDLIN( 160)								if (this25->useVirtualPos) {
HXLINE( 160)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 160)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 160)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN( 160)								int this27;
HXDLIN( 160)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE( 160)									this27 = this26;
            								}
HXDLIN( 160)								Float a12;
HXDLIN( 160)								int this28 = ((this27 >> 24) & 255);
HXDLIN( 160)								if ((this28 == 0)) {
HXLINE( 160)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float r12;
HXDLIN( 160)								int this29 = ((this27 >> 16) & 255);
HXDLIN( 160)								if ((this29 == 0)) {
HXLINE( 160)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float g12;
HXDLIN( 160)								int this30 = ((this27 >> 8) & 255);
HXDLIN( 160)								if ((this30 == 0)) {
HXLINE( 160)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float b12;
HXDLIN( 160)								int this31 = (this27 & 255);
HXDLIN( 160)								if ((this31 == 0)) {
HXLINE( 160)									b12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float a22;
HXDLIN( 160)								int this32 = ((-16776961 >> 24) & 255);
HXDLIN( 160)								if ((this32 == 0)) {
HXLINE( 160)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float r22;
HXDLIN( 160)								int this33 = ((-16776961 >> 16) & 255);
HXDLIN( 160)								if ((this33 == 0)) {
HXLINE( 160)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float g22;
HXDLIN( 160)								int this34 = ((-16776961 >> 8) & 255);
HXDLIN( 160)								if ((this34 == 0)) {
HXLINE( 160)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float b22;
HXDLIN( 160)								int this35 = (-16776961 & 255);
HXDLIN( 160)								if ((this35 == 0)) {
HXLINE( 160)									b22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 160)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 160)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 160)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN( 160)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 160)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN( 160)								{
HXLINE( 160)									int _hx_tmp7;
HXDLIN( 160)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 160)										_hx_tmp7 = blended2;
            									}
HXDLIN( 160)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE( 160)								::Dynamic this36 = this25->image;
HXDLIN( 160)								int index2;
HXDLIN( 160)								if (this25->useVirtualPos) {
HXLINE( 160)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 160)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 160)								int _hx_tmp8;
HXDLIN( 160)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE( 160)									_hx_tmp8 = c2;
            								}
HXDLIN( 160)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE( 161)			{
HXLINE( 161)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN( 161)				{
HXLINE( 161)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN( 161)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN( 161)					int r_w3 = 12;
HXDLIN( 161)					int r_h3 = 12;
HXDLIN( 161)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN( 161)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN( 161)					int ii_min6 = r_x3;
HXDLIN( 161)					int ii_max6 = xmax3;
HXDLIN( 161)					int xRange__start3 = ii_min6;
HXDLIN( 161)					int xRange__max3 = ii_max6;
HXDLIN( 161)					int ii_min7 = r_y3;
HXDLIN( 161)					int ii_max7 = ymax3;
HXDLIN( 161)					int yRange__start3 = ii_min7;
HXDLIN( 161)					int yRange__max3 = ii_max7;
HXDLIN( 161)					int range_x3 = xRange__start3;
HXDLIN( 161)					int range_y3 = (yRange__start3 - 1);
HXDLIN( 161)					int range_xReset3 = range_x3;
HXDLIN( 161)					int range_yReset3 = range_y3;
HXDLIN( 161)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN( 161)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN( 161)					int _this_min3 = 0;
HXDLIN( 161)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN( 161)					while((_this_min3 < _this_max3)){
HXLINE( 161)						_this_min3 = (_this_min3 + 1);
HXDLIN( 161)						int i6 = (_this_min3 - 1);
HXDLIN( 161)						if ((range_y3 > range_yMax3)) {
HXLINE( 161)							range_y3 = range_yReset3;
HXDLIN( 161)							range_x3 = (range_x3 + 1);
            						}
HXDLIN( 161)						range_y3 = (range_y3 + 1);
HXDLIN( 161)						int i7 = i6;
HXDLIN( 161)						{
HXLINE( 161)							int x3 = range_x3;
HXDLIN( 161)							int y3 = range_y3;
HXDLIN( 161)							int c3 = -1048336;
HXDLIN( 161)							bool _hx_tmp9;
HXDLIN( 161)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 161)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE( 161)								_hx_tmp9 = false;
            							}
HXDLIN( 161)							if (_hx_tmp9) {
HXLINE( 161)								int location3;
HXDLIN( 161)								if (this37->useVirtualPos) {
HXLINE( 161)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 161)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 161)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 161)								int this39;
HXDLIN( 161)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 161)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE( 161)									this39 = this38;
            								}
HXDLIN( 161)								Float a13;
HXDLIN( 161)								int this40 = ((this39 >> 24) & 255);
HXDLIN( 161)								if ((this40 == 0)) {
HXLINE( 161)									a13 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float r13;
HXDLIN( 161)								int this41 = ((this39 >> 16) & 255);
HXDLIN( 161)								if ((this41 == 0)) {
HXLINE( 161)									r13 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float g13;
HXDLIN( 161)								int this42 = ((this39 >> 8) & 255);
HXDLIN( 161)								if ((this42 == 0)) {
HXLINE( 161)									g13 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float b13;
HXDLIN( 161)								int this43 = (this39 & 255);
HXDLIN( 161)								if ((this43 == 0)) {
HXLINE( 161)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float a23;
HXDLIN( 161)								int this44 = ((-1048336 >> 24) & 255);
HXDLIN( 161)								if ((this44 == 0)) {
HXLINE( 161)									a23 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float r23;
HXDLIN( 161)								int this45 = ((-1048336 >> 16) & 255);
HXDLIN( 161)								if ((this45 == 0)) {
HXLINE( 161)									r23 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float g23;
HXDLIN( 161)								int this46 = ((-1048336 >> 8) & 255);
HXDLIN( 161)								if ((this46 == 0)) {
HXLINE( 161)									g23 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float b23;
HXDLIN( 161)								int this47 = (-1048336 & 255);
HXDLIN( 161)								if ((this47 == 0)) {
HXLINE( 161)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 161)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN( 161)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 161)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 161)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 161)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN( 161)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 161)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN( 161)								{
HXLINE( 161)									int _hx_tmp10;
HXDLIN( 161)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 161)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE( 161)										_hx_tmp10 = blended3;
            									}
HXDLIN( 161)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE( 161)								::Dynamic this48 = this37->image;
HXDLIN( 161)								int index3;
HXDLIN( 161)								if (this37->useVirtualPos) {
HXLINE( 161)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 161)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 161)								int _hx_tmp11;
HXDLIN( 161)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 161)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 161)									_hx_tmp11 = c3;
            								}
HXDLIN( 161)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 163)		{
HXLINE( 163)			bool hasUndo = true;
HXDLIN( 163)			int aA = ((color >> 24) & 255);
HXDLIN( 163)			int rA = ((color >> 16) & 255);
HXDLIN( 163)			int gA = ((color >> 8) & 255);
HXDLIN( 163)			int bA = (color & 255);
HXDLIN( 163)			Float bcx = (bx - cx);
HXDLIN( 163)			Float bcy = (by - cy);
HXDLIN( 163)			Float acx = (ax - cx);
HXDLIN( 163)			Float acy = (ay - cy);
HXDLIN( 163)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 163)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 163)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 163)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 163)			if ((ax > bx)) {
HXLINE( 163)				if ((ax > cx)) {
HXLINE( 163)					int min;
HXDLIN( 163)					if ((bx > cx)) {
HXLINE( 163)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 163)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 163)					int ii_min8 = min;
HXDLIN( 163)					int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 163)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 163)					int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 163)					int ii_max9 = ::Math_obj::ceil(cx);
HXDLIN( 163)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 163)				if ((bx > cx)) {
HXLINE( 163)					int min1;
HXDLIN( 163)					if ((ax > cx)) {
HXLINE( 163)						min1 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 163)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 163)					int ii_min10 = min1;
HXDLIN( 163)					int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 163)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 163)					int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 163)					int ii_max11 = ::Math_obj::ceil(cx);
HXDLIN( 163)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 163)			if ((ay > by)) {
HXLINE( 163)				if ((ay > cy)) {
HXLINE( 163)					int min2;
HXDLIN( 163)					if ((by > cy)) {
HXLINE( 163)						min2 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 163)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 163)					int ii_min12 = min2;
HXDLIN( 163)					int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 163)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 163)					int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 163)					int ii_max13 = ::Math_obj::ceil(cy);
HXDLIN( 163)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 163)				if ((by > cy)) {
HXLINE( 163)					int min3;
HXDLIN( 163)					if ((ay > cy)) {
HXLINE( 163)						min3 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 163)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 163)					int ii_min14 = min3;
HXDLIN( 163)					int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 163)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 163)					int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 163)					int ii_max15 = ::Math_obj::ceil(cy);
HXDLIN( 163)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 163)			if (hasUndo) {
HXLINE( 163)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 163)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 163)				 ::Dynamic imageType = null();
HXDLIN( 163)				 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 163)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 163)				::Dynamic undoImage1;
HXDLIN( 163)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 163)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::BytesImg b6 = byt;
HXDLIN( 163)						{
HXLINE( 163)							b6->width = width;
HXDLIN( 163)							b6->height = height;
HXDLIN( 163)							b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 163)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 163)							{
HXLINE( 163)								int len = b6->length;
HXDLIN( 163)								int w = 0;
HXDLIN( 163)								{
HXLINE( 163)									int _g = 0;
HXDLIN( 163)									int _g1 = b6->height;
HXDLIN( 163)									while((_g < _g1)){
HXLINE( 163)										_g = (_g + 1);
HXDLIN( 163)										int y4 = (_g - 1);
HXDLIN( 163)										{
HXLINE( 163)											int _g2 = 0;
HXDLIN( 163)											int _g3 = b6->width;
HXDLIN( 163)											while((_g2 < _g3)){
HXLINE( 163)												_g2 = (_g2 + 1);
HXDLIN( 163)												int x4 = (_g2 - 1);
HXDLIN( 163)												{
HXLINE( 163)													w = (w + 1);
HXDLIN( 163)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w = (w + 1);
HXDLIN( 163)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w = (w + 1);
HXDLIN( 163)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w = (w + 1);
HXDLIN( 163)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage1 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 163)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN( 163)						{
HXLINE( 163)							a7->width = width;
HXDLIN( 163)							a7->height = height;
HXDLIN( 163)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 163)							a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 163)							{
HXLINE( 163)								int _g4 = 0;
HXDLIN( 163)								int _g5 = a7->length;
HXDLIN( 163)								while((_g4 < _g5)){
HXLINE( 163)									_g4 = (_g4 + 1);
HXDLIN( 163)									int i8 = (_g4 - 1);
HXDLIN( 163)									a7->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 163)						undoImage1 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 163)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN( 163)						{
HXLINE( 163)							b7->width = width;
HXDLIN( 163)							b7->height = height;
HXDLIN( 163)							b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 163)							int size = (b7->length * 4);
HXDLIN( 163)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 163)							{
HXLINE( 163)								int _g6 = 0;
HXDLIN( 163)								int _g7 = b7->length;
HXDLIN( 163)								while((_g6 < _g7)){
HXLINE( 163)									_g6 = (_g6 + 1);
HXDLIN( 163)									int i9 = (_g6 - 1);
HXDLIN( 163)									{
HXLINE( 163)										 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN( 163)										bool undoImage2;
HXDLIN( 163)										if ((i9 >= 0)) {
HXLINE( 163)											undoImage2 = (i9 < (this50->byteLength >> 2));
            										}
            										else {
HXLINE( 163)											undoImage2 = false;
            										}
HXDLIN( 163)										if (undoImage2) {
HXLINE( 163)											 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN( 163)											int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN( 163)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 163)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage1 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 163)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 163)						{
HXLINE( 163)							v->width = width;
HXDLIN( 163)							v->height = height;
HXDLIN( 163)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 163)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 163)							{
HXLINE( 163)								int _g8 = 0;
HXDLIN( 163)								int _g9 = v->length;
HXDLIN( 163)								while((_g8 < _g9)){
HXLINE( 163)									_g8 = (_g8 + 1);
HXDLIN( 163)									int i10 = (_g8 - 1);
HXDLIN( 163)									v->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 163)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 163)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN( 163)						{
HXLINE( 163)							b8->width = width;
HXDLIN( 163)							b8->height = height;
HXDLIN( 163)							b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 163)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 163)							{
HXLINE( 163)								int len1 = b8->length;
HXDLIN( 163)								 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN( 163)								if (::hx::IsNull( d->head )) {
HXLINE( 163)									int _g10 = 0;
HXDLIN( 163)									int _g11 = len1;
HXDLIN( 163)									while((_g10 < _g11)){
HXLINE( 163)										_g10 = (_g10 + 1);
HXDLIN( 163)										int i11 = (_g10 - 1);
HXDLIN( 163)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 163)									int _g12 = 0;
HXDLIN( 163)									int _g13 = len1;
HXDLIN( 163)									while((_g12 < _g13)){
HXLINE( 163)										_g12 = (_g12 + 1);
HXDLIN( 163)										int i12 = (_g12 - 1);
HXDLIN( 163)										{
HXLINE( 163)											 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN( 163)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 163)											{
HXLINE( 163)												int _g14 = 0;
HXDLIN( 163)												int _g15 = i12;
HXDLIN( 163)												while((_g14 < _g15)){
HXLINE( 163)													_g14 = (_g14 + 1);
HXDLIN( 163)													int i13 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 163)											if (::hx::IsNull( prev )) {
HXLINE( 163)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 163)												l = null();
            											}
            											else {
HXLINE( 163)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 163)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage1 = b8;
            					}
            					break;
            				}
HXDLIN( 163)				this49->image = undoImage1;
HXDLIN( 163)				this49->width = width;
HXDLIN( 163)				this49->height = height;
HXDLIN( 163)				this49->imageType = ( (int)(imageType) );
HXDLIN( 163)				undoImage = this49;
HXDLIN( 163)				{
HXLINE( 163)					int rectLeft = xIter3->start;
HXDLIN( 163)					int rectTop = yIter3->start;
HXDLIN( 163)					int rectRight = xIter3->max;
HXDLIN( 163)					bool forceClear = false;
HXDLIN( 163)					{
HXLINE( 163)						int _g16 = rectTop;
HXDLIN( 163)						int _g17 = yIter3->max;
HXDLIN( 163)						while((_g16 < _g17)){
HXLINE( 163)							_g16 = (_g16 + 1);
HXDLIN( 163)							int dy1 = (_g16 - 1);
HXDLIN( 163)							{
HXLINE( 163)								int _g18 = rectLeft;
HXDLIN( 163)								int _g19 = rectRight;
HXDLIN( 163)								while((_g18 < _g19)){
HXLINE( 163)									_g18 = (_g18 + 1);
HXDLIN( 163)									int dx1 = (_g18 - 1);
HXDLIN( 163)									::Dynamic this51 = pixelImage->image;
HXDLIN( 163)									int index4;
HXDLIN( 163)									if (pixelImage->useVirtualPos) {
HXLINE( 163)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 163)										index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 163)									int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN( 163)									int col;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										col = c4;
            									}
HXDLIN( 163)									bool _hx_tmp12;
HXDLIN( 163)									if (pixelImage->useMask) {
HXLINE( 163)										_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 163)										_hx_tmp12 = false;
            									}
HXDLIN( 163)									if (_hx_tmp12) {
HXLINE( 163)										 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN( 163)										::Dynamic this53 = this52->image;
HXDLIN( 163)										int index5;
HXDLIN( 163)										if (this52->useVirtualPos) {
HXLINE( 163)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            										}
            										else {
HXLINE( 163)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            										}
HXDLIN( 163)										int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN( 163)										int v1;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											v1 = c5;
            										}
HXDLIN( 163)										int maskPixel = v1;
HXDLIN( 163)										int this54 = col;
HXDLIN( 163)										if ((maskPixel == 0)) {
HXLINE( 163)											col = this54;
            										}
            										else {
HXLINE( 163)											Float m0;
HXDLIN( 163)											int this55 = ((maskPixel >> 24) & 255);
HXDLIN( 163)											if ((this55 == 0)) {
HXLINE( 163)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m1;
HXDLIN( 163)											int this56 = ((maskPixel >> 16) & 255);
HXDLIN( 163)											if ((this56 == 0)) {
HXLINE( 163)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m2;
HXDLIN( 163)											int this57 = ((maskPixel >> 8) & 255);
HXDLIN( 163)											if ((this57 == 0)) {
HXLINE( 163)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m3;
HXDLIN( 163)											int this58 = (maskPixel & 255);
HXDLIN( 163)											if ((this58 == 0)) {
HXLINE( 163)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 163)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 163)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 163)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN( 163)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 163)									if ((col != 0)) {
HXLINE( 163)										int x5 = (dx1 - rectLeft);
HXDLIN( 163)										int y5 = (dy1 - rectTop);
HXDLIN( 163)										int c6 = col;
HXDLIN( 163)										bool _hx_tmp13;
HXDLIN( 163)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 163)											_hx_tmp13 = undoImage->transparent;
            										}
            										else {
HXLINE( 163)											_hx_tmp13 = false;
            										}
HXDLIN( 163)										if (_hx_tmp13) {
HXLINE( 163)											int location4;
HXDLIN( 163)											if (undoImage->useVirtualPos) {
HXLINE( 163)												location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 163)												location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 163)											int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN( 163)											int this60;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												this60 = this59;
            											}
HXDLIN( 163)											Float a14;
HXDLIN( 163)											int this61 = ((this60 >> 24) & 255);
HXDLIN( 163)											if ((this61 == 0)) {
HXLINE( 163)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r14;
HXDLIN( 163)											int this62 = ((this60 >> 16) & 255);
HXDLIN( 163)											if ((this62 == 0)) {
HXLINE( 163)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g14;
HXDLIN( 163)											int this63 = ((this60 >> 8) & 255);
HXDLIN( 163)											if ((this63 == 0)) {
HXLINE( 163)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b14;
HXDLIN( 163)											int this64 = (this60 & 255);
HXDLIN( 163)											if ((this64 == 0)) {
HXLINE( 163)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a24;
HXDLIN( 163)											int this65 = ((col >> 24) & 255);
HXDLIN( 163)											if ((this65 == 0)) {
HXLINE( 163)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r24;
HXDLIN( 163)											int this66 = ((col >> 16) & 255);
HXDLIN( 163)											if ((this66 == 0)) {
HXLINE( 163)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g24;
HXDLIN( 163)											int this67 = ((col >> 8) & 255);
HXDLIN( 163)											if ((this67 == 0)) {
HXLINE( 163)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b24;
HXDLIN( 163)											int this68 = (col & 255);
HXDLIN( 163)											if ((this68 == 0)) {
HXLINE( 163)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 163)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 163)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 163)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN( 163)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 163)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp14;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp14 = blended4;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            											}
            										}
            										else {
HXLINE( 163)											::Dynamic this69 = undoImage->image;
HXDLIN( 163)											int index6;
HXDLIN( 163)											if (undoImage->useVirtualPos) {
HXLINE( 163)												index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 163)												index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 163)											int _hx_tmp15;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												_hx_tmp15 = c6;
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 163)										if (forceClear) {
HXLINE( 163)											::Dynamic this70 = undoImage->image;
HXDLIN( 163)											int x6 = (dx1 - rectLeft);
HXDLIN( 163)											int y6 = (dy1 - rectTop);
HXDLIN( 163)											int index7;
HXDLIN( 163)											if (undoImage->useVirtualPos) {
HXLINE( 163)												index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            											}
            											else {
HXLINE( 163)												index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this70,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 163)			bool found = false;
HXDLIN( 163)			Float min4 = ( (Float)(0) );
HXDLIN( 163)			Float max = ( (Float)(0) );
HXDLIN( 163)			int a9 = 0;
HXDLIN( 163)			int r7 = 0;
HXDLIN( 163)			int g7 = 0;
HXDLIN( 163)			int b10 = 0;
HXDLIN( 163)			{
HXLINE( 163)				int _g_min = xIter3->start;
HXDLIN( 163)				int _g_max = xIter3->max;
HXDLIN( 163)				while((_g_min < _g_max)){
HXLINE( 163)					_g_min = (_g_min + 1);
HXDLIN( 163)					int px1 = (_g_min - 1);
HXDLIN( 163)					Float pcx = (( (Float)(px1) ) - cx);
HXLINE( 812)					found = false;
HXLINE( 163)					{
HXLINE( 163)						int _g_min1 = yIter3->start;
HXDLIN( 163)						int _g_max1 = yIter3->max;
HXDLIN( 163)						while((_g_min1 < _g_max1)){
HXLINE( 163)							_g_min1 = (_g_min1 + 1);
HXDLIN( 163)							int py1 = (_g_min1 - 1);
HXDLIN( 163)							Float pcy = (( (Float)(py1) ) - cy);
HXDLIN( 163)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 163)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 163)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 163)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 163)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 163)							bool _hx_tmp16;
HXDLIN( 163)							bool _hx_tmp17;
HXDLIN( 163)							if ((ratioA >= 0)) {
HXLINE( 163)								_hx_tmp17 = (ratioB >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp17 = false;
            							}
HXDLIN( 163)							if (_hx_tmp17) {
HXLINE( 163)								_hx_tmp16 = (ratioC >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp16 = false;
            							}
HXDLIN( 163)							if (_hx_tmp16) {
HXLINE( 163)								int i14 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 163)								if ((i14 > 255)) {
HXLINE(  24)									i14 = 255;
            								}
HXLINE( 163)								if ((i14 < 0)) {
HXLINE(  25)									i14 = 0;
            								}
HXLINE( 821)								r7 = i14;
HXLINE( 163)								int i15 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 163)								if ((i15 > 255)) {
HXLINE(  24)									i15 = 255;
            								}
HXLINE( 163)								if ((i15 < 0)) {
HXLINE(  25)									i15 = 0;
            								}
HXLINE( 822)								g7 = i15;
HXLINE( 163)								int i16 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 163)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 163)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 823)								b10 = i16;
HXLINE( 163)								bool _hx_tmp18;
HXDLIN( 163)								bool _hx_tmp19;
HXDLIN( 163)								if ((softAB == true)) {
HXLINE( 163)									_hx_tmp19 = (softBC == false);
            								}
            								else {
HXLINE( 163)									_hx_tmp19 = false;
            								}
HXDLIN( 163)								if (_hx_tmp19) {
HXLINE( 163)									_hx_tmp18 = false;
            								}
            								else {
HXLINE( 163)									_hx_tmp18 = false;
            								}
HXDLIN( 163)								if (_hx_tmp18) {
HXLINE( 163)									if ((ratioA < ratioC)) {
HXLINE( 163)										min4 = ratioA;
            									}
            									else {
HXLINE( 163)										min4 = ratioC;
            									}
HXDLIN( 163)									if ((ratioA > ratioB)) {
HXLINE( 163)										max = ratioA;
            									}
            									else {
HXLINE( 163)										max = ratioB;
            									}
HXDLIN( 163)									if (!((max > ratioC))) {
HXLINE( 163)										max = ratioC;
            									}
HXLINE( 829)									max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 163)									if (!((min4 < max))) {
HXLINE( 163)										min4 = ((max + min4) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i17 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 163)									if ((i17 > 255)) {
HXLINE(  24)										i17 = 255;
            									}
HXLINE( 163)									if ((i17 < 0)) {
HXLINE(  25)										i17 = 0;
            									}
HXLINE( 832)									a9 = i17;
HXLINE( 163)									{
HXLINE( 163)										int location5;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 163)										bool _hx_tmp20;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp20 = (a9 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp20 = false;
            										}
HXDLIN( 163)										if (_hx_tmp20) {
HXLINE( 163)											int this71 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 163)											int old;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old = this71;
            											}
HXDLIN( 163)											int rhs = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 163)											Float a15;
HXDLIN( 163)											int this72 = ((old >> 24) & 255);
HXDLIN( 163)											if ((this72 == 0)) {
HXLINE( 163)												a15 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r15;
HXDLIN( 163)											int this73 = ((old >> 16) & 255);
HXDLIN( 163)											if ((this73 == 0)) {
HXLINE( 163)												r15 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r15 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g15;
HXDLIN( 163)											int this74 = ((old >> 8) & 255);
HXDLIN( 163)											if ((this74 == 0)) {
HXLINE( 163)												g15 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g15 = (( (Float)(this74) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b15;
HXDLIN( 163)											int this75 = (old & 255);
HXDLIN( 163)											if ((this75 == 0)) {
HXLINE( 163)												b15 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b15 = (( (Float)(this75) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a25;
HXDLIN( 163)											int this76 = ((rhs >> 24) & 255);
HXDLIN( 163)											if ((this76 == 0)) {
HXLINE( 163)												a25 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a25 = (( (Float)(this76) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r25;
HXDLIN( 163)											int this77 = ((rhs >> 16) & 255);
HXDLIN( 163)											if ((this77 == 0)) {
HXLINE( 163)												r25 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r25 = (( (Float)(this77) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g25;
HXDLIN( 163)											int this78 = ((rhs >> 8) & 255);
HXDLIN( 163)											if ((this78 == 0)) {
HXLINE( 163)												g25 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g25 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b25;
HXDLIN( 163)											int this79 = (rhs & 255);
HXDLIN( 163)											if ((this79 == 0)) {
HXLINE( 163)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 163)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 163)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 163)											int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN( 163)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 163)											int blended5 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b16);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp21;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp21 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp21 = blended5;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp21);
            											}
            										}
            										else {
HXLINE( 163)											int value;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value = ((((a9 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            											}
            											else {
HXLINE( 163)												value = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,value);
            										}
            									}
            								}
HXDLIN( 163)								bool _hx_tmp22;
HXDLIN( 163)								if ((softAB == true)) {
HXLINE( 163)									_hx_tmp22 = (softBC == true);
            								}
            								else {
HXLINE( 163)									_hx_tmp22 = false;
            								}
HXDLIN( 163)								if (_hx_tmp22) {
HXLINE( 163)									if ((ratioB < ratioC)) {
HXLINE( 163)										min4 = ratioB;
            									}
            									else {
HXLINE( 163)										min4 = ratioC;
            									}
HXDLIN( 163)									if ((ratioA > ratioB)) {
HXLINE( 163)										max = ratioA;
            									}
            									else {
HXLINE( 163)										max = ratioB;
            									}
HXDLIN( 163)									if (!((max > ratioC))) {
HXLINE( 163)										max = ratioC;
            									}
HXLINE( 842)									max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 163)									if (!((min4 < max))) {
HXLINE( 163)										min4 = ((max + min4) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i18 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 163)									if ((i18 > 255)) {
HXLINE(  24)										i18 = 255;
            									}
HXLINE( 163)									if ((i18 < 0)) {
HXLINE(  25)										i18 = 0;
            									}
HXLINE( 845)									a9 = i18;
HXLINE( 163)									{
HXLINE( 163)										int location6;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location6 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location6 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 163)										bool _hx_tmp23;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp23 = (a9 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp23 = false;
            										}
HXDLIN( 163)										if (_hx_tmp23) {
HXLINE( 163)											int this80 = ::iterMagic::Iimg_obj::get(pixelImage->image,location6);
HXDLIN( 163)											int old1;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old1 = ((((((this80 >> 24) & 255) << 24) | ((this80 & 255) << 16)) | (((this80 >> 8) & 255) << 8)) | ((this80 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old1 = this80;
            											}
HXDLIN( 163)											int rhs1 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 163)											Float a16;
HXDLIN( 163)											int this81 = ((old1 >> 24) & 255);
HXDLIN( 163)											if ((this81 == 0)) {
HXLINE( 163)												a16 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a16 = (( (Float)(this81) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r16;
HXDLIN( 163)											int this82 = ((old1 >> 16) & 255);
HXDLIN( 163)											if ((this82 == 0)) {
HXLINE( 163)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r16 = (( (Float)(this82) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g16;
HXDLIN( 163)											int this83 = ((old1 >> 8) & 255);
HXDLIN( 163)											if ((this83 == 0)) {
HXLINE( 163)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g16 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b17;
HXDLIN( 163)											int this84 = (old1 & 255);
HXDLIN( 163)											if ((this84 == 0)) {
HXLINE( 163)												b17 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a26;
HXDLIN( 163)											int this85 = ((rhs1 >> 24) & 255);
HXDLIN( 163)											if ((this85 == 0)) {
HXLINE( 163)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a26 = (( (Float)(this85) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r26;
HXDLIN( 163)											int this86 = ((rhs1 >> 16) & 255);
HXDLIN( 163)											if ((this86 == 0)) {
HXLINE( 163)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r26 = (( (Float)(this86) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g26;
HXDLIN( 163)											int this87 = ((rhs1 >> 8) & 255);
HXDLIN( 163)											if ((this87 == 0)) {
HXLINE( 163)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g26 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b26;
HXDLIN( 163)											int this88 = (rhs1 & 255);
HXDLIN( 163)											if ((this88 == 0)) {
HXLINE( 163)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b26 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 163)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 163)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 163)											int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b26 * a26))));
HXDLIN( 163)											int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 163)											int blended6 = ((((a17 << 24) | (r9 << 16)) | (g9 << 8)) | b18);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp24;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp24 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp24 = blended6;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location6,_hx_tmp24);
            											}
            										}
            										else {
HXLINE( 163)											int value1;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value1 = ((((a9 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            											}
            											else {
HXLINE( 163)												value1 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location6,value1);
            										}
            									}
            								}
HXLINE( 850)								found = true;
            							}
            							else {
HXLINE( 163)								if (found) {
HXLINE( 163)									goto _hx_goto_73;
            								}
            							}
            						}
            						_hx_goto_73:;
            					}
            				}
            			}
HXDLIN( 163)			if ((hasHit == false)) {
HXLINE( 163)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 163)				if (hasUndo) {
HXLINE( 163)					v2->undoImage = undoImage;
HXDLIN( 163)					v2->undoX = xIter3->start;
HXDLIN( 163)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN( 163)		{
HXLINE( 163)			bool hasUndo1 = true;
HXDLIN( 163)			int aA1 = ((color >> 24) & 255);
HXDLIN( 163)			int rA1 = ((color >> 16) & 255);
HXDLIN( 163)			int gA1 = ((color >> 8) & 255);
HXDLIN( 163)			int bA1 = (color & 255);
HXDLIN( 163)			Float bcx1 = (cx - ax);
HXDLIN( 163)			Float bcy1 = (cy - ay);
HXDLIN( 163)			Float acx1 = (dx - ax);
HXDLIN( 163)			Float acy1 = (dy - ay);
HXDLIN( 163)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 163)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 163)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 163)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 163)			if ((dx > cx)) {
HXLINE( 163)				if ((dx > ax)) {
HXLINE( 163)					int min5;
HXDLIN( 163)					if ((cx > ax)) {
HXLINE( 163)						min5 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 163)						min5 = ::Math_obj::floor(cx);
            					}
HXDLIN( 163)					int ii_min16 = min5;
HXDLIN( 163)					int ii_max16 = ::Math_obj::ceil(dx);
HXDLIN( 163)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 163)					int ii_min17 = ::Math_obj::floor(cx);
HXDLIN( 163)					int ii_max17 = ::Math_obj::ceil(ax);
HXDLIN( 163)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 163)				if ((cx > ax)) {
HXLINE( 163)					int min6;
HXDLIN( 163)					if ((dx > ax)) {
HXLINE( 163)						min6 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 163)						min6 = ::Math_obj::ceil(dx);
            					}
HXDLIN( 163)					int ii_min18 = min6;
HXDLIN( 163)					int ii_max18 = ::Math_obj::ceil(cx);
HXDLIN( 163)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 163)					int ii_min19 = ::Math_obj::floor(dx);
HXDLIN( 163)					int ii_max19 = ::Math_obj::ceil(ax);
HXDLIN( 163)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 163)			if ((dy > cy)) {
HXLINE( 163)				if ((dy > ay)) {
HXLINE( 163)					int min7;
HXDLIN( 163)					if ((cy > ay)) {
HXLINE( 163)						min7 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 163)						min7 = ::Math_obj::floor(cy);
            					}
HXDLIN( 163)					int ii_min20 = min7;
HXDLIN( 163)					int ii_max20 = ::Math_obj::ceil(dy);
HXDLIN( 163)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 163)					int ii_min21 = ::Math_obj::floor(cy);
HXDLIN( 163)					int ii_max21 = ::Math_obj::ceil(ay);
HXDLIN( 163)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 163)				if ((cy > ay)) {
HXLINE( 163)					int min8;
HXDLIN( 163)					if ((dy > ay)) {
HXLINE( 163)						min8 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 163)						min8 = ::Math_obj::ceil(dy);
            					}
HXDLIN( 163)					int ii_min22 = min8;
HXDLIN( 163)					int ii_max22 = ::Math_obj::ceil(cy);
HXDLIN( 163)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 163)					int ii_min23 = ::Math_obj::floor(dy);
HXDLIN( 163)					int ii_max23 = ::Math_obj::ceil(ay);
HXDLIN( 163)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 163)			if (hasUndo1) {
HXLINE( 163)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 163)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 163)				 ::Dynamic imageType1 = null();
HXDLIN( 163)				 ::pi_xy::ImageStruct this89 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 163)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 163)				::Dynamic undoImage4;
HXDLIN( 163)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 163)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::BytesImg b19 = byt1;
HXDLIN( 163)						{
HXLINE( 163)							b19->width = width1;
HXDLIN( 163)							b19->height = height1;
HXDLIN( 163)							b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)							b19->data = ::haxe::io::Bytes_obj::alloc((b19->length * 4));
HXDLIN( 163)							{
HXLINE( 163)								int len2 = b19->length;
HXDLIN( 163)								int w1 = 0;
HXDLIN( 163)								{
HXLINE( 163)									int _g20 = 0;
HXDLIN( 163)									int _g21 = b19->height;
HXDLIN( 163)									while((_g20 < _g21)){
HXLINE( 163)										_g20 = (_g20 + 1);
HXDLIN( 163)										int y7 = (_g20 - 1);
HXDLIN( 163)										{
HXLINE( 163)											int _g22 = 0;
HXDLIN( 163)											int _g23 = b19->width;
HXDLIN( 163)											while((_g22 < _g23)){
HXLINE( 163)												_g22 = (_g22 + 1);
HXDLIN( 163)												int x7 = (_g22 - 1);
HXDLIN( 163)												{
HXLINE( 163)													w1 = (w1 + 1);
HXDLIN( 163)													b19->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w1 = (w1 + 1);
HXDLIN( 163)													b19->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w1 = (w1 + 1);
HXDLIN( 163)													b19->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w1 = (w1 + 1);
HXDLIN( 163)													b19->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage4 = b19;
            					}
            					break;
            					case (int)1: {
HXLINE( 163)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::ArrIntImg a18 = arrI1;
HXDLIN( 163)						{
HXLINE( 163)							a18->width = width1;
HXDLIN( 163)							a18->height = height1;
HXDLIN( 163)							a18->data = ::Array_obj< int >::__new(0);
HXDLIN( 163)							a18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)							{
HXLINE( 163)								int _g24 = 0;
HXDLIN( 163)								int _g25 = a18->length;
HXDLIN( 163)								while((_g24 < _g25)){
HXLINE( 163)									_g24 = (_g24 + 1);
HXDLIN( 163)									int i19 = (_g24 - 1);
HXDLIN( 163)									a18->data[i19] = 0;
            								}
            							}
            						}
HXDLIN( 163)						undoImage4 = a18;
            					}
            					break;
            					case (int)2: {
HXLINE( 163)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::U32ArrImg b20 = u32a1;
HXDLIN( 163)						{
HXLINE( 163)							b20->width = width1;
HXDLIN( 163)							b20->height = height1;
HXDLIN( 163)							b20->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)							int size1 = (b20->length * 4);
HXDLIN( 163)							b20->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 163)							{
HXLINE( 163)								int _g26 = 0;
HXDLIN( 163)								int _g27 = b20->length;
HXDLIN( 163)								while((_g26 < _g27)){
HXLINE( 163)									_g26 = (_g26 + 1);
HXDLIN( 163)									int i20 = (_g26 - 1);
HXDLIN( 163)									{
HXLINE( 163)										 ::haxe::io::ArrayBufferViewImpl this90 = b20->data;
HXDLIN( 163)										bool undoImage5;
HXDLIN( 163)										if ((i20 >= 0)) {
HXLINE( 163)											undoImage5 = (i20 < (this90->byteLength >> 2));
            										}
            										else {
HXLINE( 163)											undoImage5 = false;
            										}
HXDLIN( 163)										if (undoImage5) {
HXLINE( 163)											 ::haxe::io::Bytes _this1 = this90->bytes;
HXDLIN( 163)											int pos1 = ((i20 << 2) + this90->byteOffset);
HXDLIN( 163)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 163)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage4 = b20;
            					}
            					break;
            					case (int)3: {
HXLINE( 163)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 163)						{
HXLINE( 163)							v3->width = width1;
HXDLIN( 163)							v3->height = height1;
HXDLIN( 163)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 163)							{
HXLINE( 163)								int _g28 = 0;
HXDLIN( 163)								int _g29 = v3->length;
HXDLIN( 163)								while((_g28 < _g29)){
HXLINE( 163)									_g28 = (_g28 + 1);
HXDLIN( 163)									int i21 = (_g28 - 1);
HXDLIN( 163)									v3->data->__unsafe_set(i21,0);
            								}
            							}
            						}
HXDLIN( 163)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 163)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::StackIntImg b27 = sInt1;
HXDLIN( 163)						{
HXLINE( 163)							b27->width = width1;
HXDLIN( 163)							b27->height = height1;
HXDLIN( 163)							b27->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)							b27->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 163)							{
HXLINE( 163)								int len3 = b27->length;
HXDLIN( 163)								 ::haxe::ds::GenericStack_Int d1 = b27->data;
HXDLIN( 163)								if (::hx::IsNull( d1->head )) {
HXLINE( 163)									int _g30 = 0;
HXDLIN( 163)									int _g31 = len3;
HXDLIN( 163)									while((_g30 < _g31)){
HXLINE( 163)										_g30 = (_g30 + 1);
HXDLIN( 163)										int i22 = (_g30 - 1);
HXDLIN( 163)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 163)									int _g32 = 0;
HXDLIN( 163)									int _g33 = len3;
HXDLIN( 163)									while((_g32 < _g33)){
HXLINE( 163)										_g32 = (_g32 + 1);
HXDLIN( 163)										int i23 = (_g32 - 1);
HXDLIN( 163)										{
HXLINE( 163)											 ::haxe::ds::GenericCell_Int l1 = b27->data->head;
HXDLIN( 163)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 163)											{
HXLINE( 163)												int _g34 = 0;
HXDLIN( 163)												int _g35 = i23;
HXDLIN( 163)												while((_g34 < _g35)){
HXLINE( 163)													_g34 = (_g34 + 1);
HXDLIN( 163)													int i24 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 163)											if (::hx::IsNull( prev1 )) {
HXLINE( 163)												b27->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 163)												l1 = null();
            											}
            											else {
HXLINE( 163)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 163)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage4 = b27;
            					}
            					break;
            				}
HXDLIN( 163)				this89->image = undoImage4;
HXDLIN( 163)				this89->width = width1;
HXDLIN( 163)				this89->height = height1;
HXDLIN( 163)				this89->imageType = ( (int)(imageType1) );
HXDLIN( 163)				undoImage3 = this89;
HXDLIN( 163)				{
HXLINE( 163)					int rectLeft1 = xIter31->start;
HXDLIN( 163)					int rectTop1 = yIter31->start;
HXDLIN( 163)					int rectRight1 = xIter31->max;
HXDLIN( 163)					bool forceClear1 = false;
HXDLIN( 163)					{
HXLINE( 163)						int _g36 = rectTop1;
HXDLIN( 163)						int _g37 = yIter31->max;
HXDLIN( 163)						while((_g36 < _g37)){
HXLINE( 163)							_g36 = (_g36 + 1);
HXDLIN( 163)							int dy2 = (_g36 - 1);
HXDLIN( 163)							{
HXLINE( 163)								int _g38 = rectLeft1;
HXDLIN( 163)								int _g39 = rectRight1;
HXDLIN( 163)								while((_g38 < _g39)){
HXLINE( 163)									_g38 = (_g38 + 1);
HXDLIN( 163)									int dx2 = (_g38 - 1);
HXDLIN( 163)									::Dynamic this91 = pixelImage->image;
HXDLIN( 163)									int index8;
HXDLIN( 163)									if (pixelImage->useVirtualPos) {
HXLINE( 163)										index8 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 163)										index8 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 163)									int c7 = ::iterMagic::Iimg_obj::get(this91,index8);
HXDLIN( 163)									int col1;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										col1 = c7;
            									}
HXDLIN( 163)									bool _hx_tmp25;
HXDLIN( 163)									if (pixelImage->useMask) {
HXLINE( 163)										_hx_tmp25 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 163)										_hx_tmp25 = false;
            									}
HXDLIN( 163)									if (_hx_tmp25) {
HXLINE( 163)										 ::pi_xy::ImageStruct this92 = pixelImage->mask;
HXDLIN( 163)										::Dynamic this93 = this92->image;
HXDLIN( 163)										int index9;
HXDLIN( 163)										if (this92->useVirtualPos) {
HXLINE( 163)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this92->virtualY) * ( (Float)(this92->width) )) + dx2) - this92->virtualX));
            										}
            										else {
HXLINE( 163)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this92->width) + dx2)) ));
            										}
HXDLIN( 163)										int c8 = ::iterMagic::Iimg_obj::get(this93,index9);
HXDLIN( 163)										int v4;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											v4 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											v4 = c8;
            										}
HXDLIN( 163)										int maskPixel1 = v4;
HXDLIN( 163)										int this94 = col1;
HXDLIN( 163)										if ((maskPixel1 == 0)) {
HXLINE( 163)											col1 = this94;
            										}
            										else {
HXLINE( 163)											Float m01;
HXDLIN( 163)											int this95 = ((maskPixel1 >> 24) & 255);
HXDLIN( 163)											if ((this95 == 0)) {
HXLINE( 163)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m01 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m11;
HXDLIN( 163)											int this96 = ((maskPixel1 >> 16) & 255);
HXDLIN( 163)											if ((this96 == 0)) {
HXLINE( 163)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m11 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m21;
HXDLIN( 163)											int this97 = ((maskPixel1 >> 8) & 255);
HXDLIN( 163)											if ((this97 == 0)) {
HXLINE( 163)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m21 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m31;
HXDLIN( 163)											int this98 = (maskPixel1 & 255);
HXDLIN( 163)											if ((this98 == 0)) {
HXLINE( 163)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m31 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this94 >> 24) & 255)) )));
HXDLIN( 163)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this94 >> 16) & 255)) )));
HXDLIN( 163)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this94 >> 8) & 255)) )));
HXDLIN( 163)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this94 & 255)) )));
HXDLIN( 163)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 163)									if ((col1 != 0)) {
HXLINE( 163)										int x8 = (dx2 - rectLeft1);
HXDLIN( 163)										int y8 = (dy2 - rectTop1);
HXDLIN( 163)										int c9 = col1;
HXDLIN( 163)										bool _hx_tmp26;
HXDLIN( 163)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 163)											_hx_tmp26 = undoImage3->transparent;
            										}
            										else {
HXLINE( 163)											_hx_tmp26 = false;
            										}
HXDLIN( 163)										if (_hx_tmp26) {
HXLINE( 163)											int location7;
HXDLIN( 163)											if (undoImage3->useVirtualPos) {
HXLINE( 163)												location7 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 163)												location7 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 163)											int this99 = ::iterMagic::Iimg_obj::get(undoImage3->image,location7);
HXDLIN( 163)											int this100;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												this100 = ((((((this99 >> 24) & 255) << 24) | ((this99 & 255) << 16)) | (((this99 >> 8) & 255) << 8)) | ((this99 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												this100 = this99;
            											}
HXDLIN( 163)											Float a19;
HXDLIN( 163)											int this101 = ((this100 >> 24) & 255);
HXDLIN( 163)											if ((this101 == 0)) {
HXLINE( 163)												a19 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a19 = (( (Float)(this101) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r17;
HXDLIN( 163)											int this102 = ((this100 >> 16) & 255);
HXDLIN( 163)											if ((this102 == 0)) {
HXLINE( 163)												r17 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r17 = (( (Float)(this102) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g17;
HXDLIN( 163)											int this103 = ((this100 >> 8) & 255);
HXDLIN( 163)											if ((this103 == 0)) {
HXLINE( 163)												g17 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g17 = (( (Float)(this103) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b110;
HXDLIN( 163)											int this104 = (this100 & 255);
HXDLIN( 163)											if ((this104 == 0)) {
HXLINE( 163)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b110 = (( (Float)(this104) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a27;
HXDLIN( 163)											int this105 = ((col1 >> 24) & 255);
HXDLIN( 163)											if ((this105 == 0)) {
HXLINE( 163)												a27 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a27 = (( (Float)(this105) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r27;
HXDLIN( 163)											int this106 = ((col1 >> 16) & 255);
HXDLIN( 163)											if ((this106 == 0)) {
HXLINE( 163)												r27 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r27 = (( (Float)(this106) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g27;
HXDLIN( 163)											int this107 = ((col1 >> 8) & 255);
HXDLIN( 163)											if ((this107 == 0)) {
HXLINE( 163)												g27 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g27 = (( (Float)(this107) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b28;
HXDLIN( 163)											int this108 = (col1 & 255);
HXDLIN( 163)											if ((this108 == 0)) {
HXLINE( 163)												b28 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b28 = (( (Float)(this108) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN( 163)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 163)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 163)											int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 163)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 163)											int blended7 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b29);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp27;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp27 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp27 = blended7;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(undoImage3->image,location7,_hx_tmp27);
            											}
            										}
            										else {
HXLINE( 163)											::Dynamic this109 = undoImage3->image;
HXDLIN( 163)											int index10;
HXDLIN( 163)											if (undoImage3->useVirtualPos) {
HXLINE( 163)												index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 163)												index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 163)											int _hx_tmp28;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												_hx_tmp28 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												_hx_tmp28 = c9;
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this109,index10,_hx_tmp28);
            										}
            									}
            									else {
HXLINE( 163)										if (forceClear1) {
HXLINE( 163)											::Dynamic this110 = undoImage3->image;
HXDLIN( 163)											int x9 = (dx2 - rectLeft1);
HXDLIN( 163)											int y9 = (dy2 - rectTop1);
HXDLIN( 163)											int index11;
HXDLIN( 163)											if (undoImage3->useVirtualPos) {
HXLINE( 163)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 163)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this110,index11,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 163)			bool found1 = false;
HXDLIN( 163)			Float min9 = ( (Float)(0) );
HXDLIN( 163)			Float max1 = ( (Float)(0) );
HXDLIN( 163)			int a28 = 0;
HXDLIN( 163)			int r18 = 0;
HXDLIN( 163)			int g18 = 0;
HXDLIN( 163)			int b30 = 0;
HXDLIN( 163)			{
HXLINE( 163)				int _g_min2 = xIter31->start;
HXDLIN( 163)				int _g_max2 = xIter31->max;
HXDLIN( 163)				while((_g_min2 < _g_max2)){
HXLINE( 163)					_g_min2 = (_g_min2 + 1);
HXDLIN( 163)					int px2 = (_g_min2 - 1);
HXDLIN( 163)					Float pcx1 = (( (Float)(px2) ) - ax);
HXLINE( 812)					found1 = false;
HXLINE( 163)					{
HXLINE( 163)						int _g_min3 = yIter31->start;
HXDLIN( 163)						int _g_max3 = yIter31->max;
HXDLIN( 163)						while((_g_min3 < _g_max3)){
HXLINE( 163)							_g_min3 = (_g_min3 + 1);
HXDLIN( 163)							int py2 = (_g_min3 - 1);
HXDLIN( 163)							Float pcy1 = (( (Float)(py2) ) - ay);
HXDLIN( 163)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 163)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 163)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 163)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 163)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 163)							bool _hx_tmp29;
HXDLIN( 163)							bool _hx_tmp30;
HXDLIN( 163)							if ((ratioA1 >= 0)) {
HXLINE( 163)								_hx_tmp30 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp30 = false;
            							}
HXDLIN( 163)							if (_hx_tmp30) {
HXLINE( 163)								_hx_tmp29 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp29 = false;
            							}
HXDLIN( 163)							if (_hx_tmp29) {
HXLINE( 163)								int i25 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 163)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE( 163)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 821)								r18 = i25;
HXLINE( 163)								int i26 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 163)								if ((i26 > 255)) {
HXLINE(  24)									i26 = 255;
            								}
HXLINE( 163)								if ((i26 < 0)) {
HXLINE(  25)									i26 = 0;
            								}
HXLINE( 822)								g18 = i26;
HXLINE( 163)								int i27 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 163)								if ((i27 > 255)) {
HXLINE(  24)									i27 = 255;
            								}
HXLINE( 163)								if ((i27 < 0)) {
HXLINE(  25)									i27 = 0;
            								}
HXLINE( 823)								b30 = i27;
HXLINE( 163)								bool _hx_tmp31;
HXDLIN( 163)								if ((softCD == true)) {
HXLINE( 163)									_hx_tmp31 = (softDA == true);
            								}
            								else {
HXLINE( 163)									_hx_tmp31 = false;
            								}
HXDLIN( 163)								if (_hx_tmp31) {
HXLINE( 163)									if ((ratioA1 < ratioC1)) {
HXLINE( 163)										min9 = ratioA1;
            									}
            									else {
HXLINE( 163)										min9 = ratioC1;
            									}
HXDLIN( 163)									if ((ratioA1 > ratioB1)) {
HXLINE( 163)										max1 = ratioA1;
            									}
            									else {
HXLINE( 163)										max1 = ratioB1;
            									}
HXDLIN( 163)									if (!((max1 > ratioC1))) {
HXLINE( 163)										max1 = ratioC1;
            									}
HXLINE( 829)									max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 163)									if (!((min9 < max1))) {
HXLINE( 163)										min9 = ((max1 + min9) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i28 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 163)									if ((i28 > 255)) {
HXLINE(  24)										i28 = 255;
            									}
HXLINE( 163)									if ((i28 < 0)) {
HXLINE(  25)										i28 = 0;
            									}
HXLINE( 832)									a28 = i28;
HXLINE( 163)									{
HXLINE( 163)										int location8;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location8 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            										}
HXDLIN( 163)										bool _hx_tmp32;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp32 = (a28 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp32 = false;
            										}
HXDLIN( 163)										if (_hx_tmp32) {
HXLINE( 163)											int this111 = ::iterMagic::Iimg_obj::get(pixelImage->image,location8);
HXDLIN( 163)											int old2;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old2 = ((((((this111 >> 24) & 255) << 24) | ((this111 & 255) << 16)) | (((this111 >> 8) & 255) << 8)) | ((this111 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old2 = this111;
            											}
HXDLIN( 163)											int rhs2 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b30);
HXDLIN( 163)											Float a110;
HXDLIN( 163)											int this112 = ((old2 >> 24) & 255);
HXDLIN( 163)											if ((this112 == 0)) {
HXLINE( 163)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a110 = (( (Float)(this112) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r19;
HXDLIN( 163)											int this113 = ((old2 >> 16) & 255);
HXDLIN( 163)											if ((this113 == 0)) {
HXLINE( 163)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r19 = (( (Float)(this113) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g19;
HXDLIN( 163)											int this114 = ((old2 >> 8) & 255);
HXDLIN( 163)											if ((this114 == 0)) {
HXLINE( 163)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g19 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b111;
HXDLIN( 163)											int this115 = (old2 & 255);
HXDLIN( 163)											if ((this115 == 0)) {
HXLINE( 163)												b111 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b111 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a29;
HXDLIN( 163)											int this116 = ((rhs2 >> 24) & 255);
HXDLIN( 163)											if ((this116 == 0)) {
HXLINE( 163)												a29 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a29 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r28;
HXDLIN( 163)											int this117 = ((rhs2 >> 16) & 255);
HXDLIN( 163)											if ((this117 == 0)) {
HXLINE( 163)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r28 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g28;
HXDLIN( 163)											int this118 = ((rhs2 >> 8) & 255);
HXDLIN( 163)											if ((this118 == 0)) {
HXLINE( 163)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g28 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b210;
HXDLIN( 163)											int this119 = (rhs2 & 255);
HXDLIN( 163)											if ((this119 == 0)) {
HXLINE( 163)												b210 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b210 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a38 = (a110 * (( (Float)(1) ) - a29));
HXDLIN( 163)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a38) + (r28 * a29))));
HXDLIN( 163)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a38) + (g28 * a29))));
HXDLIN( 163)											int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b210 * a29))));
HXDLIN( 163)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a29)));
HXDLIN( 163)											int blended8 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b31);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp33;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp33 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp33 = blended8;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location8,_hx_tmp33);
            											}
            										}
            										else {
HXLINE( 163)											int value2;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value2 = ((((a28 << 24) | (b30 << 16)) | (g18 << 8)) | r18);
            											}
            											else {
HXLINE( 163)												value2 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b30);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location8,value2);
            										}
            									}
            								}
HXDLIN( 163)								bool _hx_tmp34;
HXDLIN( 163)								bool _hx_tmp35;
HXDLIN( 163)								if ((softCD == true)) {
HXLINE( 163)									_hx_tmp35 = false;
            								}
            								else {
HXLINE( 163)									_hx_tmp35 = false;
            								}
HXDLIN( 163)								if (_hx_tmp35) {
HXLINE( 163)									_hx_tmp34 = (softDA == false);
            								}
            								else {
HXLINE( 163)									_hx_tmp34 = false;
            								}
HXDLIN( 163)								if (_hx_tmp34) {
HXLINE( 163)									if ((ratioB1 < ratioC1)) {
HXLINE( 163)										min9 = ratioB1;
            									}
            									else {
HXLINE( 163)										min9 = ratioC1;
            									}
HXDLIN( 163)									if ((ratioA1 > ratioB1)) {
HXLINE( 163)										max1 = ratioA1;
            									}
            									else {
HXLINE( 163)										max1 = ratioB1;
            									}
HXDLIN( 163)									if (!((max1 > ratioC1))) {
HXLINE( 163)										max1 = ratioC1;
            									}
HXLINE( 842)									max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 163)									if (!((min9 < max1))) {
HXLINE( 163)										min9 = ((max1 + min9) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i29 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 163)									if ((i29 > 255)) {
HXLINE(  24)										i29 = 255;
            									}
HXLINE( 163)									if ((i29 < 0)) {
HXLINE(  25)										i29 = 0;
            									}
HXLINE( 845)									a28 = i29;
HXLINE( 163)									{
HXLINE( 163)										int location9;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location9 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location9 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            										}
HXDLIN( 163)										bool _hx_tmp36;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp36 = (a28 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp36 = false;
            										}
HXDLIN( 163)										if (_hx_tmp36) {
HXLINE( 163)											int this120 = ::iterMagic::Iimg_obj::get(pixelImage->image,location9);
HXDLIN( 163)											int old3;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old3 = ((((((this120 >> 24) & 255) << 24) | ((this120 & 255) << 16)) | (((this120 >> 8) & 255) << 8)) | ((this120 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old3 = this120;
            											}
HXDLIN( 163)											int rhs3 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b30);
HXDLIN( 163)											Float a111;
HXDLIN( 163)											int this121 = ((old3 >> 24) & 255);
HXDLIN( 163)											if ((this121 == 0)) {
HXLINE( 163)												a111 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a111 = (( (Float)(this121) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r110;
HXDLIN( 163)											int this122 = ((old3 >> 16) & 255);
HXDLIN( 163)											if ((this122 == 0)) {
HXLINE( 163)												r110 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r110 = (( (Float)(this122) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g110;
HXDLIN( 163)											int this123 = ((old3 >> 8) & 255);
HXDLIN( 163)											if ((this123 == 0)) {
HXLINE( 163)												g110 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g110 = (( (Float)(this123) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b112;
HXDLIN( 163)											int this124 = (old3 & 255);
HXDLIN( 163)											if ((this124 == 0)) {
HXLINE( 163)												b112 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b112 = (( (Float)(this124) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a210;
HXDLIN( 163)											int this125 = ((rhs3 >> 24) & 255);
HXDLIN( 163)											if ((this125 == 0)) {
HXLINE( 163)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a210 = (( (Float)(this125) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r29;
HXDLIN( 163)											int this126 = ((rhs3 >> 16) & 255);
HXDLIN( 163)											if ((this126 == 0)) {
HXLINE( 163)												r29 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r29 = (( (Float)(this126) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g29;
HXDLIN( 163)											int this127 = ((rhs3 >> 8) & 255);
HXDLIN( 163)											if ((this127 == 0)) {
HXLINE( 163)												g29 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g29 = (( (Float)(this127) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b211;
HXDLIN( 163)											int this128 = (rhs3 & 255);
HXDLIN( 163)											if ((this128 == 0)) {
HXLINE( 163)												b211 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b211 = (( (Float)(this128) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 163)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a39) + (r29 * a210))));
HXDLIN( 163)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a39) + (g29 * a210))));
HXDLIN( 163)											int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b211 * a210))));
HXDLIN( 163)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 163)											int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b32);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp37;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp37 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp37 = blended9;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location9,_hx_tmp37);
            											}
            										}
            										else {
HXLINE( 163)											int value3;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value3 = ((((a28 << 24) | (b30 << 16)) | (g18 << 8)) | r18);
            											}
            											else {
HXLINE( 163)												value3 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b30);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location9,value3);
            										}
            									}
            								}
HXLINE( 850)								found1 = true;
            							}
            							else {
HXLINE( 163)								if (found1) {
HXLINE( 163)									goto _hx_goto_85;
            								}
            							}
            						}
            						_hx_goto_85:;
            					}
            				}
            			}
HXDLIN( 163)			if ((hasHit == false)) {
HXLINE( 163)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN( 163)				if (hasUndo1) {
HXLINE( 163)					v5->undoImage = undoImage3;
HXDLIN( 163)					v5->undoX = xIter31->start;
HXDLIN( 163)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 163)		{
HXLINE( 163)			bool hasUndo2 = true;
HXDLIN( 163)			int aA2 = ((color >> 24) & 255);
HXDLIN( 163)			int rA2 = ((color >> 16) & 255);
HXDLIN( 163)			int gA2 = ((color >> 8) & 255);
HXDLIN( 163)			int bA2 = (color & 255);
HXDLIN( 163)			Float bcx2 = (bx - dx);
HXDLIN( 163)			Float bcy2 = (by - dy);
HXDLIN( 163)			Float acx2 = (ax - dx);
HXDLIN( 163)			Float acy2 = (ay - dy);
HXDLIN( 163)			Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 163)			Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 163)			Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 163)			Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 163)			if ((ax > bx)) {
HXLINE( 163)				if ((ax > dx)) {
HXLINE( 163)					int min10;
HXDLIN( 163)					if ((bx > dx)) {
HXLINE( 163)						min10 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 163)						min10 = ::Math_obj::floor(bx);
            					}
HXDLIN( 163)					int ii_min24 = min10;
HXDLIN( 163)					int ii_max24 = ::Math_obj::ceil(ax);
HXDLIN( 163)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE( 163)					int ii_min25 = ::Math_obj::floor(bx);
HXDLIN( 163)					int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN( 163)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE( 163)				if ((bx > dx)) {
HXLINE( 163)					int min11;
HXDLIN( 163)					if ((ax > dx)) {
HXLINE( 163)						min11 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 163)						min11 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 163)					int ii_min26 = min11;
HXDLIN( 163)					int ii_max26 = ::Math_obj::ceil(bx);
HXDLIN( 163)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE( 163)					int ii_min27 = ::Math_obj::floor(ax);
HXDLIN( 163)					int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN( 163)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 163)			if ((ay > by)) {
HXLINE( 163)				if ((ay > dy)) {
HXLINE( 163)					int min12;
HXDLIN( 163)					if ((by > dy)) {
HXLINE( 163)						min12 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 163)						min12 = ::Math_obj::floor(by);
            					}
HXDLIN( 163)					int ii_min28 = min12;
HXDLIN( 163)					int ii_max28 = ::Math_obj::ceil(ay);
HXDLIN( 163)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE( 163)					int ii_min29 = ::Math_obj::floor(by);
HXDLIN( 163)					int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN( 163)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE( 163)				if ((by > dy)) {
HXLINE( 163)					int min13;
HXDLIN( 163)					if ((ay > dy)) {
HXLINE( 163)						min13 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 163)						min13 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 163)					int ii_min30 = min13;
HXDLIN( 163)					int ii_max30 = ::Math_obj::ceil(by);
HXDLIN( 163)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE( 163)					int ii_min31 = ::Math_obj::floor(ay);
HXDLIN( 163)					int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN( 163)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 163)			if (hasUndo2) {
HXLINE( 163)				int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 163)				int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 163)				 ::Dynamic imageType2 = null();
HXDLIN( 163)				 ::pi_xy::ImageStruct this129 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 163)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 163)				::Dynamic undoImage7;
HXDLIN( 163)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 163)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::BytesImg b33 = byt2;
HXDLIN( 163)						{
HXLINE( 163)							b33->width = width2;
HXDLIN( 163)							b33->height = height2;
HXDLIN( 163)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 163)							b33->data = ::haxe::io::Bytes_obj::alloc((b33->length * 4));
HXDLIN( 163)							{
HXLINE( 163)								int len4 = b33->length;
HXDLIN( 163)								int w2 = 0;
HXDLIN( 163)								{
HXLINE( 163)									int _g40 = 0;
HXDLIN( 163)									int _g41 = b33->height;
HXDLIN( 163)									while((_g40 < _g41)){
HXLINE( 163)										_g40 = (_g40 + 1);
HXDLIN( 163)										int y10 = (_g40 - 1);
HXDLIN( 163)										{
HXLINE( 163)											int _g42 = 0;
HXDLIN( 163)											int _g43 = b33->width;
HXDLIN( 163)											while((_g42 < _g43)){
HXLINE( 163)												_g42 = (_g42 + 1);
HXDLIN( 163)												int x10 = (_g42 - 1);
HXDLIN( 163)												{
HXLINE( 163)													w2 = (w2 + 1);
HXDLIN( 163)													b33->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w2 = (w2 + 1);
HXDLIN( 163)													b33->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w2 = (w2 + 1);
HXDLIN( 163)													b33->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w2 = (w2 + 1);
HXDLIN( 163)													b33->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage7 = b33;
            					}
            					break;
            					case (int)1: {
HXLINE( 163)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::ArrIntImg a41 = arrI2;
HXDLIN( 163)						{
HXLINE( 163)							a41->width = width2;
HXDLIN( 163)							a41->height = height2;
HXDLIN( 163)							a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 163)							a41->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 163)							{
HXLINE( 163)								int _g44 = 0;
HXDLIN( 163)								int _g45 = a41->length;
HXDLIN( 163)								while((_g44 < _g45)){
HXLINE( 163)									_g44 = (_g44 + 1);
HXDLIN( 163)									int i30 = (_g44 - 1);
HXDLIN( 163)									a41->data[i30] = 0;
            								}
            							}
            						}
HXDLIN( 163)						undoImage7 = a41;
            					}
            					break;
            					case (int)2: {
HXLINE( 163)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::U32ArrImg b34 = u32a2;
HXDLIN( 163)						{
HXLINE( 163)							b34->width = width2;
HXDLIN( 163)							b34->height = height2;
HXDLIN( 163)							b34->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 163)							int size2 = (b34->length * 4);
HXDLIN( 163)							b34->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 163)							{
HXLINE( 163)								int _g46 = 0;
HXDLIN( 163)								int _g47 = b34->length;
HXDLIN( 163)								while((_g46 < _g47)){
HXLINE( 163)									_g46 = (_g46 + 1);
HXDLIN( 163)									int i31 = (_g46 - 1);
HXDLIN( 163)									{
HXLINE( 163)										 ::haxe::io::ArrayBufferViewImpl this130 = b34->data;
HXDLIN( 163)										bool undoImage8;
HXDLIN( 163)										if ((i31 >= 0)) {
HXLINE( 163)											undoImage8 = (i31 < (this130->byteLength >> 2));
            										}
            										else {
HXLINE( 163)											undoImage8 = false;
            										}
HXDLIN( 163)										if (undoImage8) {
HXLINE( 163)											 ::haxe::io::Bytes _this2 = this130->bytes;
HXDLIN( 163)											int pos2 = ((i31 << 2) + this130->byteOffset);
HXDLIN( 163)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 163)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage7 = b34;
            					}
            					break;
            					case (int)3: {
HXLINE( 163)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 163)						{
HXLINE( 163)							v6->width = width2;
HXDLIN( 163)							v6->height = height2;
HXDLIN( 163)							v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 163)							v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 163)							{
HXLINE( 163)								int _g48 = 0;
HXDLIN( 163)								int _g49 = v6->length;
HXDLIN( 163)								while((_g48 < _g49)){
HXLINE( 163)									_g48 = (_g48 + 1);
HXDLIN( 163)									int i32 = (_g48 - 1);
HXDLIN( 163)									v6->data->__unsafe_set(i32,0);
            								}
            							}
            						}
HXDLIN( 163)						undoImage7 = v6;
            					}
            					break;
            					case (int)4: {
HXLINE( 163)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::StackIntImg b35 = sInt2;
HXDLIN( 163)						{
HXLINE( 163)							b35->width = width2;
HXDLIN( 163)							b35->height = height2;
HXDLIN( 163)							b35->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 163)							b35->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 163)							{
HXLINE( 163)								int len5 = b35->length;
HXDLIN( 163)								 ::haxe::ds::GenericStack_Int d2 = b35->data;
HXDLIN( 163)								if (::hx::IsNull( d2->head )) {
HXLINE( 163)									int _g50 = 0;
HXDLIN( 163)									int _g51 = len5;
HXDLIN( 163)									while((_g50 < _g51)){
HXLINE( 163)										_g50 = (_g50 + 1);
HXDLIN( 163)										int i33 = (_g50 - 1);
HXDLIN( 163)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 163)									int _g52 = 0;
HXDLIN( 163)									int _g53 = len5;
HXDLIN( 163)									while((_g52 < _g53)){
HXLINE( 163)										_g52 = (_g52 + 1);
HXDLIN( 163)										int i34 = (_g52 - 1);
HXDLIN( 163)										{
HXLINE( 163)											 ::haxe::ds::GenericCell_Int l2 = b35->data->head;
HXDLIN( 163)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 163)											{
HXLINE( 163)												int _g54 = 0;
HXDLIN( 163)												int _g55 = i34;
HXDLIN( 163)												while((_g54 < _g55)){
HXLINE( 163)													_g54 = (_g54 + 1);
HXDLIN( 163)													int i35 = (_g54 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 163)											if (::hx::IsNull( prev2 )) {
HXLINE( 163)												b35->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 163)												l2 = null();
            											}
            											else {
HXLINE( 163)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 163)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage7 = b35;
            					}
            					break;
            				}
HXDLIN( 163)				this129->image = undoImage7;
HXDLIN( 163)				this129->width = width2;
HXDLIN( 163)				this129->height = height2;
HXDLIN( 163)				this129->imageType = ( (int)(imageType2) );
HXDLIN( 163)				undoImage6 = this129;
HXDLIN( 163)				{
HXLINE( 163)					int rectLeft2 = xIter32->start;
HXDLIN( 163)					int rectTop2 = yIter32->start;
HXDLIN( 163)					int rectRight2 = xIter32->max;
HXDLIN( 163)					bool forceClear2 = false;
HXDLIN( 163)					{
HXLINE( 163)						int _g56 = rectTop2;
HXDLIN( 163)						int _g57 = yIter32->max;
HXDLIN( 163)						while((_g56 < _g57)){
HXLINE( 163)							_g56 = (_g56 + 1);
HXDLIN( 163)							int dy3 = (_g56 - 1);
HXDLIN( 163)							{
HXLINE( 163)								int _g58 = rectLeft2;
HXDLIN( 163)								int _g59 = rectRight2;
HXDLIN( 163)								while((_g58 < _g59)){
HXLINE( 163)									_g58 = (_g58 + 1);
HXDLIN( 163)									int dx3 = (_g58 - 1);
HXDLIN( 163)									::Dynamic this131 = pixelImage->image;
HXDLIN( 163)									int index12;
HXDLIN( 163)									if (pixelImage->useVirtualPos) {
HXLINE( 163)										index12 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 163)										index12 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            									}
HXDLIN( 163)									int c10 = ::iterMagic::Iimg_obj::get(this131,index12);
HXDLIN( 163)									int col2;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										col2 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										col2 = c10;
            									}
HXDLIN( 163)									bool _hx_tmp38;
HXDLIN( 163)									if (pixelImage->useMask) {
HXLINE( 163)										_hx_tmp38 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 163)										_hx_tmp38 = false;
            									}
HXDLIN( 163)									if (_hx_tmp38) {
HXLINE( 163)										 ::pi_xy::ImageStruct this132 = pixelImage->mask;
HXDLIN( 163)										::Dynamic this133 = this132->image;
HXDLIN( 163)										int index13;
HXDLIN( 163)										if (this132->useVirtualPos) {
HXLINE( 163)											index13 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this132->virtualY) * ( (Float)(this132->width) )) + dx3) - this132->virtualX));
            										}
            										else {
HXLINE( 163)											index13 = ::Std_obj::_hx_int(( (Float)(((dy3 * this132->width) + dx3)) ));
            										}
HXDLIN( 163)										int c11 = ::iterMagic::Iimg_obj::get(this133,index13);
HXDLIN( 163)										int v7;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											v7 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											v7 = c11;
            										}
HXDLIN( 163)										int maskPixel2 = v7;
HXDLIN( 163)										int this134 = col2;
HXDLIN( 163)										if ((maskPixel2 == 0)) {
HXLINE( 163)											col2 = this134;
            										}
            										else {
HXLINE( 163)											Float m02;
HXDLIN( 163)											int this135 = ((maskPixel2 >> 24) & 255);
HXDLIN( 163)											if ((this135 == 0)) {
HXLINE( 163)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m02 = (( (Float)(this135) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m12;
HXDLIN( 163)											int this136 = ((maskPixel2 >> 16) & 255);
HXDLIN( 163)											if ((this136 == 0)) {
HXLINE( 163)												m12 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m12 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m22;
HXDLIN( 163)											int this137 = ((maskPixel2 >> 8) & 255);
HXDLIN( 163)											if ((this137 == 0)) {
HXLINE( 163)												m22 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m22 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m32;
HXDLIN( 163)											int this138 = (maskPixel2 & 255);
HXDLIN( 163)											if ((this138 == 0)) {
HXLINE( 163)												m32 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m32 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this134 >> 24) & 255)) )));
HXDLIN( 163)											int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this134 >> 16) & 255)) )));
HXDLIN( 163)											int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this134 >> 8) & 255)) )));
HXDLIN( 163)											int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this134 & 255)) )));
HXDLIN( 163)											col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 163)									if ((col2 != 0)) {
HXLINE( 163)										int x11 = (dx3 - rectLeft2);
HXDLIN( 163)										int y11 = (dy3 - rectTop2);
HXDLIN( 163)										int c12 = col2;
HXDLIN( 163)										bool _hx_tmp39;
HXDLIN( 163)										if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 163)											_hx_tmp39 = undoImage6->transparent;
            										}
            										else {
HXLINE( 163)											_hx_tmp39 = false;
            										}
HXDLIN( 163)										if (_hx_tmp39) {
HXLINE( 163)											int location10;
HXDLIN( 163)											if (undoImage6->useVirtualPos) {
HXLINE( 163)												location10 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 163)												location10 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            											}
HXDLIN( 163)											int this139 = ::iterMagic::Iimg_obj::get(undoImage6->image,location10);
HXDLIN( 163)											int this140;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												this140 = ((((((this139 >> 24) & 255) << 24) | ((this139 & 255) << 16)) | (((this139 >> 8) & 255) << 8)) | ((this139 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												this140 = this139;
            											}
HXDLIN( 163)											Float a112;
HXDLIN( 163)											int this141 = ((this140 >> 24) & 255);
HXDLIN( 163)											if ((this141 == 0)) {
HXLINE( 163)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a112 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r111;
HXDLIN( 163)											int this142 = ((this140 >> 16) & 255);
HXDLIN( 163)											if ((this142 == 0)) {
HXLINE( 163)												r111 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r111 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g111;
HXDLIN( 163)											int this143 = ((this140 >> 8) & 255);
HXDLIN( 163)											if ((this143 == 0)) {
HXLINE( 163)												g111 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g111 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b113;
HXDLIN( 163)											int this144 = (this140 & 255);
HXDLIN( 163)											if ((this144 == 0)) {
HXLINE( 163)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b113 = (( (Float)(this144) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a211;
HXDLIN( 163)											int this145 = ((col2 >> 24) & 255);
HXDLIN( 163)											if ((this145 == 0)) {
HXLINE( 163)												a211 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a211 = (( (Float)(this145) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r210;
HXDLIN( 163)											int this146 = ((col2 >> 16) & 255);
HXDLIN( 163)											if ((this146 == 0)) {
HXLINE( 163)												r210 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r210 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g210;
HXDLIN( 163)											int this147 = ((col2 >> 8) & 255);
HXDLIN( 163)											if ((this147 == 0)) {
HXLINE( 163)												g210 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g210 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b212;
HXDLIN( 163)											int this148 = (col2 & 255);
HXDLIN( 163)											if ((this148 == 0)) {
HXLINE( 163)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b212 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 163)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a310) + (r210 * a211))));
HXDLIN( 163)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a310) + (g210 * a211))));
HXDLIN( 163)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b212 * a211))));
HXDLIN( 163)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 163)											int blended10 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp40;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp40 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp40 = blended10;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(undoImage6->image,location10,_hx_tmp40);
            											}
            										}
            										else {
HXLINE( 163)											::Dynamic this149 = undoImage6->image;
HXDLIN( 163)											int index14;
HXDLIN( 163)											if (undoImage6->useVirtualPos) {
HXLINE( 163)												index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 163)												index14 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            											}
HXDLIN( 163)											int _hx_tmp41;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												_hx_tmp41 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												_hx_tmp41 = c12;
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this149,index14,_hx_tmp41);
            										}
            									}
            									else {
HXLINE( 163)										if (forceClear2) {
HXLINE( 163)											::Dynamic this150 = undoImage6->image;
HXDLIN( 163)											int x12 = (dx3 - rectLeft2);
HXDLIN( 163)											int y12 = (dy3 - rectTop2);
HXDLIN( 163)											int index15;
HXDLIN( 163)											if (undoImage6->useVirtualPos) {
HXLINE( 163)												index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 163)												index15 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this150,index15,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 163)			bool found2 = false;
HXDLIN( 163)			Float min14 = ( (Float)(0) );
HXDLIN( 163)			Float max2 = ( (Float)(0) );
HXDLIN( 163)			int a43 = 0;
HXDLIN( 163)			int r32 = 0;
HXDLIN( 163)			int g32 = 0;
HXDLIN( 163)			int b37 = 0;
HXDLIN( 163)			{
HXLINE( 163)				int _g_min4 = xIter32->start;
HXDLIN( 163)				int _g_max4 = xIter32->max;
HXDLIN( 163)				while((_g_min4 < _g_max4)){
HXLINE( 163)					_g_min4 = (_g_min4 + 1);
HXDLIN( 163)					int px3 = (_g_min4 - 1);
HXDLIN( 163)					Float pcx2 = (( (Float)(px3) ) - dx);
HXLINE( 812)					found2 = false;
HXLINE( 163)					{
HXLINE( 163)						int _g_min5 = yIter32->start;
HXDLIN( 163)						int _g_max5 = yIter32->max;
HXDLIN( 163)						while((_g_min5 < _g_max5)){
HXLINE( 163)							_g_min5 = (_g_min5 + 1);
HXDLIN( 163)							int py3 = (_g_min5 - 1);
HXDLIN( 163)							Float pcy2 = (( (Float)(py3) ) - dy);
HXDLIN( 163)							Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 163)							Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 163)							Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 163)							Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 163)							Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 163)							bool _hx_tmp42;
HXDLIN( 163)							bool _hx_tmp43;
HXDLIN( 163)							if ((ratioA2 >= 0)) {
HXLINE( 163)								_hx_tmp43 = (ratioB2 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp43 = false;
            							}
HXDLIN( 163)							if (_hx_tmp43) {
HXLINE( 163)								_hx_tmp42 = (ratioC2 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp42 = false;
            							}
HXDLIN( 163)							if (_hx_tmp42) {
HXLINE( 163)								int i36 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN( 163)								if ((i36 > 255)) {
HXLINE(  24)									i36 = 255;
            								}
HXLINE( 163)								if ((i36 < 0)) {
HXLINE(  25)									i36 = 0;
            								}
HXLINE( 821)								r32 = i36;
HXLINE( 163)								int i37 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN( 163)								if ((i37 > 255)) {
HXLINE(  24)									i37 = 255;
            								}
HXLINE( 163)								if ((i37 < 0)) {
HXLINE(  25)									i37 = 0;
            								}
HXLINE( 822)								g32 = i37;
HXLINE( 163)								int i38 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN( 163)								if ((i38 > 255)) {
HXLINE(  24)									i38 = 255;
            								}
HXLINE( 163)								if ((i38 < 0)) {
HXLINE(  25)									i38 = 0;
            								}
HXLINE( 823)								b37 = i38;
HXLINE( 163)								bool _hx_tmp44;
HXDLIN( 163)								if ((softAB == true)) {
HXLINE( 163)									_hx_tmp44 = (softDA == true);
            								}
            								else {
HXLINE( 163)									_hx_tmp44 = false;
            								}
HXDLIN( 163)								if (_hx_tmp44) {
HXLINE( 163)									if ((ratioA2 < ratioC2)) {
HXLINE( 163)										min14 = ratioA2;
            									}
            									else {
HXLINE( 163)										min14 = ratioC2;
            									}
HXDLIN( 163)									if ((ratioA2 > ratioB2)) {
HXLINE( 163)										max2 = ratioA2;
            									}
            									else {
HXLINE( 163)										max2 = ratioB2;
            									}
HXDLIN( 163)									if (!((max2 > ratioC2))) {
HXLINE( 163)										max2 = ratioC2;
            									}
HXLINE( 829)									max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE( 163)									if (!((min14 < max2))) {
HXLINE( 163)										min14 = ((max2 + min14) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i39 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min14));
HXDLIN( 163)									if ((i39 > 255)) {
HXLINE(  24)										i39 = 255;
            									}
HXLINE( 163)									if ((i39 < 0)) {
HXLINE(  25)										i39 = 0;
            									}
HXLINE( 832)									a43 = i39;
HXLINE( 163)									{
HXLINE( 163)										int location11;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location11 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location11 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            										}
HXDLIN( 163)										bool _hx_tmp45;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp45 = (a43 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp45 = false;
            										}
HXDLIN( 163)										if (_hx_tmp45) {
HXLINE( 163)											int this151 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 163)											int old4;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old4 = ((((((this151 >> 24) & 255) << 24) | ((this151 & 255) << 16)) | (((this151 >> 8) & 255) << 8)) | ((this151 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old4 = this151;
            											}
HXDLIN( 163)											int rhs4 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 163)											Float a113;
HXDLIN( 163)											int this152 = ((old4 >> 24) & 255);
HXDLIN( 163)											if ((this152 == 0)) {
HXLINE( 163)												a113 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a113 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r112;
HXDLIN( 163)											int this153 = ((old4 >> 16) & 255);
HXDLIN( 163)											if ((this153 == 0)) {
HXLINE( 163)												r112 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r112 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g112;
HXDLIN( 163)											int this154 = ((old4 >> 8) & 255);
HXDLIN( 163)											if ((this154 == 0)) {
HXLINE( 163)												g112 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g112 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b114;
HXDLIN( 163)											int this155 = (old4 & 255);
HXDLIN( 163)											if ((this155 == 0)) {
HXLINE( 163)												b114 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b114 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a212;
HXDLIN( 163)											int this156 = ((rhs4 >> 24) & 255);
HXDLIN( 163)											if ((this156 == 0)) {
HXLINE( 163)												a212 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a212 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r211;
HXDLIN( 163)											int this157 = ((rhs4 >> 16) & 255);
HXDLIN( 163)											if ((this157 == 0)) {
HXLINE( 163)												r211 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r211 = (( (Float)(this157) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g211;
HXDLIN( 163)											int this158 = ((rhs4 >> 8) & 255);
HXDLIN( 163)											if ((this158 == 0)) {
HXLINE( 163)												g211 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g211 = (( (Float)(this158) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b213;
HXDLIN( 163)											int this159 = (rhs4 & 255);
HXDLIN( 163)											if ((this159 == 0)) {
HXLINE( 163)												b213 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b213 = (( (Float)(this159) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 163)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a311) + (r211 * a212))));
HXDLIN( 163)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a311) + (g211 * a212))));
HXDLIN( 163)											int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b213 * a212))));
HXDLIN( 163)											int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 163)											int blended11 = ((((a44 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp46;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp46 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp46 = blended11;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp46);
            											}
            										}
            										else {
HXLINE( 163)											int value4;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value4 = ((((a43 << 24) | (b37 << 16)) | (g32 << 8)) | r32);
            											}
            											else {
HXLINE( 163)												value4 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location11,value4);
            										}
            									}
            								}
HXDLIN( 163)								bool _hx_tmp47;
HXDLIN( 163)								bool _hx_tmp48;
HXDLIN( 163)								if ((softAB == true)) {
HXLINE( 163)									_hx_tmp48 = false;
            								}
            								else {
HXLINE( 163)									_hx_tmp48 = false;
            								}
HXDLIN( 163)								if (_hx_tmp48) {
HXLINE( 163)									_hx_tmp47 = (softDA == false);
            								}
            								else {
HXLINE( 163)									_hx_tmp47 = false;
            								}
HXDLIN( 163)								if (_hx_tmp47) {
HXLINE( 163)									if ((ratioB2 < ratioC2)) {
HXLINE( 163)										min14 = ratioB2;
            									}
            									else {
HXLINE( 163)										min14 = ratioC2;
            									}
HXDLIN( 163)									if ((ratioA2 > ratioB2)) {
HXLINE( 163)										max2 = ratioA2;
            									}
            									else {
HXLINE( 163)										max2 = ratioB2;
            									}
HXDLIN( 163)									if (!((max2 > ratioC2))) {
HXLINE( 163)										max2 = ratioC2;
            									}
HXLINE( 842)									max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE( 163)									if (!((min14 < max2))) {
HXLINE( 163)										min14 = ((max2 + min14) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i40 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min14));
HXDLIN( 163)									if ((i40 > 255)) {
HXLINE(  24)										i40 = 255;
            									}
HXLINE( 163)									if ((i40 < 0)) {
HXLINE(  25)										i40 = 0;
            									}
HXLINE( 845)									a43 = i40;
HXLINE( 163)									{
HXLINE( 163)										int location12;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location12 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location12 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            										}
HXDLIN( 163)										bool _hx_tmp49;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp49 = (a43 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp49 = false;
            										}
HXDLIN( 163)										if (_hx_tmp49) {
HXLINE( 163)											int this160 = ::iterMagic::Iimg_obj::get(pixelImage->image,location12);
HXDLIN( 163)											int old5;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old5 = ((((((this160 >> 24) & 255) << 24) | ((this160 & 255) << 16)) | (((this160 >> 8) & 255) << 8)) | ((this160 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old5 = this160;
            											}
HXDLIN( 163)											int rhs5 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 163)											Float a114;
HXDLIN( 163)											int this161 = ((old5 >> 24) & 255);
HXDLIN( 163)											if ((this161 == 0)) {
HXLINE( 163)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a114 = (( (Float)(this161) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r113;
HXDLIN( 163)											int this162 = ((old5 >> 16) & 255);
HXDLIN( 163)											if ((this162 == 0)) {
HXLINE( 163)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r113 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g113;
HXDLIN( 163)											int this163 = ((old5 >> 8) & 255);
HXDLIN( 163)											if ((this163 == 0)) {
HXLINE( 163)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g113 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b115;
HXDLIN( 163)											int this164 = (old5 & 255);
HXDLIN( 163)											if ((this164 == 0)) {
HXLINE( 163)												b115 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b115 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a213;
HXDLIN( 163)											int this165 = ((rhs5 >> 24) & 255);
HXDLIN( 163)											if ((this165 == 0)) {
HXLINE( 163)												a213 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a213 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r212;
HXDLIN( 163)											int this166 = ((rhs5 >> 16) & 255);
HXDLIN( 163)											if ((this166 == 0)) {
HXLINE( 163)												r212 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r212 = (( (Float)(this166) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g212;
HXDLIN( 163)											int this167 = ((rhs5 >> 8) & 255);
HXDLIN( 163)											if ((this167 == 0)) {
HXLINE( 163)												g212 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g212 = (( (Float)(this167) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b214;
HXDLIN( 163)											int this168 = (rhs5 & 255);
HXDLIN( 163)											if ((this168 == 0)) {
HXLINE( 163)												b214 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b214 = (( (Float)(this168) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 163)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a312) + (r212 * a213))));
HXDLIN( 163)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a312) + (g212 * a213))));
HXDLIN( 163)											int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b214 * a213))));
HXDLIN( 163)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 163)											int blended12 = ((((a45 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp50;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp50 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp50 = blended12;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location12,_hx_tmp50);
            											}
            										}
            										else {
HXLINE( 163)											int value5;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value5 = ((((a43 << 24) | (b37 << 16)) | (g32 << 8)) | r32);
            											}
            											else {
HXLINE( 163)												value5 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location12,value5);
            										}
            									}
            								}
HXLINE( 850)								found2 = true;
            							}
            							else {
HXLINE( 163)								if (found2) {
HXLINE( 163)									goto _hx_goto_97;
            								}
            							}
            						}
            						_hx_goto_97:;
            					}
            				}
            			}
HXDLIN( 163)			if ((hasHit == false)) {
HXLINE( 163)				 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 163)				if (hasUndo2) {
HXLINE( 163)					v8->undoImage = undoImage6;
HXDLIN( 163)					v8->undoX = xIter32->start;
HXDLIN( 163)					v8->undoY = yIter32->start;
            				}
            			}
            		}
HXDLIN( 163)		{
HXLINE( 163)			bool hasUndo3 = true;
HXDLIN( 163)			int aA3 = ((color >> 24) & 255);
HXDLIN( 163)			int rA3 = ((color >> 16) & 255);
HXDLIN( 163)			int gA3 = ((color >> 8) & 255);
HXDLIN( 163)			int bA3 = (color & 255);
HXDLIN( 163)			Float bcx3 = (cx - dx);
HXDLIN( 163)			Float bcy3 = (cy - dy);
HXDLIN( 163)			Float acx3 = (bx - dx);
HXDLIN( 163)			Float acy3 = (by - dy);
HXDLIN( 163)			Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 163)			Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 163)			Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 163)			Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 163)			if ((bx > cx)) {
HXLINE( 163)				if ((bx > dx)) {
HXLINE( 163)					int min15;
HXDLIN( 163)					if ((cx > dx)) {
HXLINE( 163)						min15 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 163)						min15 = ::Math_obj::floor(cx);
            					}
HXDLIN( 163)					int ii_min32 = min15;
HXDLIN( 163)					int ii_max32 = ::Math_obj::ceil(bx);
HXDLIN( 163)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            				}
            				else {
HXLINE( 163)					int ii_min33 = ::Math_obj::floor(cx);
HXDLIN( 163)					int ii_max33 = ::Math_obj::ceil(dx);
HXDLIN( 163)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            				}
            			}
            			else {
HXLINE( 163)				if ((cx > dx)) {
HXLINE( 163)					int min16;
HXDLIN( 163)					if ((bx > dx)) {
HXLINE( 163)						min16 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 163)						min16 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 163)					int ii_min34 = min16;
HXDLIN( 163)					int ii_max34 = ::Math_obj::ceil(cx);
HXDLIN( 163)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            				}
            				else {
HXLINE( 163)					int ii_min35 = ::Math_obj::floor(bx);
HXDLIN( 163)					int ii_max35 = ::Math_obj::ceil(dx);
HXDLIN( 163)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 163)			if ((by > cy)) {
HXLINE( 163)				if ((by > dy)) {
HXLINE( 163)					int min17;
HXDLIN( 163)					if ((cy > dy)) {
HXLINE( 163)						min17 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 163)						min17 = ::Math_obj::floor(cy);
            					}
HXDLIN( 163)					int ii_min36 = min17;
HXDLIN( 163)					int ii_max36 = ::Math_obj::ceil(by);
HXDLIN( 163)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            				}
            				else {
HXLINE( 163)					int ii_min37 = ::Math_obj::floor(cy);
HXDLIN( 163)					int ii_max37 = ::Math_obj::ceil(dy);
HXDLIN( 163)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            				}
            			}
            			else {
HXLINE( 163)				if ((cy > dy)) {
HXLINE( 163)					int min18;
HXDLIN( 163)					if ((by > dy)) {
HXLINE( 163)						min18 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 163)						min18 = ::Math_obj::ceil(by);
            					}
HXDLIN( 163)					int ii_min38 = min18;
HXDLIN( 163)					int ii_max38 = ::Math_obj::ceil(cy);
HXDLIN( 163)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            				}
            				else {
HXLINE( 163)					int ii_min39 = ::Math_obj::floor(by);
HXDLIN( 163)					int ii_max39 = ::Math_obj::ceil(dy);
HXDLIN( 163)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            				}
            			}
HXDLIN( 163)			 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 163)			if (hasUndo3) {
HXLINE( 163)				int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 163)				int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 163)				 ::Dynamic imageType3 = null();
HXDLIN( 163)				 ::pi_xy::ImageStruct this169 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 163)				if (::hx::IsNull( imageType3 )) {
HXLINE(  54)					imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 163)				::Dynamic undoImage10;
HXDLIN( 163)				switch((int)(( (int)(imageType3) ))){
            					case (int)0: {
HXLINE( 163)						 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::BytesImg b40 = byt3;
HXDLIN( 163)						{
HXLINE( 163)							b40->width = width3;
HXDLIN( 163)							b40->height = height3;
HXDLIN( 163)							b40->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 163)							b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN( 163)							{
HXLINE( 163)								int len6 = b40->length;
HXDLIN( 163)								int w3 = 0;
HXDLIN( 163)								{
HXLINE( 163)									int _g60 = 0;
HXDLIN( 163)									int _g61 = b40->height;
HXDLIN( 163)									while((_g60 < _g61)){
HXLINE( 163)										_g60 = (_g60 + 1);
HXDLIN( 163)										int y13 = (_g60 - 1);
HXDLIN( 163)										{
HXLINE( 163)											int _g62 = 0;
HXDLIN( 163)											int _g63 = b40->width;
HXDLIN( 163)											while((_g62 < _g63)){
HXLINE( 163)												_g62 = (_g62 + 1);
HXDLIN( 163)												int x13 = (_g62 - 1);
HXDLIN( 163)												{
HXLINE( 163)													w3 = (w3 + 1);
HXDLIN( 163)													b40->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w3 = (w3 + 1);
HXDLIN( 163)													b40->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w3 = (w3 + 1);
HXDLIN( 163)													b40->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 163)												{
HXLINE( 163)													w3 = (w3 + 1);
HXDLIN( 163)													b40->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage10 = b40;
            					}
            					break;
            					case (int)1: {
HXLINE( 163)						 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::ArrIntImg a46 = arrI3;
HXDLIN( 163)						{
HXLINE( 163)							a46->width = width3;
HXDLIN( 163)							a46->height = height3;
HXDLIN( 163)							a46->data = ::Array_obj< int >::__new(0);
HXDLIN( 163)							a46->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 163)							{
HXLINE( 163)								int _g64 = 0;
HXDLIN( 163)								int _g65 = a46->length;
HXDLIN( 163)								while((_g64 < _g65)){
HXLINE( 163)									_g64 = (_g64 + 1);
HXDLIN( 163)									int i41 = (_g64 - 1);
HXDLIN( 163)									a46->data[i41] = 0;
            								}
            							}
            						}
HXDLIN( 163)						undoImage10 = a46;
            					}
            					break;
            					case (int)2: {
HXLINE( 163)						 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::U32ArrImg b41 = u32a3;
HXDLIN( 163)						{
HXLINE( 163)							b41->width = width3;
HXDLIN( 163)							b41->height = height3;
HXDLIN( 163)							b41->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 163)							int size3 = (b41->length * 4);
HXDLIN( 163)							b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 163)							{
HXLINE( 163)								int _g66 = 0;
HXDLIN( 163)								int _g67 = b41->length;
HXDLIN( 163)								while((_g66 < _g67)){
HXLINE( 163)									_g66 = (_g66 + 1);
HXDLIN( 163)									int i42 = (_g66 - 1);
HXDLIN( 163)									{
HXLINE( 163)										 ::haxe::io::ArrayBufferViewImpl this170 = b41->data;
HXDLIN( 163)										bool undoImage11;
HXDLIN( 163)										if ((i42 >= 0)) {
HXLINE( 163)											undoImage11 = (i42 < (this170->byteLength >> 2));
            										}
            										else {
HXLINE( 163)											undoImage11 = false;
            										}
HXDLIN( 163)										if (undoImage11) {
HXLINE( 163)											 ::haxe::io::Bytes _this3 = this170->bytes;
HXDLIN( 163)											int pos3 = ((i42 << 2) + this170->byteOffset);
HXDLIN( 163)											_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 163)											_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 163)											_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage10 = b41;
            					}
            					break;
            					case (int)3: {
HXLINE( 163)						 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN( 163)						{
HXLINE( 163)							v9->width = width3;
HXDLIN( 163)							v9->height = height3;
HXDLIN( 163)							v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 163)							v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 163)							{
HXLINE( 163)								int _g68 = 0;
HXDLIN( 163)								int _g69 = v9->length;
HXDLIN( 163)								while((_g68 < _g69)){
HXLINE( 163)									_g68 = (_g68 + 1);
HXDLIN( 163)									int i43 = (_g68 - 1);
HXDLIN( 163)									v9->data->__unsafe_set(i43,0);
            								}
            							}
            						}
HXDLIN( 163)						undoImage10 = v9;
            					}
            					break;
            					case (int)4: {
HXLINE( 163)						 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)						 ::iterMagic::StackIntImg b42 = sInt3;
HXDLIN( 163)						{
HXLINE( 163)							b42->width = width3;
HXDLIN( 163)							b42->height = height3;
HXDLIN( 163)							b42->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 163)							b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 163)							{
HXLINE( 163)								int len7 = b42->length;
HXDLIN( 163)								 ::haxe::ds::GenericStack_Int d3 = b42->data;
HXDLIN( 163)								if (::hx::IsNull( d3->head )) {
HXLINE( 163)									int _g70 = 0;
HXDLIN( 163)									int _g71 = len7;
HXDLIN( 163)									while((_g70 < _g71)){
HXLINE( 163)										_g70 = (_g70 + 1);
HXDLIN( 163)										int i44 = (_g70 - 1);
HXDLIN( 163)										d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            									}
            								}
            								else {
HXLINE( 163)									int _g72 = 0;
HXDLIN( 163)									int _g73 = len7;
HXDLIN( 163)									while((_g72 < _g73)){
HXLINE( 163)										_g72 = (_g72 + 1);
HXDLIN( 163)										int i45 = (_g72 - 1);
HXDLIN( 163)										{
HXLINE( 163)											 ::haxe::ds::GenericCell_Int l3 = b42->data->head;
HXDLIN( 163)											 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 163)											{
HXLINE( 163)												int _g74 = 0;
HXDLIN( 163)												int _g75 = i45;
HXDLIN( 163)												while((_g74 < _g75)){
HXLINE( 163)													_g74 = (_g74 + 1);
HXDLIN( 163)													int i46 = (_g74 - 1);
HXLINE( 345)													prev3 = l3;
HXLINE( 346)													l3 = l3->next;
            												}
            											}
HXLINE( 163)											if (::hx::IsNull( prev3 )) {
HXLINE( 163)												b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 163)												l3 = null();
            											}
            											else {
HXLINE( 163)												prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 163)												l3 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 163)						undoImage10 = b42;
            					}
            					break;
            				}
HXDLIN( 163)				this169->image = undoImage10;
HXDLIN( 163)				this169->width = width3;
HXDLIN( 163)				this169->height = height3;
HXDLIN( 163)				this169->imageType = ( (int)(imageType3) );
HXDLIN( 163)				undoImage9 = this169;
HXDLIN( 163)				{
HXLINE( 163)					int rectLeft3 = xIter33->start;
HXDLIN( 163)					int rectTop3 = yIter33->start;
HXDLIN( 163)					int rectRight3 = xIter33->max;
HXDLIN( 163)					bool forceClear3 = false;
HXDLIN( 163)					{
HXLINE( 163)						int _g76 = rectTop3;
HXDLIN( 163)						int _g77 = yIter33->max;
HXDLIN( 163)						while((_g76 < _g77)){
HXLINE( 163)							_g76 = (_g76 + 1);
HXDLIN( 163)							int dy4 = (_g76 - 1);
HXDLIN( 163)							{
HXLINE( 163)								int _g78 = rectLeft3;
HXDLIN( 163)								int _g79 = rectRight3;
HXDLIN( 163)								while((_g78 < _g79)){
HXLINE( 163)									_g78 = (_g78 + 1);
HXDLIN( 163)									int dx4 = (_g78 - 1);
HXDLIN( 163)									::Dynamic this171 = pixelImage->image;
HXDLIN( 163)									int index16;
HXDLIN( 163)									if (pixelImage->useVirtualPos) {
HXLINE( 163)										index16 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 163)										index16 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            									}
HXDLIN( 163)									int c13 = ::iterMagic::Iimg_obj::get(this171,index16);
HXDLIN( 163)									int col3;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										col3 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										col3 = c13;
            									}
HXDLIN( 163)									bool _hx_tmp51;
HXDLIN( 163)									if (pixelImage->useMask) {
HXLINE( 163)										_hx_tmp51 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 163)										_hx_tmp51 = false;
            									}
HXDLIN( 163)									if (_hx_tmp51) {
HXLINE( 163)										 ::pi_xy::ImageStruct this172 = pixelImage->mask;
HXDLIN( 163)										::Dynamic this173 = this172->image;
HXDLIN( 163)										int index17;
HXDLIN( 163)										if (this172->useVirtualPos) {
HXLINE( 163)											index17 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this172->virtualY) * ( (Float)(this172->width) )) + dx4) - this172->virtualX));
            										}
            										else {
HXLINE( 163)											index17 = ::Std_obj::_hx_int(( (Float)(((dy4 * this172->width) + dx4)) ));
            										}
HXDLIN( 163)										int c14 = ::iterMagic::Iimg_obj::get(this173,index17);
HXDLIN( 163)										int v10;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											v10 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											v10 = c14;
            										}
HXDLIN( 163)										int maskPixel3 = v10;
HXDLIN( 163)										int this174 = col3;
HXDLIN( 163)										if ((maskPixel3 == 0)) {
HXLINE( 163)											col3 = this174;
            										}
            										else {
HXLINE( 163)											Float m03;
HXDLIN( 163)											int this175 = ((maskPixel3 >> 24) & 255);
HXDLIN( 163)											if ((this175 == 0)) {
HXLINE( 163)												m03 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m03 = (( (Float)(this175) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m13;
HXDLIN( 163)											int this176 = ((maskPixel3 >> 16) & 255);
HXDLIN( 163)											if ((this176 == 0)) {
HXLINE( 163)												m13 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m13 = (( (Float)(this176) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m23;
HXDLIN( 163)											int this177 = ((maskPixel3 >> 8) & 255);
HXDLIN( 163)											if ((this177 == 0)) {
HXLINE( 163)												m23 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m23 = (( (Float)(this177) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float m33;
HXDLIN( 163)											int this178 = (maskPixel3 & 255);
HXDLIN( 163)											if ((this178 == 0)) {
HXLINE( 163)												m33 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												m33 = (( (Float)(this178) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this174 >> 24) & 255)) )));
HXDLIN( 163)											int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this174 >> 16) & 255)) )));
HXDLIN( 163)											int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this174 >> 8) & 255)) )));
HXDLIN( 163)											int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this174 & 255)) )));
HXDLIN( 163)											col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 163)									if ((col3 != 0)) {
HXLINE( 163)										int x14 = (dx4 - rectLeft3);
HXDLIN( 163)										int y14 = (dy4 - rectTop3);
HXDLIN( 163)										int c15 = col3;
HXDLIN( 163)										bool _hx_tmp52;
HXDLIN( 163)										if ((((c15 >> 24) & 255) < 254)) {
HXLINE( 163)											_hx_tmp52 = undoImage9->transparent;
            										}
            										else {
HXLINE( 163)											_hx_tmp52 = false;
            										}
HXDLIN( 163)										if (_hx_tmp52) {
HXLINE( 163)											int location13;
HXDLIN( 163)											if (undoImage9->useVirtualPos) {
HXLINE( 163)												location13 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 163)												location13 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            											}
HXDLIN( 163)											int this179 = ::iterMagic::Iimg_obj::get(undoImage9->image,location13);
HXDLIN( 163)											int this180;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												this180 = ((((((this179 >> 24) & 255) << 24) | ((this179 & 255) << 16)) | (((this179 >> 8) & 255) << 8)) | ((this179 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												this180 = this179;
            											}
HXDLIN( 163)											Float a115;
HXDLIN( 163)											int this181 = ((this180 >> 24) & 255);
HXDLIN( 163)											if ((this181 == 0)) {
HXLINE( 163)												a115 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a115 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r114;
HXDLIN( 163)											int this182 = ((this180 >> 16) & 255);
HXDLIN( 163)											if ((this182 == 0)) {
HXLINE( 163)												r114 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r114 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g114;
HXDLIN( 163)											int this183 = ((this180 >> 8) & 255);
HXDLIN( 163)											if ((this183 == 0)) {
HXLINE( 163)												g114 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g114 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b116;
HXDLIN( 163)											int this184 = (this180 & 255);
HXDLIN( 163)											if ((this184 == 0)) {
HXLINE( 163)												b116 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b116 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a214;
HXDLIN( 163)											int this185 = ((col3 >> 24) & 255);
HXDLIN( 163)											if ((this185 == 0)) {
HXLINE( 163)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a214 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r213;
HXDLIN( 163)											int this186 = ((col3 >> 16) & 255);
HXDLIN( 163)											if ((this186 == 0)) {
HXLINE( 163)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r213 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g213;
HXDLIN( 163)											int this187 = ((col3 >> 8) & 255);
HXDLIN( 163)											if ((this187 == 0)) {
HXLINE( 163)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g213 = (( (Float)(this187) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b215;
HXDLIN( 163)											int this188 = (col3 & 255);
HXDLIN( 163)											if ((this188 == 0)) {
HXLINE( 163)												b215 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b215 = (( (Float)(this188) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 163)											int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a313) + (r213 * a214))));
HXDLIN( 163)											int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a313) + (g213 * a214))));
HXDLIN( 163)											int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b215 * a214))));
HXDLIN( 163)											int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 163)											int blended13 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b43);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp53;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp53 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp53 = blended13;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(undoImage9->image,location13,_hx_tmp53);
            											}
            										}
            										else {
HXLINE( 163)											::Dynamic this189 = undoImage9->image;
HXDLIN( 163)											int index18;
HXDLIN( 163)											if (undoImage9->useVirtualPos) {
HXLINE( 163)												index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 163)												index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            											}
HXDLIN( 163)											int _hx_tmp54;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												_hx_tmp54 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												_hx_tmp54 = c15;
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this189,index18,_hx_tmp54);
            										}
            									}
            									else {
HXLINE( 163)										if (forceClear3) {
HXLINE( 163)											::Dynamic this190 = undoImage9->image;
HXDLIN( 163)											int x15 = (dx4 - rectLeft3);
HXDLIN( 163)											int y15 = (dy4 - rectTop3);
HXDLIN( 163)											int index19;
HXDLIN( 163)											if (undoImage9->useVirtualPos) {
HXLINE( 163)												index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 163)												index19 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this190,index19,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 163)			bool found3 = false;
HXDLIN( 163)			Float min19 = ( (Float)(0) );
HXDLIN( 163)			Float max3 = ( (Float)(0) );
HXDLIN( 163)			int a48 = 0;
HXDLIN( 163)			int r36 = 0;
HXDLIN( 163)			int g36 = 0;
HXDLIN( 163)			int b44 = 0;
HXDLIN( 163)			{
HXLINE( 163)				int _g_min6 = xIter33->start;
HXDLIN( 163)				int _g_max6 = xIter33->max;
HXDLIN( 163)				while((_g_min6 < _g_max6)){
HXLINE( 163)					_g_min6 = (_g_min6 + 1);
HXDLIN( 163)					int px4 = (_g_min6 - 1);
HXDLIN( 163)					Float pcx3 = (( (Float)(px4) ) - dx);
HXLINE( 812)					found3 = false;
HXLINE( 163)					{
HXLINE( 163)						int _g_min7 = yIter33->start;
HXDLIN( 163)						int _g_max7 = yIter33->max;
HXDLIN( 163)						while((_g_min7 < _g_max7)){
HXLINE( 163)							_g_min7 = (_g_min7 + 1);
HXDLIN( 163)							int py4 = (_g_min7 - 1);
HXDLIN( 163)							Float pcy3 = (( (Float)(py4) ) - dy);
HXDLIN( 163)							Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 163)							Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 163)							Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 163)							Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 163)							Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 163)							bool _hx_tmp55;
HXDLIN( 163)							bool _hx_tmp56;
HXDLIN( 163)							if ((ratioA3 >= 0)) {
HXLINE( 163)								_hx_tmp56 = (ratioB3 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp56 = false;
            							}
HXDLIN( 163)							if (_hx_tmp56) {
HXLINE( 163)								_hx_tmp55 = (ratioC3 >= 0);
            							}
            							else {
HXLINE( 163)								_hx_tmp55 = false;
            							}
HXDLIN( 163)							if (_hx_tmp55) {
HXLINE( 163)								int i47 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN( 163)								if ((i47 > 255)) {
HXLINE(  24)									i47 = 255;
            								}
HXLINE( 163)								if ((i47 < 0)) {
HXLINE(  25)									i47 = 0;
            								}
HXLINE( 821)								r36 = i47;
HXLINE( 163)								int i48 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN( 163)								if ((i48 > 255)) {
HXLINE(  24)									i48 = 255;
            								}
HXLINE( 163)								if ((i48 < 0)) {
HXLINE(  25)									i48 = 0;
            								}
HXLINE( 822)								g36 = i48;
HXLINE( 163)								int i49 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN( 163)								if ((i49 > 255)) {
HXLINE(  24)									i49 = 255;
            								}
HXLINE( 163)								if ((i49 < 0)) {
HXLINE(  25)									i49 = 0;
            								}
HXLINE( 823)								b44 = i49;
HXLINE( 163)								bool _hx_tmp57;
HXDLIN( 163)								bool _hx_tmp58;
HXDLIN( 163)								if ((softBC == true)) {
HXLINE( 163)									_hx_tmp58 = (softCD == false);
            								}
            								else {
HXLINE( 163)									_hx_tmp58 = false;
            								}
HXDLIN( 163)								if (_hx_tmp58) {
HXLINE( 163)									_hx_tmp57 = false;
            								}
            								else {
HXLINE( 163)									_hx_tmp57 = false;
            								}
HXDLIN( 163)								if (_hx_tmp57) {
HXLINE( 163)									if ((ratioA3 < ratioC3)) {
HXLINE( 163)										min19 = ratioA3;
            									}
            									else {
HXLINE( 163)										min19 = ratioC3;
            									}
HXDLIN( 163)									if ((ratioA3 > ratioB3)) {
HXLINE( 163)										max3 = ratioA3;
            									}
            									else {
HXLINE( 163)										max3 = ratioB3;
            									}
HXDLIN( 163)									if (!((max3 > ratioC3))) {
HXLINE( 163)										max3 = ratioC3;
            									}
HXLINE( 829)									max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE( 163)									if (!((min19 < max3))) {
HXLINE( 163)										min19 = ((max3 + min19) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i50 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min19));
HXDLIN( 163)									if ((i50 > 255)) {
HXLINE(  24)										i50 = 255;
            									}
HXLINE( 163)									if ((i50 < 0)) {
HXLINE(  25)										i50 = 0;
            									}
HXLINE( 832)									a48 = i50;
HXLINE( 163)									{
HXLINE( 163)										int location14;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location14 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location14 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            										}
HXDLIN( 163)										bool _hx_tmp59;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp59 = (a48 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp59 = false;
            										}
HXDLIN( 163)										if (_hx_tmp59) {
HXLINE( 163)											int this191 = ::iterMagic::Iimg_obj::get(pixelImage->image,location14);
HXDLIN( 163)											int old6;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old6 = ((((((this191 >> 24) & 255) << 24) | ((this191 & 255) << 16)) | (((this191 >> 8) & 255) << 8)) | ((this191 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old6 = this191;
            											}
HXDLIN( 163)											int rhs6 = ((((a48 << 24) | (r36 << 16)) | (g36 << 8)) | b44);
HXDLIN( 163)											Float a116;
HXDLIN( 163)											int this192 = ((old6 >> 24) & 255);
HXDLIN( 163)											if ((this192 == 0)) {
HXLINE( 163)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a116 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r115;
HXDLIN( 163)											int this193 = ((old6 >> 16) & 255);
HXDLIN( 163)											if ((this193 == 0)) {
HXLINE( 163)												r115 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r115 = (( (Float)(this193) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g115;
HXDLIN( 163)											int this194 = ((old6 >> 8) & 255);
HXDLIN( 163)											if ((this194 == 0)) {
HXLINE( 163)												g115 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g115 = (( (Float)(this194) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b117;
HXDLIN( 163)											int this195 = (old6 & 255);
HXDLIN( 163)											if ((this195 == 0)) {
HXLINE( 163)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b117 = (( (Float)(this195) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a215;
HXDLIN( 163)											int this196 = ((rhs6 >> 24) & 255);
HXDLIN( 163)											if ((this196 == 0)) {
HXLINE( 163)												a215 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a215 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r214;
HXDLIN( 163)											int this197 = ((rhs6 >> 16) & 255);
HXDLIN( 163)											if ((this197 == 0)) {
HXLINE( 163)												r214 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r214 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g214;
HXDLIN( 163)											int this198 = ((rhs6 >> 8) & 255);
HXDLIN( 163)											if ((this198 == 0)) {
HXLINE( 163)												g214 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g214 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b216;
HXDLIN( 163)											int this199 = (rhs6 & 255);
HXDLIN( 163)											if ((this199 == 0)) {
HXLINE( 163)												b216 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b216 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 163)											int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a314) + (r214 * a215))));
HXDLIN( 163)											int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a314) + (g214 * a215))));
HXDLIN( 163)											int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b216 * a215))));
HXDLIN( 163)											int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 163)											int blended14 = ((((a49 << 24) | (r37 << 16)) | (g37 << 8)) | b45);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp60;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp60 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp60 = blended14;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location14,_hx_tmp60);
            											}
            										}
            										else {
HXLINE( 163)											int value6;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value6 = ((((a48 << 24) | (b44 << 16)) | (g36 << 8)) | r36);
            											}
            											else {
HXLINE( 163)												value6 = ((((a48 << 24) | (r36 << 16)) | (g36 << 8)) | b44);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location14,value6);
            										}
            									}
            								}
HXDLIN( 163)								bool _hx_tmp61;
HXDLIN( 163)								if ((softBC == true)) {
HXLINE( 163)									_hx_tmp61 = (softCD == true);
            								}
            								else {
HXLINE( 163)									_hx_tmp61 = false;
            								}
HXDLIN( 163)								if (_hx_tmp61) {
HXLINE( 163)									if ((ratioB3 < ratioC3)) {
HXLINE( 163)										min19 = ratioB3;
            									}
            									else {
HXLINE( 163)										min19 = ratioC3;
            									}
HXDLIN( 163)									if ((ratioA3 > ratioB3)) {
HXLINE( 163)										max3 = ratioA3;
            									}
            									else {
HXLINE( 163)										max3 = ratioB3;
            									}
HXDLIN( 163)									if (!((max3 > ratioC3))) {
HXLINE( 163)										max3 = ratioC3;
            									}
HXLINE( 842)									max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE( 163)									if (!((min19 < max3))) {
HXLINE( 163)										min19 = ((max3 + min19) / ( (Float)(2) ));
            									}
HXDLIN( 163)									int i51 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min19));
HXDLIN( 163)									if ((i51 > 255)) {
HXLINE(  24)										i51 = 255;
            									}
HXLINE( 163)									if ((i51 < 0)) {
HXLINE(  25)										i51 = 0;
            									}
HXLINE( 845)									a48 = i51;
HXLINE( 163)									{
HXLINE( 163)										int location15;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											location15 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											location15 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            										}
HXDLIN( 163)										bool _hx_tmp62;
HXDLIN( 163)										if (pixelImage->transparent) {
HXLINE( 163)											_hx_tmp62 = (a48 < 254);
            										}
            										else {
HXLINE( 163)											_hx_tmp62 = false;
            										}
HXDLIN( 163)										if (_hx_tmp62) {
HXLINE( 163)											int this200 = ::iterMagic::Iimg_obj::get(pixelImage->image,location15);
HXDLIN( 163)											int old7;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												old7 = ((((((this200 >> 24) & 255) << 24) | ((this200 & 255) << 16)) | (((this200 >> 8) & 255) << 8)) | ((this200 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												old7 = this200;
            											}
HXDLIN( 163)											int rhs7 = ((((a48 << 24) | (r36 << 16)) | (g36 << 8)) | b44);
HXDLIN( 163)											Float a117;
HXDLIN( 163)											int this201 = ((old7 >> 24) & 255);
HXDLIN( 163)											if ((this201 == 0)) {
HXLINE( 163)												a117 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a117 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r116;
HXDLIN( 163)											int this202 = ((old7 >> 16) & 255);
HXDLIN( 163)											if ((this202 == 0)) {
HXLINE( 163)												r116 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r116 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g116;
HXDLIN( 163)											int this203 = ((old7 >> 8) & 255);
HXDLIN( 163)											if ((this203 == 0)) {
HXLINE( 163)												g116 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g116 = (( (Float)(this203) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b118;
HXDLIN( 163)											int this204 = (old7 & 255);
HXDLIN( 163)											if ((this204 == 0)) {
HXLINE( 163)												b118 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b118 = (( (Float)(this204) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a216;
HXDLIN( 163)											int this205 = ((rhs7 >> 24) & 255);
HXDLIN( 163)											if ((this205 == 0)) {
HXLINE( 163)												a216 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a216 = (( (Float)(this205) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r215;
HXDLIN( 163)											int this206 = ((rhs7 >> 16) & 255);
HXDLIN( 163)											if ((this206 == 0)) {
HXLINE( 163)												r215 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r215 = (( (Float)(this206) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g215;
HXDLIN( 163)											int this207 = ((rhs7 >> 8) & 255);
HXDLIN( 163)											if ((this207 == 0)) {
HXLINE( 163)												g215 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g215 = (( (Float)(this207) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b217;
HXDLIN( 163)											int this208 = (rhs7 & 255);
HXDLIN( 163)											if ((this208 == 0)) {
HXLINE( 163)												b217 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b217 = (( (Float)(this208) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 163)											int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a315) + (r215 * a216))));
HXDLIN( 163)											int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a315) + (g215 * a216))));
HXDLIN( 163)											int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b217 * a216))));
HXDLIN( 163)											int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 163)											int blended15 = ((((a50 << 24) | (r38 << 16)) | (g38 << 8)) | b46);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp63;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp63 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp63 = blended15;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location15,_hx_tmp63);
            											}
            										}
            										else {
HXLINE( 163)											int value7;
HXDLIN( 163)											if (pixelImage->isLittle) {
HXLINE( 163)												value7 = ((((a48 << 24) | (b44 << 16)) | (g36 << 8)) | r36);
            											}
            											else {
HXLINE( 163)												value7 = ((((a48 << 24) | (r36 << 16)) | (g36 << 8)) | b44);
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(pixelImage->image,location15,value7);
            										}
            									}
            								}
HXLINE( 850)								found3 = true;
            							}
            							else {
HXLINE( 163)								if (found3) {
HXLINE( 163)									goto _hx_goto_109;
            								}
            							}
            						}
            						_hx_goto_109:;
            					}
            				}
            			}
HXDLIN( 163)			if ((hasHit == false)) {
HXLINE( 163)				 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 163)				if (hasUndo3) {
HXLINE( 163)					v11->undoImage = undoImage9;
HXDLIN( 163)					v11->undoX = xIter33->start;
HXDLIN( 163)					v11->undoY = yIter33->start;
            				}
            			}
            		}
HXDLIN( 163)		if ((hasHit == true)) {
HXLINE( 163)			 ::pi_xy::algo::HitQuad v12 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 163)			return v12;
            		}
            		else {
HXLINE( 163)			return null();
            		}
HXDLIN( 163)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(LinePixel_Fields__obj,rotateSoftLineLuxury,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateSoftLinePartial( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta,int color,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_softTop,::hx::Null< bool >  __o_softRight,::hx::Null< bool >  __o_softBottom,::hx::Null< bool >  __o_softLeft,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		Float softC = __o_softC.Default(((Float)10.));
            		bool softTop = __o_softTop.Default(true);
            		bool softRight = __o_softRight.Default(true);
            		bool softBottom = __o_softBottom.Default(true);
            		bool softLeft = __o_softLeft.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_177_rotateSoftLinePartial)
HXLINE( 178)		Float sin = ::Math_obj::sin(theta);
HXLINE( 179)		Float cos = ::Math_obj::cos(theta);
HXLINE( 180)		Float radius = (thick / ( (Float)(2) ));
HXLINE( 181)		Float dx = ((Float)0.1);
HXLINE( 182)		Float dy = radius;
HXLINE( 183)		Float cx = h;
HXLINE( 184)		Float cy = radius;
HXLINE( 185)		Float bx = h;
HXLINE( 186)		Float by = -(radius);
HXLINE( 187)		Float ax = ((Float)0.1);
HXLINE( 188)		Float ay = -(radius);
HXLINE( 189)		Float temp = ((Float)0.);
HXLINE( 190)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 191)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 192)		ax = temp;
HXLINE( 194)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 195)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 196)		bx = temp;
HXLINE( 198)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 199)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 200)		cx = temp;
HXLINE( 202)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 203)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 204)		dx = temp;
HXLINE( 211)		if (( (bool)(debugCorners) )) {
HXLINE( 212)			{
HXLINE( 212)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN( 212)				{
HXLINE( 212)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN( 212)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN( 212)					int r_w = 12;
HXDLIN( 212)					int r_h = 12;
HXDLIN( 212)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 212)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 212)					int ii_min = r_x;
HXDLIN( 212)					int ii_max = xmax;
HXDLIN( 212)					int xRange__start = ii_min;
HXDLIN( 212)					int xRange__max = ii_max;
HXDLIN( 212)					int ii_min1 = r_y;
HXDLIN( 212)					int ii_max1 = ymax;
HXDLIN( 212)					int yRange__start = ii_min1;
HXDLIN( 212)					int yRange__max = ii_max1;
HXDLIN( 212)					int range_x = xRange__start;
HXDLIN( 212)					int range_y = (yRange__start - 1);
HXDLIN( 212)					int range_xReset = range_x;
HXDLIN( 212)					int range_yReset = range_y;
HXDLIN( 212)					int range_xMax = (xRange__max - 2);
HXDLIN( 212)					int range_yMax = (yRange__max - 2);
HXDLIN( 212)					int _this_min = 0;
HXDLIN( 212)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 212)					while((_this_min < _this_max)){
HXLINE( 212)						_this_min = (_this_min + 1);
HXDLIN( 212)						int i = (_this_min - 1);
HXDLIN( 212)						if ((range_y > range_yMax)) {
HXLINE( 212)							range_y = range_yReset;
HXDLIN( 212)							range_x = (range_x + 1);
            						}
HXDLIN( 212)						range_y = (range_y + 1);
HXDLIN( 212)						int i1 = i;
HXDLIN( 212)						{
HXLINE( 212)							int x = range_x;
HXDLIN( 212)							int y = range_y;
HXDLIN( 212)							int c = -65536;
HXDLIN( 212)							bool _hx_tmp;
HXDLIN( 212)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 212)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 212)								_hx_tmp = false;
            							}
HXDLIN( 212)							if (_hx_tmp) {
HXLINE( 212)								int location;
HXDLIN( 212)								if (this1->useVirtualPos) {
HXLINE( 212)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 212)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 212)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 212)								int this3;
HXDLIN( 212)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 212)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 212)									this3 = this2;
            								}
HXDLIN( 212)								Float a1;
HXDLIN( 212)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 212)								if ((this4 == 0)) {
HXLINE( 212)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float r1;
HXDLIN( 212)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 212)								if ((this5 == 0)) {
HXLINE( 212)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float g1;
HXDLIN( 212)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 212)								if ((this6 == 0)) {
HXLINE( 212)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float b1;
HXDLIN( 212)								int this7 = (this3 & 255);
HXDLIN( 212)								if ((this7 == 0)) {
HXLINE( 212)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float a2;
HXDLIN( 212)								int this8 = ((-65536 >> 24) & 255);
HXDLIN( 212)								if ((this8 == 0)) {
HXLINE( 212)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float r2;
HXDLIN( 212)								int this9 = ((-65536 >> 16) & 255);
HXDLIN( 212)								if ((this9 == 0)) {
HXLINE( 212)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float g2;
HXDLIN( 212)								int this10 = ((-65536 >> 8) & 255);
HXDLIN( 212)								if ((this10 == 0)) {
HXLINE( 212)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float b2;
HXDLIN( 212)								int this11 = (-65536 & 255);
HXDLIN( 212)								if ((this11 == 0)) {
HXLINE( 212)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 212)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 212)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 212)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 212)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 212)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 212)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 212)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 212)								{
HXLINE( 212)									int _hx_tmp1;
HXDLIN( 212)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 212)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 212)										_hx_tmp1 = blended;
            									}
HXDLIN( 212)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 212)								::Dynamic this12 = this1->image;
HXDLIN( 212)								int index;
HXDLIN( 212)								if (this1->useVirtualPos) {
HXLINE( 212)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 212)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 212)								int _hx_tmp2;
HXDLIN( 212)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 212)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 212)									_hx_tmp2 = c;
            								}
HXDLIN( 212)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE( 213)			{
HXLINE( 213)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN( 213)				{
HXLINE( 213)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN( 213)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN( 213)					int r_w1 = 12;
HXDLIN( 213)					int r_h1 = 12;
HXDLIN( 213)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 213)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 213)					int ii_min2 = r_x1;
HXDLIN( 213)					int ii_max2 = xmax1;
HXDLIN( 213)					int xRange__start1 = ii_min2;
HXDLIN( 213)					int xRange__max1 = ii_max2;
HXDLIN( 213)					int ii_min3 = r_y1;
HXDLIN( 213)					int ii_max3 = ymax1;
HXDLIN( 213)					int yRange__start1 = ii_min3;
HXDLIN( 213)					int yRange__max1 = ii_max3;
HXDLIN( 213)					int range_x1 = xRange__start1;
HXDLIN( 213)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 213)					int range_xReset1 = range_x1;
HXDLIN( 213)					int range_yReset1 = range_y1;
HXDLIN( 213)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 213)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 213)					int _this_min1 = 0;
HXDLIN( 213)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 213)					while((_this_min1 < _this_max1)){
HXLINE( 213)						_this_min1 = (_this_min1 + 1);
HXDLIN( 213)						int i2 = (_this_min1 - 1);
HXDLIN( 213)						if ((range_y1 > range_yMax1)) {
HXLINE( 213)							range_y1 = range_yReset1;
HXDLIN( 213)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 213)						range_y1 = (range_y1 + 1);
HXDLIN( 213)						int i3 = i2;
HXDLIN( 213)						{
HXLINE( 213)							int x1 = range_x1;
HXDLIN( 213)							int y1 = range_y1;
HXDLIN( 213)							int c1 = -16711936;
HXDLIN( 213)							bool _hx_tmp3;
HXDLIN( 213)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 213)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE( 213)								_hx_tmp3 = false;
            							}
HXDLIN( 213)							if (_hx_tmp3) {
HXLINE( 213)								int location1;
HXDLIN( 213)								if (this13->useVirtualPos) {
HXLINE( 213)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 213)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 213)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN( 213)								int this15;
HXDLIN( 213)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 213)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE( 213)									this15 = this14;
            								}
HXDLIN( 213)								Float a11;
HXDLIN( 213)								int this16 = ((this15 >> 24) & 255);
HXDLIN( 213)								if ((this16 == 0)) {
HXLINE( 213)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float r11;
HXDLIN( 213)								int this17 = ((this15 >> 16) & 255);
HXDLIN( 213)								if ((this17 == 0)) {
HXLINE( 213)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float g11;
HXDLIN( 213)								int this18 = ((this15 >> 8) & 255);
HXDLIN( 213)								if ((this18 == 0)) {
HXLINE( 213)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float b11;
HXDLIN( 213)								int this19 = (this15 & 255);
HXDLIN( 213)								if ((this19 == 0)) {
HXLINE( 213)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float a21;
HXDLIN( 213)								int this20 = ((-16711936 >> 24) & 255);
HXDLIN( 213)								if ((this20 == 0)) {
HXLINE( 213)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float r21;
HXDLIN( 213)								int this21 = ((-16711936 >> 16) & 255);
HXDLIN( 213)								if ((this21 == 0)) {
HXLINE( 213)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float g21;
HXDLIN( 213)								int this22 = ((-16711936 >> 8) & 255);
HXDLIN( 213)								if ((this22 == 0)) {
HXLINE( 213)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float b21;
HXDLIN( 213)								int this23 = (-16711936 & 255);
HXDLIN( 213)								if ((this23 == 0)) {
HXLINE( 213)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 213)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN( 213)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 213)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 213)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 213)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 213)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 213)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 213)								{
HXLINE( 213)									int _hx_tmp4;
HXDLIN( 213)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 213)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 213)										_hx_tmp4 = blended1;
            									}
HXDLIN( 213)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 213)								::Dynamic this24 = this13->image;
HXDLIN( 213)								int index1;
HXDLIN( 213)								if (this13->useVirtualPos) {
HXLINE( 213)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 213)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 213)								int _hx_tmp5;
HXDLIN( 213)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 213)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 213)									_hx_tmp5 = c1;
            								}
HXDLIN( 213)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE( 214)			{
HXLINE( 214)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN( 214)				{
HXLINE( 214)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN( 214)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN( 214)					int r_w2 = 12;
HXDLIN( 214)					int r_h2 = 12;
HXDLIN( 214)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 214)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 214)					int ii_min4 = r_x2;
HXDLIN( 214)					int ii_max4 = xmax2;
HXDLIN( 214)					int xRange__start2 = ii_min4;
HXDLIN( 214)					int xRange__max2 = ii_max4;
HXDLIN( 214)					int ii_min5 = r_y2;
HXDLIN( 214)					int ii_max5 = ymax2;
HXDLIN( 214)					int yRange__start2 = ii_min5;
HXDLIN( 214)					int yRange__max2 = ii_max5;
HXDLIN( 214)					int range_x2 = xRange__start2;
HXDLIN( 214)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 214)					int range_xReset2 = range_x2;
HXDLIN( 214)					int range_yReset2 = range_y2;
HXDLIN( 214)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 214)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 214)					int _this_min2 = 0;
HXDLIN( 214)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 214)					while((_this_min2 < _this_max2)){
HXLINE( 214)						_this_min2 = (_this_min2 + 1);
HXDLIN( 214)						int i4 = (_this_min2 - 1);
HXDLIN( 214)						if ((range_y2 > range_yMax2)) {
HXLINE( 214)							range_y2 = range_yReset2;
HXDLIN( 214)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 214)						range_y2 = (range_y2 + 1);
HXDLIN( 214)						int i5 = i4;
HXDLIN( 214)						{
HXLINE( 214)							int x2 = range_x2;
HXDLIN( 214)							int y2 = range_y2;
HXDLIN( 214)							int c2 = -16776961;
HXDLIN( 214)							bool _hx_tmp6;
HXDLIN( 214)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 214)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE( 214)								_hx_tmp6 = false;
            							}
HXDLIN( 214)							if (_hx_tmp6) {
HXLINE( 214)								int location2;
HXDLIN( 214)								if (this25->useVirtualPos) {
HXLINE( 214)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 214)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 214)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN( 214)								int this27;
HXDLIN( 214)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE( 214)									this27 = this26;
            								}
HXDLIN( 214)								Float a12;
HXDLIN( 214)								int this28 = ((this27 >> 24) & 255);
HXDLIN( 214)								if ((this28 == 0)) {
HXLINE( 214)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float r12;
HXDLIN( 214)								int this29 = ((this27 >> 16) & 255);
HXDLIN( 214)								if ((this29 == 0)) {
HXLINE( 214)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float g12;
HXDLIN( 214)								int this30 = ((this27 >> 8) & 255);
HXDLIN( 214)								if ((this30 == 0)) {
HXLINE( 214)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float b12;
HXDLIN( 214)								int this31 = (this27 & 255);
HXDLIN( 214)								if ((this31 == 0)) {
HXLINE( 214)									b12 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float a22;
HXDLIN( 214)								int this32 = ((-16776961 >> 24) & 255);
HXDLIN( 214)								if ((this32 == 0)) {
HXLINE( 214)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float r22;
HXDLIN( 214)								int this33 = ((-16776961 >> 16) & 255);
HXDLIN( 214)								if ((this33 == 0)) {
HXLINE( 214)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float g22;
HXDLIN( 214)								int this34 = ((-16776961 >> 8) & 255);
HXDLIN( 214)								if ((this34 == 0)) {
HXLINE( 214)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float b22;
HXDLIN( 214)								int this35 = (-16776961 & 255);
HXDLIN( 214)								if ((this35 == 0)) {
HXLINE( 214)									b22 = ((Float)0.);
            								}
            								else {
HXLINE( 214)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 214)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 214)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 214)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 214)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN( 214)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 214)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN( 214)								{
HXLINE( 214)									int _hx_tmp7;
HXDLIN( 214)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 214)										_hx_tmp7 = blended2;
            									}
HXDLIN( 214)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE( 214)								::Dynamic this36 = this25->image;
HXDLIN( 214)								int index2;
HXDLIN( 214)								if (this25->useVirtualPos) {
HXLINE( 214)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 214)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 214)								int _hx_tmp8;
HXDLIN( 214)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE( 214)									_hx_tmp8 = c2;
            								}
HXDLIN( 214)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE( 215)			{
HXLINE( 215)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN( 215)				{
HXLINE( 215)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN( 215)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN( 215)					int r_w3 = 12;
HXDLIN( 215)					int r_h3 = 12;
HXDLIN( 215)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN( 215)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN( 215)					int ii_min6 = r_x3;
HXDLIN( 215)					int ii_max6 = xmax3;
HXDLIN( 215)					int xRange__start3 = ii_min6;
HXDLIN( 215)					int xRange__max3 = ii_max6;
HXDLIN( 215)					int ii_min7 = r_y3;
HXDLIN( 215)					int ii_max7 = ymax3;
HXDLIN( 215)					int yRange__start3 = ii_min7;
HXDLIN( 215)					int yRange__max3 = ii_max7;
HXDLIN( 215)					int range_x3 = xRange__start3;
HXDLIN( 215)					int range_y3 = (yRange__start3 - 1);
HXDLIN( 215)					int range_xReset3 = range_x3;
HXDLIN( 215)					int range_yReset3 = range_y3;
HXDLIN( 215)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN( 215)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN( 215)					int _this_min3 = 0;
HXDLIN( 215)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN( 215)					while((_this_min3 < _this_max3)){
HXLINE( 215)						_this_min3 = (_this_min3 + 1);
HXDLIN( 215)						int i6 = (_this_min3 - 1);
HXDLIN( 215)						if ((range_y3 > range_yMax3)) {
HXLINE( 215)							range_y3 = range_yReset3;
HXDLIN( 215)							range_x3 = (range_x3 + 1);
            						}
HXDLIN( 215)						range_y3 = (range_y3 + 1);
HXDLIN( 215)						int i7 = i6;
HXDLIN( 215)						{
HXLINE( 215)							int x3 = range_x3;
HXDLIN( 215)							int y3 = range_y3;
HXDLIN( 215)							int c3 = -1048336;
HXDLIN( 215)							bool _hx_tmp9;
HXDLIN( 215)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 215)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE( 215)								_hx_tmp9 = false;
            							}
HXDLIN( 215)							if (_hx_tmp9) {
HXLINE( 215)								int location3;
HXDLIN( 215)								if (this37->useVirtualPos) {
HXLINE( 215)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 215)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 215)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 215)								int this39;
HXDLIN( 215)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 215)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE( 215)									this39 = this38;
            								}
HXDLIN( 215)								Float a13;
HXDLIN( 215)								int this40 = ((this39 >> 24) & 255);
HXDLIN( 215)								if ((this40 == 0)) {
HXLINE( 215)									a13 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float r13;
HXDLIN( 215)								int this41 = ((this39 >> 16) & 255);
HXDLIN( 215)								if ((this41 == 0)) {
HXLINE( 215)									r13 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float g13;
HXDLIN( 215)								int this42 = ((this39 >> 8) & 255);
HXDLIN( 215)								if ((this42 == 0)) {
HXLINE( 215)									g13 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float b13;
HXDLIN( 215)								int this43 = (this39 & 255);
HXDLIN( 215)								if ((this43 == 0)) {
HXLINE( 215)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float a23;
HXDLIN( 215)								int this44 = ((-1048336 >> 24) & 255);
HXDLIN( 215)								if ((this44 == 0)) {
HXLINE( 215)									a23 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float r23;
HXDLIN( 215)								int this45 = ((-1048336 >> 16) & 255);
HXDLIN( 215)								if ((this45 == 0)) {
HXLINE( 215)									r23 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float g23;
HXDLIN( 215)								int this46 = ((-1048336 >> 8) & 255);
HXDLIN( 215)								if ((this46 == 0)) {
HXLINE( 215)									g23 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float b23;
HXDLIN( 215)								int this47 = (-1048336 & 255);
HXDLIN( 215)								if ((this47 == 0)) {
HXLINE( 215)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 215)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN( 215)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 215)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 215)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 215)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN( 215)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 215)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN( 215)								{
HXLINE( 215)									int _hx_tmp10;
HXDLIN( 215)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 215)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE( 215)										_hx_tmp10 = blended3;
            									}
HXDLIN( 215)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE( 215)								::Dynamic this48 = this37->image;
HXDLIN( 215)								int index3;
HXDLIN( 215)								if (this37->useVirtualPos) {
HXLINE( 215)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 215)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 215)								int _hx_tmp11;
HXDLIN( 215)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 215)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 215)									_hx_tmp11 = c3;
            								}
HXDLIN( 215)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 217)		Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN( 217)		Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN( 217)		if (softTop) {
HXLINE( 217)			bool hasUndo = false;
HXDLIN( 217)			int aA = ((color >> 24) & 255);
HXDLIN( 217)			int rA = ((color >> 16) & 255);
HXDLIN( 217)			int gA = ((color >> 8) & 255);
HXDLIN( 217)			int bA = (color & 255);
HXDLIN( 217)			Float bcx = (ax - bx);
HXDLIN( 217)			Float bcy = (ay - by);
HXDLIN( 217)			Float acx = (ex - bx);
HXDLIN( 217)			Float acy = (ey - by);
HXDLIN( 217)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 217)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 217)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 217)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 217)			if ((ex > ax)) {
HXLINE( 217)				if ((ex > bx)) {
HXLINE( 217)					int min;
HXDLIN( 217)					if ((ax > bx)) {
HXLINE( 217)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 217)						min = ::Math_obj::floor(ax);
            					}
HXDLIN( 217)					int ii_min8 = min;
HXDLIN( 217)					int ii_max8 = ::Math_obj::ceil(ex);
HXDLIN( 217)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 217)					int ii_min9 = ::Math_obj::floor(ax);
HXDLIN( 217)					int ii_max9 = ::Math_obj::ceil(bx);
HXDLIN( 217)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 217)				if ((ax > bx)) {
HXLINE( 217)					int min1;
HXDLIN( 217)					if ((ex > bx)) {
HXLINE( 217)						min1 = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 217)						min1 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 217)					int ii_min10 = min1;
HXDLIN( 217)					int ii_max10 = ::Math_obj::ceil(ax);
HXDLIN( 217)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 217)					int ii_min11 = ::Math_obj::floor(ex);
HXDLIN( 217)					int ii_max11 = ::Math_obj::ceil(bx);
HXDLIN( 217)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 217)			if ((ey > ay)) {
HXLINE( 217)				if ((ey > by)) {
HXLINE( 217)					int min2;
HXDLIN( 217)					if ((ay > by)) {
HXLINE( 217)						min2 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 217)						min2 = ::Math_obj::floor(ay);
            					}
HXDLIN( 217)					int ii_min12 = min2;
HXDLIN( 217)					int ii_max12 = ::Math_obj::ceil(ey);
HXDLIN( 217)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 217)					int ii_min13 = ::Math_obj::floor(ay);
HXDLIN( 217)					int ii_max13 = ::Math_obj::ceil(by);
HXDLIN( 217)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 217)				if ((ay > by)) {
HXLINE( 217)					int min3;
HXDLIN( 217)					if ((ey > by)) {
HXLINE( 217)						min3 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 217)						min3 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 217)					int ii_min14 = min3;
HXDLIN( 217)					int ii_max14 = ::Math_obj::ceil(ay);
HXDLIN( 217)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 217)					int ii_min15 = ::Math_obj::floor(ey);
HXDLIN( 217)					int ii_max15 = ::Math_obj::ceil(by);
HXDLIN( 217)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 217)			if (hasUndo) {
HXLINE( 217)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 217)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 217)				 ::Dynamic imageType = null();
HXDLIN( 217)				 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 217)				::Dynamic undoImage1;
HXDLIN( 217)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 217)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::BytesImg b6 = byt;
HXDLIN( 217)						{
HXLINE( 217)							b6->width = width;
HXDLIN( 217)							b6->height = height;
HXDLIN( 217)							b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 217)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 217)							{
HXLINE( 217)								int len = b6->length;
HXDLIN( 217)								int w = 0;
HXDLIN( 217)								{
HXLINE( 217)									int _g = 0;
HXDLIN( 217)									int _g1 = b6->height;
HXDLIN( 217)									while((_g < _g1)){
HXLINE( 217)										_g = (_g + 1);
HXDLIN( 217)										int y4 = (_g - 1);
HXDLIN( 217)										{
HXLINE( 217)											int _g2 = 0;
HXDLIN( 217)											int _g3 = b6->width;
HXDLIN( 217)											while((_g2 < _g3)){
HXLINE( 217)												_g2 = (_g2 + 1);
HXDLIN( 217)												int x4 = (_g2 - 1);
HXDLIN( 217)												{
HXLINE( 217)													w = (w + 1);
HXDLIN( 217)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w = (w + 1);
HXDLIN( 217)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w = (w + 1);
HXDLIN( 217)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w = (w + 1);
HXDLIN( 217)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage1 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 217)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN( 217)						{
HXLINE( 217)							a7->width = width;
HXDLIN( 217)							a7->height = height;
HXDLIN( 217)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)							a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 217)							{
HXLINE( 217)								int _g4 = 0;
HXDLIN( 217)								int _g5 = a7->length;
HXDLIN( 217)								while((_g4 < _g5)){
HXLINE( 217)									_g4 = (_g4 + 1);
HXDLIN( 217)									int i8 = (_g4 - 1);
HXDLIN( 217)									a7->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 217)						undoImage1 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 217)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN( 217)						{
HXLINE( 217)							b7->width = width;
HXDLIN( 217)							b7->height = height;
HXDLIN( 217)							b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 217)							int size = (b7->length * 4);
HXDLIN( 217)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 217)							{
HXLINE( 217)								int _g6 = 0;
HXDLIN( 217)								int _g7 = b7->length;
HXDLIN( 217)								while((_g6 < _g7)){
HXLINE( 217)									_g6 = (_g6 + 1);
HXDLIN( 217)									int i9 = (_g6 - 1);
HXDLIN( 217)									{
HXLINE( 217)										 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN( 217)										bool undoImage2;
HXDLIN( 217)										if ((i9 >= 0)) {
HXLINE( 217)											undoImage2 = (i9 < (this50->byteLength >> 2));
            										}
            										else {
HXLINE( 217)											undoImage2 = false;
            										}
HXDLIN( 217)										if (undoImage2) {
HXLINE( 217)											 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN( 217)											int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN( 217)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 217)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage1 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 217)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 217)						{
HXLINE( 217)							v->width = width;
HXDLIN( 217)							v->height = height;
HXDLIN( 217)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 217)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 217)							{
HXLINE( 217)								int _g8 = 0;
HXDLIN( 217)								int _g9 = v->length;
HXDLIN( 217)								while((_g8 < _g9)){
HXLINE( 217)									_g8 = (_g8 + 1);
HXDLIN( 217)									int i10 = (_g8 - 1);
HXDLIN( 217)									v->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 217)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 217)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN( 217)						{
HXLINE( 217)							b8->width = width;
HXDLIN( 217)							b8->height = height;
HXDLIN( 217)							b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 217)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)							{
HXLINE( 217)								int len1 = b8->length;
HXDLIN( 217)								 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN( 217)								if (::hx::IsNull( d->head )) {
HXLINE( 217)									int _g10 = 0;
HXDLIN( 217)									int _g11 = len1;
HXDLIN( 217)									while((_g10 < _g11)){
HXLINE( 217)										_g10 = (_g10 + 1);
HXDLIN( 217)										int i11 = (_g10 - 1);
HXDLIN( 217)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 217)									int _g12 = 0;
HXDLIN( 217)									int _g13 = len1;
HXDLIN( 217)									while((_g12 < _g13)){
HXLINE( 217)										_g12 = (_g12 + 1);
HXDLIN( 217)										int i12 = (_g12 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN( 217)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 217)											{
HXLINE( 217)												int _g14 = 0;
HXDLIN( 217)												int _g15 = i12;
HXDLIN( 217)												while((_g14 < _g15)){
HXLINE( 217)													_g14 = (_g14 + 1);
HXDLIN( 217)													int i13 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 217)											if (::hx::IsNull( prev )) {
HXLINE( 217)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 217)												l = null();
            											}
            											else {
HXLINE( 217)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 217)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage1 = b8;
            					}
            					break;
            				}
HXDLIN( 217)				this49->image = undoImage1;
HXDLIN( 217)				this49->width = width;
HXDLIN( 217)				this49->height = height;
HXDLIN( 217)				this49->imageType = ( (int)(imageType) );
HXDLIN( 217)				undoImage = this49;
HXDLIN( 217)				{
HXLINE( 217)					int rectLeft = xIter3->start;
HXDLIN( 217)					int rectTop = yIter3->start;
HXDLIN( 217)					int rectRight = xIter3->max;
HXDLIN( 217)					bool forceClear = false;
HXDLIN( 217)					{
HXLINE( 217)						int _g16 = rectTop;
HXDLIN( 217)						int _g17 = yIter3->max;
HXDLIN( 217)						while((_g16 < _g17)){
HXLINE( 217)							_g16 = (_g16 + 1);
HXDLIN( 217)							int dy1 = (_g16 - 1);
HXDLIN( 217)							{
HXLINE( 217)								int _g18 = rectLeft;
HXDLIN( 217)								int _g19 = rectRight;
HXDLIN( 217)								while((_g18 < _g19)){
HXLINE( 217)									_g18 = (_g18 + 1);
HXDLIN( 217)									int dx1 = (_g18 - 1);
HXDLIN( 217)									::Dynamic this51 = pixelImage->image;
HXDLIN( 217)									int index4;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 217)									int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN( 217)									int col;
HXDLIN( 217)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)										col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 217)										col = c4;
            									}
HXDLIN( 217)									bool _hx_tmp12;
HXDLIN( 217)									if (pixelImage->useMask) {
HXLINE( 217)										_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 217)										_hx_tmp12 = false;
            									}
HXDLIN( 217)									if (_hx_tmp12) {
HXLINE( 217)										 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN( 217)										::Dynamic this53 = this52->image;
HXDLIN( 217)										int index5;
HXDLIN( 217)										if (this52->useVirtualPos) {
HXLINE( 217)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            										}
            										else {
HXLINE( 217)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            										}
HXDLIN( 217)										int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN( 217)										int v1;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											v1 = c5;
            										}
HXDLIN( 217)										int maskPixel = v1;
HXDLIN( 217)										int this54 = col;
HXDLIN( 217)										if ((maskPixel == 0)) {
HXLINE( 217)											col = this54;
            										}
            										else {
HXLINE( 217)											Float m0;
HXDLIN( 217)											int this55 = ((maskPixel >> 24) & 255);
HXDLIN( 217)											if ((this55 == 0)) {
HXLINE( 217)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m1;
HXDLIN( 217)											int this56 = ((maskPixel >> 16) & 255);
HXDLIN( 217)											if ((this56 == 0)) {
HXLINE( 217)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m2;
HXDLIN( 217)											int this57 = ((maskPixel >> 8) & 255);
HXDLIN( 217)											if ((this57 == 0)) {
HXLINE( 217)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m3;
HXDLIN( 217)											int this58 = (maskPixel & 255);
HXDLIN( 217)											if ((this58 == 0)) {
HXLINE( 217)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 217)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 217)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 217)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN( 217)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 217)									if ((col != 0)) {
HXLINE( 217)										int x5 = (dx1 - rectLeft);
HXDLIN( 217)										int y5 = (dy1 - rectTop);
HXDLIN( 217)										int c6 = col;
HXDLIN( 217)										bool _hx_tmp13;
HXDLIN( 217)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 217)											_hx_tmp13 = undoImage->transparent;
            										}
            										else {
HXLINE( 217)											_hx_tmp13 = false;
            										}
HXDLIN( 217)										if (_hx_tmp13) {
HXLINE( 217)											int location4;
HXDLIN( 217)											if (undoImage->useVirtualPos) {
HXLINE( 217)												location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 217)												location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 217)											int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN( 217)											int this60;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												this60 = this59;
            											}
HXDLIN( 217)											Float a14;
HXDLIN( 217)											int this61 = ((this60 >> 24) & 255);
HXDLIN( 217)											if ((this61 == 0)) {
HXLINE( 217)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r14;
HXDLIN( 217)											int this62 = ((this60 >> 16) & 255);
HXDLIN( 217)											if ((this62 == 0)) {
HXLINE( 217)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g14;
HXDLIN( 217)											int this63 = ((this60 >> 8) & 255);
HXDLIN( 217)											if ((this63 == 0)) {
HXLINE( 217)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b14;
HXDLIN( 217)											int this64 = (this60 & 255);
HXDLIN( 217)											if ((this64 == 0)) {
HXLINE( 217)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a24;
HXDLIN( 217)											int this65 = ((col >> 24) & 255);
HXDLIN( 217)											if ((this65 == 0)) {
HXLINE( 217)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r24;
HXDLIN( 217)											int this66 = ((col >> 16) & 255);
HXDLIN( 217)											if ((this66 == 0)) {
HXLINE( 217)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g24;
HXDLIN( 217)											int this67 = ((col >> 8) & 255);
HXDLIN( 217)											if ((this67 == 0)) {
HXLINE( 217)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b24;
HXDLIN( 217)											int this68 = (col & 255);
HXDLIN( 217)											if ((this68 == 0)) {
HXLINE( 217)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 217)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 217)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 217)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN( 217)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 217)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN( 217)											{
HXLINE( 217)												int _hx_tmp14;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp14 = blended4;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            											}
            										}
            										else {
HXLINE( 217)											::Dynamic this69 = undoImage->image;
HXDLIN( 217)											int index6;
HXDLIN( 217)											if (undoImage->useVirtualPos) {
HXLINE( 217)												index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 217)												index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 217)											int _hx_tmp15;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp15 = c6;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 217)										if (forceClear) {
HXLINE( 217)											::Dynamic this70 = undoImage->image;
HXDLIN( 217)											int x6 = (dx1 - rectLeft);
HXDLIN( 217)											int y6 = (dy1 - rectTop);
HXDLIN( 217)											int index7;
HXDLIN( 217)											if (undoImage->useVirtualPos) {
HXLINE( 217)												index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            											}
            											else {
HXLINE( 217)												index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this70,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 217)			bool found = false;
HXDLIN( 217)			{
HXLINE( 217)				int _g_min = xIter3->start;
HXDLIN( 217)				int _g_max = xIter3->max;
HXDLIN( 217)				while((_g_min < _g_max)){
HXLINE( 217)					_g_min = (_g_min + 1);
HXDLIN( 217)					int px1 = (_g_min - 1);
HXDLIN( 217)					Float pcx = (( (Float)(px1) ) - bx);
HXLINE( 619)					found = false;
HXLINE( 217)					{
HXLINE( 217)						int _g_min1 = yIter3->start;
HXDLIN( 217)						int _g_max1 = yIter3->max;
HXDLIN( 217)						while((_g_min1 < _g_max1)){
HXLINE( 217)							_g_min1 = (_g_min1 + 1);
HXDLIN( 217)							int py1 = (_g_min1 - 1);
HXDLIN( 217)							Float pcy = (( (Float)(py1) ) - by);
HXDLIN( 217)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 217)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 217)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 217)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 217)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 217)							bool _hx_tmp16;
HXDLIN( 217)							bool _hx_tmp17;
HXDLIN( 217)							if ((ratioA >= 0)) {
HXLINE( 217)								_hx_tmp17 = (ratioB >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp17 = false;
            							}
HXDLIN( 217)							if (_hx_tmp17) {
HXLINE( 217)								_hx_tmp16 = (ratioC >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp16 = false;
            							}
HXDLIN( 217)							if (_hx_tmp16) {
HXLINE( 217)								int i14 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 217)								if ((i14 > 255)) {
HXLINE(  24)									i14 = 255;
            								}
HXLINE( 217)								if ((i14 < 0)) {
HXLINE(  25)									i14 = 0;
            								}
HXLINE( 217)								int a9 = i14;
HXDLIN( 217)								int i15 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 217)								if ((i15 > 255)) {
HXLINE(  24)									i15 = 255;
            								}
HXLINE( 217)								if ((i15 < 0)) {
HXLINE(  25)									i15 = 0;
            								}
HXLINE( 217)								int r7 = i15;
HXDLIN( 217)								int i16 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 217)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 217)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 217)								int g7 = i16;
HXDLIN( 217)								int i17 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 217)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 217)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 217)								int b10 = i17;
HXDLIN( 217)								{
HXLINE( 217)									int location5;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 217)									bool _hx_tmp18;
HXDLIN( 217)									if (pixelImage->transparent) {
HXLINE( 217)										_hx_tmp18 = (a9 < 254);
            									}
            									else {
HXLINE( 217)										_hx_tmp18 = false;
            									}
HXDLIN( 217)									if (_hx_tmp18) {
HXLINE( 217)										int this71 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 217)										int old;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											old = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											old = this71;
            										}
HXDLIN( 217)										int rhs = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 217)										Float a15;
HXDLIN( 217)										int this72 = ((old >> 24) & 255);
HXDLIN( 217)										if ((this72 == 0)) {
HXLINE( 217)											a15 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r15;
HXDLIN( 217)										int this73 = ((old >> 16) & 255);
HXDLIN( 217)										if ((this73 == 0)) {
HXLINE( 217)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r15 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g15;
HXDLIN( 217)										int this74 = ((old >> 8) & 255);
HXDLIN( 217)										if ((this74 == 0)) {
HXLINE( 217)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g15 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b15;
HXDLIN( 217)										int this75 = (old & 255);
HXDLIN( 217)										if ((this75 == 0)) {
HXLINE( 217)											b15 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b15 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a25;
HXDLIN( 217)										int this76 = ((rhs >> 24) & 255);
HXDLIN( 217)										if ((this76 == 0)) {
HXLINE( 217)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a25 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r25;
HXDLIN( 217)										int this77 = ((rhs >> 16) & 255);
HXDLIN( 217)										if ((this77 == 0)) {
HXLINE( 217)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r25 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g25;
HXDLIN( 217)										int this78 = ((rhs >> 8) & 255);
HXDLIN( 217)										if ((this78 == 0)) {
HXLINE( 217)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g25 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b25;
HXDLIN( 217)										int this79 = (rhs & 255);
HXDLIN( 217)										if ((this79 == 0)) {
HXLINE( 217)											b25 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 217)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 217)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 217)										int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN( 217)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 217)										int blended5 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b16);
HXDLIN( 217)										{
HXLINE( 217)											int _hx_tmp19;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp19 = blended5;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp19);
            										}
            									}
            									else {
HXLINE( 217)										int value;
HXDLIN( 217)										if (pixelImage->isLittle) {
HXLINE( 217)											value = ((((a9 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            										}
            										else {
HXLINE( 217)											value = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            										}
HXDLIN( 217)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,value);
            									}
            								}
HXLINE( 633)								found = true;
            							}
            							else {
HXLINE( 217)								if (found) {
HXLINE( 217)									goto _hx_goto_126;
            								}
            							}
            						}
            						_hx_goto_126:;
            					}
            				}
            			}
HXDLIN( 217)			{
HXLINE( 217)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,ax,ay,bx,by,true);
HXDLIN( 217)				if (hasUndo) {
HXLINE( 217)					v2->undoImage = undoImage;
HXDLIN( 217)					v2->undoX = xIter3->start;
HXDLIN( 217)					v2->undoY = yIter3->start;
            				}
            			}
            		}
            		else {
HXLINE( 217)			Float bx1 = ax;
HXDLIN( 217)			Float by1 = ay;
HXDLIN( 217)			Float cx1 = bx;
HXDLIN( 217)			Float cy1 = by;
HXDLIN( 217)			bool hasUndo1 = false;
HXDLIN( 217)			bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN( 217)			if (!(adjustWinding)) {
HXLINE( 217)				Float bx_ = bx1;
HXDLIN( 217)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE( 217)			{
HXLINE( 217)				Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN( 217)				Float sx = (cy1 - ey);
HXDLIN( 217)				Float sy = (ex - cx1);
HXDLIN( 217)				Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN( 217)				Float tx = (ey - by1);
HXDLIN( 217)				Float ty = (bx1 - ex);
HXDLIN( 217)				Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 217)				if ((ex > bx1)) {
HXLINE( 217)					if ((ex > cx1)) {
HXLINE( 217)						int min4;
HXDLIN( 217)						if ((bx1 > cx1)) {
HXLINE( 217)							min4 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 217)							min4 = ::Math_obj::floor(bx1);
            						}
HXDLIN( 217)						int ii_min16 = min4;
HXDLIN( 217)						int ii_max16 = ::Math_obj::ceil(ex);
HXDLIN( 217)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE( 217)						int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 217)						int ii_max17 = ::Math_obj::ceil(cx1);
HXDLIN( 217)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE( 217)					if ((bx1 > cx1)) {
HXLINE( 217)						int min5;
HXDLIN( 217)						if ((ex > cx1)) {
HXLINE( 217)							min5 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 217)							min5 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 217)						int ii_min18 = min5;
HXDLIN( 217)						int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 217)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE( 217)						int ii_min19 = ::Math_obj::floor(ex);
HXDLIN( 217)						int ii_max19 = ::Math_obj::ceil(cx1);
HXDLIN( 217)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 217)				if ((ey > by1)) {
HXLINE( 217)					if ((ey > cy1)) {
HXLINE( 217)						int min6;
HXDLIN( 217)						if ((by1 > cy1)) {
HXLINE( 217)							min6 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 217)							min6 = ::Math_obj::floor(by1);
            						}
HXDLIN( 217)						int ii_min20 = min6;
HXDLIN( 217)						int ii_max20 = ::Math_obj::ceil(ey);
HXDLIN( 217)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE( 217)						int ii_min21 = ::Math_obj::floor(by1);
HXDLIN( 217)						int ii_max21 = ::Math_obj::ceil(cy1);
HXDLIN( 217)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE( 217)					if ((by1 > cy1)) {
HXLINE( 217)						int min7;
HXDLIN( 217)						if ((ey > cy1)) {
HXLINE( 217)							min7 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 217)							min7 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 217)						int ii_min22 = min7;
HXDLIN( 217)						int ii_max22 = ::Math_obj::ceil(by1);
HXDLIN( 217)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE( 217)						int ii_min23 = ::Math_obj::floor(ey);
HXDLIN( 217)						int ii_max23 = ::Math_obj::ceil(cy1);
HXDLIN( 217)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 217)				if (hasUndo1) {
HXLINE( 217)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 217)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 217)					 ::Dynamic imageType1 = null();
HXDLIN( 217)					 ::pi_xy::ImageStruct this80 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 217)					::Dynamic undoImage4;
HXDLIN( 217)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 217)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::BytesImg b17 = byt1;
HXDLIN( 217)							{
HXLINE( 217)								b17->width = width1;
HXDLIN( 217)								b17->height = height1;
HXDLIN( 217)								b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 217)								b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 217)								{
HXLINE( 217)									int len2 = b17->length;
HXDLIN( 217)									int w1 = 0;
HXDLIN( 217)									{
HXLINE( 217)										int _g20 = 0;
HXDLIN( 217)										int _g21 = b17->height;
HXDLIN( 217)										while((_g20 < _g21)){
HXLINE( 217)											_g20 = (_g20 + 1);
HXDLIN( 217)											int y7 = (_g20 - 1);
HXDLIN( 217)											{
HXLINE( 217)												int _g22 = 0;
HXDLIN( 217)												int _g23 = b17->width;
HXDLIN( 217)												while((_g22 < _g23)){
HXLINE( 217)													_g22 = (_g22 + 1);
HXDLIN( 217)													int x7 = (_g22 - 1);
HXDLIN( 217)													{
HXLINE( 217)														w1 = (w1 + 1);
HXDLIN( 217)														b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w1 = (w1 + 1);
HXDLIN( 217)														b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w1 = (w1 + 1);
HXDLIN( 217)														b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w1 = (w1 + 1);
HXDLIN( 217)														b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage4 = b17;
            						}
            						break;
            						case (int)1: {
HXLINE( 217)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN( 217)							{
HXLINE( 217)								a16->width = width1;
HXDLIN( 217)								a16->height = height1;
HXDLIN( 217)								a16->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)								a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 217)								{
HXLINE( 217)									int _g24 = 0;
HXDLIN( 217)									int _g25 = a16->length;
HXDLIN( 217)									while((_g24 < _g25)){
HXLINE( 217)										_g24 = (_g24 + 1);
HXDLIN( 217)										int i18 = (_g24 - 1);
HXDLIN( 217)										a16->data[i18] = 0;
            									}
            								}
            							}
HXDLIN( 217)							undoImage4 = a16;
            						}
            						break;
            						case (int)2: {
HXLINE( 217)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::U32ArrImg b18 = u32a1;
HXDLIN( 217)							{
HXLINE( 217)								b18->width = width1;
HXDLIN( 217)								b18->height = height1;
HXDLIN( 217)								b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 217)								int size1 = (b18->length * 4);
HXDLIN( 217)								b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 217)								{
HXLINE( 217)									int _g26 = 0;
HXDLIN( 217)									int _g27 = b18->length;
HXDLIN( 217)									while((_g26 < _g27)){
HXLINE( 217)										_g26 = (_g26 + 1);
HXDLIN( 217)										int i19 = (_g26 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::io::ArrayBufferViewImpl this81 = b18->data;
HXDLIN( 217)											bool undoImage5;
HXDLIN( 217)											if ((i19 >= 0)) {
HXLINE( 217)												undoImage5 = (i19 < (this81->byteLength >> 2));
            											}
            											else {
HXLINE( 217)												undoImage5 = false;
            											}
HXDLIN( 217)											if (undoImage5) {
HXLINE( 217)												 ::haxe::io::Bytes _this1 = this81->bytes;
HXDLIN( 217)												int pos1 = ((i19 << 2) + this81->byteOffset);
HXDLIN( 217)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 217)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage4 = b18;
            						}
            						break;
            						case (int)3: {
HXLINE( 217)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 217)							{
HXLINE( 217)								v3->width = width1;
HXDLIN( 217)								v3->height = height1;
HXDLIN( 217)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 217)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 217)								{
HXLINE( 217)									int _g28 = 0;
HXDLIN( 217)									int _g29 = v3->length;
HXDLIN( 217)									while((_g28 < _g29)){
HXLINE( 217)										_g28 = (_g28 + 1);
HXDLIN( 217)										int i20 = (_g28 - 1);
HXDLIN( 217)										v3->data->__unsafe_set(i20,0);
            									}
            								}
            							}
HXDLIN( 217)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 217)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::StackIntImg b19 = sInt1;
HXDLIN( 217)							{
HXLINE( 217)								b19->width = width1;
HXDLIN( 217)								b19->height = height1;
HXDLIN( 217)								b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 217)								b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)								{
HXLINE( 217)									int len3 = b19->length;
HXDLIN( 217)									 ::haxe::ds::GenericStack_Int d1 = b19->data;
HXDLIN( 217)									if (::hx::IsNull( d1->head )) {
HXLINE( 217)										int _g30 = 0;
HXDLIN( 217)										int _g31 = len3;
HXDLIN( 217)										while((_g30 < _g31)){
HXLINE( 217)											_g30 = (_g30 + 1);
HXDLIN( 217)											int i21 = (_g30 - 1);
HXDLIN( 217)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 217)										int _g32 = 0;
HXDLIN( 217)										int _g33 = len3;
HXDLIN( 217)										while((_g32 < _g33)){
HXLINE( 217)											_g32 = (_g32 + 1);
HXDLIN( 217)											int i22 = (_g32 - 1);
HXDLIN( 217)											{
HXLINE( 217)												 ::haxe::ds::GenericCell_Int l1 = b19->data->head;
HXDLIN( 217)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 217)												{
HXLINE( 217)													int _g34 = 0;
HXDLIN( 217)													int _g35 = i22;
HXDLIN( 217)													while((_g34 < _g35)){
HXLINE( 217)														_g34 = (_g34 + 1);
HXDLIN( 217)														int i23 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 217)												if (::hx::IsNull( prev1 )) {
HXLINE( 217)													b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 217)													l1 = null();
            												}
            												else {
HXLINE( 217)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 217)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage4 = b19;
            						}
            						break;
            					}
HXDLIN( 217)					this80->image = undoImage4;
HXDLIN( 217)					this80->width = width1;
HXDLIN( 217)					this80->height = height1;
HXDLIN( 217)					this80->imageType = ( (int)(imageType1) );
HXDLIN( 217)					undoImage3 = this80;
HXDLIN( 217)					{
HXLINE( 217)						int rectLeft1 = xIter31->start;
HXDLIN( 217)						int rectTop1 = yIter31->start;
HXDLIN( 217)						int rectRight1 = xIter31->max;
HXDLIN( 217)						bool forceClear1 = false;
HXDLIN( 217)						{
HXLINE( 217)							int _g36 = rectTop1;
HXDLIN( 217)							int _g37 = yIter31->max;
HXDLIN( 217)							while((_g36 < _g37)){
HXLINE( 217)								_g36 = (_g36 + 1);
HXDLIN( 217)								int dy2 = (_g36 - 1);
HXDLIN( 217)								{
HXLINE( 217)									int _g38 = rectLeft1;
HXDLIN( 217)									int _g39 = rectRight1;
HXDLIN( 217)									while((_g38 < _g39)){
HXLINE( 217)										_g38 = (_g38 + 1);
HXDLIN( 217)										int dx2 = (_g38 - 1);
HXDLIN( 217)										::Dynamic this82 = pixelImage->image;
HXDLIN( 217)										int index8;
HXDLIN( 217)										if (pixelImage->useVirtualPos) {
HXLINE( 217)											index8 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 217)											index8 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 217)										int c7 = ::iterMagic::Iimg_obj::get(this82,index8);
HXDLIN( 217)										int col1;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											col1 = c7;
            										}
HXDLIN( 217)										bool _hx_tmp20;
HXDLIN( 217)										if (pixelImage->useMask) {
HXLINE( 217)											_hx_tmp20 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 217)											_hx_tmp20 = false;
            										}
HXDLIN( 217)										if (_hx_tmp20) {
HXLINE( 217)											 ::pi_xy::ImageStruct this83 = pixelImage->mask;
HXDLIN( 217)											::Dynamic this84 = this83->image;
HXDLIN( 217)											int index9;
HXDLIN( 217)											if (this83->useVirtualPos) {
HXLINE( 217)												index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this83->virtualY) * ( (Float)(this83->width) )) + dx2) - this83->virtualX));
            											}
            											else {
HXLINE( 217)												index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this83->width) + dx2)) ));
            											}
HXDLIN( 217)											int c8 = ::iterMagic::Iimg_obj::get(this84,index9);
HXDLIN( 217)											int v4;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												v4 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												v4 = c8;
            											}
HXDLIN( 217)											int maskPixel1 = v4;
HXDLIN( 217)											int this85 = col1;
HXDLIN( 217)											if ((maskPixel1 == 0)) {
HXLINE( 217)												col1 = this85;
            											}
            											else {
HXLINE( 217)												Float m01;
HXDLIN( 217)												int this86 = ((maskPixel1 >> 24) & 255);
HXDLIN( 217)												if ((this86 == 0)) {
HXLINE( 217)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m01 = (( (Float)(this86) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m11;
HXDLIN( 217)												int this87 = ((maskPixel1 >> 16) & 255);
HXDLIN( 217)												if ((this87 == 0)) {
HXLINE( 217)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m11 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m21;
HXDLIN( 217)												int this88 = ((maskPixel1 >> 8) & 255);
HXDLIN( 217)												if ((this88 == 0)) {
HXLINE( 217)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m21 = (( (Float)(this88) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m31;
HXDLIN( 217)												int this89 = (maskPixel1 & 255);
HXDLIN( 217)												if ((this89 == 0)) {
HXLINE( 217)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m31 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this85 >> 24) & 255)) )));
HXDLIN( 217)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this85 >> 16) & 255)) )));
HXDLIN( 217)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this85 >> 8) & 255)) )));
HXDLIN( 217)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this85 & 255)) )));
HXDLIN( 217)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 217)										if ((col1 != 0)) {
HXLINE( 217)											int x8 = (dx2 - rectLeft1);
HXDLIN( 217)											int y8 = (dy2 - rectTop1);
HXDLIN( 217)											int c9 = col1;
HXDLIN( 217)											bool _hx_tmp21;
HXDLIN( 217)											if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp21 = undoImage3->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp21 = false;
            											}
HXDLIN( 217)											if (_hx_tmp21) {
HXLINE( 217)												int location6;
HXDLIN( 217)												if (undoImage3->useVirtualPos) {
HXLINE( 217)													location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 217)													location6 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            												}
HXDLIN( 217)												int this90 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN( 217)												int this91;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this91 = this90;
            												}
HXDLIN( 217)												Float a17;
HXDLIN( 217)												int this92 = ((this91 >> 24) & 255);
HXDLIN( 217)												if ((this92 == 0)) {
HXLINE( 217)													a17 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r16;
HXDLIN( 217)												int this93 = ((this91 >> 16) & 255);
HXDLIN( 217)												if ((this93 == 0)) {
HXLINE( 217)													r16 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r16 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g16;
HXDLIN( 217)												int this94 = ((this91 >> 8) & 255);
HXDLIN( 217)												if ((this94 == 0)) {
HXLINE( 217)													g16 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g16 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b110;
HXDLIN( 217)												int this95 = (this91 & 255);
HXDLIN( 217)												if ((this95 == 0)) {
HXLINE( 217)													b110 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b110 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a26;
HXDLIN( 217)												int this96 = ((col1 >> 24) & 255);
HXDLIN( 217)												if ((this96 == 0)) {
HXLINE( 217)													a26 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a26 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r26;
HXDLIN( 217)												int this97 = ((col1 >> 16) & 255);
HXDLIN( 217)												if ((this97 == 0)) {
HXLINE( 217)													r26 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r26 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g26;
HXDLIN( 217)												int this98 = ((col1 >> 8) & 255);
HXDLIN( 217)												if ((this98 == 0)) {
HXLINE( 217)													g26 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g26 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b26;
HXDLIN( 217)												int this99 = (col1 & 255);
HXDLIN( 217)												if ((this99 == 0)) {
HXLINE( 217)													b26 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b26 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 217)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 217)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 217)												int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b26 * a26))));
HXDLIN( 217)												int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 217)												int blended6 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp22;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp22 = blended6;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this100 = undoImage3->image;
HXDLIN( 217)												int index10;
HXDLIN( 217)												if (undoImage3->useVirtualPos) {
HXLINE( 217)													index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 217)													index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            												}
HXDLIN( 217)												int _hx_tmp23;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp23 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp23 = c9;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp23);
            											}
            										}
            										else {
HXLINE( 217)											if (forceClear1) {
HXLINE( 217)												::Dynamic this101 = undoImage3->image;
HXDLIN( 217)												int x9 = (dx2 - rectLeft1);
HXDLIN( 217)												int y9 = (dy2 - rectTop1);
HXDLIN( 217)												int index11;
HXDLIN( 217)												if (undoImage3->useVirtualPos) {
HXLINE( 217)													index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 217)													index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this101,index11,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 217)				bool found1 = false;
HXDLIN( 217)				Float s = ((Float)0.);
HXDLIN( 217)				Float t = ((Float)0.);
HXDLIN( 217)				Float sxx = ((Float)0.);
HXDLIN( 217)				Float txx = ((Float)0.);
HXDLIN( 217)				{
HXLINE( 217)					int _g_min2 = xIter31->start;
HXDLIN( 217)					int _g_max2 = xIter31->max;
HXDLIN( 217)					while((_g_min2 < _g_max2)){
HXLINE( 217)						_g_min2 = (_g_min2 + 1);
HXDLIN( 217)						int x10 = (_g_min2 - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x10) ));
HXLINE(  61)						txx = (tx * ( (Float)(x10) ));
HXLINE(  62)						found1 = false;
HXLINE( 217)						{
HXLINE( 217)							int _g_min3 = yIter31->start;
HXDLIN( 217)							int _g_max3 = yIter31->max;
HXDLIN( 217)							while((_g_min3 < _g_max3)){
HXLINE( 217)								_g_min3 = (_g_min3 + 1);
HXDLIN( 217)								int y10 = (_g_min3 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y10) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y10) )));
HXLINE( 217)								bool _hx_tmp24;
HXDLIN( 217)								if (!((s <= 0))) {
HXLINE( 217)									_hx_tmp24 = (t <= 0);
            								}
            								else {
HXLINE( 217)									_hx_tmp24 = true;
            								}
HXDLIN( 217)								if (_hx_tmp24) {
HXLINE( 217)									if (found1) {
HXLINE( 217)										goto _hx_goto_138;
            									}
            								}
            								else {
HXLINE( 217)									if (((s + t) < A)) {
HXLINE( 217)										{
HXLINE( 217)											int c10 = color;
HXDLIN( 217)											bool _hx_tmp25;
HXDLIN( 217)											if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp25 = pixelImage->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp25 = false;
            											}
HXDLIN( 217)											if (_hx_tmp25) {
HXLINE( 217)												int location7;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													location7 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x10) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													location7 = ::Std_obj::_hx_int(( (Float)(((y10 * pixelImage->width) + x10)) ));
            												}
HXDLIN( 217)												int this102 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 217)												int this103;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this103 = ((((((this102 >> 24) & 255) << 24) | ((this102 & 255) << 16)) | (((this102 >> 8) & 255) << 8)) | ((this102 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this103 = this102;
            												}
HXDLIN( 217)												Float a19;
HXDLIN( 217)												int this104 = ((this103 >> 24) & 255);
HXDLIN( 217)												if ((this104 == 0)) {
HXLINE( 217)													a19 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a19 = (( (Float)(this104) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r17;
HXDLIN( 217)												int this105 = ((this103 >> 16) & 255);
HXDLIN( 217)												if ((this105 == 0)) {
HXLINE( 217)													r17 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r17 = (( (Float)(this105) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g17;
HXDLIN( 217)												int this106 = ((this103 >> 8) & 255);
HXDLIN( 217)												if ((this106 == 0)) {
HXLINE( 217)													g17 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g17 = (( (Float)(this106) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b111;
HXDLIN( 217)												int this107 = (this103 & 255);
HXDLIN( 217)												if ((this107 == 0)) {
HXLINE( 217)													b111 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b111 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a27;
HXDLIN( 217)												int this108 = ((color >> 24) & 255);
HXDLIN( 217)												if ((this108 == 0)) {
HXLINE( 217)													a27 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a27 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r27;
HXDLIN( 217)												int this109 = ((color >> 16) & 255);
HXDLIN( 217)												if ((this109 == 0)) {
HXLINE( 217)													r27 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r27 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g27;
HXDLIN( 217)												int this110 = ((color >> 8) & 255);
HXDLIN( 217)												if ((this110 == 0)) {
HXLINE( 217)													g27 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g27 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b27;
HXDLIN( 217)												int this111 = (color & 255);
HXDLIN( 217)												if ((this111 == 0)) {
HXLINE( 217)													b27 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b27 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN( 217)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 217)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 217)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b27 * a27))));
HXDLIN( 217)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 217)												int blended7 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b28);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp26;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp26 = blended7;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp26);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this112 = pixelImage->image;
HXDLIN( 217)												int index12;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x10) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													index12 = ::Std_obj::_hx_int(( (Float)(((y10 * pixelImage->width) + x10)) ));
            												}
HXDLIN( 217)												int _hx_tmp27;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp27 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp27 = c10;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this112,index12,_hx_tmp27);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE( 217)										if (found1) {
HXLINE( 217)											goto _hx_goto_138;
            										}
            									}
            								}
            							}
            							_hx_goto_138:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 217)		if (softRight) {
HXLINE( 217)			bool hasUndo2 = false;
HXDLIN( 217)			int aA1 = ((color >> 24) & 255);
HXDLIN( 217)			int rA1 = ((color >> 16) & 255);
HXDLIN( 217)			int gA1 = ((color >> 8) & 255);
HXDLIN( 217)			int bA1 = (color & 255);
HXDLIN( 217)			Float bcx1 = (bx - cx);
HXDLIN( 217)			Float bcy1 = (by - cy);
HXDLIN( 217)			Float acx1 = (ex - cx);
HXDLIN( 217)			Float acy1 = (ey - cy);
HXDLIN( 217)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 217)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 217)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 217)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 217)			if ((ex > bx)) {
HXLINE( 217)				if ((ex > cx)) {
HXLINE( 217)					int min8;
HXDLIN( 217)					if ((bx > cx)) {
HXLINE( 217)						min8 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 217)						min8 = ::Math_obj::floor(bx);
            					}
HXDLIN( 217)					int ii_min24 = min8;
HXDLIN( 217)					int ii_max24 = ::Math_obj::ceil(ex);
HXDLIN( 217)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE( 217)					int ii_min25 = ::Math_obj::floor(bx);
HXDLIN( 217)					int ii_max25 = ::Math_obj::ceil(cx);
HXDLIN( 217)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE( 217)				if ((bx > cx)) {
HXLINE( 217)					int min9;
HXDLIN( 217)					if ((ex > cx)) {
HXLINE( 217)						min9 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 217)						min9 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 217)					int ii_min26 = min9;
HXDLIN( 217)					int ii_max26 = ::Math_obj::ceil(bx);
HXDLIN( 217)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE( 217)					int ii_min27 = ::Math_obj::floor(ex);
HXDLIN( 217)					int ii_max27 = ::Math_obj::ceil(cx);
HXDLIN( 217)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 217)			if ((ey > by)) {
HXLINE( 217)				if ((ey > cy)) {
HXLINE( 217)					int min10;
HXDLIN( 217)					if ((by > cy)) {
HXLINE( 217)						min10 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 217)						min10 = ::Math_obj::floor(by);
            					}
HXDLIN( 217)					int ii_min28 = min10;
HXDLIN( 217)					int ii_max28 = ::Math_obj::ceil(ey);
HXDLIN( 217)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE( 217)					int ii_min29 = ::Math_obj::floor(by);
HXDLIN( 217)					int ii_max29 = ::Math_obj::ceil(cy);
HXDLIN( 217)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE( 217)				if ((by > cy)) {
HXLINE( 217)					int min11;
HXDLIN( 217)					if ((ey > cy)) {
HXLINE( 217)						min11 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 217)						min11 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 217)					int ii_min30 = min11;
HXDLIN( 217)					int ii_max30 = ::Math_obj::ceil(by);
HXDLIN( 217)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE( 217)					int ii_min31 = ::Math_obj::floor(ey);
HXDLIN( 217)					int ii_max31 = ::Math_obj::ceil(cy);
HXDLIN( 217)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 217)			if (hasUndo2) {
HXLINE( 217)				int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 217)				int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 217)				 ::Dynamic imageType2 = null();
HXDLIN( 217)				 ::pi_xy::ImageStruct this113 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 217)				::Dynamic undoImage7;
HXDLIN( 217)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 217)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::BytesImg b29 = byt2;
HXDLIN( 217)						{
HXLINE( 217)							b29->width = width2;
HXDLIN( 217)							b29->height = height2;
HXDLIN( 217)							b29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 217)							b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 217)							{
HXLINE( 217)								int len4 = b29->length;
HXDLIN( 217)								int w2 = 0;
HXDLIN( 217)								{
HXLINE( 217)									int _g40 = 0;
HXDLIN( 217)									int _g41 = b29->height;
HXDLIN( 217)									while((_g40 < _g41)){
HXLINE( 217)										_g40 = (_g40 + 1);
HXDLIN( 217)										int y11 = (_g40 - 1);
HXDLIN( 217)										{
HXLINE( 217)											int _g42 = 0;
HXDLIN( 217)											int _g43 = b29->width;
HXDLIN( 217)											while((_g42 < _g43)){
HXLINE( 217)												_g42 = (_g42 + 1);
HXDLIN( 217)												int x11 = (_g42 - 1);
HXDLIN( 217)												{
HXLINE( 217)													w2 = (w2 + 1);
HXDLIN( 217)													b29->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w2 = (w2 + 1);
HXDLIN( 217)													b29->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w2 = (w2 + 1);
HXDLIN( 217)													b29->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w2 = (w2 + 1);
HXDLIN( 217)													b29->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage7 = b29;
            					}
            					break;
            					case (int)1: {
HXLINE( 217)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::ArrIntImg a28 = arrI2;
HXDLIN( 217)						{
HXLINE( 217)							a28->width = width2;
HXDLIN( 217)							a28->height = height2;
HXDLIN( 217)							a28->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)							a28->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 217)							{
HXLINE( 217)								int _g44 = 0;
HXDLIN( 217)								int _g45 = a28->length;
HXDLIN( 217)								while((_g44 < _g45)){
HXLINE( 217)									_g44 = (_g44 + 1);
HXDLIN( 217)									int i24 = (_g44 - 1);
HXDLIN( 217)									a28->data[i24] = 0;
            								}
            							}
            						}
HXDLIN( 217)						undoImage7 = a28;
            					}
            					break;
            					case (int)2: {
HXLINE( 217)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::U32ArrImg b30 = u32a2;
HXDLIN( 217)						{
HXLINE( 217)							b30->width = width2;
HXDLIN( 217)							b30->height = height2;
HXDLIN( 217)							b30->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 217)							int size2 = (b30->length * 4);
HXDLIN( 217)							b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 217)							{
HXLINE( 217)								int _g46 = 0;
HXDLIN( 217)								int _g47 = b30->length;
HXDLIN( 217)								while((_g46 < _g47)){
HXLINE( 217)									_g46 = (_g46 + 1);
HXDLIN( 217)									int i25 = (_g46 - 1);
HXDLIN( 217)									{
HXLINE( 217)										 ::haxe::io::ArrayBufferViewImpl this114 = b30->data;
HXDLIN( 217)										bool undoImage8;
HXDLIN( 217)										if ((i25 >= 0)) {
HXLINE( 217)											undoImage8 = (i25 < (this114->byteLength >> 2));
            										}
            										else {
HXLINE( 217)											undoImage8 = false;
            										}
HXDLIN( 217)										if (undoImage8) {
HXLINE( 217)											 ::haxe::io::Bytes _this2 = this114->bytes;
HXDLIN( 217)											int pos2 = ((i25 << 2) + this114->byteOffset);
HXDLIN( 217)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 217)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage7 = b30;
            					}
            					break;
            					case (int)3: {
HXLINE( 217)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 217)						{
HXLINE( 217)							v5->width = width2;
HXDLIN( 217)							v5->height = height2;
HXDLIN( 217)							v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 217)							v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 217)							{
HXLINE( 217)								int _g48 = 0;
HXDLIN( 217)								int _g49 = v5->length;
HXDLIN( 217)								while((_g48 < _g49)){
HXLINE( 217)									_g48 = (_g48 + 1);
HXDLIN( 217)									int i26 = (_g48 - 1);
HXDLIN( 217)									v5->data->__unsafe_set(i26,0);
            								}
            							}
            						}
HXDLIN( 217)						undoImage7 = v5;
            					}
            					break;
            					case (int)4: {
HXLINE( 217)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::StackIntImg b31 = sInt2;
HXDLIN( 217)						{
HXLINE( 217)							b31->width = width2;
HXDLIN( 217)							b31->height = height2;
HXDLIN( 217)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 217)							b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)							{
HXLINE( 217)								int len5 = b31->length;
HXDLIN( 217)								 ::haxe::ds::GenericStack_Int d2 = b31->data;
HXDLIN( 217)								if (::hx::IsNull( d2->head )) {
HXLINE( 217)									int _g50 = 0;
HXDLIN( 217)									int _g51 = len5;
HXDLIN( 217)									while((_g50 < _g51)){
HXLINE( 217)										_g50 = (_g50 + 1);
HXDLIN( 217)										int i27 = (_g50 - 1);
HXDLIN( 217)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 217)									int _g52 = 0;
HXDLIN( 217)									int _g53 = len5;
HXDLIN( 217)									while((_g52 < _g53)){
HXLINE( 217)										_g52 = (_g52 + 1);
HXDLIN( 217)										int i28 = (_g52 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::ds::GenericCell_Int l2 = b31->data->head;
HXDLIN( 217)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 217)											{
HXLINE( 217)												int _g54 = 0;
HXDLIN( 217)												int _g55 = i28;
HXDLIN( 217)												while((_g54 < _g55)){
HXLINE( 217)													_g54 = (_g54 + 1);
HXDLIN( 217)													int i29 = (_g54 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 217)											if (::hx::IsNull( prev2 )) {
HXLINE( 217)												b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 217)												l2 = null();
            											}
            											else {
HXLINE( 217)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 217)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage7 = b31;
            					}
            					break;
            				}
HXDLIN( 217)				this113->image = undoImage7;
HXDLIN( 217)				this113->width = width2;
HXDLIN( 217)				this113->height = height2;
HXDLIN( 217)				this113->imageType = ( (int)(imageType2) );
HXDLIN( 217)				undoImage6 = this113;
HXDLIN( 217)				{
HXLINE( 217)					int rectLeft2 = xIter32->start;
HXDLIN( 217)					int rectTop2 = yIter32->start;
HXDLIN( 217)					int rectRight2 = xIter32->max;
HXDLIN( 217)					bool forceClear2 = false;
HXDLIN( 217)					{
HXLINE( 217)						int _g56 = rectTop2;
HXDLIN( 217)						int _g57 = yIter32->max;
HXDLIN( 217)						while((_g56 < _g57)){
HXLINE( 217)							_g56 = (_g56 + 1);
HXDLIN( 217)							int dy3 = (_g56 - 1);
HXDLIN( 217)							{
HXLINE( 217)								int _g58 = rectLeft2;
HXDLIN( 217)								int _g59 = rectRight2;
HXDLIN( 217)								while((_g58 < _g59)){
HXLINE( 217)									_g58 = (_g58 + 1);
HXDLIN( 217)									int dx3 = (_g58 - 1);
HXDLIN( 217)									::Dynamic this115 = pixelImage->image;
HXDLIN( 217)									int index13;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										index13 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										index13 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            									}
HXDLIN( 217)									int c11 = ::iterMagic::Iimg_obj::get(this115,index13);
HXDLIN( 217)									int col2;
HXDLIN( 217)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)										col2 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            									}
            									else {
HXLINE( 217)										col2 = c11;
            									}
HXDLIN( 217)									bool _hx_tmp28;
HXDLIN( 217)									if (pixelImage->useMask) {
HXLINE( 217)										_hx_tmp28 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 217)										_hx_tmp28 = false;
            									}
HXDLIN( 217)									if (_hx_tmp28) {
HXLINE( 217)										 ::pi_xy::ImageStruct this116 = pixelImage->mask;
HXDLIN( 217)										::Dynamic this117 = this116->image;
HXDLIN( 217)										int index14;
HXDLIN( 217)										if (this116->useVirtualPos) {
HXLINE( 217)											index14 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this116->virtualY) * ( (Float)(this116->width) )) + dx3) - this116->virtualX));
            										}
            										else {
HXLINE( 217)											index14 = ::Std_obj::_hx_int(( (Float)(((dy3 * this116->width) + dx3)) ));
            										}
HXDLIN( 217)										int c12 = ::iterMagic::Iimg_obj::get(this117,index14);
HXDLIN( 217)										int v6;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											v6 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											v6 = c12;
            										}
HXDLIN( 217)										int maskPixel2 = v6;
HXDLIN( 217)										int this118 = col2;
HXDLIN( 217)										if ((maskPixel2 == 0)) {
HXLINE( 217)											col2 = this118;
            										}
            										else {
HXLINE( 217)											Float m02;
HXDLIN( 217)											int this119 = ((maskPixel2 >> 24) & 255);
HXDLIN( 217)											if ((this119 == 0)) {
HXLINE( 217)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m02 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m12;
HXDLIN( 217)											int this120 = ((maskPixel2 >> 16) & 255);
HXDLIN( 217)											if ((this120 == 0)) {
HXLINE( 217)												m12 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m12 = (( (Float)(this120) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m22;
HXDLIN( 217)											int this121 = ((maskPixel2 >> 8) & 255);
HXDLIN( 217)											if ((this121 == 0)) {
HXLINE( 217)												m22 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m22 = (( (Float)(this121) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m32;
HXDLIN( 217)											int this122 = (maskPixel2 & 255);
HXDLIN( 217)											if ((this122 == 0)) {
HXLINE( 217)												m32 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m32 = (( (Float)(this122) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this118 >> 24) & 255)) )));
HXDLIN( 217)											int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this118 >> 16) & 255)) )));
HXDLIN( 217)											int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this118 >> 8) & 255)) )));
HXDLIN( 217)											int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this118 & 255)) )));
HXDLIN( 217)											col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 217)									if ((col2 != 0)) {
HXLINE( 217)										int x12 = (dx3 - rectLeft2);
HXDLIN( 217)										int y12 = (dy3 - rectTop2);
HXDLIN( 217)										int c13 = col2;
HXDLIN( 217)										bool _hx_tmp29;
HXDLIN( 217)										if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 217)											_hx_tmp29 = undoImage6->transparent;
            										}
            										else {
HXLINE( 217)											_hx_tmp29 = false;
            										}
HXDLIN( 217)										if (_hx_tmp29) {
HXLINE( 217)											int location8;
HXDLIN( 217)											if (undoImage6->useVirtualPos) {
HXLINE( 217)												location8 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 217)												location8 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            											}
HXDLIN( 217)											int this123 = ::iterMagic::Iimg_obj::get(undoImage6->image,location8);
HXDLIN( 217)											int this124;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												this124 = ((((((this123 >> 24) & 255) << 24) | ((this123 & 255) << 16)) | (((this123 >> 8) & 255) << 8)) | ((this123 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												this124 = this123;
            											}
HXDLIN( 217)											Float a110;
HXDLIN( 217)											int this125 = ((this124 >> 24) & 255);
HXDLIN( 217)											if ((this125 == 0)) {
HXLINE( 217)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a110 = (( (Float)(this125) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r18;
HXDLIN( 217)											int this126 = ((this124 >> 16) & 255);
HXDLIN( 217)											if ((this126 == 0)) {
HXLINE( 217)												r18 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r18 = (( (Float)(this126) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g18;
HXDLIN( 217)											int this127 = ((this124 >> 8) & 255);
HXDLIN( 217)											if ((this127 == 0)) {
HXLINE( 217)												g18 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g18 = (( (Float)(this127) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b112;
HXDLIN( 217)											int this128 = (this124 & 255);
HXDLIN( 217)											if ((this128 == 0)) {
HXLINE( 217)												b112 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b112 = (( (Float)(this128) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a29;
HXDLIN( 217)											int this129 = ((col2 >> 24) & 255);
HXDLIN( 217)											if ((this129 == 0)) {
HXLINE( 217)												a29 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a29 = (( (Float)(this129) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r28;
HXDLIN( 217)											int this130 = ((col2 >> 16) & 255);
HXDLIN( 217)											if ((this130 == 0)) {
HXLINE( 217)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r28 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g28;
HXDLIN( 217)											int this131 = ((col2 >> 8) & 255);
HXDLIN( 217)											if ((this131 == 0)) {
HXLINE( 217)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g28 = (( (Float)(this131) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b210;
HXDLIN( 217)											int this132 = (col2 & 255);
HXDLIN( 217)											if ((this132 == 0)) {
HXLINE( 217)												b210 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b210 = (( (Float)(this132) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a38 = (a110 * (( (Float)(1) ) - a29));
HXDLIN( 217)											int r19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a29))));
HXDLIN( 217)											int g19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a29))));
HXDLIN( 217)											int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b210 * a29))));
HXDLIN( 217)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a29)));
HXDLIN( 217)											int blended8 = ((((a30 << 24) | (r19 << 16)) | (g19 << 8)) | b32);
HXDLIN( 217)											{
HXLINE( 217)												int _hx_tmp30;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp30 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp30 = blended8;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(undoImage6->image,location8,_hx_tmp30);
            											}
            										}
            										else {
HXLINE( 217)											::Dynamic this133 = undoImage6->image;
HXDLIN( 217)											int index15;
HXDLIN( 217)											if (undoImage6->useVirtualPos) {
HXLINE( 217)												index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 217)												index15 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            											}
HXDLIN( 217)											int _hx_tmp31;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp31 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp31 = c13;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this133,index15,_hx_tmp31);
            										}
            									}
            									else {
HXLINE( 217)										if (forceClear2) {
HXLINE( 217)											::Dynamic this134 = undoImage6->image;
HXDLIN( 217)											int x13 = (dx3 - rectLeft2);
HXDLIN( 217)											int y13 = (dy3 - rectTop2);
HXDLIN( 217)											int index16;
HXDLIN( 217)											if (undoImage6->useVirtualPos) {
HXLINE( 217)												index16 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x13) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 217)												index16 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage6->width) + x13)) ));
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this134,index16,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 217)			bool found2 = false;
HXDLIN( 217)			{
HXLINE( 217)				int _g_min4 = xIter32->start;
HXDLIN( 217)				int _g_max4 = xIter32->max;
HXDLIN( 217)				while((_g_min4 < _g_max4)){
HXLINE( 217)					_g_min4 = (_g_min4 + 1);
HXDLIN( 217)					int px2 = (_g_min4 - 1);
HXDLIN( 217)					Float pcx1 = (( (Float)(px2) ) - cx);
HXLINE( 619)					found2 = false;
HXLINE( 217)					{
HXLINE( 217)						int _g_min5 = yIter32->start;
HXDLIN( 217)						int _g_max5 = yIter32->max;
HXDLIN( 217)						while((_g_min5 < _g_max5)){
HXLINE( 217)							_g_min5 = (_g_min5 + 1);
HXDLIN( 217)							int py2 = (_g_min5 - 1);
HXDLIN( 217)							Float pcy1 = (( (Float)(py2) ) - cy);
HXDLIN( 217)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 217)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 217)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 217)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 217)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 217)							bool _hx_tmp32;
HXDLIN( 217)							bool _hx_tmp33;
HXDLIN( 217)							if ((ratioA1 >= 0)) {
HXLINE( 217)								_hx_tmp33 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp33 = false;
            							}
HXDLIN( 217)							if (_hx_tmp33) {
HXLINE( 217)								_hx_tmp32 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp32 = false;
            							}
HXDLIN( 217)							if (_hx_tmp32) {
HXLINE( 217)								int i30 = ::Std_obj::_hx_int((( (Float)(aA1) ) * (softC * ratioB1)));
HXDLIN( 217)								if ((i30 > 255)) {
HXLINE(  24)									i30 = 255;
            								}
HXLINE( 217)								if ((i30 < 0)) {
HXLINE(  25)									i30 = 0;
            								}
HXLINE( 217)								int a39 = i30;
HXDLIN( 217)								int i31 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 217)								if ((i31 > 255)) {
HXLINE(  24)									i31 = 255;
            								}
HXLINE( 217)								if ((i31 < 0)) {
HXLINE(  25)									i31 = 0;
            								}
HXLINE( 217)								int r20 = i31;
HXDLIN( 217)								int i32 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 217)								if ((i32 > 255)) {
HXLINE(  24)									i32 = 255;
            								}
HXLINE( 217)								if ((i32 < 0)) {
HXLINE(  25)									i32 = 0;
            								}
HXLINE( 217)								int g20 = i32;
HXDLIN( 217)								int i33 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 217)								if ((i33 > 255)) {
HXLINE(  24)									i33 = 255;
            								}
HXLINE( 217)								if ((i33 < 0)) {
HXLINE(  25)									i33 = 0;
            								}
HXLINE( 217)								int b33 = i33;
HXDLIN( 217)								{
HXLINE( 217)									int location9;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										location9 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										location9 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 217)									bool _hx_tmp34;
HXDLIN( 217)									if (pixelImage->transparent) {
HXLINE( 217)										_hx_tmp34 = (a39 < 254);
            									}
            									else {
HXLINE( 217)										_hx_tmp34 = false;
            									}
HXDLIN( 217)									if (_hx_tmp34) {
HXLINE( 217)										int this135 = ::iterMagic::Iimg_obj::get(pixelImage->image,location9);
HXDLIN( 217)										int old1;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											old1 = ((((((this135 >> 24) & 255) << 24) | ((this135 & 255) << 16)) | (((this135 >> 8) & 255) << 8)) | ((this135 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											old1 = this135;
            										}
HXDLIN( 217)										int rhs1 = ((((a39 << 24) | (r20 << 16)) | (g20 << 8)) | b33);
HXDLIN( 217)										Float a111;
HXDLIN( 217)										int this136 = ((old1 >> 24) & 255);
HXDLIN( 217)										if ((this136 == 0)) {
HXLINE( 217)											a111 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r110;
HXDLIN( 217)										int this137 = ((old1 >> 16) & 255);
HXDLIN( 217)										if ((this137 == 0)) {
HXLINE( 217)											r110 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r110 = (( (Float)(this137) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g110;
HXDLIN( 217)										int this138 = ((old1 >> 8) & 255);
HXDLIN( 217)										if ((this138 == 0)) {
HXLINE( 217)											g110 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g110 = (( (Float)(this138) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b113;
HXDLIN( 217)										int this139 = (old1 & 255);
HXDLIN( 217)										if ((this139 == 0)) {
HXLINE( 217)											b113 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b113 = (( (Float)(this139) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a210;
HXDLIN( 217)										int this140 = ((rhs1 >> 24) & 255);
HXDLIN( 217)										if ((this140 == 0)) {
HXLINE( 217)											a210 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r29;
HXDLIN( 217)										int this141 = ((rhs1 >> 16) & 255);
HXDLIN( 217)										if ((this141 == 0)) {
HXLINE( 217)											r29 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g29;
HXDLIN( 217)										int this142 = ((rhs1 >> 8) & 255);
HXDLIN( 217)										if ((this142 == 0)) {
HXLINE( 217)											g29 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b211;
HXDLIN( 217)										int this143 = (rhs1 & 255);
HXDLIN( 217)										if ((this143 == 0)) {
HXLINE( 217)											b211 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b211 = (( (Float)(this143) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a310 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 217)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r29 * a210))));
HXDLIN( 217)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g29 * a210))));
HXDLIN( 217)										int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a210))));
HXDLIN( 217)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a210)));
HXDLIN( 217)										int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b34);
HXDLIN( 217)										{
HXLINE( 217)											int _hx_tmp35;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp35 = blended9;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(pixelImage->image,location9,_hx_tmp35);
            										}
            									}
            									else {
HXLINE( 217)										int value1;
HXDLIN( 217)										if (pixelImage->isLittle) {
HXLINE( 217)											value1 = ((((a39 << 24) | (b33 << 16)) | (g20 << 8)) | r20);
            										}
            										else {
HXLINE( 217)											value1 = ((((a39 << 24) | (r20 << 16)) | (g20 << 8)) | b33);
            										}
HXDLIN( 217)										::iterMagic::Iimg_obj::set(pixelImage->image,location9,value1);
            									}
            								}
HXLINE( 633)								found2 = true;
            							}
            							else {
HXLINE( 217)								if (found2) {
HXLINE( 217)									goto _hx_goto_150;
            								}
            							}
            						}
            						_hx_goto_150:;
            					}
            				}
            			}
HXDLIN( 217)			{
HXLINE( 217)				 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,bx,by,cx,cy,true);
HXDLIN( 217)				if (hasUndo2) {
HXLINE( 217)					v7->undoImage = undoImage6;
HXDLIN( 217)					v7->undoX = xIter32->start;
HXDLIN( 217)					v7->undoY = yIter32->start;
            				}
            			}
            		}
            		else {
HXLINE( 217)			Float bx2 = bx;
HXDLIN( 217)			Float by2 = by;
HXDLIN( 217)			Float cx2 = cx;
HXDLIN( 217)			Float cy2 = cy;
HXDLIN( 217)			bool hasUndo3 = false;
HXDLIN( 217)			bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN( 217)			if (!(adjustWinding1)) {
HXLINE( 217)				Float bx_1 = bx2;
HXDLIN( 217)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE( 217)			{
HXLINE( 217)				Float s01 = ((ey * cx2) - (ex * cy2));
HXDLIN( 217)				Float sx1 = (cy2 - ey);
HXDLIN( 217)				Float sy1 = (ex - cx2);
HXDLIN( 217)				Float t01 = ((ex * by2) - (ey * bx2));
HXDLIN( 217)				Float tx1 = (ey - by2);
HXDLIN( 217)				Float ty1 = (bx2 - ex);
HXDLIN( 217)				Float A1 = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 217)				if ((ex > bx2)) {
HXLINE( 217)					if ((ex > cx2)) {
HXLINE( 217)						int min12;
HXDLIN( 217)						if ((bx2 > cx2)) {
HXLINE( 217)							min12 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 217)							min12 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 217)						int ii_min32 = min12;
HXDLIN( 217)						int ii_max32 = ::Math_obj::ceil(ex);
HXDLIN( 217)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXLINE( 217)						int ii_min33 = ::Math_obj::floor(bx2);
HXDLIN( 217)						int ii_max33 = ::Math_obj::ceil(cx2);
HXDLIN( 217)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXLINE( 217)					if ((bx2 > cx2)) {
HXLINE( 217)						int min13;
HXDLIN( 217)						if ((ex > cx2)) {
HXLINE( 217)							min13 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 217)							min13 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 217)						int ii_min34 = min13;
HXDLIN( 217)						int ii_max34 = ::Math_obj::ceil(bx2);
HXDLIN( 217)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXLINE( 217)						int ii_min35 = ::Math_obj::floor(ex);
HXDLIN( 217)						int ii_max35 = ::Math_obj::ceil(cx2);
HXDLIN( 217)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 217)				if ((ey > by2)) {
HXLINE( 217)					if ((ey > cy2)) {
HXLINE( 217)						int min14;
HXDLIN( 217)						if ((by2 > cy2)) {
HXLINE( 217)							min14 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 217)							min14 = ::Math_obj::floor(by2);
            						}
HXDLIN( 217)						int ii_min36 = min14;
HXDLIN( 217)						int ii_max36 = ::Math_obj::ceil(ey);
HXDLIN( 217)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXLINE( 217)						int ii_min37 = ::Math_obj::floor(by2);
HXDLIN( 217)						int ii_max37 = ::Math_obj::ceil(cy2);
HXDLIN( 217)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXLINE( 217)					if ((by2 > cy2)) {
HXLINE( 217)						int min15;
HXDLIN( 217)						if ((ey > cy2)) {
HXLINE( 217)							min15 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 217)							min15 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 217)						int ii_min38 = min15;
HXDLIN( 217)						int ii_max38 = ::Math_obj::ceil(by2);
HXDLIN( 217)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXLINE( 217)						int ii_min39 = ::Math_obj::floor(ey);
HXDLIN( 217)						int ii_max39 = ::Math_obj::ceil(cy2);
HXDLIN( 217)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 217)				if (hasUndo3) {
HXLINE( 217)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 217)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 217)					 ::Dynamic imageType3 = null();
HXDLIN( 217)					 ::pi_xy::ImageStruct this144 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 217)					::Dynamic undoImage10;
HXDLIN( 217)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 217)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::BytesImg b35 = byt3;
HXDLIN( 217)							{
HXLINE( 217)								b35->width = width3;
HXDLIN( 217)								b35->height = height3;
HXDLIN( 217)								b35->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 217)								b35->data = ::haxe::io::Bytes_obj::alloc((b35->length * 4));
HXDLIN( 217)								{
HXLINE( 217)									int len6 = b35->length;
HXDLIN( 217)									int w3 = 0;
HXDLIN( 217)									{
HXLINE( 217)										int _g60 = 0;
HXDLIN( 217)										int _g61 = b35->height;
HXDLIN( 217)										while((_g60 < _g61)){
HXLINE( 217)											_g60 = (_g60 + 1);
HXDLIN( 217)											int y14 = (_g60 - 1);
HXDLIN( 217)											{
HXLINE( 217)												int _g62 = 0;
HXDLIN( 217)												int _g63 = b35->width;
HXDLIN( 217)												while((_g62 < _g63)){
HXLINE( 217)													_g62 = (_g62 + 1);
HXDLIN( 217)													int x14 = (_g62 - 1);
HXDLIN( 217)													{
HXLINE( 217)														w3 = (w3 + 1);
HXDLIN( 217)														b35->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w3 = (w3 + 1);
HXDLIN( 217)														b35->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w3 = (w3 + 1);
HXDLIN( 217)														b35->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w3 = (w3 + 1);
HXDLIN( 217)														b35->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage10 = b35;
            						}
            						break;
            						case (int)1: {
HXLINE( 217)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::ArrIntImg a41 = arrI3;
HXDLIN( 217)							{
HXLINE( 217)								a41->width = width3;
HXDLIN( 217)								a41->height = height3;
HXDLIN( 217)								a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)								a41->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 217)								{
HXLINE( 217)									int _g64 = 0;
HXDLIN( 217)									int _g65 = a41->length;
HXDLIN( 217)									while((_g64 < _g65)){
HXLINE( 217)										_g64 = (_g64 + 1);
HXDLIN( 217)										int i34 = (_g64 - 1);
HXDLIN( 217)										a41->data[i34] = 0;
            									}
            								}
            							}
HXDLIN( 217)							undoImage10 = a41;
            						}
            						break;
            						case (int)2: {
HXLINE( 217)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::U32ArrImg b36 = u32a3;
HXDLIN( 217)							{
HXLINE( 217)								b36->width = width3;
HXDLIN( 217)								b36->height = height3;
HXDLIN( 217)								b36->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 217)								int size3 = (b36->length * 4);
HXDLIN( 217)								b36->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 217)								{
HXLINE( 217)									int _g66 = 0;
HXDLIN( 217)									int _g67 = b36->length;
HXDLIN( 217)									while((_g66 < _g67)){
HXLINE( 217)										_g66 = (_g66 + 1);
HXDLIN( 217)										int i35 = (_g66 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::io::ArrayBufferViewImpl this145 = b36->data;
HXDLIN( 217)											bool undoImage11;
HXDLIN( 217)											if ((i35 >= 0)) {
HXLINE( 217)												undoImage11 = (i35 < (this145->byteLength >> 2));
            											}
            											else {
HXLINE( 217)												undoImage11 = false;
            											}
HXDLIN( 217)											if (undoImage11) {
HXLINE( 217)												 ::haxe::io::Bytes _this3 = this145->bytes;
HXDLIN( 217)												int pos3 = ((i35 << 2) + this145->byteOffset);
HXDLIN( 217)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 217)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage10 = b36;
            						}
            						break;
            						case (int)3: {
HXLINE( 217)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 217)							{
HXLINE( 217)								v8->width = width3;
HXDLIN( 217)								v8->height = height3;
HXDLIN( 217)								v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 217)								v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 217)								{
HXLINE( 217)									int _g68 = 0;
HXDLIN( 217)									int _g69 = v8->length;
HXDLIN( 217)									while((_g68 < _g69)){
HXLINE( 217)										_g68 = (_g68 + 1);
HXDLIN( 217)										int i36 = (_g68 - 1);
HXDLIN( 217)										v8->data->__unsafe_set(i36,0);
            									}
            								}
            							}
HXDLIN( 217)							undoImage10 = v8;
            						}
            						break;
            						case (int)4: {
HXLINE( 217)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::StackIntImg b37 = sInt3;
HXDLIN( 217)							{
HXLINE( 217)								b37->width = width3;
HXDLIN( 217)								b37->height = height3;
HXDLIN( 217)								b37->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 217)								b37->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)								{
HXLINE( 217)									int len7 = b37->length;
HXDLIN( 217)									 ::haxe::ds::GenericStack_Int d3 = b37->data;
HXDLIN( 217)									if (::hx::IsNull( d3->head )) {
HXLINE( 217)										int _g70 = 0;
HXDLIN( 217)										int _g71 = len7;
HXDLIN( 217)										while((_g70 < _g71)){
HXLINE( 217)											_g70 = (_g70 + 1);
HXDLIN( 217)											int i37 = (_g70 - 1);
HXDLIN( 217)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 217)										int _g72 = 0;
HXDLIN( 217)										int _g73 = len7;
HXDLIN( 217)										while((_g72 < _g73)){
HXLINE( 217)											_g72 = (_g72 + 1);
HXDLIN( 217)											int i38 = (_g72 - 1);
HXDLIN( 217)											{
HXLINE( 217)												 ::haxe::ds::GenericCell_Int l3 = b37->data->head;
HXDLIN( 217)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 217)												{
HXLINE( 217)													int _g74 = 0;
HXDLIN( 217)													int _g75 = i38;
HXDLIN( 217)													while((_g74 < _g75)){
HXLINE( 217)														_g74 = (_g74 + 1);
HXDLIN( 217)														int i39 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 217)												if (::hx::IsNull( prev3 )) {
HXLINE( 217)													b37->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 217)													l3 = null();
            												}
            												else {
HXLINE( 217)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 217)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage10 = b37;
            						}
            						break;
            					}
HXDLIN( 217)					this144->image = undoImage10;
HXDLIN( 217)					this144->width = width3;
HXDLIN( 217)					this144->height = height3;
HXDLIN( 217)					this144->imageType = ( (int)(imageType3) );
HXDLIN( 217)					undoImage9 = this144;
HXDLIN( 217)					{
HXLINE( 217)						int rectLeft3 = xIter33->start;
HXDLIN( 217)						int rectTop3 = yIter33->start;
HXDLIN( 217)						int rectRight3 = xIter33->max;
HXDLIN( 217)						bool forceClear3 = false;
HXDLIN( 217)						{
HXLINE( 217)							int _g76 = rectTop3;
HXDLIN( 217)							int _g77 = yIter33->max;
HXDLIN( 217)							while((_g76 < _g77)){
HXLINE( 217)								_g76 = (_g76 + 1);
HXDLIN( 217)								int dy4 = (_g76 - 1);
HXDLIN( 217)								{
HXLINE( 217)									int _g78 = rectLeft3;
HXDLIN( 217)									int _g79 = rectRight3;
HXDLIN( 217)									while((_g78 < _g79)){
HXLINE( 217)										_g78 = (_g78 + 1);
HXDLIN( 217)										int dx4 = (_g78 - 1);
HXDLIN( 217)										::Dynamic this146 = pixelImage->image;
HXDLIN( 217)										int index17;
HXDLIN( 217)										if (pixelImage->useVirtualPos) {
HXLINE( 217)											index17 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 217)											index17 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            										}
HXDLIN( 217)										int c14 = ::iterMagic::Iimg_obj::get(this146,index17);
HXDLIN( 217)										int col3;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											col3 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											col3 = c14;
            										}
HXDLIN( 217)										bool _hx_tmp36;
HXDLIN( 217)										if (pixelImage->useMask) {
HXLINE( 217)											_hx_tmp36 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 217)											_hx_tmp36 = false;
            										}
HXDLIN( 217)										if (_hx_tmp36) {
HXLINE( 217)											 ::pi_xy::ImageStruct this147 = pixelImage->mask;
HXDLIN( 217)											::Dynamic this148 = this147->image;
HXDLIN( 217)											int index18;
HXDLIN( 217)											if (this147->useVirtualPos) {
HXLINE( 217)												index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this147->virtualY) * ( (Float)(this147->width) )) + dx4) - this147->virtualX));
            											}
            											else {
HXLINE( 217)												index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this147->width) + dx4)) ));
            											}
HXDLIN( 217)											int c15 = ::iterMagic::Iimg_obj::get(this148,index18);
HXDLIN( 217)											int v9;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												v9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												v9 = c15;
            											}
HXDLIN( 217)											int maskPixel3 = v9;
HXDLIN( 217)											int this149 = col3;
HXDLIN( 217)											if ((maskPixel3 == 0)) {
HXLINE( 217)												col3 = this149;
            											}
            											else {
HXLINE( 217)												Float m03;
HXDLIN( 217)												int this150 = ((maskPixel3 >> 24) & 255);
HXDLIN( 217)												if ((this150 == 0)) {
HXLINE( 217)													m03 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m03 = (( (Float)(this150) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m13;
HXDLIN( 217)												int this151 = ((maskPixel3 >> 16) & 255);
HXDLIN( 217)												if ((this151 == 0)) {
HXLINE( 217)													m13 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m13 = (( (Float)(this151) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m23;
HXDLIN( 217)												int this152 = ((maskPixel3 >> 8) & 255);
HXDLIN( 217)												if ((this152 == 0)) {
HXLINE( 217)													m23 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m23 = (( (Float)(this152) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m33;
HXDLIN( 217)												int this153 = (maskPixel3 & 255);
HXDLIN( 217)												if ((this153 == 0)) {
HXLINE( 217)													m33 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m33 = (( (Float)(this153) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this149 >> 24) & 255)) )));
HXDLIN( 217)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this149 >> 16) & 255)) )));
HXDLIN( 217)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this149 >> 8) & 255)) )));
HXDLIN( 217)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this149 & 255)) )));
HXDLIN( 217)												col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 217)										if ((col3 != 0)) {
HXLINE( 217)											int x15 = (dx4 - rectLeft3);
HXDLIN( 217)											int y15 = (dy4 - rectTop3);
HXDLIN( 217)											int c16 = col3;
HXDLIN( 217)											bool _hx_tmp37;
HXDLIN( 217)											if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp37 = undoImage9->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp37 = false;
            											}
HXDLIN( 217)											if (_hx_tmp37) {
HXLINE( 217)												int location10;
HXDLIN( 217)												if (undoImage9->useVirtualPos) {
HXLINE( 217)													location10 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 217)													location10 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            												}
HXDLIN( 217)												int this154 = ::iterMagic::Iimg_obj::get(undoImage9->image,location10);
HXDLIN( 217)												int this155;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this155 = ((((((this154 >> 24) & 255) << 24) | ((this154 & 255) << 16)) | (((this154 >> 8) & 255) << 8)) | ((this154 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this155 = this154;
            												}
HXDLIN( 217)												Float a112;
HXDLIN( 217)												int this156 = ((this155 >> 24) & 255);
HXDLIN( 217)												if ((this156 == 0)) {
HXLINE( 217)													a112 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a112 = (( (Float)(this156) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r111;
HXDLIN( 217)												int this157 = ((this155 >> 16) & 255);
HXDLIN( 217)												if ((this157 == 0)) {
HXLINE( 217)													r111 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r111 = (( (Float)(this157) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g111;
HXDLIN( 217)												int this158 = ((this155 >> 8) & 255);
HXDLIN( 217)												if ((this158 == 0)) {
HXLINE( 217)													g111 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g111 = (( (Float)(this158) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b114;
HXDLIN( 217)												int this159 = (this155 & 255);
HXDLIN( 217)												if ((this159 == 0)) {
HXLINE( 217)													b114 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b114 = (( (Float)(this159) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a211;
HXDLIN( 217)												int this160 = ((col3 >> 24) & 255);
HXDLIN( 217)												if ((this160 == 0)) {
HXLINE( 217)													a211 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a211 = (( (Float)(this160) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r210;
HXDLIN( 217)												int this161 = ((col3 >> 16) & 255);
HXDLIN( 217)												if ((this161 == 0)) {
HXLINE( 217)													r210 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r210 = (( (Float)(this161) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g210;
HXDLIN( 217)												int this162 = ((col3 >> 8) & 255);
HXDLIN( 217)												if ((this162 == 0)) {
HXLINE( 217)													g210 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g210 = (( (Float)(this162) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b212;
HXDLIN( 217)												int this163 = (col3 & 255);
HXDLIN( 217)												if ((this163 == 0)) {
HXLINE( 217)													b212 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b212 = (( (Float)(this163) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a311 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 217)												int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r210 * a211))));
HXDLIN( 217)												int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g210 * a211))));
HXDLIN( 217)												int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a211))));
HXDLIN( 217)												int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a211)));
HXDLIN( 217)												int blended10 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b38);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp38;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp38 = blended10;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(undoImage9->image,location10,_hx_tmp38);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this164 = undoImage9->image;
HXDLIN( 217)												int index19;
HXDLIN( 217)												if (undoImage9->useVirtualPos) {
HXLINE( 217)													index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 217)													index19 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            												}
HXDLIN( 217)												int _hx_tmp39;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp39 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp39 = c16;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this164,index19,_hx_tmp39);
            											}
            										}
            										else {
HXLINE( 217)											if (forceClear3) {
HXLINE( 217)												::Dynamic this165 = undoImage9->image;
HXDLIN( 217)												int x16 = (dx4 - rectLeft3);
HXDLIN( 217)												int y16 = (dy4 - rectTop3);
HXDLIN( 217)												int index20;
HXDLIN( 217)												if (undoImage9->useVirtualPos) {
HXLINE( 217)													index20 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x16) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 217)													index20 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage9->width) + x16)) ));
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this165,index20,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 217)				bool found3 = false;
HXDLIN( 217)				Float s1 = ((Float)0.);
HXDLIN( 217)				Float t1 = ((Float)0.);
HXDLIN( 217)				Float sxx1 = ((Float)0.);
HXDLIN( 217)				Float txx1 = ((Float)0.);
HXDLIN( 217)				{
HXLINE( 217)					int _g_min6 = xIter33->start;
HXDLIN( 217)					int _g_max6 = xIter33->max;
HXDLIN( 217)					while((_g_min6 < _g_max6)){
HXLINE( 217)						_g_min6 = (_g_min6 + 1);
HXDLIN( 217)						int x17 = (_g_min6 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x17) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x17) ));
HXLINE(  62)						found3 = false;
HXLINE( 217)						{
HXLINE( 217)							int _g_min7 = yIter33->start;
HXDLIN( 217)							int _g_max7 = yIter33->max;
HXDLIN( 217)							while((_g_min7 < _g_max7)){
HXLINE( 217)								_g_min7 = (_g_min7 + 1);
HXDLIN( 217)								int y17 = (_g_min7 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y17) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y17) )));
HXLINE( 217)								bool _hx_tmp40;
HXDLIN( 217)								if (!((s1 <= 0))) {
HXLINE( 217)									_hx_tmp40 = (t1 <= 0);
            								}
            								else {
HXLINE( 217)									_hx_tmp40 = true;
            								}
HXDLIN( 217)								if (_hx_tmp40) {
HXLINE( 217)									if (found3) {
HXLINE( 217)										goto _hx_goto_162;
            									}
            								}
            								else {
HXLINE( 217)									if (((s1 + t1) < A1)) {
HXLINE( 217)										{
HXLINE( 217)											int c17 = color;
HXDLIN( 217)											bool _hx_tmp41;
HXDLIN( 217)											if ((((c17 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp41 = pixelImage->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp41 = false;
            											}
HXDLIN( 217)											if (_hx_tmp41) {
HXLINE( 217)												int location11;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													location11 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x17) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													location11 = ::Std_obj::_hx_int(( (Float)(((y17 * pixelImage->width) + x17)) ));
            												}
HXDLIN( 217)												int this166 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 217)												int this167;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this167 = ((((((this166 >> 24) & 255) << 24) | ((this166 & 255) << 16)) | (((this166 >> 8) & 255) << 8)) | ((this166 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this167 = this166;
            												}
HXDLIN( 217)												Float a113;
HXDLIN( 217)												int this168 = ((this167 >> 24) & 255);
HXDLIN( 217)												if ((this168 == 0)) {
HXLINE( 217)													a113 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a113 = (( (Float)(this168) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r112;
HXDLIN( 217)												int this169 = ((this167 >> 16) & 255);
HXDLIN( 217)												if ((this169 == 0)) {
HXLINE( 217)													r112 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r112 = (( (Float)(this169) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g112;
HXDLIN( 217)												int this170 = ((this167 >> 8) & 255);
HXDLIN( 217)												if ((this170 == 0)) {
HXLINE( 217)													g112 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g112 = (( (Float)(this170) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b115;
HXDLIN( 217)												int this171 = (this167 & 255);
HXDLIN( 217)												if ((this171 == 0)) {
HXLINE( 217)													b115 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b115 = (( (Float)(this171) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a212;
HXDLIN( 217)												int this172 = ((color >> 24) & 255);
HXDLIN( 217)												if ((this172 == 0)) {
HXLINE( 217)													a212 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a212 = (( (Float)(this172) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r211;
HXDLIN( 217)												int this173 = ((color >> 16) & 255);
HXDLIN( 217)												if ((this173 == 0)) {
HXLINE( 217)													r211 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r211 = (( (Float)(this173) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g211;
HXDLIN( 217)												int this174 = ((color >> 8) & 255);
HXDLIN( 217)												if ((this174 == 0)) {
HXLINE( 217)													g211 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g211 = (( (Float)(this174) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b213;
HXDLIN( 217)												int this175 = (color & 255);
HXDLIN( 217)												if ((this175 == 0)) {
HXLINE( 217)													b213 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b213 = (( (Float)(this175) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a312 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 217)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r211 * a212))));
HXDLIN( 217)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g211 * a212))));
HXDLIN( 217)												int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a212))));
HXDLIN( 217)												int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a212)));
HXDLIN( 217)												int blended11 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b39);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp42;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp42 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp42 = blended11;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp42);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this176 = pixelImage->image;
HXDLIN( 217)												int index21;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													index21 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x17) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													index21 = ::Std_obj::_hx_int(( (Float)(((y17 * pixelImage->width) + x17)) ));
            												}
HXDLIN( 217)												int _hx_tmp43;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp43 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp43 = c17;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this176,index21,_hx_tmp43);
            											}
            										}
HXLINE(  73)										found3 = true;
            									}
            									else {
HXLINE( 217)										if (found3) {
HXLINE( 217)											goto _hx_goto_162;
            										}
            									}
            								}
            							}
            							_hx_goto_162:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 217)		if (softBottom) {
HXLINE( 217)			bool hasUndo4 = false;
HXDLIN( 217)			int aA2 = ((color >> 24) & 255);
HXDLIN( 217)			int rA2 = ((color >> 16) & 255);
HXDLIN( 217)			int gA2 = ((color >> 8) & 255);
HXDLIN( 217)			int bA2 = (color & 255);
HXDLIN( 217)			Float bcx2 = (cx - dx);
HXDLIN( 217)			Float bcy2 = (cy - dy);
HXDLIN( 217)			Float acx2 = (ex - dx);
HXDLIN( 217)			Float acy2 = (ey - dy);
HXDLIN( 217)			Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 217)			Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 217)			Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 217)			Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 217)			if ((ex > cx)) {
HXLINE( 217)				if ((ex > dx)) {
HXLINE( 217)					int min16;
HXDLIN( 217)					if ((cx > dx)) {
HXLINE( 217)						min16 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 217)						min16 = ::Math_obj::floor(cx);
            					}
HXDLIN( 217)					int ii_min40 = min16;
HXDLIN( 217)					int ii_max40 = ::Math_obj::ceil(ex);
HXDLIN( 217)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            				}
            				else {
HXLINE( 217)					int ii_min41 = ::Math_obj::floor(cx);
HXDLIN( 217)					int ii_max41 = ::Math_obj::ceil(dx);
HXDLIN( 217)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            				}
            			}
            			else {
HXLINE( 217)				if ((cx > dx)) {
HXLINE( 217)					int min17;
HXDLIN( 217)					if ((ex > dx)) {
HXLINE( 217)						min17 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 217)						min17 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 217)					int ii_min42 = min17;
HXDLIN( 217)					int ii_max42 = ::Math_obj::ceil(cx);
HXDLIN( 217)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            				}
            				else {
HXLINE( 217)					int ii_min43 = ::Math_obj::floor(ex);
HXDLIN( 217)					int ii_max43 = ::Math_obj::ceil(dx);
HXDLIN( 217)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 217)			if ((ey > cy)) {
HXLINE( 217)				if ((ey > dy)) {
HXLINE( 217)					int min18;
HXDLIN( 217)					if ((cy > dy)) {
HXLINE( 217)						min18 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 217)						min18 = ::Math_obj::floor(cy);
            					}
HXDLIN( 217)					int ii_min44 = min18;
HXDLIN( 217)					int ii_max44 = ::Math_obj::ceil(ey);
HXDLIN( 217)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            				}
            				else {
HXLINE( 217)					int ii_min45 = ::Math_obj::floor(cy);
HXDLIN( 217)					int ii_max45 = ::Math_obj::ceil(dy);
HXDLIN( 217)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            				}
            			}
            			else {
HXLINE( 217)				if ((cy > dy)) {
HXLINE( 217)					int min19;
HXDLIN( 217)					if ((ey > dy)) {
HXLINE( 217)						min19 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 217)						min19 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 217)					int ii_min46 = min19;
HXDLIN( 217)					int ii_max46 = ::Math_obj::ceil(cy);
HXDLIN( 217)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            				}
            				else {
HXLINE( 217)					int ii_min47 = ::Math_obj::floor(ey);
HXDLIN( 217)					int ii_max47 = ::Math_obj::ceil(dy);
HXDLIN( 217)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 217)			if (hasUndo4) {
HXLINE( 217)				int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 217)				int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 217)				 ::Dynamic imageType4 = null();
HXDLIN( 217)				 ::pi_xy::ImageStruct this177 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)				if (::hx::IsNull( imageType4 )) {
HXLINE(  54)					imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 217)				::Dynamic undoImage13;
HXDLIN( 217)				switch((int)(( (int)(imageType4) ))){
            					case (int)0: {
HXLINE( 217)						 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::BytesImg b40 = byt4;
HXDLIN( 217)						{
HXLINE( 217)							b40->width = width4;
HXDLIN( 217)							b40->height = height4;
HXDLIN( 217)							b40->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 217)							b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN( 217)							{
HXLINE( 217)								int len8 = b40->length;
HXDLIN( 217)								int w4 = 0;
HXDLIN( 217)								{
HXLINE( 217)									int _g80 = 0;
HXDLIN( 217)									int _g81 = b40->height;
HXDLIN( 217)									while((_g80 < _g81)){
HXLINE( 217)										_g80 = (_g80 + 1);
HXDLIN( 217)										int y18 = (_g80 - 1);
HXDLIN( 217)										{
HXLINE( 217)											int _g82 = 0;
HXDLIN( 217)											int _g83 = b40->width;
HXDLIN( 217)											while((_g82 < _g83)){
HXLINE( 217)												_g82 = (_g82 + 1);
HXDLIN( 217)												int x18 = (_g82 - 1);
HXDLIN( 217)												{
HXLINE( 217)													w4 = (w4 + 1);
HXDLIN( 217)													b40->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w4 = (w4 + 1);
HXDLIN( 217)													b40->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w4 = (w4 + 1);
HXDLIN( 217)													b40->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w4 = (w4 + 1);
HXDLIN( 217)													b40->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage13 = b40;
            					}
            					break;
            					case (int)1: {
HXLINE( 217)						 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::ArrIntImg a44 = arrI4;
HXDLIN( 217)						{
HXLINE( 217)							a44->width = width4;
HXDLIN( 217)							a44->height = height4;
HXDLIN( 217)							a44->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)							a44->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 217)							{
HXLINE( 217)								int _g84 = 0;
HXDLIN( 217)								int _g85 = a44->length;
HXDLIN( 217)								while((_g84 < _g85)){
HXLINE( 217)									_g84 = (_g84 + 1);
HXDLIN( 217)									int i40 = (_g84 - 1);
HXDLIN( 217)									a44->data[i40] = 0;
            								}
            							}
            						}
HXDLIN( 217)						undoImage13 = a44;
            					}
            					break;
            					case (int)2: {
HXLINE( 217)						 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::U32ArrImg b41 = u32a4;
HXDLIN( 217)						{
HXLINE( 217)							b41->width = width4;
HXDLIN( 217)							b41->height = height4;
HXDLIN( 217)							b41->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 217)							int size4 = (b41->length * 4);
HXDLIN( 217)							b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 217)							{
HXLINE( 217)								int _g86 = 0;
HXDLIN( 217)								int _g87 = b41->length;
HXDLIN( 217)								while((_g86 < _g87)){
HXLINE( 217)									_g86 = (_g86 + 1);
HXDLIN( 217)									int i41 = (_g86 - 1);
HXDLIN( 217)									{
HXLINE( 217)										 ::haxe::io::ArrayBufferViewImpl this178 = b41->data;
HXDLIN( 217)										bool undoImage14;
HXDLIN( 217)										if ((i41 >= 0)) {
HXLINE( 217)											undoImage14 = (i41 < (this178->byteLength >> 2));
            										}
            										else {
HXLINE( 217)											undoImage14 = false;
            										}
HXDLIN( 217)										if (undoImage14) {
HXLINE( 217)											 ::haxe::io::Bytes _this4 = this178->bytes;
HXDLIN( 217)											int pos4 = ((i41 << 2) + this178->byteOffset);
HXDLIN( 217)											_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 217)											_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage13 = b41;
            					}
            					break;
            					case (int)3: {
HXLINE( 217)						 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::VecIntImg v10 = vec4;
HXDLIN( 217)						{
HXLINE( 217)							v10->width = width4;
HXDLIN( 217)							v10->height = height4;
HXDLIN( 217)							v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 217)							v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 217)							{
HXLINE( 217)								int _g88 = 0;
HXDLIN( 217)								int _g89 = v10->length;
HXDLIN( 217)								while((_g88 < _g89)){
HXLINE( 217)									_g88 = (_g88 + 1);
HXDLIN( 217)									int i42 = (_g88 - 1);
HXDLIN( 217)									v10->data->__unsafe_set(i42,0);
            								}
            							}
            						}
HXDLIN( 217)						undoImage13 = v10;
            					}
            					break;
            					case (int)4: {
HXLINE( 217)						 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::StackIntImg b42 = sInt4;
HXDLIN( 217)						{
HXLINE( 217)							b42->width = width4;
HXDLIN( 217)							b42->height = height4;
HXDLIN( 217)							b42->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 217)							b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)							{
HXLINE( 217)								int len9 = b42->length;
HXDLIN( 217)								 ::haxe::ds::GenericStack_Int d4 = b42->data;
HXDLIN( 217)								if (::hx::IsNull( d4->head )) {
HXLINE( 217)									int _g90 = 0;
HXDLIN( 217)									int _g91 = len9;
HXDLIN( 217)									while((_g90 < _g91)){
HXLINE( 217)										_g90 = (_g90 + 1);
HXDLIN( 217)										int i43 = (_g90 - 1);
HXDLIN( 217)										d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            									}
            								}
            								else {
HXLINE( 217)									int _g92 = 0;
HXDLIN( 217)									int _g93 = len9;
HXDLIN( 217)									while((_g92 < _g93)){
HXLINE( 217)										_g92 = (_g92 + 1);
HXDLIN( 217)										int i44 = (_g92 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::ds::GenericCell_Int l4 = b42->data->head;
HXDLIN( 217)											 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 217)											{
HXLINE( 217)												int _g94 = 0;
HXDLIN( 217)												int _g95 = i44;
HXDLIN( 217)												while((_g94 < _g95)){
HXLINE( 217)													_g94 = (_g94 + 1);
HXDLIN( 217)													int i45 = (_g94 - 1);
HXLINE( 345)													prev4 = l4;
HXLINE( 346)													l4 = l4->next;
            												}
            											}
HXLINE( 217)											if (::hx::IsNull( prev4 )) {
HXLINE( 217)												b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 217)												l4 = null();
            											}
            											else {
HXLINE( 217)												prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 217)												l4 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage13 = b42;
            					}
            					break;
            				}
HXDLIN( 217)				this177->image = undoImage13;
HXDLIN( 217)				this177->width = width4;
HXDLIN( 217)				this177->height = height4;
HXDLIN( 217)				this177->imageType = ( (int)(imageType4) );
HXDLIN( 217)				undoImage12 = this177;
HXDLIN( 217)				{
HXLINE( 217)					int rectLeft4 = xIter34->start;
HXDLIN( 217)					int rectTop4 = yIter34->start;
HXDLIN( 217)					int rectRight4 = xIter34->max;
HXDLIN( 217)					bool forceClear4 = false;
HXDLIN( 217)					{
HXLINE( 217)						int _g96 = rectTop4;
HXDLIN( 217)						int _g97 = yIter34->max;
HXDLIN( 217)						while((_g96 < _g97)){
HXLINE( 217)							_g96 = (_g96 + 1);
HXDLIN( 217)							int dy5 = (_g96 - 1);
HXDLIN( 217)							{
HXLINE( 217)								int _g98 = rectLeft4;
HXDLIN( 217)								int _g99 = rectRight4;
HXDLIN( 217)								while((_g98 < _g99)){
HXLINE( 217)									_g98 = (_g98 + 1);
HXDLIN( 217)									int dx5 = (_g98 - 1);
HXDLIN( 217)									::Dynamic this179 = pixelImage->image;
HXDLIN( 217)									int index22;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										index22 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx5) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										index22 = ::Std_obj::_hx_int(( (Float)(((dy5 * pixelImage->width) + dx5)) ));
            									}
HXDLIN( 217)									int c18 = ::iterMagic::Iimg_obj::get(this179,index22);
HXDLIN( 217)									int col4;
HXDLIN( 217)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)										col4 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXLINE( 217)										col4 = c18;
            									}
HXDLIN( 217)									bool _hx_tmp44;
HXDLIN( 217)									if (pixelImage->useMask) {
HXLINE( 217)										_hx_tmp44 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 217)										_hx_tmp44 = false;
            									}
HXDLIN( 217)									if (_hx_tmp44) {
HXLINE( 217)										 ::pi_xy::ImageStruct this180 = pixelImage->mask;
HXDLIN( 217)										::Dynamic this181 = this180->image;
HXDLIN( 217)										int index23;
HXDLIN( 217)										if (this180->useVirtualPos) {
HXLINE( 217)											index23 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this180->virtualY) * ( (Float)(this180->width) )) + dx5) - this180->virtualX));
            										}
            										else {
HXLINE( 217)											index23 = ::Std_obj::_hx_int(( (Float)(((dy5 * this180->width) + dx5)) ));
            										}
HXDLIN( 217)										int c19 = ::iterMagic::Iimg_obj::get(this181,index23);
HXDLIN( 217)										int v11;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											v11 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											v11 = c19;
            										}
HXDLIN( 217)										int maskPixel4 = v11;
HXDLIN( 217)										int this182 = col4;
HXDLIN( 217)										if ((maskPixel4 == 0)) {
HXLINE( 217)											col4 = this182;
            										}
            										else {
HXLINE( 217)											Float m04;
HXDLIN( 217)											int this183 = ((maskPixel4 >> 24) & 255);
HXDLIN( 217)											if ((this183 == 0)) {
HXLINE( 217)												m04 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m04 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m14;
HXDLIN( 217)											int this184 = ((maskPixel4 >> 16) & 255);
HXDLIN( 217)											if ((this184 == 0)) {
HXLINE( 217)												m14 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m14 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m24;
HXDLIN( 217)											int this185 = ((maskPixel4 >> 8) & 255);
HXDLIN( 217)											if ((this185 == 0)) {
HXLINE( 217)												m24 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m24 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m34;
HXDLIN( 217)											int this186 = (maskPixel4 & 255);
HXDLIN( 217)											if ((this186 == 0)) {
HXLINE( 217)												m34 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m34 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this182 >> 24) & 255)) )));
HXDLIN( 217)											int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this182 >> 16) & 255)) )));
HXDLIN( 217)											int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this182 >> 8) & 255)) )));
HXDLIN( 217)											int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this182 & 255)) )));
HXDLIN( 217)											col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 217)									if ((col4 != 0)) {
HXLINE( 217)										int x19 = (dx5 - rectLeft4);
HXDLIN( 217)										int y19 = (dy5 - rectTop4);
HXDLIN( 217)										int c20 = col4;
HXDLIN( 217)										bool _hx_tmp45;
HXDLIN( 217)										if ((((c20 >> 24) & 255) < 254)) {
HXLINE( 217)											_hx_tmp45 = undoImage12->transparent;
            										}
            										else {
HXLINE( 217)											_hx_tmp45 = false;
            										}
HXDLIN( 217)										if (_hx_tmp45) {
HXLINE( 217)											int location12;
HXDLIN( 217)											if (undoImage12->useVirtualPos) {
HXLINE( 217)												location12 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 217)												location12 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            											}
HXDLIN( 217)											int this187 = ::iterMagic::Iimg_obj::get(undoImage12->image,location12);
HXDLIN( 217)											int this188;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												this188 = ((((((this187 >> 24) & 255) << 24) | ((this187 & 255) << 16)) | (((this187 >> 8) & 255) << 8)) | ((this187 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												this188 = this187;
            											}
HXDLIN( 217)											Float a114;
HXDLIN( 217)											int this189 = ((this188 >> 24) & 255);
HXDLIN( 217)											if ((this189 == 0)) {
HXLINE( 217)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a114 = (( (Float)(this189) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r113;
HXDLIN( 217)											int this190 = ((this188 >> 16) & 255);
HXDLIN( 217)											if ((this190 == 0)) {
HXLINE( 217)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r113 = (( (Float)(this190) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g113;
HXDLIN( 217)											int this191 = ((this188 >> 8) & 255);
HXDLIN( 217)											if ((this191 == 0)) {
HXLINE( 217)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g113 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b116;
HXDLIN( 217)											int this192 = (this188 & 255);
HXDLIN( 217)											if ((this192 == 0)) {
HXLINE( 217)												b116 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b116 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a213;
HXDLIN( 217)											int this193 = ((col4 >> 24) & 255);
HXDLIN( 217)											if ((this193 == 0)) {
HXLINE( 217)												a213 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a213 = (( (Float)(this193) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r212;
HXDLIN( 217)											int this194 = ((col4 >> 16) & 255);
HXDLIN( 217)											if ((this194 == 0)) {
HXLINE( 217)												r212 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r212 = (( (Float)(this194) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g212;
HXDLIN( 217)											int this195 = ((col4 >> 8) & 255);
HXDLIN( 217)											if ((this195 == 0)) {
HXLINE( 217)												g212 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g212 = (( (Float)(this195) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b214;
HXDLIN( 217)											int this196 = (col4 & 255);
HXDLIN( 217)											if ((this196 == 0)) {
HXLINE( 217)												b214 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b214 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a313 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 217)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r212 * a213))));
HXDLIN( 217)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g212 * a213))));
HXDLIN( 217)											int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a213))));
HXDLIN( 217)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a213)));
HXDLIN( 217)											int blended12 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b43);
HXDLIN( 217)											{
HXLINE( 217)												int _hx_tmp46;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp46 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp46 = blended12;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(undoImage12->image,location12,_hx_tmp46);
            											}
            										}
            										else {
HXLINE( 217)											::Dynamic this197 = undoImage12->image;
HXDLIN( 217)											int index24;
HXDLIN( 217)											if (undoImage12->useVirtualPos) {
HXLINE( 217)												index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 217)												index24 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            											}
HXDLIN( 217)											int _hx_tmp47;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp47 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp47 = c20;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this197,index24,_hx_tmp47);
            										}
            									}
            									else {
HXLINE( 217)										if (forceClear4) {
HXLINE( 217)											::Dynamic this198 = undoImage12->image;
HXDLIN( 217)											int x20 = (dx5 - rectLeft4);
HXDLIN( 217)											int y20 = (dy5 - rectTop4);
HXDLIN( 217)											int index25;
HXDLIN( 217)											if (undoImage12->useVirtualPos) {
HXLINE( 217)												index25 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x20) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 217)												index25 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage12->width) + x20)) ));
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this198,index25,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 217)			bool found4 = false;
HXDLIN( 217)			{
HXLINE( 217)				int _g_min8 = xIter34->start;
HXDLIN( 217)				int _g_max8 = xIter34->max;
HXDLIN( 217)				while((_g_min8 < _g_max8)){
HXLINE( 217)					_g_min8 = (_g_min8 + 1);
HXDLIN( 217)					int px3 = (_g_min8 - 1);
HXDLIN( 217)					Float pcx2 = (( (Float)(px3) ) - dx);
HXLINE( 619)					found4 = false;
HXLINE( 217)					{
HXLINE( 217)						int _g_min9 = yIter34->start;
HXDLIN( 217)						int _g_max9 = yIter34->max;
HXDLIN( 217)						while((_g_min9 < _g_max9)){
HXLINE( 217)							_g_min9 = (_g_min9 + 1);
HXDLIN( 217)							int py3 = (_g_min9 - 1);
HXDLIN( 217)							Float pcy2 = (( (Float)(py3) ) - dy);
HXDLIN( 217)							Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 217)							Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 217)							Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 217)							Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 217)							Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 217)							bool _hx_tmp48;
HXDLIN( 217)							bool _hx_tmp49;
HXDLIN( 217)							if ((ratioA2 >= 0)) {
HXLINE( 217)								_hx_tmp49 = (ratioB2 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp49 = false;
            							}
HXDLIN( 217)							if (_hx_tmp49) {
HXLINE( 217)								_hx_tmp48 = (ratioC2 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp48 = false;
            							}
HXDLIN( 217)							if (_hx_tmp48) {
HXLINE( 217)								int i46 = ::Std_obj::_hx_int((( (Float)(aA2) ) * (softC * ratioB2)));
HXDLIN( 217)								if ((i46 > 255)) {
HXLINE(  24)									i46 = 255;
            								}
HXLINE( 217)								if ((i46 < 0)) {
HXLINE(  25)									i46 = 0;
            								}
HXLINE( 217)								int a46 = i46;
HXDLIN( 217)								int i47 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN( 217)								if ((i47 > 255)) {
HXLINE(  24)									i47 = 255;
            								}
HXLINE( 217)								if ((i47 < 0)) {
HXLINE(  25)									i47 = 0;
            								}
HXLINE( 217)								int r34 = i47;
HXDLIN( 217)								int i48 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN( 217)								if ((i48 > 255)) {
HXLINE(  24)									i48 = 255;
            								}
HXLINE( 217)								if ((i48 < 0)) {
HXLINE(  25)									i48 = 0;
            								}
HXLINE( 217)								int g34 = i48;
HXDLIN( 217)								int i49 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN( 217)								if ((i49 > 255)) {
HXLINE(  24)									i49 = 255;
            								}
HXLINE( 217)								if ((i49 < 0)) {
HXLINE(  25)									i49 = 0;
            								}
HXLINE( 217)								int b44 = i49;
HXDLIN( 217)								{
HXLINE( 217)									int location13;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										location13 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										location13 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            									}
HXDLIN( 217)									bool _hx_tmp50;
HXDLIN( 217)									if (pixelImage->transparent) {
HXLINE( 217)										_hx_tmp50 = (a46 < 254);
            									}
            									else {
HXLINE( 217)										_hx_tmp50 = false;
            									}
HXDLIN( 217)									if (_hx_tmp50) {
HXLINE( 217)										int this199 = ::iterMagic::Iimg_obj::get(pixelImage->image,location13);
HXDLIN( 217)										int old2;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											old2 = ((((((this199 >> 24) & 255) << 24) | ((this199 & 255) << 16)) | (((this199 >> 8) & 255) << 8)) | ((this199 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											old2 = this199;
            										}
HXDLIN( 217)										int rhs2 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b44);
HXDLIN( 217)										Float a115;
HXDLIN( 217)										int this200 = ((old2 >> 24) & 255);
HXDLIN( 217)										if ((this200 == 0)) {
HXLINE( 217)											a115 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a115 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r114;
HXDLIN( 217)										int this201 = ((old2 >> 16) & 255);
HXDLIN( 217)										if ((this201 == 0)) {
HXLINE( 217)											r114 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r114 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g114;
HXDLIN( 217)										int this202 = ((old2 >> 8) & 255);
HXDLIN( 217)										if ((this202 == 0)) {
HXLINE( 217)											g114 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g114 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b117;
HXDLIN( 217)										int this203 = (old2 & 255);
HXDLIN( 217)										if ((this203 == 0)) {
HXLINE( 217)											b117 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b117 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a214;
HXDLIN( 217)										int this204 = ((rhs2 >> 24) & 255);
HXDLIN( 217)										if ((this204 == 0)) {
HXLINE( 217)											a214 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a214 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r213;
HXDLIN( 217)										int this205 = ((rhs2 >> 16) & 255);
HXDLIN( 217)										if ((this205 == 0)) {
HXLINE( 217)											r213 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r213 = (( (Float)(this205) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g213;
HXDLIN( 217)										int this206 = ((rhs2 >> 8) & 255);
HXDLIN( 217)										if ((this206 == 0)) {
HXLINE( 217)											g213 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g213 = (( (Float)(this206) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b215;
HXDLIN( 217)										int this207 = (rhs2 & 255);
HXDLIN( 217)										if ((this207 == 0)) {
HXLINE( 217)											b215 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b215 = (( (Float)(this207) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a314 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 217)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r213 * a214))));
HXDLIN( 217)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g213 * a214))));
HXDLIN( 217)										int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a214))));
HXDLIN( 217)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a214)));
HXDLIN( 217)										int blended13 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b45);
HXDLIN( 217)										{
HXLINE( 217)											int _hx_tmp51;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp51 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp51 = blended13;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(pixelImage->image,location13,_hx_tmp51);
            										}
            									}
            									else {
HXLINE( 217)										int value2;
HXDLIN( 217)										if (pixelImage->isLittle) {
HXLINE( 217)											value2 = ((((a46 << 24) | (b44 << 16)) | (g34 << 8)) | r34);
            										}
            										else {
HXLINE( 217)											value2 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b44);
            										}
HXDLIN( 217)										::iterMagic::Iimg_obj::set(pixelImage->image,location13,value2);
            									}
            								}
HXLINE( 633)								found4 = true;
            							}
            							else {
HXLINE( 217)								if (found4) {
HXLINE( 217)									goto _hx_goto_174;
            								}
            							}
            						}
            						_hx_goto_174:;
            					}
            				}
            			}
HXDLIN( 217)			{
HXLINE( 217)				 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,cx,cy,dx,dy,true);
HXDLIN( 217)				if (hasUndo4) {
HXLINE( 217)					v12->undoImage = undoImage12;
HXDLIN( 217)					v12->undoX = xIter34->start;
HXDLIN( 217)					v12->undoY = yIter34->start;
            				}
            			}
            		}
            		else {
HXLINE( 217)			Float bx3 = cx;
HXDLIN( 217)			Float by3 = cy;
HXDLIN( 217)			Float cx3 = dx;
HXDLIN( 217)			Float cy3 = dy;
HXDLIN( 217)			bool hasUndo5 = false;
HXDLIN( 217)			bool adjustWinding2 = (((((ex * by3) - (bx3 * ey)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ey) - (ex * cy3))) > 0);
HXDLIN( 217)			if (!(adjustWinding2)) {
HXLINE( 217)				Float bx_2 = bx3;
HXDLIN( 217)				Float by_2 = by3;
HXLINE(  25)				bx3 = cx3;
HXLINE(  26)				by3 = cy3;
HXLINE(  27)				cx3 = bx_2;
HXLINE(  28)				cy3 = by_2;
            			}
HXLINE( 217)			{
HXLINE( 217)				Float s02 = ((ey * cx3) - (ex * cy3));
HXDLIN( 217)				Float sx2 = (cy3 - ey);
HXDLIN( 217)				Float sy2 = (ex - cx3);
HXDLIN( 217)				Float t02 = ((ex * by3) - (ey * bx3));
HXDLIN( 217)				Float tx2 = (ey - by3);
HXDLIN( 217)				Float ty2 = (bx3 - ex);
HXDLIN( 217)				Float A2 = ((((-(by3) * cx3) + (ey * (-(bx3) + cx3))) + (ex * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 217)				if ((ex > bx3)) {
HXLINE( 217)					if ((ex > cx3)) {
HXLINE( 217)						int min20;
HXDLIN( 217)						if ((bx3 > cx3)) {
HXLINE( 217)							min20 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 217)							min20 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 217)						int ii_min48 = min20;
HXDLIN( 217)						int ii_max48 = ::Math_obj::ceil(ex);
HXDLIN( 217)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            					}
            					else {
HXLINE( 217)						int ii_min49 = ::Math_obj::floor(bx3);
HXDLIN( 217)						int ii_max49 = ::Math_obj::ceil(cx3);
HXDLIN( 217)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            					}
            				}
            				else {
HXLINE( 217)					if ((bx3 > cx3)) {
HXLINE( 217)						int min21;
HXDLIN( 217)						if ((ex > cx3)) {
HXLINE( 217)							min21 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 217)							min21 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 217)						int ii_min50 = min21;
HXDLIN( 217)						int ii_max50 = ::Math_obj::ceil(bx3);
HXDLIN( 217)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            					}
            					else {
HXLINE( 217)						int ii_min51 = ::Math_obj::floor(ex);
HXDLIN( 217)						int ii_max51 = ::Math_obj::ceil(cx3);
HXDLIN( 217)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 217)				if ((ey > by3)) {
HXLINE( 217)					if ((ey > cy3)) {
HXLINE( 217)						int min22;
HXDLIN( 217)						if ((by3 > cy3)) {
HXLINE( 217)							min22 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 217)							min22 = ::Math_obj::floor(by3);
            						}
HXDLIN( 217)						int ii_min52 = min22;
HXDLIN( 217)						int ii_max52 = ::Math_obj::ceil(ey);
HXDLIN( 217)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            					}
            					else {
HXLINE( 217)						int ii_min53 = ::Math_obj::floor(by3);
HXDLIN( 217)						int ii_max53 = ::Math_obj::ceil(cy3);
HXDLIN( 217)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            					}
            				}
            				else {
HXLINE( 217)					if ((by3 > cy3)) {
HXLINE( 217)						int min23;
HXDLIN( 217)						if ((ey > cy3)) {
HXLINE( 217)							min23 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 217)							min23 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 217)						int ii_min54 = min23;
HXDLIN( 217)						int ii_max54 = ::Math_obj::ceil(by3);
HXDLIN( 217)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            					}
            					else {
HXLINE( 217)						int ii_min55 = ::Math_obj::floor(ey);
HXDLIN( 217)						int ii_max55 = ::Math_obj::ceil(cy3);
HXDLIN( 217)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 217)				if (hasUndo5) {
HXLINE( 217)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 217)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 217)					 ::Dynamic imageType5 = null();
HXDLIN( 217)					 ::pi_xy::ImageStruct this208 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 217)					::Dynamic undoImage16;
HXDLIN( 217)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXLINE( 217)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::BytesImg b46 = byt5;
HXDLIN( 217)							{
HXLINE( 217)								b46->width = width5;
HXDLIN( 217)								b46->height = height5;
HXDLIN( 217)								b46->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 217)								b46->data = ::haxe::io::Bytes_obj::alloc((b46->length * 4));
HXDLIN( 217)								{
HXLINE( 217)									int len10 = b46->length;
HXDLIN( 217)									int w5 = 0;
HXDLIN( 217)									{
HXLINE( 217)										int _g100 = 0;
HXDLIN( 217)										int _g101 = b46->height;
HXDLIN( 217)										while((_g100 < _g101)){
HXLINE( 217)											_g100 = (_g100 + 1);
HXDLIN( 217)											int y21 = (_g100 - 1);
HXDLIN( 217)											{
HXLINE( 217)												int _g102 = 0;
HXDLIN( 217)												int _g103 = b46->width;
HXDLIN( 217)												while((_g102 < _g103)){
HXLINE( 217)													_g102 = (_g102 + 1);
HXDLIN( 217)													int x21 = (_g102 - 1);
HXDLIN( 217)													{
HXLINE( 217)														w5 = (w5 + 1);
HXDLIN( 217)														b46->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w5 = (w5 + 1);
HXDLIN( 217)														b46->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w5 = (w5 + 1);
HXDLIN( 217)														b46->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w5 = (w5 + 1);
HXDLIN( 217)														b46->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage16 = b46;
            						}
            						break;
            						case (int)1: {
HXLINE( 217)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::ArrIntImg a48 = arrI5;
HXDLIN( 217)							{
HXLINE( 217)								a48->width = width5;
HXDLIN( 217)								a48->height = height5;
HXDLIN( 217)								a48->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)								a48->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 217)								{
HXLINE( 217)									int _g104 = 0;
HXDLIN( 217)									int _g105 = a48->length;
HXDLIN( 217)									while((_g104 < _g105)){
HXLINE( 217)										_g104 = (_g104 + 1);
HXDLIN( 217)										int i50 = (_g104 - 1);
HXDLIN( 217)										a48->data[i50] = 0;
            									}
            								}
            							}
HXDLIN( 217)							undoImage16 = a48;
            						}
            						break;
            						case (int)2: {
HXLINE( 217)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::U32ArrImg b47 = u32a5;
HXDLIN( 217)							{
HXLINE( 217)								b47->width = width5;
HXDLIN( 217)								b47->height = height5;
HXDLIN( 217)								b47->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 217)								int size5 = (b47->length * 4);
HXDLIN( 217)								b47->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 217)								{
HXLINE( 217)									int _g106 = 0;
HXDLIN( 217)									int _g107 = b47->length;
HXDLIN( 217)									while((_g106 < _g107)){
HXLINE( 217)										_g106 = (_g106 + 1);
HXDLIN( 217)										int i51 = (_g106 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::io::ArrayBufferViewImpl this209 = b47->data;
HXDLIN( 217)											bool undoImage17;
HXDLIN( 217)											if ((i51 >= 0)) {
HXLINE( 217)												undoImage17 = (i51 < (this209->byteLength >> 2));
            											}
            											else {
HXLINE( 217)												undoImage17 = false;
            											}
HXDLIN( 217)											if (undoImage17) {
HXLINE( 217)												 ::haxe::io::Bytes _this5 = this209->bytes;
HXDLIN( 217)												int pos5 = ((i51 << 2) + this209->byteOffset);
HXDLIN( 217)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 217)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage16 = b47;
            						}
            						break;
            						case (int)3: {
HXLINE( 217)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::VecIntImg v13 = vec5;
HXDLIN( 217)							{
HXLINE( 217)								v13->width = width5;
HXDLIN( 217)								v13->height = height5;
HXDLIN( 217)								v13->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 217)								v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 217)								{
HXLINE( 217)									int _g108 = 0;
HXDLIN( 217)									int _g109 = v13->length;
HXDLIN( 217)									while((_g108 < _g109)){
HXLINE( 217)										_g108 = (_g108 + 1);
HXDLIN( 217)										int i52 = (_g108 - 1);
HXDLIN( 217)										v13->data->__unsafe_set(i52,0);
            									}
            								}
            							}
HXDLIN( 217)							undoImage16 = v13;
            						}
            						break;
            						case (int)4: {
HXLINE( 217)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::StackIntImg b48 = sInt5;
HXDLIN( 217)							{
HXLINE( 217)								b48->width = width5;
HXDLIN( 217)								b48->height = height5;
HXDLIN( 217)								b48->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 217)								b48->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)								{
HXLINE( 217)									int len11 = b48->length;
HXDLIN( 217)									 ::haxe::ds::GenericStack_Int d5 = b48->data;
HXDLIN( 217)									if (::hx::IsNull( d5->head )) {
HXLINE( 217)										int _g110 = 0;
HXDLIN( 217)										int _g111 = len11;
HXDLIN( 217)										while((_g110 < _g111)){
HXLINE( 217)											_g110 = (_g110 + 1);
HXDLIN( 217)											int i53 = (_g110 - 1);
HXDLIN( 217)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXLINE( 217)										int _g112 = 0;
HXDLIN( 217)										int _g113 = len11;
HXDLIN( 217)										while((_g112 < _g113)){
HXLINE( 217)											_g112 = (_g112 + 1);
HXDLIN( 217)											int i54 = (_g112 - 1);
HXDLIN( 217)											{
HXLINE( 217)												 ::haxe::ds::GenericCell_Int l5 = b48->data->head;
HXDLIN( 217)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 217)												{
HXLINE( 217)													int _g114 = 0;
HXDLIN( 217)													int _g115 = i54;
HXDLIN( 217)													while((_g114 < _g115)){
HXLINE( 217)														_g114 = (_g114 + 1);
HXDLIN( 217)														int i55 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 217)												if (::hx::IsNull( prev5 )) {
HXLINE( 217)													b48->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 217)													l5 = null();
            												}
            												else {
HXLINE( 217)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 217)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage16 = b48;
            						}
            						break;
            					}
HXDLIN( 217)					this208->image = undoImage16;
HXDLIN( 217)					this208->width = width5;
HXDLIN( 217)					this208->height = height5;
HXDLIN( 217)					this208->imageType = ( (int)(imageType5) );
HXDLIN( 217)					undoImage15 = this208;
HXDLIN( 217)					{
HXLINE( 217)						int rectLeft5 = xIter35->start;
HXDLIN( 217)						int rectTop5 = yIter35->start;
HXDLIN( 217)						int rectRight5 = xIter35->max;
HXDLIN( 217)						bool forceClear5 = false;
HXDLIN( 217)						{
HXLINE( 217)							int _g116 = rectTop5;
HXDLIN( 217)							int _g117 = yIter35->max;
HXDLIN( 217)							while((_g116 < _g117)){
HXLINE( 217)								_g116 = (_g116 + 1);
HXDLIN( 217)								int dy6 = (_g116 - 1);
HXDLIN( 217)								{
HXLINE( 217)									int _g118 = rectLeft5;
HXDLIN( 217)									int _g119 = rectRight5;
HXDLIN( 217)									while((_g118 < _g119)){
HXLINE( 217)										_g118 = (_g118 + 1);
HXDLIN( 217)										int dx6 = (_g118 - 1);
HXDLIN( 217)										::Dynamic this210 = pixelImage->image;
HXDLIN( 217)										int index26;
HXDLIN( 217)										if (pixelImage->useVirtualPos) {
HXLINE( 217)											index26 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx6) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 217)											index26 = ::Std_obj::_hx_int(( (Float)(((dy6 * pixelImage->width) + dx6)) ));
            										}
HXDLIN( 217)										int c21 = ::iterMagic::Iimg_obj::get(this210,index26);
HXDLIN( 217)										int col5;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											col5 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											col5 = c21;
            										}
HXDLIN( 217)										bool _hx_tmp52;
HXDLIN( 217)										if (pixelImage->useMask) {
HXLINE( 217)											_hx_tmp52 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 217)											_hx_tmp52 = false;
            										}
HXDLIN( 217)										if (_hx_tmp52) {
HXLINE( 217)											 ::pi_xy::ImageStruct this211 = pixelImage->mask;
HXDLIN( 217)											::Dynamic this212 = this211->image;
HXDLIN( 217)											int index27;
HXDLIN( 217)											if (this211->useVirtualPos) {
HXLINE( 217)												index27 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this211->virtualY) * ( (Float)(this211->width) )) + dx6) - this211->virtualX));
            											}
            											else {
HXLINE( 217)												index27 = ::Std_obj::_hx_int(( (Float)(((dy6 * this211->width) + dx6)) ));
            											}
HXDLIN( 217)											int c22 = ::iterMagic::Iimg_obj::get(this212,index27);
HXDLIN( 217)											int v14;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												v14 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												v14 = c22;
            											}
HXDLIN( 217)											int maskPixel5 = v14;
HXDLIN( 217)											int this213 = col5;
HXDLIN( 217)											if ((maskPixel5 == 0)) {
HXLINE( 217)												col5 = this213;
            											}
            											else {
HXLINE( 217)												Float m05;
HXDLIN( 217)												int this214 = ((maskPixel5 >> 24) & 255);
HXDLIN( 217)												if ((this214 == 0)) {
HXLINE( 217)													m05 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m05 = (( (Float)(this214) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m15;
HXDLIN( 217)												int this215 = ((maskPixel5 >> 16) & 255);
HXDLIN( 217)												if ((this215 == 0)) {
HXLINE( 217)													m15 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m15 = (( (Float)(this215) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m25;
HXDLIN( 217)												int this216 = ((maskPixel5 >> 8) & 255);
HXDLIN( 217)												if ((this216 == 0)) {
HXLINE( 217)													m25 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m25 = (( (Float)(this216) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m35;
HXDLIN( 217)												int this217 = (maskPixel5 & 255);
HXDLIN( 217)												if ((this217 == 0)) {
HXLINE( 217)													m35 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m35 = (( (Float)(this217) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this213 >> 24) & 255)) )));
HXDLIN( 217)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this213 >> 16) & 255)) )));
HXDLIN( 217)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this213 >> 8) & 255)) )));
HXDLIN( 217)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this213 & 255)) )));
HXDLIN( 217)												col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 217)										if ((col5 != 0)) {
HXLINE( 217)											int x22 = (dx6 - rectLeft5);
HXDLIN( 217)											int y22 = (dy6 - rectTop5);
HXDLIN( 217)											int c23 = col5;
HXDLIN( 217)											bool _hx_tmp53;
HXDLIN( 217)											if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp53 = undoImage15->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp53 = false;
            											}
HXDLIN( 217)											if (_hx_tmp53) {
HXLINE( 217)												int location14;
HXDLIN( 217)												if (undoImage15->useVirtualPos) {
HXLINE( 217)													location14 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 217)													location14 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            												}
HXDLIN( 217)												int this218 = ::iterMagic::Iimg_obj::get(undoImage15->image,location14);
HXDLIN( 217)												int this219;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this219 = ((((((this218 >> 24) & 255) << 24) | ((this218 & 255) << 16)) | (((this218 >> 8) & 255) << 8)) | ((this218 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this219 = this218;
            												}
HXDLIN( 217)												Float a116;
HXDLIN( 217)												int this220 = ((this219 >> 24) & 255);
HXDLIN( 217)												if ((this220 == 0)) {
HXLINE( 217)													a116 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a116 = (( (Float)(this220) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r115;
HXDLIN( 217)												int this221 = ((this219 >> 16) & 255);
HXDLIN( 217)												if ((this221 == 0)) {
HXLINE( 217)													r115 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r115 = (( (Float)(this221) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g115;
HXDLIN( 217)												int this222 = ((this219 >> 8) & 255);
HXDLIN( 217)												if ((this222 == 0)) {
HXLINE( 217)													g115 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g115 = (( (Float)(this222) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b118;
HXDLIN( 217)												int this223 = (this219 & 255);
HXDLIN( 217)												if ((this223 == 0)) {
HXLINE( 217)													b118 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b118 = (( (Float)(this223) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a215;
HXDLIN( 217)												int this224 = ((col5 >> 24) & 255);
HXDLIN( 217)												if ((this224 == 0)) {
HXLINE( 217)													a215 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a215 = (( (Float)(this224) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r214;
HXDLIN( 217)												int this225 = ((col5 >> 16) & 255);
HXDLIN( 217)												if ((this225 == 0)) {
HXLINE( 217)													r214 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r214 = (( (Float)(this225) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g214;
HXDLIN( 217)												int this226 = ((col5 >> 8) & 255);
HXDLIN( 217)												if ((this226 == 0)) {
HXLINE( 217)													g214 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g214 = (( (Float)(this226) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b216;
HXDLIN( 217)												int this227 = (col5 & 255);
HXDLIN( 217)												if ((this227 == 0)) {
HXLINE( 217)													b216 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b216 = (( (Float)(this227) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a315 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 217)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r214 * a215))));
HXDLIN( 217)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g214 * a215))));
HXDLIN( 217)												int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a215))));
HXDLIN( 217)												int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a215)));
HXDLIN( 217)												int blended14 = ((((a49 << 24) | (r36 << 16)) | (g36 << 8)) | b49);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp54;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp54 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp54 = blended14;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(undoImage15->image,location14,_hx_tmp54);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this228 = undoImage15->image;
HXDLIN( 217)												int index28;
HXDLIN( 217)												if (undoImage15->useVirtualPos) {
HXLINE( 217)													index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 217)													index28 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            												}
HXDLIN( 217)												int _hx_tmp55;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp55 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp55 = c23;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this228,index28,_hx_tmp55);
            											}
            										}
            										else {
HXLINE( 217)											if (forceClear5) {
HXLINE( 217)												::Dynamic this229 = undoImage15->image;
HXDLIN( 217)												int x23 = (dx6 - rectLeft5);
HXDLIN( 217)												int y23 = (dy6 - rectTop5);
HXDLIN( 217)												int index29;
HXDLIN( 217)												if (undoImage15->useVirtualPos) {
HXLINE( 217)													index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x23) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 217)													index29 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage15->width) + x23)) ));
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this229,index29,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 217)				bool found5 = false;
HXDLIN( 217)				Float s2 = ((Float)0.);
HXDLIN( 217)				Float t2 = ((Float)0.);
HXDLIN( 217)				Float sxx2 = ((Float)0.);
HXDLIN( 217)				Float txx2 = ((Float)0.);
HXDLIN( 217)				{
HXLINE( 217)					int _g_min10 = xIter35->start;
HXDLIN( 217)					int _g_max10 = xIter35->max;
HXDLIN( 217)					while((_g_min10 < _g_max10)){
HXLINE( 217)						_g_min10 = (_g_min10 + 1);
HXDLIN( 217)						int x24 = (_g_min10 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x24) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x24) ));
HXLINE(  62)						found5 = false;
HXLINE( 217)						{
HXLINE( 217)							int _g_min11 = yIter35->start;
HXDLIN( 217)							int _g_max11 = yIter35->max;
HXDLIN( 217)							while((_g_min11 < _g_max11)){
HXLINE( 217)								_g_min11 = (_g_min11 + 1);
HXDLIN( 217)								int y24 = (_g_min11 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y24) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y24) )));
HXLINE( 217)								bool _hx_tmp56;
HXDLIN( 217)								if (!((s2 <= 0))) {
HXLINE( 217)									_hx_tmp56 = (t2 <= 0);
            								}
            								else {
HXLINE( 217)									_hx_tmp56 = true;
            								}
HXDLIN( 217)								if (_hx_tmp56) {
HXLINE( 217)									if (found5) {
HXLINE( 217)										goto _hx_goto_186;
            									}
            								}
            								else {
HXLINE( 217)									if (((s2 + t2) < A2)) {
HXLINE( 217)										{
HXLINE( 217)											int c24 = color;
HXDLIN( 217)											bool _hx_tmp57;
HXDLIN( 217)											if ((((c24 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp57 = pixelImage->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp57 = false;
            											}
HXDLIN( 217)											if (_hx_tmp57) {
HXLINE( 217)												int location15;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													location15 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x24) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													location15 = ::Std_obj::_hx_int(( (Float)(((y24 * pixelImage->width) + x24)) ));
            												}
HXDLIN( 217)												int this230 = ::iterMagic::Iimg_obj::get(pixelImage->image,location15);
HXDLIN( 217)												int this231;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this231 = ((((((this230 >> 24) & 255) << 24) | ((this230 & 255) << 16)) | (((this230 >> 8) & 255) << 8)) | ((this230 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this231 = this230;
            												}
HXDLIN( 217)												Float a117;
HXDLIN( 217)												int this232 = ((this231 >> 24) & 255);
HXDLIN( 217)												if ((this232 == 0)) {
HXLINE( 217)													a117 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a117 = (( (Float)(this232) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r116;
HXDLIN( 217)												int this233 = ((this231 >> 16) & 255);
HXDLIN( 217)												if ((this233 == 0)) {
HXLINE( 217)													r116 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r116 = (( (Float)(this233) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g116;
HXDLIN( 217)												int this234 = ((this231 >> 8) & 255);
HXDLIN( 217)												if ((this234 == 0)) {
HXLINE( 217)													g116 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g116 = (( (Float)(this234) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b119;
HXDLIN( 217)												int this235 = (this231 & 255);
HXDLIN( 217)												if ((this235 == 0)) {
HXLINE( 217)													b119 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b119 = (( (Float)(this235) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a216;
HXDLIN( 217)												int this236 = ((color >> 24) & 255);
HXDLIN( 217)												if ((this236 == 0)) {
HXLINE( 217)													a216 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a216 = (( (Float)(this236) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r215;
HXDLIN( 217)												int this237 = ((color >> 16) & 255);
HXDLIN( 217)												if ((this237 == 0)) {
HXLINE( 217)													r215 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r215 = (( (Float)(this237) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g215;
HXDLIN( 217)												int this238 = ((color >> 8) & 255);
HXDLIN( 217)												if ((this238 == 0)) {
HXLINE( 217)													g215 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g215 = (( (Float)(this238) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b217;
HXDLIN( 217)												int this239 = (color & 255);
HXDLIN( 217)												if ((this239 == 0)) {
HXLINE( 217)													b217 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b217 = (( (Float)(this239) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a316 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 217)												int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r215 * a216))));
HXDLIN( 217)												int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g215 * a216))));
HXDLIN( 217)												int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a216))));
HXDLIN( 217)												int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a216)));
HXDLIN( 217)												int blended15 = ((((a50 << 24) | (r37 << 16)) | (g37 << 8)) | b50);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp58;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp58 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp58 = blended15;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(pixelImage->image,location15,_hx_tmp58);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this240 = pixelImage->image;
HXDLIN( 217)												int index30;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													index30 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x24) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													index30 = ::Std_obj::_hx_int(( (Float)(((y24 * pixelImage->width) + x24)) ));
            												}
HXDLIN( 217)												int _hx_tmp59;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp59 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp59 = c24;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this240,index30,_hx_tmp59);
            											}
            										}
HXLINE(  73)										found5 = true;
            									}
            									else {
HXLINE( 217)										if (found5) {
HXLINE( 217)											goto _hx_goto_186;
            										}
            									}
            								}
            							}
            							_hx_goto_186:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 217)		if (softLeft) {
HXLINE( 217)			bool hasUndo6 = false;
HXDLIN( 217)			int aA3 = ((color >> 24) & 255);
HXDLIN( 217)			int rA3 = ((color >> 16) & 255);
HXDLIN( 217)			int gA3 = ((color >> 8) & 255);
HXDLIN( 217)			int bA3 = (color & 255);
HXDLIN( 217)			Float bcx3 = (dx - ax);
HXDLIN( 217)			Float bcy3 = (dy - ay);
HXDLIN( 217)			Float acx3 = (ex - ax);
HXDLIN( 217)			Float acy3 = (ey - ay);
HXDLIN( 217)			Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 217)			Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 217)			Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 217)			Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 217)			if ((ex > dx)) {
HXLINE( 217)				if ((ex > ax)) {
HXLINE( 217)					int min24;
HXDLIN( 217)					if ((dx > ax)) {
HXLINE( 217)						min24 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 217)						min24 = ::Math_obj::floor(dx);
            					}
HXDLIN( 217)					int ii_min56 = min24;
HXDLIN( 217)					int ii_max56 = ::Math_obj::ceil(ex);
HXDLIN( 217)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            				}
            				else {
HXLINE( 217)					int ii_min57 = ::Math_obj::floor(dx);
HXDLIN( 217)					int ii_max57 = ::Math_obj::ceil(ax);
HXDLIN( 217)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            				}
            			}
            			else {
HXLINE( 217)				if ((dx > ax)) {
HXLINE( 217)					int min25;
HXDLIN( 217)					if ((ex > ax)) {
HXLINE( 217)						min25 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 217)						min25 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 217)					int ii_min58 = min25;
HXDLIN( 217)					int ii_max58 = ::Math_obj::ceil(dx);
HXDLIN( 217)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            				}
            				else {
HXLINE( 217)					int ii_min59 = ::Math_obj::floor(ex);
HXDLIN( 217)					int ii_max59 = ::Math_obj::ceil(ax);
HXDLIN( 217)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 217)			if ((ey > dy)) {
HXLINE( 217)				if ((ey > ay)) {
HXLINE( 217)					int min26;
HXDLIN( 217)					if ((dy > ay)) {
HXLINE( 217)						min26 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 217)						min26 = ::Math_obj::floor(dy);
            					}
HXDLIN( 217)					int ii_min60 = min26;
HXDLIN( 217)					int ii_max60 = ::Math_obj::ceil(ey);
HXDLIN( 217)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            				}
            				else {
HXLINE( 217)					int ii_min61 = ::Math_obj::floor(dy);
HXDLIN( 217)					int ii_max61 = ::Math_obj::ceil(ay);
HXDLIN( 217)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            				}
            			}
            			else {
HXLINE( 217)				if ((dy > ay)) {
HXLINE( 217)					int min27;
HXDLIN( 217)					if ((ey > ay)) {
HXLINE( 217)						min27 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 217)						min27 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 217)					int ii_min62 = min27;
HXDLIN( 217)					int ii_max62 = ::Math_obj::ceil(dy);
HXDLIN( 217)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            				}
            				else {
HXLINE( 217)					int ii_min63 = ::Math_obj::floor(ey);
HXDLIN( 217)					int ii_max63 = ::Math_obj::ceil(ay);
HXDLIN( 217)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            				}
            			}
HXDLIN( 217)			 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 217)			if (hasUndo6) {
HXLINE( 217)				int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 217)				int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 217)				 ::Dynamic imageType6 = null();
HXDLIN( 217)				 ::pi_xy::ImageStruct this241 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)				if (::hx::IsNull( imageType6 )) {
HXLINE(  54)					imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 217)				::Dynamic undoImage19;
HXDLIN( 217)				switch((int)(( (int)(imageType6) ))){
            					case (int)0: {
HXLINE( 217)						 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::BytesImg b51 = byt6;
HXDLIN( 217)						{
HXLINE( 217)							b51->width = width6;
HXDLIN( 217)							b51->height = height6;
HXDLIN( 217)							b51->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 217)							b51->data = ::haxe::io::Bytes_obj::alloc((b51->length * 4));
HXDLIN( 217)							{
HXLINE( 217)								int len12 = b51->length;
HXDLIN( 217)								int w6 = 0;
HXDLIN( 217)								{
HXLINE( 217)									int _g120 = 0;
HXDLIN( 217)									int _g121 = b51->height;
HXDLIN( 217)									while((_g120 < _g121)){
HXLINE( 217)										_g120 = (_g120 + 1);
HXDLIN( 217)										int y25 = (_g120 - 1);
HXDLIN( 217)										{
HXLINE( 217)											int _g122 = 0;
HXDLIN( 217)											int _g123 = b51->width;
HXDLIN( 217)											while((_g122 < _g123)){
HXLINE( 217)												_g122 = (_g122 + 1);
HXDLIN( 217)												int x25 = (_g122 - 1);
HXDLIN( 217)												{
HXLINE( 217)													w6 = (w6 + 1);
HXDLIN( 217)													b51->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w6 = (w6 + 1);
HXDLIN( 217)													b51->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w6 = (w6 + 1);
HXDLIN( 217)													b51->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 217)												{
HXLINE( 217)													w6 = (w6 + 1);
HXDLIN( 217)													b51->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage19 = b51;
            					}
            					break;
            					case (int)1: {
HXLINE( 217)						 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::ArrIntImg a51 = arrI6;
HXDLIN( 217)						{
HXLINE( 217)							a51->width = width6;
HXDLIN( 217)							a51->height = height6;
HXDLIN( 217)							a51->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)							a51->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 217)							{
HXLINE( 217)								int _g124 = 0;
HXDLIN( 217)								int _g125 = a51->length;
HXDLIN( 217)								while((_g124 < _g125)){
HXLINE( 217)									_g124 = (_g124 + 1);
HXDLIN( 217)									int i56 = (_g124 - 1);
HXDLIN( 217)									a51->data[i56] = 0;
            								}
            							}
            						}
HXDLIN( 217)						undoImage19 = a51;
            					}
            					break;
            					case (int)2: {
HXLINE( 217)						 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::U32ArrImg b52 = u32a6;
HXDLIN( 217)						{
HXLINE( 217)							b52->width = width6;
HXDLIN( 217)							b52->height = height6;
HXDLIN( 217)							b52->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 217)							int size6 = (b52->length * 4);
HXDLIN( 217)							b52->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 217)							{
HXLINE( 217)								int _g126 = 0;
HXDLIN( 217)								int _g127 = b52->length;
HXDLIN( 217)								while((_g126 < _g127)){
HXLINE( 217)									_g126 = (_g126 + 1);
HXDLIN( 217)									int i57 = (_g126 - 1);
HXDLIN( 217)									{
HXLINE( 217)										 ::haxe::io::ArrayBufferViewImpl this242 = b52->data;
HXDLIN( 217)										bool undoImage20;
HXDLIN( 217)										if ((i57 >= 0)) {
HXLINE( 217)											undoImage20 = (i57 < (this242->byteLength >> 2));
            										}
            										else {
HXLINE( 217)											undoImage20 = false;
            										}
HXDLIN( 217)										if (undoImage20) {
HXLINE( 217)											 ::haxe::io::Bytes _this6 = this242->bytes;
HXDLIN( 217)											int pos6 = ((i57 << 2) + this242->byteOffset);
HXDLIN( 217)											_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 217)											_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)											_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage19 = b52;
            					}
            					break;
            					case (int)3: {
HXLINE( 217)						 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::VecIntImg v15 = vec6;
HXDLIN( 217)						{
HXLINE( 217)							v15->width = width6;
HXDLIN( 217)							v15->height = height6;
HXDLIN( 217)							v15->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 217)							v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN( 217)							{
HXLINE( 217)								int _g128 = 0;
HXDLIN( 217)								int _g129 = v15->length;
HXDLIN( 217)								while((_g128 < _g129)){
HXLINE( 217)									_g128 = (_g128 + 1);
HXDLIN( 217)									int i58 = (_g128 - 1);
HXDLIN( 217)									v15->data->__unsafe_set(i58,0);
            								}
            							}
            						}
HXDLIN( 217)						undoImage19 = v15;
            					}
            					break;
            					case (int)4: {
HXLINE( 217)						 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)						 ::iterMagic::StackIntImg b53 = sInt6;
HXDLIN( 217)						{
HXLINE( 217)							b53->width = width6;
HXDLIN( 217)							b53->height = height6;
HXDLIN( 217)							b53->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 217)							b53->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)							{
HXLINE( 217)								int len13 = b53->length;
HXDLIN( 217)								 ::haxe::ds::GenericStack_Int d6 = b53->data;
HXDLIN( 217)								if (::hx::IsNull( d6->head )) {
HXLINE( 217)									int _g130 = 0;
HXDLIN( 217)									int _g131 = len13;
HXDLIN( 217)									while((_g130 < _g131)){
HXLINE( 217)										_g130 = (_g130 + 1);
HXDLIN( 217)										int i59 = (_g130 - 1);
HXDLIN( 217)										d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            									}
            								}
            								else {
HXLINE( 217)									int _g132 = 0;
HXDLIN( 217)									int _g133 = len13;
HXDLIN( 217)									while((_g132 < _g133)){
HXLINE( 217)										_g132 = (_g132 + 1);
HXDLIN( 217)										int i60 = (_g132 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::ds::GenericCell_Int l6 = b53->data->head;
HXDLIN( 217)											 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 217)											{
HXLINE( 217)												int _g134 = 0;
HXDLIN( 217)												int _g135 = i60;
HXDLIN( 217)												while((_g134 < _g135)){
HXLINE( 217)													_g134 = (_g134 + 1);
HXDLIN( 217)													int i61 = (_g134 - 1);
HXLINE( 345)													prev6 = l6;
HXLINE( 346)													l6 = l6->next;
            												}
            											}
HXLINE( 217)											if (::hx::IsNull( prev6 )) {
HXLINE( 217)												b53->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 217)												l6 = null();
            											}
            											else {
HXLINE( 217)												prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 217)												l6 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 217)						undoImage19 = b53;
            					}
            					break;
            				}
HXDLIN( 217)				this241->image = undoImage19;
HXDLIN( 217)				this241->width = width6;
HXDLIN( 217)				this241->height = height6;
HXDLIN( 217)				this241->imageType = ( (int)(imageType6) );
HXDLIN( 217)				undoImage18 = this241;
HXDLIN( 217)				{
HXLINE( 217)					int rectLeft6 = xIter36->start;
HXDLIN( 217)					int rectTop6 = yIter36->start;
HXDLIN( 217)					int rectRight6 = xIter36->max;
HXDLIN( 217)					bool forceClear6 = false;
HXDLIN( 217)					{
HXLINE( 217)						int _g136 = rectTop6;
HXDLIN( 217)						int _g137 = yIter36->max;
HXDLIN( 217)						while((_g136 < _g137)){
HXLINE( 217)							_g136 = (_g136 + 1);
HXDLIN( 217)							int dy7 = (_g136 - 1);
HXDLIN( 217)							{
HXLINE( 217)								int _g138 = rectLeft6;
HXDLIN( 217)								int _g139 = rectRight6;
HXDLIN( 217)								while((_g138 < _g139)){
HXLINE( 217)									_g138 = (_g138 + 1);
HXDLIN( 217)									int dx7 = (_g138 - 1);
HXDLIN( 217)									::Dynamic this243 = pixelImage->image;
HXDLIN( 217)									int index31;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										index31 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx7) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										index31 = ::Std_obj::_hx_int(( (Float)(((dy7 * pixelImage->width) + dx7)) ));
            									}
HXDLIN( 217)									int c25 = ::iterMagic::Iimg_obj::get(this243,index31);
HXDLIN( 217)									int col6;
HXDLIN( 217)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)										col6 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            									}
            									else {
HXLINE( 217)										col6 = c25;
            									}
HXDLIN( 217)									bool _hx_tmp60;
HXDLIN( 217)									if (pixelImage->useMask) {
HXLINE( 217)										_hx_tmp60 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 217)										_hx_tmp60 = false;
            									}
HXDLIN( 217)									if (_hx_tmp60) {
HXLINE( 217)										 ::pi_xy::ImageStruct this244 = pixelImage->mask;
HXDLIN( 217)										::Dynamic this245 = this244->image;
HXDLIN( 217)										int index32;
HXDLIN( 217)										if (this244->useVirtualPos) {
HXLINE( 217)											index32 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this244->virtualY) * ( (Float)(this244->width) )) + dx7) - this244->virtualX));
            										}
            										else {
HXLINE( 217)											index32 = ::Std_obj::_hx_int(( (Float)(((dy7 * this244->width) + dx7)) ));
            										}
HXDLIN( 217)										int c26 = ::iterMagic::Iimg_obj::get(this245,index32);
HXDLIN( 217)										int v16;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											v16 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											v16 = c26;
            										}
HXDLIN( 217)										int maskPixel6 = v16;
HXDLIN( 217)										int this246 = col6;
HXDLIN( 217)										if ((maskPixel6 == 0)) {
HXLINE( 217)											col6 = this246;
            										}
            										else {
HXLINE( 217)											Float m06;
HXDLIN( 217)											int this247 = ((maskPixel6 >> 24) & 255);
HXDLIN( 217)											if ((this247 == 0)) {
HXLINE( 217)												m06 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m06 = (( (Float)(this247) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m16;
HXDLIN( 217)											int this248 = ((maskPixel6 >> 16) & 255);
HXDLIN( 217)											if ((this248 == 0)) {
HXLINE( 217)												m16 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m16 = (( (Float)(this248) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m26;
HXDLIN( 217)											int this249 = ((maskPixel6 >> 8) & 255);
HXDLIN( 217)											if ((this249 == 0)) {
HXLINE( 217)												m26 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m26 = (( (Float)(this249) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float m36;
HXDLIN( 217)											int this250 = (maskPixel6 & 255);
HXDLIN( 217)											if ((this250 == 0)) {
HXLINE( 217)												m36 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												m36 = (( (Float)(this250) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this246 >> 24) & 255)) )));
HXDLIN( 217)											int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this246 >> 16) & 255)) )));
HXDLIN( 217)											int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this246 >> 8) & 255)) )));
HXDLIN( 217)											int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this246 & 255)) )));
HXDLIN( 217)											col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 217)									if ((col6 != 0)) {
HXLINE( 217)										int x26 = (dx7 - rectLeft6);
HXDLIN( 217)										int y26 = (dy7 - rectTop6);
HXDLIN( 217)										int c27 = col6;
HXDLIN( 217)										bool _hx_tmp61;
HXDLIN( 217)										if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 217)											_hx_tmp61 = undoImage18->transparent;
            										}
            										else {
HXLINE( 217)											_hx_tmp61 = false;
            										}
HXDLIN( 217)										if (_hx_tmp61) {
HXLINE( 217)											int location16;
HXDLIN( 217)											if (undoImage18->useVirtualPos) {
HXLINE( 217)												location16 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 217)												location16 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            											}
HXDLIN( 217)											int this251 = ::iterMagic::Iimg_obj::get(undoImage18->image,location16);
HXDLIN( 217)											int this252;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												this252 = ((((((this251 >> 24) & 255) << 24) | ((this251 & 255) << 16)) | (((this251 >> 8) & 255) << 8)) | ((this251 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												this252 = this251;
            											}
HXDLIN( 217)											Float a118;
HXDLIN( 217)											int this253 = ((this252 >> 24) & 255);
HXDLIN( 217)											if ((this253 == 0)) {
HXLINE( 217)												a118 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a118 = (( (Float)(this253) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r117;
HXDLIN( 217)											int this254 = ((this252 >> 16) & 255);
HXDLIN( 217)											if ((this254 == 0)) {
HXLINE( 217)												r117 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r117 = (( (Float)(this254) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g117;
HXDLIN( 217)											int this255 = ((this252 >> 8) & 255);
HXDLIN( 217)											if ((this255 == 0)) {
HXLINE( 217)												g117 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g117 = (( (Float)(this255) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b120;
HXDLIN( 217)											int this256 = (this252 & 255);
HXDLIN( 217)											if ((this256 == 0)) {
HXLINE( 217)												b120 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b120 = (( (Float)(this256) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a217;
HXDLIN( 217)											int this257 = ((col6 >> 24) & 255);
HXDLIN( 217)											if ((this257 == 0)) {
HXLINE( 217)												a217 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												a217 = (( (Float)(this257) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float r216;
HXDLIN( 217)											int this258 = ((col6 >> 16) & 255);
HXDLIN( 217)											if ((this258 == 0)) {
HXLINE( 217)												r216 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												r216 = (( (Float)(this258) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float g216;
HXDLIN( 217)											int this259 = ((col6 >> 8) & 255);
HXDLIN( 217)											if ((this259 == 0)) {
HXLINE( 217)												g216 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												g216 = (( (Float)(this259) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float b218;
HXDLIN( 217)											int this260 = (col6 & 255);
HXDLIN( 217)											if ((this260 == 0)) {
HXLINE( 217)												b218 = ((Float)0.);
            											}
            											else {
HXLINE( 217)												b218 = (( (Float)(this260) ) / ( (Float)(255) ));
            											}
HXDLIN( 217)											Float a317 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 217)											int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r216 * a217))));
HXDLIN( 217)											int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g216 * a217))));
HXDLIN( 217)											int b54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a217))));
HXDLIN( 217)											int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a217)));
HXDLIN( 217)											int blended16 = ((((a52 << 24) | (r38 << 16)) | (g38 << 8)) | b54);
HXDLIN( 217)											{
HXLINE( 217)												int _hx_tmp62;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp62 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp62 = blended16;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(undoImage18->image,location16,_hx_tmp62);
            											}
            										}
            										else {
HXLINE( 217)											::Dynamic this261 = undoImage18->image;
HXDLIN( 217)											int index33;
HXDLIN( 217)											if (undoImage18->useVirtualPos) {
HXLINE( 217)												index33 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 217)												index33 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            											}
HXDLIN( 217)											int _hx_tmp63;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp63 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp63 = c27;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this261,index33,_hx_tmp63);
            										}
            									}
            									else {
HXLINE( 217)										if (forceClear6) {
HXLINE( 217)											::Dynamic this262 = undoImage18->image;
HXDLIN( 217)											int x27 = (dx7 - rectLeft6);
HXDLIN( 217)											int y27 = (dy7 - rectTop6);
HXDLIN( 217)											int index34;
HXDLIN( 217)											if (undoImage18->useVirtualPos) {
HXLINE( 217)												index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x27) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 217)												index34 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage18->width) + x27)) ));
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(this262,index34,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 217)			bool found6 = false;
HXDLIN( 217)			{
HXLINE( 217)				int _g_min12 = xIter36->start;
HXDLIN( 217)				int _g_max12 = xIter36->max;
HXDLIN( 217)				while((_g_min12 < _g_max12)){
HXLINE( 217)					_g_min12 = (_g_min12 + 1);
HXDLIN( 217)					int px4 = (_g_min12 - 1);
HXDLIN( 217)					Float pcx3 = (( (Float)(px4) ) - ax);
HXLINE( 619)					found6 = false;
HXLINE( 217)					{
HXLINE( 217)						int _g_min13 = yIter36->start;
HXDLIN( 217)						int _g_max13 = yIter36->max;
HXDLIN( 217)						while((_g_min13 < _g_max13)){
HXLINE( 217)							_g_min13 = (_g_min13 + 1);
HXDLIN( 217)							int py4 = (_g_min13 - 1);
HXDLIN( 217)							Float pcy3 = (( (Float)(py4) ) - ay);
HXDLIN( 217)							Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 217)							Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 217)							Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 217)							Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 217)							Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 217)							bool _hx_tmp64;
HXDLIN( 217)							bool _hx_tmp65;
HXDLIN( 217)							if ((ratioA3 >= 0)) {
HXLINE( 217)								_hx_tmp65 = (ratioB3 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp65 = false;
            							}
HXDLIN( 217)							if (_hx_tmp65) {
HXLINE( 217)								_hx_tmp64 = (ratioC3 >= 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp64 = false;
            							}
HXDLIN( 217)							if (_hx_tmp64) {
HXLINE( 217)								int i62 = ::Std_obj::_hx_int((( (Float)(aA3) ) * (softC * ratioB3)));
HXDLIN( 217)								if ((i62 > 255)) {
HXLINE(  24)									i62 = 255;
            								}
HXLINE( 217)								if ((i62 < 0)) {
HXLINE(  25)									i62 = 0;
            								}
HXLINE( 217)								int a53 = i62;
HXDLIN( 217)								int i63 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN( 217)								if ((i63 > 255)) {
HXLINE(  24)									i63 = 255;
            								}
HXLINE( 217)								if ((i63 < 0)) {
HXLINE(  25)									i63 = 0;
            								}
HXLINE( 217)								int r39 = i63;
HXDLIN( 217)								int i64 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN( 217)								if ((i64 > 255)) {
HXLINE(  24)									i64 = 255;
            								}
HXLINE( 217)								if ((i64 < 0)) {
HXLINE(  25)									i64 = 0;
            								}
HXLINE( 217)								int g39 = i64;
HXDLIN( 217)								int i65 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN( 217)								if ((i65 > 255)) {
HXLINE(  24)									i65 = 255;
            								}
HXLINE( 217)								if ((i65 < 0)) {
HXLINE(  25)									i65 = 0;
            								}
HXLINE( 217)								int b55 = i65;
HXDLIN( 217)								{
HXLINE( 217)									int location17;
HXDLIN( 217)									if (pixelImage->useVirtualPos) {
HXLINE( 217)										location17 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 217)										location17 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            									}
HXDLIN( 217)									bool _hx_tmp66;
HXDLIN( 217)									if (pixelImage->transparent) {
HXLINE( 217)										_hx_tmp66 = (a53 < 254);
            									}
            									else {
HXLINE( 217)										_hx_tmp66 = false;
            									}
HXDLIN( 217)									if (_hx_tmp66) {
HXLINE( 217)										int this263 = ::iterMagic::Iimg_obj::get(pixelImage->image,location17);
HXDLIN( 217)										int old3;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											old3 = ((((((this263 >> 24) & 255) << 24) | ((this263 & 255) << 16)) | (((this263 >> 8) & 255) << 8)) | ((this263 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											old3 = this263;
            										}
HXDLIN( 217)										int rhs3 = ((((a53 << 24) | (r39 << 16)) | (g39 << 8)) | b55);
HXDLIN( 217)										Float a119;
HXDLIN( 217)										int this264 = ((old3 >> 24) & 255);
HXDLIN( 217)										if ((this264 == 0)) {
HXLINE( 217)											a119 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a119 = (( (Float)(this264) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r118;
HXDLIN( 217)										int this265 = ((old3 >> 16) & 255);
HXDLIN( 217)										if ((this265 == 0)) {
HXLINE( 217)											r118 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r118 = (( (Float)(this265) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g118;
HXDLIN( 217)										int this266 = ((old3 >> 8) & 255);
HXDLIN( 217)										if ((this266 == 0)) {
HXLINE( 217)											g118 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g118 = (( (Float)(this266) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b121;
HXDLIN( 217)										int this267 = (old3 & 255);
HXDLIN( 217)										if ((this267 == 0)) {
HXLINE( 217)											b121 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b121 = (( (Float)(this267) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a218;
HXDLIN( 217)										int this268 = ((rhs3 >> 24) & 255);
HXDLIN( 217)										if ((this268 == 0)) {
HXLINE( 217)											a218 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											a218 = (( (Float)(this268) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float r217;
HXDLIN( 217)										int this269 = ((rhs3 >> 16) & 255);
HXDLIN( 217)										if ((this269 == 0)) {
HXLINE( 217)											r217 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											r217 = (( (Float)(this269) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float g217;
HXDLIN( 217)										int this270 = ((rhs3 >> 8) & 255);
HXDLIN( 217)										if ((this270 == 0)) {
HXLINE( 217)											g217 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											g217 = (( (Float)(this270) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float b219;
HXDLIN( 217)										int this271 = (rhs3 & 255);
HXDLIN( 217)										if ((this271 == 0)) {
HXLINE( 217)											b219 = ((Float)0.);
            										}
            										else {
HXLINE( 217)											b219 = (( (Float)(this271) ) / ( (Float)(255) ));
            										}
HXDLIN( 217)										Float a318 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 217)										int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r217 * a218))));
HXDLIN( 217)										int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g217 * a218))));
HXDLIN( 217)										int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a218))));
HXDLIN( 217)										int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a218)));
HXDLIN( 217)										int blended17 = ((((a54 << 24) | (r40 << 16)) | (g40 << 8)) | b56);
HXDLIN( 217)										{
HXLINE( 217)											int _hx_tmp67;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												_hx_tmp67 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												_hx_tmp67 = blended17;
            											}
HXDLIN( 217)											::iterMagic::Iimg_obj::set(pixelImage->image,location17,_hx_tmp67);
            										}
            									}
            									else {
HXLINE( 217)										int value3;
HXDLIN( 217)										if (pixelImage->isLittle) {
HXLINE( 217)											value3 = ((((a53 << 24) | (b55 << 16)) | (g39 << 8)) | r39);
            										}
            										else {
HXLINE( 217)											value3 = ((((a53 << 24) | (r39 << 16)) | (g39 << 8)) | b55);
            										}
HXDLIN( 217)										::iterMagic::Iimg_obj::set(pixelImage->image,location17,value3);
            									}
            								}
HXLINE( 633)								found6 = true;
            							}
            							else {
HXLINE( 217)								if (found6) {
HXLINE( 217)									goto _hx_goto_198;
            								}
            							}
            						}
            						_hx_goto_198:;
            					}
            				}
            			}
HXDLIN( 217)			{
HXLINE( 217)				 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,dx,dy,ax,ay,true);
HXDLIN( 217)				if (hasUndo6) {
HXLINE( 217)					v17->undoImage = undoImage18;
HXDLIN( 217)					v17->undoX = xIter36->start;
HXDLIN( 217)					v17->undoY = yIter36->start;
            				}
            			}
            		}
            		else {
HXLINE( 217)			Float bx4 = dx;
HXDLIN( 217)			Float by4 = dy;
HXDLIN( 217)			Float cx4 = ax;
HXDLIN( 217)			Float cy4 = ay;
HXDLIN( 217)			bool hasUndo7 = false;
HXDLIN( 217)			bool adjustWinding3 = (((((ex * by4) - (bx4 * ey)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ey) - (ex * cy4))) > 0);
HXDLIN( 217)			if (!(adjustWinding3)) {
HXLINE( 217)				Float bx_3 = bx4;
HXDLIN( 217)				Float by_3 = by4;
HXLINE(  25)				bx4 = cx4;
HXLINE(  26)				by4 = cy4;
HXLINE(  27)				cx4 = bx_3;
HXLINE(  28)				cy4 = by_3;
            			}
HXLINE( 217)			{
HXLINE( 217)				Float s03 = ((ey * cx4) - (ex * cy4));
HXDLIN( 217)				Float sx3 = (cy4 - ey);
HXDLIN( 217)				Float sy3 = (ex - cx4);
HXDLIN( 217)				Float t03 = ((ex * by4) - (ey * bx4));
HXDLIN( 217)				Float tx3 = (ey - by4);
HXDLIN( 217)				Float ty3 = (bx4 - ex);
HXDLIN( 217)				Float A3 = ((((-(by4) * cx4) + (ey * (-(bx4) + cx4))) + (ex * (by4 - cy4))) + (bx4 * cy4));
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 217)				if ((ex > bx4)) {
HXLINE( 217)					if ((ex > cx4)) {
HXLINE( 217)						int min28;
HXDLIN( 217)						if ((bx4 > cx4)) {
HXLINE( 217)							min28 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 217)							min28 = ::Math_obj::floor(bx4);
            						}
HXDLIN( 217)						int ii_min64 = min28;
HXDLIN( 217)						int ii_max64 = ::Math_obj::ceil(ex);
HXDLIN( 217)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            					}
            					else {
HXLINE( 217)						int ii_min65 = ::Math_obj::floor(bx4);
HXDLIN( 217)						int ii_max65 = ::Math_obj::ceil(cx4);
HXDLIN( 217)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            					}
            				}
            				else {
HXLINE( 217)					if ((bx4 > cx4)) {
HXLINE( 217)						int min29;
HXDLIN( 217)						if ((ex > cx4)) {
HXLINE( 217)							min29 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 217)							min29 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 217)						int ii_min66 = min29;
HXDLIN( 217)						int ii_max66 = ::Math_obj::ceil(bx4);
HXDLIN( 217)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            					}
            					else {
HXLINE( 217)						int ii_min67 = ::Math_obj::floor(ex);
HXDLIN( 217)						int ii_max67 = ::Math_obj::ceil(cx4);
HXDLIN( 217)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 217)				if ((ey > by4)) {
HXLINE( 217)					if ((ey > cy4)) {
HXLINE( 217)						int min30;
HXDLIN( 217)						if ((by4 > cy4)) {
HXLINE( 217)							min30 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 217)							min30 = ::Math_obj::floor(by4);
            						}
HXDLIN( 217)						int ii_min68 = min30;
HXDLIN( 217)						int ii_max68 = ::Math_obj::ceil(ey);
HXDLIN( 217)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            					}
            					else {
HXLINE( 217)						int ii_min69 = ::Math_obj::floor(by4);
HXDLIN( 217)						int ii_max69 = ::Math_obj::ceil(cy4);
HXDLIN( 217)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            					}
            				}
            				else {
HXLINE( 217)					if ((by4 > cy4)) {
HXLINE( 217)						int min31;
HXDLIN( 217)						if ((ey > cy4)) {
HXLINE( 217)							min31 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 217)							min31 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 217)						int ii_min70 = min31;
HXDLIN( 217)						int ii_max70 = ::Math_obj::ceil(by4);
HXDLIN( 217)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            					}
            					else {
HXLINE( 217)						int ii_min71 = ::Math_obj::floor(ey);
HXDLIN( 217)						int ii_max71 = ::Math_obj::ceil(cy4);
HXDLIN( 217)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            					}
            				}
HXDLIN( 217)				 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 217)				if (hasUndo7) {
HXLINE( 217)					int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 217)					int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 217)					 ::Dynamic imageType7 = null();
HXDLIN( 217)					 ::pi_xy::ImageStruct this272 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 217)					if (::hx::IsNull( imageType7 )) {
HXLINE(  54)						imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 217)					::Dynamic undoImage22;
HXDLIN( 217)					switch((int)(( (int)(imageType7) ))){
            						case (int)0: {
HXLINE( 217)							 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::BytesImg b57 = byt7;
HXDLIN( 217)							{
HXLINE( 217)								b57->width = width7;
HXDLIN( 217)								b57->height = height7;
HXDLIN( 217)								b57->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 217)								b57->data = ::haxe::io::Bytes_obj::alloc((b57->length * 4));
HXDLIN( 217)								{
HXLINE( 217)									int len14 = b57->length;
HXDLIN( 217)									int w7 = 0;
HXDLIN( 217)									{
HXLINE( 217)										int _g140 = 0;
HXDLIN( 217)										int _g141 = b57->height;
HXDLIN( 217)										while((_g140 < _g141)){
HXLINE( 217)											_g140 = (_g140 + 1);
HXDLIN( 217)											int y28 = (_g140 - 1);
HXDLIN( 217)											{
HXLINE( 217)												int _g142 = 0;
HXDLIN( 217)												int _g143 = b57->width;
HXDLIN( 217)												while((_g142 < _g143)){
HXLINE( 217)													_g142 = (_g142 + 1);
HXDLIN( 217)													int x28 = (_g142 - 1);
HXDLIN( 217)													{
HXLINE( 217)														w7 = (w7 + 1);
HXDLIN( 217)														b57->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w7 = (w7 + 1);
HXDLIN( 217)														b57->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w7 = (w7 + 1);
HXDLIN( 217)														b57->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 217)													{
HXLINE( 217)														w7 = (w7 + 1);
HXDLIN( 217)														b57->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage22 = b57;
            						}
            						break;
            						case (int)1: {
HXLINE( 217)							 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::ArrIntImg a55 = arrI7;
HXDLIN( 217)							{
HXLINE( 217)								a55->width = width7;
HXDLIN( 217)								a55->height = height7;
HXDLIN( 217)								a55->data = ::Array_obj< int >::__new(0);
HXDLIN( 217)								a55->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 217)								{
HXLINE( 217)									int _g144 = 0;
HXDLIN( 217)									int _g145 = a55->length;
HXDLIN( 217)									while((_g144 < _g145)){
HXLINE( 217)										_g144 = (_g144 + 1);
HXDLIN( 217)										int i66 = (_g144 - 1);
HXDLIN( 217)										a55->data[i66] = 0;
            									}
            								}
            							}
HXDLIN( 217)							undoImage22 = a55;
            						}
            						break;
            						case (int)2: {
HXLINE( 217)							 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::U32ArrImg b58 = u32a7;
HXDLIN( 217)							{
HXLINE( 217)								b58->width = width7;
HXDLIN( 217)								b58->height = height7;
HXDLIN( 217)								b58->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 217)								int size7 = (b58->length * 4);
HXDLIN( 217)								b58->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 217)								{
HXLINE( 217)									int _g146 = 0;
HXDLIN( 217)									int _g147 = b58->length;
HXDLIN( 217)									while((_g146 < _g147)){
HXLINE( 217)										_g146 = (_g146 + 1);
HXDLIN( 217)										int i67 = (_g146 - 1);
HXDLIN( 217)										{
HXLINE( 217)											 ::haxe::io::ArrayBufferViewImpl this273 = b58->data;
HXDLIN( 217)											bool undoImage23;
HXDLIN( 217)											if ((i67 >= 0)) {
HXLINE( 217)												undoImage23 = (i67 < (this273->byteLength >> 2));
            											}
            											else {
HXLINE( 217)												undoImage23 = false;
            											}
HXDLIN( 217)											if (undoImage23) {
HXLINE( 217)												 ::haxe::io::Bytes _this7 = this273->bytes;
HXDLIN( 217)												int pos7 = ((i67 << 2) + this273->byteOffset);
HXDLIN( 217)												_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 217)												_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 217)												_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage22 = b58;
            						}
            						break;
            						case (int)3: {
HXLINE( 217)							 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::VecIntImg v18 = vec7;
HXDLIN( 217)							{
HXLINE( 217)								v18->width = width7;
HXDLIN( 217)								v18->height = height7;
HXDLIN( 217)								v18->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 217)								v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 217)								{
HXLINE( 217)									int _g148 = 0;
HXDLIN( 217)									int _g149 = v18->length;
HXDLIN( 217)									while((_g148 < _g149)){
HXLINE( 217)										_g148 = (_g148 + 1);
HXDLIN( 217)										int i68 = (_g148 - 1);
HXDLIN( 217)										v18->data->__unsafe_set(i68,0);
            									}
            								}
            							}
HXDLIN( 217)							undoImage22 = v18;
            						}
            						break;
            						case (int)4: {
HXLINE( 217)							 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 217)							 ::iterMagic::StackIntImg b59 = sInt7;
HXDLIN( 217)							{
HXLINE( 217)								b59->width = width7;
HXDLIN( 217)								b59->height = height7;
HXDLIN( 217)								b59->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 217)								b59->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 217)								{
HXLINE( 217)									int len15 = b59->length;
HXDLIN( 217)									 ::haxe::ds::GenericStack_Int d7 = b59->data;
HXDLIN( 217)									if (::hx::IsNull( d7->head )) {
HXLINE( 217)										int _g150 = 0;
HXDLIN( 217)										int _g151 = len15;
HXDLIN( 217)										while((_g150 < _g151)){
HXLINE( 217)											_g150 = (_g150 + 1);
HXDLIN( 217)											int i69 = (_g150 - 1);
HXDLIN( 217)											d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            										}
            									}
            									else {
HXLINE( 217)										int _g152 = 0;
HXDLIN( 217)										int _g153 = len15;
HXDLIN( 217)										while((_g152 < _g153)){
HXLINE( 217)											_g152 = (_g152 + 1);
HXDLIN( 217)											int i70 = (_g152 - 1);
HXDLIN( 217)											{
HXLINE( 217)												 ::haxe::ds::GenericCell_Int l7 = b59->data->head;
HXDLIN( 217)												 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 217)												{
HXLINE( 217)													int _g154 = 0;
HXDLIN( 217)													int _g155 = i70;
HXDLIN( 217)													while((_g154 < _g155)){
HXLINE( 217)														_g154 = (_g154 + 1);
HXDLIN( 217)														int i71 = (_g154 - 1);
HXLINE( 345)														prev7 = l7;
HXLINE( 346)														l7 = l7->next;
            													}
            												}
HXLINE( 217)												if (::hx::IsNull( prev7 )) {
HXLINE( 217)													b59->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 217)													l7 = null();
            												}
            												else {
HXLINE( 217)													prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 217)													l7 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 217)							undoImage22 = b59;
            						}
            						break;
            					}
HXDLIN( 217)					this272->image = undoImage22;
HXDLIN( 217)					this272->width = width7;
HXDLIN( 217)					this272->height = height7;
HXDLIN( 217)					this272->imageType = ( (int)(imageType7) );
HXDLIN( 217)					undoImage21 = this272;
HXDLIN( 217)					{
HXLINE( 217)						int rectLeft7 = xIter37->start;
HXDLIN( 217)						int rectTop7 = yIter37->start;
HXDLIN( 217)						int rectRight7 = xIter37->max;
HXDLIN( 217)						bool forceClear7 = false;
HXDLIN( 217)						{
HXLINE( 217)							int _g156 = rectTop7;
HXDLIN( 217)							int _g157 = yIter37->max;
HXDLIN( 217)							while((_g156 < _g157)){
HXLINE( 217)								_g156 = (_g156 + 1);
HXDLIN( 217)								int dy8 = (_g156 - 1);
HXDLIN( 217)								{
HXLINE( 217)									int _g158 = rectLeft7;
HXDLIN( 217)									int _g159 = rectRight7;
HXDLIN( 217)									while((_g158 < _g159)){
HXLINE( 217)										_g158 = (_g158 + 1);
HXDLIN( 217)										int dx8 = (_g158 - 1);
HXDLIN( 217)										::Dynamic this274 = pixelImage->image;
HXDLIN( 217)										int index35;
HXDLIN( 217)										if (pixelImage->useVirtualPos) {
HXLINE( 217)											index35 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx8) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 217)											index35 = ::Std_obj::_hx_int(( (Float)(((dy8 * pixelImage->width) + dx8)) ));
            										}
HXDLIN( 217)										int c28 = ::iterMagic::Iimg_obj::get(this274,index35);
HXDLIN( 217)										int col7;
HXDLIN( 217)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)											col7 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            										}
            										else {
HXLINE( 217)											col7 = c28;
            										}
HXDLIN( 217)										bool _hx_tmp68;
HXDLIN( 217)										if (pixelImage->useMask) {
HXLINE( 217)											_hx_tmp68 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 217)											_hx_tmp68 = false;
            										}
HXDLIN( 217)										if (_hx_tmp68) {
HXLINE( 217)											 ::pi_xy::ImageStruct this275 = pixelImage->mask;
HXDLIN( 217)											::Dynamic this276 = this275->image;
HXDLIN( 217)											int index36;
HXDLIN( 217)											if (this275->useVirtualPos) {
HXLINE( 217)												index36 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this275->virtualY) * ( (Float)(this275->width) )) + dx8) - this275->virtualX));
            											}
            											else {
HXLINE( 217)												index36 = ::Std_obj::_hx_int(( (Float)(((dy8 * this275->width) + dx8)) ));
            											}
HXDLIN( 217)											int c29 = ::iterMagic::Iimg_obj::get(this276,index36);
HXDLIN( 217)											int v19;
HXDLIN( 217)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)												v19 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            											}
            											else {
HXLINE( 217)												v19 = c29;
            											}
HXDLIN( 217)											int maskPixel7 = v19;
HXDLIN( 217)											int this277 = col7;
HXDLIN( 217)											if ((maskPixel7 == 0)) {
HXLINE( 217)												col7 = this277;
            											}
            											else {
HXLINE( 217)												Float m07;
HXDLIN( 217)												int this278 = ((maskPixel7 >> 24) & 255);
HXDLIN( 217)												if ((this278 == 0)) {
HXLINE( 217)													m07 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m07 = (( (Float)(this278) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m17;
HXDLIN( 217)												int this279 = ((maskPixel7 >> 16) & 255);
HXDLIN( 217)												if ((this279 == 0)) {
HXLINE( 217)													m17 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m17 = (( (Float)(this279) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m27;
HXDLIN( 217)												int this280 = ((maskPixel7 >> 8) & 255);
HXDLIN( 217)												if ((this280 == 0)) {
HXLINE( 217)													m27 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m27 = (( (Float)(this280) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float m37;
HXDLIN( 217)												int this281 = (maskPixel7 & 255);
HXDLIN( 217)												if ((this281 == 0)) {
HXLINE( 217)													m37 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													m37 = (( (Float)(this281) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this277 >> 24) & 255)) )));
HXDLIN( 217)												int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this277 >> 16) & 255)) )));
HXDLIN( 217)												int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this277 >> 8) & 255)) )));
HXDLIN( 217)												int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this277 & 255)) )));
HXDLIN( 217)												col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 217)										if ((col7 != 0)) {
HXLINE( 217)											int x29 = (dx8 - rectLeft7);
HXDLIN( 217)											int y29 = (dy8 - rectTop7);
HXDLIN( 217)											int c30 = col7;
HXDLIN( 217)											bool _hx_tmp69;
HXDLIN( 217)											if ((((c30 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp69 = undoImage21->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp69 = false;
            											}
HXDLIN( 217)											if (_hx_tmp69) {
HXLINE( 217)												int location18;
HXDLIN( 217)												if (undoImage21->useVirtualPos) {
HXLINE( 217)													location18 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x29) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 217)													location18 = ::Std_obj::_hx_int(( (Float)(((y29 * undoImage21->width) + x29)) ));
            												}
HXDLIN( 217)												int this282 = ::iterMagic::Iimg_obj::get(undoImage21->image,location18);
HXDLIN( 217)												int this283;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this283 = ((((((this282 >> 24) & 255) << 24) | ((this282 & 255) << 16)) | (((this282 >> 8) & 255) << 8)) | ((this282 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this283 = this282;
            												}
HXDLIN( 217)												Float a120;
HXDLIN( 217)												int this284 = ((this283 >> 24) & 255);
HXDLIN( 217)												if ((this284 == 0)) {
HXLINE( 217)													a120 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a120 = (( (Float)(this284) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r119;
HXDLIN( 217)												int this285 = ((this283 >> 16) & 255);
HXDLIN( 217)												if ((this285 == 0)) {
HXLINE( 217)													r119 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r119 = (( (Float)(this285) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g119;
HXDLIN( 217)												int this286 = ((this283 >> 8) & 255);
HXDLIN( 217)												if ((this286 == 0)) {
HXLINE( 217)													g119 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g119 = (( (Float)(this286) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b122;
HXDLIN( 217)												int this287 = (this283 & 255);
HXDLIN( 217)												if ((this287 == 0)) {
HXLINE( 217)													b122 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b122 = (( (Float)(this287) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a219;
HXDLIN( 217)												int this288 = ((col7 >> 24) & 255);
HXDLIN( 217)												if ((this288 == 0)) {
HXLINE( 217)													a219 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a219 = (( (Float)(this288) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r218;
HXDLIN( 217)												int this289 = ((col7 >> 16) & 255);
HXDLIN( 217)												if ((this289 == 0)) {
HXLINE( 217)													r218 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r218 = (( (Float)(this289) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g218;
HXDLIN( 217)												int this290 = ((col7 >> 8) & 255);
HXDLIN( 217)												if ((this290 == 0)) {
HXLINE( 217)													g218 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g218 = (( (Float)(this290) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b220;
HXDLIN( 217)												int this291 = (col7 & 255);
HXDLIN( 217)												if ((this291 == 0)) {
HXLINE( 217)													b220 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b220 = (( (Float)(this291) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a319 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 217)												int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r218 * a219))));
HXDLIN( 217)												int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g218 * a219))));
HXDLIN( 217)												int b60 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a219))));
HXDLIN( 217)												int a56 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a219)));
HXDLIN( 217)												int blended18 = ((((a56 << 24) | (r41 << 16)) | (g41 << 8)) | b60);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp70;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp70 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp70 = blended18;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(undoImage21->image,location18,_hx_tmp70);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this292 = undoImage21->image;
HXDLIN( 217)												int index37;
HXDLIN( 217)												if (undoImage21->useVirtualPos) {
HXLINE( 217)													index37 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x29) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 217)													index37 = ::Std_obj::_hx_int(( (Float)(((y29 * undoImage21->width) + x29)) ));
            												}
HXDLIN( 217)												int _hx_tmp71;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp71 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp71 = c30;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this292,index37,_hx_tmp71);
            											}
            										}
            										else {
HXLINE( 217)											if (forceClear7) {
HXLINE( 217)												::Dynamic this293 = undoImage21->image;
HXDLIN( 217)												int x30 = (dx8 - rectLeft7);
HXDLIN( 217)												int y30 = (dy8 - rectTop7);
HXDLIN( 217)												int index38;
HXDLIN( 217)												if (undoImage21->useVirtualPos) {
HXLINE( 217)													index38 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x30) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 217)													index38 = ::Std_obj::_hx_int(( (Float)(((y30 * undoImage21->width) + x30)) ));
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this293,index38,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 217)				bool found7 = false;
HXDLIN( 217)				Float s3 = ((Float)0.);
HXDLIN( 217)				Float t3 = ((Float)0.);
HXDLIN( 217)				Float sxx3 = ((Float)0.);
HXDLIN( 217)				Float txx3 = ((Float)0.);
HXDLIN( 217)				{
HXLINE( 217)					int _g_min14 = xIter37->start;
HXDLIN( 217)					int _g_max14 = xIter37->max;
HXDLIN( 217)					while((_g_min14 < _g_max14)){
HXLINE( 217)						_g_min14 = (_g_min14 + 1);
HXDLIN( 217)						int x31 = (_g_min14 - 1);
HXLINE(  60)						sxx3 = (sx3 * ( (Float)(x31) ));
HXLINE(  61)						txx3 = (tx3 * ( (Float)(x31) ));
HXLINE(  62)						found7 = false;
HXLINE( 217)						{
HXLINE( 217)							int _g_min15 = yIter37->start;
HXDLIN( 217)							int _g_max15 = yIter37->max;
HXDLIN( 217)							while((_g_min15 < _g_max15)){
HXLINE( 217)								_g_min15 = (_g_min15 + 1);
HXDLIN( 217)								int y31 = (_g_min15 - 1);
HXLINE(  64)								s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y31) )));
HXLINE(  65)								t3 = ((t03 + txx3) + (ty3 * ( (Float)(y31) )));
HXLINE( 217)								bool _hx_tmp72;
HXDLIN( 217)								if (!((s3 <= 0))) {
HXLINE( 217)									_hx_tmp72 = (t3 <= 0);
            								}
            								else {
HXLINE( 217)									_hx_tmp72 = true;
            								}
HXDLIN( 217)								if (_hx_tmp72) {
HXLINE( 217)									if (found7) {
HXLINE( 217)										goto _hx_goto_210;
            									}
            								}
            								else {
HXLINE( 217)									if (((s3 + t3) < A3)) {
HXLINE( 217)										{
HXLINE( 217)											int c31 = color;
HXDLIN( 217)											bool _hx_tmp73;
HXDLIN( 217)											if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 217)												_hx_tmp73 = pixelImage->transparent;
            											}
            											else {
HXLINE( 217)												_hx_tmp73 = false;
            											}
HXDLIN( 217)											if (_hx_tmp73) {
HXLINE( 217)												int location19;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													location19 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x31) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													location19 = ::Std_obj::_hx_int(( (Float)(((y31 * pixelImage->width) + x31)) ));
            												}
HXDLIN( 217)												int this294 = ::iterMagic::Iimg_obj::get(pixelImage->image,location19);
HXDLIN( 217)												int this295;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													this295 = ((((((this294 >> 24) & 255) << 24) | ((this294 & 255) << 16)) | (((this294 >> 8) & 255) << 8)) | ((this294 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													this295 = this294;
            												}
HXDLIN( 217)												Float a121;
HXDLIN( 217)												int this296 = ((this295 >> 24) & 255);
HXDLIN( 217)												if ((this296 == 0)) {
HXLINE( 217)													a121 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a121 = (( (Float)(this296) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r120;
HXDLIN( 217)												int this297 = ((this295 >> 16) & 255);
HXDLIN( 217)												if ((this297 == 0)) {
HXLINE( 217)													r120 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r120 = (( (Float)(this297) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g120;
HXDLIN( 217)												int this298 = ((this295 >> 8) & 255);
HXDLIN( 217)												if ((this298 == 0)) {
HXLINE( 217)													g120 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g120 = (( (Float)(this298) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b123;
HXDLIN( 217)												int this299 = (this295 & 255);
HXDLIN( 217)												if ((this299 == 0)) {
HXLINE( 217)													b123 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b123 = (( (Float)(this299) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a220;
HXDLIN( 217)												int this300 = ((color >> 24) & 255);
HXDLIN( 217)												if ((this300 == 0)) {
HXLINE( 217)													a220 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													a220 = (( (Float)(this300) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float r219;
HXDLIN( 217)												int this301 = ((color >> 16) & 255);
HXDLIN( 217)												if ((this301 == 0)) {
HXLINE( 217)													r219 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													r219 = (( (Float)(this301) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float g219;
HXDLIN( 217)												int this302 = ((color >> 8) & 255);
HXDLIN( 217)												if ((this302 == 0)) {
HXLINE( 217)													g219 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													g219 = (( (Float)(this302) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float b221;
HXDLIN( 217)												int this303 = (color & 255);
HXDLIN( 217)												if ((this303 == 0)) {
HXLINE( 217)													b221 = ((Float)0.);
            												}
            												else {
HXLINE( 217)													b221 = (( (Float)(this303) ) / ( (Float)(255) ));
            												}
HXDLIN( 217)												Float a320 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 217)												int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r219 * a220))));
HXDLIN( 217)												int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g219 * a220))));
HXDLIN( 217)												int b61 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a220))));
HXDLIN( 217)												int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a220)));
HXDLIN( 217)												int blended19 = ((((a57 << 24) | (r42 << 16)) | (g42 << 8)) | b61);
HXDLIN( 217)												{
HXLINE( 217)													int _hx_tmp74;
HXDLIN( 217)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)														_hx_tmp74 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            													}
            													else {
HXLINE( 217)														_hx_tmp74 = blended19;
            													}
HXDLIN( 217)													::iterMagic::Iimg_obj::set(pixelImage->image,location19,_hx_tmp74);
            												}
            											}
            											else {
HXLINE( 217)												::Dynamic this304 = pixelImage->image;
HXDLIN( 217)												int index39;
HXDLIN( 217)												if (pixelImage->useVirtualPos) {
HXLINE( 217)													index39 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x31) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 217)													index39 = ::Std_obj::_hx_int(( (Float)(((y31 * pixelImage->width) + x31)) ));
            												}
HXDLIN( 217)												int _hx_tmp75;
HXDLIN( 217)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 217)													_hx_tmp75 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            												}
            												else {
HXLINE( 217)													_hx_tmp75 = c31;
            												}
HXDLIN( 217)												::iterMagic::Iimg_obj::set(this304,index39,_hx_tmp75);
            											}
            										}
HXLINE(  73)										found7 = true;
            									}
            									else {
HXLINE( 217)										if (found7) {
HXLINE( 217)											goto _hx_goto_210;
            										}
            									}
            								}
            							}
            							_hx_goto_210:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 217)		if ((hasHit == true)) {
HXLINE( 217)			 ::pi_xy::algo::HitQuad v20 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 217)			return v20;
            		}
            		else {
HXLINE( 217)			return null();
            		}
HXDLIN( 217)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(LinePixel_Fields__obj,rotateSoftLinePartial,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateLineFlare( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick1,Float thick2,Float h,Float theta,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_226_rotateLineFlare)
HXLINE( 227)		Float sin = ::Math_obj::sin(theta);
HXLINE( 228)		Float cos = ::Math_obj::cos(theta);
HXLINE( 229)		Float radius1 = (thick1 / ( (Float)(2) ));
HXLINE( 230)		Float radius2 = (thick2 / ( (Float)(2) ));
HXLINE( 231)		Float dx = ((Float)0.1);
HXLINE( 232)		Float dy = radius1;
HXLINE( 233)		Float cx = h;
HXLINE( 234)		Float cy = radius2;
HXLINE( 235)		Float bx = h;
HXLINE( 236)		Float by = -(radius2);
HXLINE( 237)		Float ax = ((Float)0.1);
HXLINE( 238)		Float ay = -(radius1);
HXLINE( 239)		Float temp = ((Float)0.);
HXLINE( 240)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 241)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 242)		ax = temp;
HXLINE( 244)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 245)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 246)		bx = temp;
HXLINE( 248)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 249)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 250)		cx = temp;
HXLINE( 252)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 253)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 254)		dx = temp;
HXLINE( 261)		{
HXLINE( 261)			Float bx1 = bx;
HXDLIN( 261)			Float by1 = by;
HXDLIN( 261)			Float cx1 = dx;
HXDLIN( 261)			Float cy1 = dy;
HXDLIN( 261)			bool hasUndo = false;
HXDLIN( 261)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 261)			if (!(adjustWinding)) {
HXLINE( 261)				Float bx_ = bx1;
HXDLIN( 261)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE( 261)			{
HXLINE( 261)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 261)				Float sx = (cy1 - ay);
HXDLIN( 261)				Float sy = (ax - cx1);
HXDLIN( 261)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 261)				Float tx = (ay - by1);
HXDLIN( 261)				Float ty = (bx1 - ax);
HXDLIN( 261)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 261)				if ((ax > bx1)) {
HXLINE( 261)					if ((ax > cx1)) {
HXLINE( 261)						int min;
HXDLIN( 261)						if ((bx1 > cx1)) {
HXLINE( 261)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 261)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 261)						int ii_min = min;
HXDLIN( 261)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 261)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 261)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 261)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 261)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 261)					if ((bx1 > cx1)) {
HXLINE( 261)						int min1;
HXDLIN( 261)						if ((ax > cx1)) {
HXLINE( 261)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 261)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 261)						int ii_min2 = min1;
HXDLIN( 261)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 261)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 261)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 261)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 261)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 261)				if ((ay > by1)) {
HXLINE( 261)					if ((ay > cy1)) {
HXLINE( 261)						int min2;
HXDLIN( 261)						if ((by1 > cy1)) {
HXLINE( 261)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 261)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 261)						int ii_min4 = min2;
HXDLIN( 261)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 261)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 261)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 261)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 261)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 261)					if ((by1 > cy1)) {
HXLINE( 261)						int min3;
HXDLIN( 261)						if ((ay > cy1)) {
HXLINE( 261)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 261)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 261)						int ii_min6 = min3;
HXDLIN( 261)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 261)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 261)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 261)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 261)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 261)				if (hasUndo) {
HXLINE( 261)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 261)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 261)					 ::Dynamic imageType = null();
HXDLIN( 261)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 261)					::Dynamic undoImage1;
HXDLIN( 261)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 261)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 261)							{
HXLINE( 261)								b->width = width;
HXDLIN( 261)								b->height = height;
HXDLIN( 261)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 261)								{
HXLINE( 261)									int len = b->length;
HXDLIN( 261)									int w = 0;
HXDLIN( 261)									{
HXLINE( 261)										int _g = 0;
HXDLIN( 261)										int _g1 = b->height;
HXDLIN( 261)										while((_g < _g1)){
HXLINE( 261)											_g = (_g + 1);
HXDLIN( 261)											int y = (_g - 1);
HXDLIN( 261)											{
HXLINE( 261)												int _g2 = 0;
HXDLIN( 261)												int _g3 = b->width;
HXDLIN( 261)												while((_g2 < _g3)){
HXLINE( 261)													_g2 = (_g2 + 1);
HXDLIN( 261)													int x = (_g2 - 1);
HXDLIN( 261)													{
HXLINE( 261)														w = (w + 1);
HXDLIN( 261)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w = (w + 1);
HXDLIN( 261)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w = (w + 1);
HXDLIN( 261)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w = (w + 1);
HXDLIN( 261)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 261)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 261)							{
HXLINE( 261)								a->width = width;
HXDLIN( 261)								a->height = height;
HXDLIN( 261)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)								{
HXLINE( 261)									int _g4 = 0;
HXDLIN( 261)									int _g5 = a->length;
HXDLIN( 261)									while((_g4 < _g5)){
HXLINE( 261)										_g4 = (_g4 + 1);
HXDLIN( 261)										int i = (_g4 - 1);
HXDLIN( 261)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 261)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 261)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 261)							{
HXLINE( 261)								b1->width = width;
HXDLIN( 261)								b1->height = height;
HXDLIN( 261)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)								int size = (b1->length * 4);
HXDLIN( 261)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 261)								{
HXLINE( 261)									int _g6 = 0;
HXDLIN( 261)									int _g7 = b1->length;
HXDLIN( 261)									while((_g6 < _g7)){
HXLINE( 261)										_g6 = (_g6 + 1);
HXDLIN( 261)										int i1 = (_g6 - 1);
HXDLIN( 261)										{
HXLINE( 261)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 261)											bool undoImage2;
HXDLIN( 261)											if ((i1 >= 0)) {
HXLINE( 261)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE( 261)												undoImage2 = false;
            											}
HXDLIN( 261)											if (undoImage2) {
HXLINE( 261)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 261)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 261)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 261)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 261)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 261)							{
HXLINE( 261)								v->width = width;
HXDLIN( 261)								v->height = height;
HXDLIN( 261)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 261)								{
HXLINE( 261)									int _g8 = 0;
HXDLIN( 261)									int _g9 = v->length;
HXDLIN( 261)									while((_g8 < _g9)){
HXLINE( 261)										_g8 = (_g8 + 1);
HXDLIN( 261)										int i2 = (_g8 - 1);
HXDLIN( 261)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 261)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 261)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 261)							{
HXLINE( 261)								b2->width = width;
HXDLIN( 261)								b2->height = height;
HXDLIN( 261)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)								{
HXLINE( 261)									int len1 = b2->length;
HXDLIN( 261)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 261)									if (::hx::IsNull( d->head )) {
HXLINE( 261)										int _g10 = 0;
HXDLIN( 261)										int _g11 = len1;
HXDLIN( 261)										while((_g10 < _g11)){
HXLINE( 261)											_g10 = (_g10 + 1);
HXDLIN( 261)											int i3 = (_g10 - 1);
HXDLIN( 261)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 261)										int _g12 = 0;
HXDLIN( 261)										int _g13 = len1;
HXDLIN( 261)										while((_g12 < _g13)){
HXLINE( 261)											_g12 = (_g12 + 1);
HXDLIN( 261)											int i4 = (_g12 - 1);
HXDLIN( 261)											{
HXLINE( 261)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 261)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 261)												{
HXLINE( 261)													int _g14 = 0;
HXDLIN( 261)													int _g15 = i4;
HXDLIN( 261)													while((_g14 < _g15)){
HXLINE( 261)														_g14 = (_g14 + 1);
HXDLIN( 261)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 261)												if (::hx::IsNull( prev )) {
HXLINE( 261)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 261)													l = null();
            												}
            												else {
HXLINE( 261)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 261)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 261)					this1->image = undoImage1;
HXDLIN( 261)					this1->width = width;
HXDLIN( 261)					this1->height = height;
HXDLIN( 261)					this1->imageType = ( (int)(imageType) );
HXDLIN( 261)					undoImage = this1;
HXDLIN( 261)					{
HXLINE( 261)						int rectLeft = xIter3->start;
HXDLIN( 261)						int rectTop = yIter3->start;
HXDLIN( 261)						int rectRight = xIter3->max;
HXDLIN( 261)						bool forceClear = false;
HXDLIN( 261)						{
HXLINE( 261)							int _g16 = rectTop;
HXDLIN( 261)							int _g17 = yIter3->max;
HXDLIN( 261)							while((_g16 < _g17)){
HXLINE( 261)								_g16 = (_g16 + 1);
HXDLIN( 261)								int dy1 = (_g16 - 1);
HXDLIN( 261)								{
HXLINE( 261)									int _g18 = rectLeft;
HXDLIN( 261)									int _g19 = rectRight;
HXDLIN( 261)									while((_g18 < _g19)){
HXLINE( 261)										_g18 = (_g18 + 1);
HXDLIN( 261)										int dx1 = (_g18 - 1);
HXDLIN( 261)										::Dynamic this3 = pixelImage->image;
HXDLIN( 261)										int index;
HXDLIN( 261)										if (pixelImage->useVirtualPos) {
HXLINE( 261)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 261)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 261)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 261)										int col;
HXDLIN( 261)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 261)											col = c;
            										}
HXDLIN( 261)										bool _hx_tmp;
HXDLIN( 261)										if (pixelImage->useMask) {
HXLINE( 261)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 261)											_hx_tmp = false;
            										}
HXDLIN( 261)										if (_hx_tmp) {
HXLINE( 261)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 261)											::Dynamic this5 = this4->image;
HXDLIN( 261)											int index1;
HXDLIN( 261)											if (this4->useVirtualPos) {
HXLINE( 261)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE( 261)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN( 261)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 261)											int v1;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												v1 = c1;
            											}
HXDLIN( 261)											int maskPixel = v1;
HXDLIN( 261)											int this6 = col;
HXDLIN( 261)											if ((maskPixel == 0)) {
HXLINE( 261)												col = this6;
            											}
            											else {
HXLINE( 261)												Float m0;
HXDLIN( 261)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 261)												if ((this7 == 0)) {
HXLINE( 261)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m1;
HXDLIN( 261)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 261)												if ((this8 == 0)) {
HXLINE( 261)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m2;
HXDLIN( 261)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 261)												if ((this9 == 0)) {
HXLINE( 261)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m3;
HXDLIN( 261)												int this10 = (maskPixel & 255);
HXDLIN( 261)												if ((this10 == 0)) {
HXLINE( 261)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 261)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 261)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 261)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 261)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 261)										if ((col != 0)) {
HXLINE( 261)											int x1 = (dx1 - rectLeft);
HXDLIN( 261)											int y1 = (dy1 - rectTop);
HXDLIN( 261)											int c2 = col;
HXDLIN( 261)											bool _hx_tmp1;
HXDLIN( 261)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp1 = false;
            											}
HXDLIN( 261)											if (_hx_tmp1) {
HXLINE( 261)												int location;
HXDLIN( 261)												if (undoImage->useVirtualPos) {
HXLINE( 261)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 261)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 261)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 261)												int this12;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this12 = this11;
            												}
HXDLIN( 261)												Float a1;
HXDLIN( 261)												int this13 = ((this12 >> 24) & 255);
HXDLIN( 261)												if ((this13 == 0)) {
HXLINE( 261)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r1;
HXDLIN( 261)												int this14 = ((this12 >> 16) & 255);
HXDLIN( 261)												if ((this14 == 0)) {
HXLINE( 261)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g1;
HXDLIN( 261)												int this15 = ((this12 >> 8) & 255);
HXDLIN( 261)												if ((this15 == 0)) {
HXLINE( 261)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b11;
HXDLIN( 261)												int this16 = (this12 & 255);
HXDLIN( 261)												if ((this16 == 0)) {
HXLINE( 261)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a2;
HXDLIN( 261)												int this17 = ((col >> 24) & 255);
HXDLIN( 261)												if ((this17 == 0)) {
HXLINE( 261)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r2;
HXDLIN( 261)												int this18 = ((col >> 16) & 255);
HXDLIN( 261)												if ((this18 == 0)) {
HXLINE( 261)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g2;
HXDLIN( 261)												int this19 = ((col >> 8) & 255);
HXDLIN( 261)												if ((this19 == 0)) {
HXLINE( 261)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b21;
HXDLIN( 261)												int this20 = (col & 255);
HXDLIN( 261)												if ((this20 == 0)) {
HXLINE( 261)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 261)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 261)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 261)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 261)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 261)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp2;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp2 = blended;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this21 = undoImage->image;
HXDLIN( 261)												int index2;
HXDLIN( 261)												if (undoImage->useVirtualPos) {
HXLINE( 261)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 261)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 261)												int _hx_tmp3;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp3 = c2;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 261)											if (forceClear) {
HXLINE( 261)												::Dynamic this22 = undoImage->image;
HXDLIN( 261)												int x2 = (dx1 - rectLeft);
HXDLIN( 261)												int y2 = (dy1 - rectTop);
HXDLIN( 261)												int index3;
HXDLIN( 261)												if (undoImage->useVirtualPos) {
HXLINE( 261)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 261)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				bool found = false;
HXDLIN( 261)				Float s = ((Float)0.);
HXDLIN( 261)				Float t = ((Float)0.);
HXDLIN( 261)				Float sxx = ((Float)0.);
HXDLIN( 261)				Float txx = ((Float)0.);
HXDLIN( 261)				{
HXLINE( 261)					int _g_min = xIter3->start;
HXDLIN( 261)					int _g_max = xIter3->max;
HXDLIN( 261)					while((_g_min < _g_max)){
HXLINE( 261)						_g_min = (_g_min + 1);
HXDLIN( 261)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE( 261)						{
HXLINE( 261)							int _g_min1 = yIter3->start;
HXDLIN( 261)							int _g_max1 = yIter3->max;
HXDLIN( 261)							while((_g_min1 < _g_max1)){
HXLINE( 261)								_g_min1 = (_g_min1 + 1);
HXDLIN( 261)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 261)								bool _hx_tmp4;
HXDLIN( 261)								if (!((s <= 0))) {
HXLINE( 261)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp4 = true;
            								}
HXDLIN( 261)								if (_hx_tmp4) {
HXLINE( 261)									if (found) {
HXLINE( 261)										goto _hx_goto_223;
            									}
            								}
            								else {
HXLINE( 261)									if (((s + t) < A)) {
HXLINE( 261)										{
HXLINE( 261)											int c3 = color;
HXDLIN( 261)											bool _hx_tmp5;
HXDLIN( 261)											if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp5 = pixelImage->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp5 = false;
            											}
HXDLIN( 261)											if (_hx_tmp5) {
HXLINE( 261)												int location1;
HXDLIN( 261)												if (pixelImage->useVirtualPos) {
HXLINE( 261)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 261)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 261)												int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 261)												int this24;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this24 = this23;
            												}
HXDLIN( 261)												Float a11;
HXDLIN( 261)												int this25 = ((this24 >> 24) & 255);
HXDLIN( 261)												if ((this25 == 0)) {
HXLINE( 261)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r11;
HXDLIN( 261)												int this26 = ((this24 >> 16) & 255);
HXDLIN( 261)												if ((this26 == 0)) {
HXLINE( 261)													r11 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g11;
HXDLIN( 261)												int this27 = ((this24 >> 8) & 255);
HXDLIN( 261)												if ((this27 == 0)) {
HXLINE( 261)													g11 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b12;
HXDLIN( 261)												int this28 = (this24 & 255);
HXDLIN( 261)												if ((this28 == 0)) {
HXLINE( 261)													b12 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a21;
HXDLIN( 261)												int this29 = ((color >> 24) & 255);
HXDLIN( 261)												if ((this29 == 0)) {
HXLINE( 261)													a21 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r21;
HXDLIN( 261)												int this30 = ((color >> 16) & 255);
HXDLIN( 261)												if ((this30 == 0)) {
HXLINE( 261)													r21 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g21;
HXDLIN( 261)												int this31 = ((color >> 8) & 255);
HXDLIN( 261)												if ((this31 == 0)) {
HXLINE( 261)													g21 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b22;
HXDLIN( 261)												int this32 = (color & 255);
HXDLIN( 261)												if ((this32 == 0)) {
HXLINE( 261)													b22 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 261)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 261)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 261)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 261)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 261)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp6;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp6 = blended1;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this33 = pixelImage->image;
HXDLIN( 261)												int index4;
HXDLIN( 261)												if (pixelImage->useVirtualPos) {
HXLINE( 261)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 261)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 261)												int _hx_tmp7;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp7 = c3;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXLINE( 261)										if (found) {
HXLINE( 261)											goto _hx_goto_223;
            										}
            									}
            								}
            							}
            							_hx_goto_223:;
            						}
            					}
            				}
HXDLIN( 261)				if ((hasHit == true)) {
HXLINE( 261)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 261)					if (hasUndo) {
HXLINE( 261)						v2->undoImage = undoImage;
HXDLIN( 261)						v2->undoX = xIter3->start;
HXDLIN( 261)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN( 261)		{
HXLINE( 261)			Float bx2 = cx;
HXDLIN( 261)			Float by2 = cy;
HXDLIN( 261)			Float cx2 = dx;
HXDLIN( 261)			Float cy2 = dy;
HXDLIN( 261)			bool hasUndo1 = false;
HXDLIN( 261)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN( 261)			if (!(adjustWinding1)) {
HXLINE( 261)				Float bx_1 = bx2;
HXDLIN( 261)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE( 261)			{
HXLINE( 261)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN( 261)				Float sx1 = (cy2 - by);
HXDLIN( 261)				Float sy1 = (bx - cx2);
HXDLIN( 261)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN( 261)				Float tx1 = (by - by2);
HXDLIN( 261)				Float ty1 = (bx2 - bx);
HXDLIN( 261)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 261)				if ((bx > bx2)) {
HXLINE( 261)					if ((bx > cx2)) {
HXLINE( 261)						int min4;
HXDLIN( 261)						if ((bx2 > cx2)) {
HXLINE( 261)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 261)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 261)						int ii_min8 = min4;
HXDLIN( 261)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 261)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 261)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN( 261)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 261)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 261)					if ((bx2 > cx2)) {
HXLINE( 261)						int min5;
HXDLIN( 261)						if ((bx > cx2)) {
HXLINE( 261)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 261)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 261)						int ii_min10 = min5;
HXDLIN( 261)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN( 261)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 261)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 261)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 261)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 261)				if ((by > by2)) {
HXLINE( 261)					if ((by > cy2)) {
HXLINE( 261)						int min6;
HXDLIN( 261)						if ((by2 > cy2)) {
HXLINE( 261)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 261)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN( 261)						int ii_min12 = min6;
HXDLIN( 261)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 261)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 261)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN( 261)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 261)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 261)					if ((by2 > cy2)) {
HXLINE( 261)						int min7;
HXDLIN( 261)						if ((by > cy2)) {
HXLINE( 261)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 261)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN( 261)						int ii_min14 = min7;
HXDLIN( 261)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN( 261)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 261)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 261)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 261)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 261)				if (hasUndo1) {
HXLINE( 261)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 261)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 261)					 ::Dynamic imageType1 = null();
HXDLIN( 261)					 ::pi_xy::ImageStruct this34 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 261)					::Dynamic undoImage4;
HXDLIN( 261)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 261)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 261)							{
HXLINE( 261)								b5->width = width1;
HXDLIN( 261)								b5->height = height1;
HXDLIN( 261)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 261)								{
HXLINE( 261)									int len2 = b5->length;
HXDLIN( 261)									int w1 = 0;
HXDLIN( 261)									{
HXLINE( 261)										int _g20 = 0;
HXDLIN( 261)										int _g21 = b5->height;
HXDLIN( 261)										while((_g20 < _g21)){
HXLINE( 261)											_g20 = (_g20 + 1);
HXDLIN( 261)											int y4 = (_g20 - 1);
HXDLIN( 261)											{
HXLINE( 261)												int _g22 = 0;
HXDLIN( 261)												int _g23 = b5->width;
HXDLIN( 261)												while((_g22 < _g23)){
HXLINE( 261)													_g22 = (_g22 + 1);
HXDLIN( 261)													int x4 = (_g22 - 1);
HXDLIN( 261)													{
HXLINE( 261)														w1 = (w1 + 1);
HXDLIN( 261)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w1 = (w1 + 1);
HXDLIN( 261)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w1 = (w1 + 1);
HXDLIN( 261)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w1 = (w1 + 1);
HXDLIN( 261)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE( 261)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 261)							{
HXLINE( 261)								a6->width = width1;
HXDLIN( 261)								a6->height = height1;
HXDLIN( 261)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)								{
HXLINE( 261)									int _g24 = 0;
HXDLIN( 261)									int _g25 = a6->length;
HXDLIN( 261)									while((_g24 < _g25)){
HXLINE( 261)										_g24 = (_g24 + 1);
HXDLIN( 261)										int i6 = (_g24 - 1);
HXDLIN( 261)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 261)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE( 261)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 261)							{
HXLINE( 261)								b6->width = width1;
HXDLIN( 261)								b6->height = height1;
HXDLIN( 261)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)								int size1 = (b6->length * 4);
HXDLIN( 261)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 261)								{
HXLINE( 261)									int _g26 = 0;
HXDLIN( 261)									int _g27 = b6->length;
HXDLIN( 261)									while((_g26 < _g27)){
HXLINE( 261)										_g26 = (_g26 + 1);
HXDLIN( 261)										int i7 = (_g26 - 1);
HXDLIN( 261)										{
HXLINE( 261)											 ::haxe::io::ArrayBufferViewImpl this35 = b6->data;
HXDLIN( 261)											bool undoImage5;
HXDLIN( 261)											if ((i7 >= 0)) {
HXLINE( 261)												undoImage5 = (i7 < (this35->byteLength >> 2));
            											}
            											else {
HXLINE( 261)												undoImage5 = false;
            											}
HXDLIN( 261)											if (undoImage5) {
HXLINE( 261)												 ::haxe::io::Bytes _this1 = this35->bytes;
HXDLIN( 261)												int pos1 = ((i7 << 2) + this35->byteOffset);
HXDLIN( 261)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 261)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE( 261)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 261)							{
HXLINE( 261)								v3->width = width1;
HXDLIN( 261)								v3->height = height1;
HXDLIN( 261)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 261)								{
HXLINE( 261)									int _g28 = 0;
HXDLIN( 261)									int _g29 = v3->length;
HXDLIN( 261)									while((_g28 < _g29)){
HXLINE( 261)										_g28 = (_g28 + 1);
HXDLIN( 261)										int i8 = (_g28 - 1);
HXDLIN( 261)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 261)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 261)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 261)							{
HXLINE( 261)								b7->width = width1;
HXDLIN( 261)								b7->height = height1;
HXDLIN( 261)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)								{
HXLINE( 261)									int len3 = b7->length;
HXDLIN( 261)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 261)									if (::hx::IsNull( d1->head )) {
HXLINE( 261)										int _g30 = 0;
HXDLIN( 261)										int _g31 = len3;
HXDLIN( 261)										while((_g30 < _g31)){
HXLINE( 261)											_g30 = (_g30 + 1);
HXDLIN( 261)											int i9 = (_g30 - 1);
HXDLIN( 261)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 261)										int _g32 = 0;
HXDLIN( 261)										int _g33 = len3;
HXDLIN( 261)										while((_g32 < _g33)){
HXLINE( 261)											_g32 = (_g32 + 1);
HXDLIN( 261)											int i10 = (_g32 - 1);
HXDLIN( 261)											{
HXLINE( 261)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 261)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 261)												{
HXLINE( 261)													int _g34 = 0;
HXDLIN( 261)													int _g35 = i10;
HXDLIN( 261)													while((_g34 < _g35)){
HXLINE( 261)														_g34 = (_g34 + 1);
HXDLIN( 261)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 261)												if (::hx::IsNull( prev1 )) {
HXLINE( 261)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 261)													l1 = null();
            												}
            												else {
HXLINE( 261)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 261)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN( 261)					this34->image = undoImage4;
HXDLIN( 261)					this34->width = width1;
HXDLIN( 261)					this34->height = height1;
HXDLIN( 261)					this34->imageType = ( (int)(imageType1) );
HXDLIN( 261)					undoImage3 = this34;
HXDLIN( 261)					{
HXLINE( 261)						int rectLeft1 = xIter31->start;
HXDLIN( 261)						int rectTop1 = yIter31->start;
HXDLIN( 261)						int rectRight1 = xIter31->max;
HXDLIN( 261)						bool forceClear1 = false;
HXDLIN( 261)						{
HXLINE( 261)							int _g36 = rectTop1;
HXDLIN( 261)							int _g37 = yIter31->max;
HXDLIN( 261)							while((_g36 < _g37)){
HXLINE( 261)								_g36 = (_g36 + 1);
HXDLIN( 261)								int dy2 = (_g36 - 1);
HXDLIN( 261)								{
HXLINE( 261)									int _g38 = rectLeft1;
HXDLIN( 261)									int _g39 = rectRight1;
HXDLIN( 261)									while((_g38 < _g39)){
HXLINE( 261)										_g38 = (_g38 + 1);
HXDLIN( 261)										int dx2 = (_g38 - 1);
HXDLIN( 261)										::Dynamic this36 = pixelImage->image;
HXDLIN( 261)										int index5;
HXDLIN( 261)										if (pixelImage->useVirtualPos) {
HXLINE( 261)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 261)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 261)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 261)										int col1;
HXDLIN( 261)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)											col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 261)											col1 = c4;
            										}
HXDLIN( 261)										bool _hx_tmp8;
HXDLIN( 261)										if (pixelImage->useMask) {
HXLINE( 261)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 261)											_hx_tmp8 = false;
            										}
HXDLIN( 261)										if (_hx_tmp8) {
HXLINE( 261)											 ::pi_xy::ImageStruct this37 = pixelImage->mask;
HXDLIN( 261)											::Dynamic this38 = this37->image;
HXDLIN( 261)											int index6;
HXDLIN( 261)											if (this37->useVirtualPos) {
HXLINE( 261)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx2) - this37->virtualX));
            											}
            											else {
HXLINE( 261)												index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this37->width) + dx2)) ));
            											}
HXDLIN( 261)											int c5 = ::iterMagic::Iimg_obj::get(this38,index6);
HXDLIN( 261)											int v4;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												v4 = c5;
            											}
HXDLIN( 261)											int maskPixel1 = v4;
HXDLIN( 261)											int this39 = col1;
HXDLIN( 261)											if ((maskPixel1 == 0)) {
HXLINE( 261)												col1 = this39;
            											}
            											else {
HXLINE( 261)												Float m01;
HXDLIN( 261)												int this40 = ((maskPixel1 >> 24) & 255);
HXDLIN( 261)												if ((this40 == 0)) {
HXLINE( 261)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m01 = (( (Float)(this40) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m11;
HXDLIN( 261)												int this41 = ((maskPixel1 >> 16) & 255);
HXDLIN( 261)												if ((this41 == 0)) {
HXLINE( 261)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m11 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m21;
HXDLIN( 261)												int this42 = ((maskPixel1 >> 8) & 255);
HXDLIN( 261)												if ((this42 == 0)) {
HXLINE( 261)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m21 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m31;
HXDLIN( 261)												int this43 = (maskPixel1 & 255);
HXDLIN( 261)												if ((this43 == 0)) {
HXLINE( 261)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m31 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this39 >> 24) & 255)) )));
HXDLIN( 261)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this39 >> 16) & 255)) )));
HXDLIN( 261)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this39 >> 8) & 255)) )));
HXDLIN( 261)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this39 & 255)) )));
HXDLIN( 261)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 261)										if ((col1 != 0)) {
HXLINE( 261)											int x5 = (dx2 - rectLeft1);
HXDLIN( 261)											int y5 = (dy2 - rectTop1);
HXDLIN( 261)											int c6 = col1;
HXDLIN( 261)											bool _hx_tmp9;
HXDLIN( 261)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp9 = false;
            											}
HXDLIN( 261)											if (_hx_tmp9) {
HXLINE( 261)												int location2;
HXDLIN( 261)												if (undoImage3->useVirtualPos) {
HXLINE( 261)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 261)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 261)												int this44 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 261)												int this45;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this45 = ((((((this44 >> 24) & 255) << 24) | ((this44 & 255) << 16)) | (((this44 >> 8) & 255) << 8)) | ((this44 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this45 = this44;
            												}
HXDLIN( 261)												Float a12;
HXDLIN( 261)												int this46 = ((this45 >> 24) & 255);
HXDLIN( 261)												if ((this46 == 0)) {
HXLINE( 261)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a12 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r12;
HXDLIN( 261)												int this47 = ((this45 >> 16) & 255);
HXDLIN( 261)												if ((this47 == 0)) {
HXLINE( 261)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g12;
HXDLIN( 261)												int this48 = ((this45 >> 8) & 255);
HXDLIN( 261)												if ((this48 == 0)) {
HXLINE( 261)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b13;
HXDLIN( 261)												int this49 = (this45 & 255);
HXDLIN( 261)												if ((this49 == 0)) {
HXLINE( 261)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b13 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a22;
HXDLIN( 261)												int this50 = ((col1 >> 24) & 255);
HXDLIN( 261)												if ((this50 == 0)) {
HXLINE( 261)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a22 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r22;
HXDLIN( 261)												int this51 = ((col1 >> 16) & 255);
HXDLIN( 261)												if ((this51 == 0)) {
HXLINE( 261)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g22;
HXDLIN( 261)												int this52 = ((col1 >> 8) & 255);
HXDLIN( 261)												if ((this52 == 0)) {
HXLINE( 261)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b23;
HXDLIN( 261)												int this53 = (col1 & 255);
HXDLIN( 261)												if ((this53 == 0)) {
HXLINE( 261)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b23 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 261)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 261)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 261)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 261)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 261)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp10;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp10 = blended2;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this54 = undoImage3->image;
HXDLIN( 261)												int index7;
HXDLIN( 261)												if (undoImage3->useVirtualPos) {
HXLINE( 261)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 261)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 261)												int _hx_tmp11;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp11 = c6;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this54,index7,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 261)											if (forceClear1) {
HXLINE( 261)												::Dynamic this55 = undoImage3->image;
HXDLIN( 261)												int x6 = (dx2 - rectLeft1);
HXDLIN( 261)												int y6 = (dy2 - rectTop1);
HXDLIN( 261)												int index8;
HXDLIN( 261)												if (undoImage3->useVirtualPos) {
HXLINE( 261)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 261)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this55,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				bool found1 = false;
HXDLIN( 261)				Float s1 = ((Float)0.);
HXDLIN( 261)				Float t1 = ((Float)0.);
HXDLIN( 261)				Float sxx1 = ((Float)0.);
HXDLIN( 261)				Float txx1 = ((Float)0.);
HXDLIN( 261)				{
HXLINE( 261)					int _g_min2 = xIter31->start;
HXDLIN( 261)					int _g_max2 = xIter31->max;
HXDLIN( 261)					while((_g_min2 < _g_max2)){
HXLINE( 261)						_g_min2 = (_g_min2 + 1);
HXDLIN( 261)						int x7 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)						found1 = false;
HXLINE( 261)						{
HXLINE( 261)							int _g_min3 = yIter31->start;
HXDLIN( 261)							int _g_max3 = yIter31->max;
HXDLIN( 261)							while((_g_min3 < _g_max3)){
HXLINE( 261)								_g_min3 = (_g_min3 + 1);
HXDLIN( 261)								int y7 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 261)								bool _hx_tmp12;
HXDLIN( 261)								if (!((s1 <= 0))) {
HXLINE( 261)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp12 = true;
            								}
HXDLIN( 261)								if (_hx_tmp12) {
HXLINE( 261)									if (found1) {
HXLINE( 261)										goto _hx_goto_235;
            									}
            								}
            								else {
HXLINE( 261)									if (((s1 + t1) < A1)) {
HXLINE( 261)										{
HXLINE( 261)											int c7 = color;
HXDLIN( 261)											bool _hx_tmp13;
HXDLIN( 261)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp13 = false;
            											}
HXDLIN( 261)											if (_hx_tmp13) {
HXLINE( 261)												int location3;
HXDLIN( 261)												if (pixelImage->useVirtualPos) {
HXLINE( 261)													location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 261)													location3 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN( 261)												int this56 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 261)												int this57;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this57 = ((((((this56 >> 24) & 255) << 24) | ((this56 & 255) << 16)) | (((this56 >> 8) & 255) << 8)) | ((this56 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this57 = this56;
            												}
HXDLIN( 261)												Float a13;
HXDLIN( 261)												int this58 = ((this57 >> 24) & 255);
HXDLIN( 261)												if ((this58 == 0)) {
HXLINE( 261)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r13;
HXDLIN( 261)												int this59 = ((this57 >> 16) & 255);
HXDLIN( 261)												if ((this59 == 0)) {
HXLINE( 261)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r13 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g13;
HXDLIN( 261)												int this60 = ((this57 >> 8) & 255);
HXDLIN( 261)												if ((this60 == 0)) {
HXLINE( 261)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b14;
HXDLIN( 261)												int this61 = (this57 & 255);
HXDLIN( 261)												if ((this61 == 0)) {
HXLINE( 261)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b14 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a23;
HXDLIN( 261)												int this62 = ((color >> 24) & 255);
HXDLIN( 261)												if ((this62 == 0)) {
HXLINE( 261)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r23;
HXDLIN( 261)												int this63 = ((color >> 16) & 255);
HXDLIN( 261)												if ((this63 == 0)) {
HXLINE( 261)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r23 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g23;
HXDLIN( 261)												int this64 = ((color >> 8) & 255);
HXDLIN( 261)												if ((this64 == 0)) {
HXLINE( 261)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b24;
HXDLIN( 261)												int this65 = (color & 255);
HXDLIN( 261)												if ((this65 == 0)) {
HXLINE( 261)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b24 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 261)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 261)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 261)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 261)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 261)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp14;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp14 = blended3;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this66 = pixelImage->image;
HXDLIN( 261)												int index9;
HXDLIN( 261)												if (pixelImage->useVirtualPos) {
HXLINE( 261)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 261)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN( 261)												int _hx_tmp15;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp15 = c7;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this66,index9,_hx_tmp15);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE( 261)										if (found1) {
HXLINE( 261)											goto _hx_goto_235;
            										}
            									}
            								}
            							}
            							_hx_goto_235:;
            						}
            					}
            				}
HXDLIN( 261)				if ((hasHit == true)) {
HXLINE( 261)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN( 261)					if (hasUndo1) {
HXLINE( 261)						v5->undoImage = undoImage3;
HXDLIN( 261)						v5->undoX = xIter31->start;
HXDLIN( 261)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN( 261)		if ((hasHit == true)) {
HXLINE( 261)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 261)			return v6;
            		}
            		else {
HXLINE( 261)			return null();
            		}
HXDLIN( 261)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(LinePixel_Fields__obj,rotateLineFlare,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateSoftLineFlare( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick1,Float thick2,Float h,Float theta,int color,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_softTop,::hx::Null< bool >  __o_softRight,::hx::Null< bool >  __o_softBottom,::hx::Null< bool >  __o_softLeft,::hx::Null< bool >  __o_hasHit){
            		Float softC = __o_softC.Default(((Float)10.));
            		bool softTop = __o_softTop.Default(true);
            		bool softRight = __o_softRight.Default(true);
            		bool softBottom = __o_softBottom.Default(true);
            		bool softLeft = __o_softLeft.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_274_rotateSoftLineFlare)
HXLINE( 275)		Float sin = ::Math_obj::sin(theta);
HXLINE( 276)		Float cos = ::Math_obj::cos(theta);
HXLINE( 277)		Float radius1 = (thick1 / ( (Float)(2) ));
HXLINE( 278)		Float radius2 = (thick2 / ( (Float)(2) ));
HXLINE( 279)		Float dx = ((Float)0.1);
HXLINE( 280)		Float dy = radius1;
HXLINE( 281)		Float cx = h;
HXLINE( 282)		Float cy = radius2;
HXLINE( 283)		Float bx = h;
HXLINE( 284)		Float by = -(radius2);
HXLINE( 285)		Float ax = ((Float)0.1);
HXLINE( 286)		Float ay = -(radius1);
HXLINE( 287)		Float temp = ((Float)0.);
HXLINE( 288)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)		ax = temp;
HXLINE( 292)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)		bx = temp;
HXLINE( 296)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)		cx = temp;
HXLINE( 300)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)		dx = temp;
HXLINE( 309)		Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN( 309)		Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN( 309)		if (softTop) {
HXLINE( 309)			bool hasUndo = false;
HXDLIN( 309)			int aA = ((color >> 24) & 255);
HXDLIN( 309)			int rA = ((color >> 16) & 255);
HXDLIN( 309)			int gA = ((color >> 8) & 255);
HXDLIN( 309)			int bA = (color & 255);
HXDLIN( 309)			Float bcx = (ax - bx);
HXDLIN( 309)			Float bcy = (ay - by);
HXDLIN( 309)			Float acx = (ex - bx);
HXDLIN( 309)			Float acy = (ey - by);
HXDLIN( 309)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 309)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 309)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 309)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 309)			if ((ex > ax)) {
HXLINE( 309)				if ((ex > bx)) {
HXLINE( 309)					int min;
HXDLIN( 309)					if ((ax > bx)) {
HXLINE( 309)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 309)						min = ::Math_obj::floor(ax);
            					}
HXDLIN( 309)					int ii_min = min;
HXDLIN( 309)					int ii_max = ::Math_obj::ceil(ex);
HXDLIN( 309)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 309)					int ii_min1 = ::Math_obj::floor(ax);
HXDLIN( 309)					int ii_max1 = ::Math_obj::ceil(bx);
HXDLIN( 309)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 309)				if ((ax > bx)) {
HXLINE( 309)					int min1;
HXDLIN( 309)					if ((ex > bx)) {
HXLINE( 309)						min1 = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 309)						min1 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 309)					int ii_min2 = min1;
HXDLIN( 309)					int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN( 309)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 309)					int ii_min3 = ::Math_obj::floor(ex);
HXDLIN( 309)					int ii_max3 = ::Math_obj::ceil(bx);
HXDLIN( 309)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 309)			if ((ey > ay)) {
HXLINE( 309)				if ((ey > by)) {
HXLINE( 309)					int min2;
HXDLIN( 309)					if ((ay > by)) {
HXLINE( 309)						min2 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 309)						min2 = ::Math_obj::floor(ay);
            					}
HXDLIN( 309)					int ii_min4 = min2;
HXDLIN( 309)					int ii_max4 = ::Math_obj::ceil(ey);
HXDLIN( 309)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 309)					int ii_min5 = ::Math_obj::floor(ay);
HXDLIN( 309)					int ii_max5 = ::Math_obj::ceil(by);
HXDLIN( 309)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 309)				if ((ay > by)) {
HXLINE( 309)					int min3;
HXDLIN( 309)					if ((ey > by)) {
HXLINE( 309)						min3 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 309)						min3 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 309)					int ii_min6 = min3;
HXDLIN( 309)					int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN( 309)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 309)					int ii_min7 = ::Math_obj::floor(ey);
HXDLIN( 309)					int ii_max7 = ::Math_obj::ceil(by);
HXDLIN( 309)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 309)			if (hasUndo) {
HXLINE( 309)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 309)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 309)				 ::Dynamic imageType = null();
HXDLIN( 309)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 309)				::Dynamic undoImage1;
HXDLIN( 309)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 309)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 309)						{
HXLINE( 309)							b->width = width;
HXDLIN( 309)							b->height = height;
HXDLIN( 309)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 309)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 309)							{
HXLINE( 309)								int len = b->length;
HXDLIN( 309)								int w = 0;
HXDLIN( 309)								{
HXLINE( 309)									int _g = 0;
HXDLIN( 309)									int _g1 = b->height;
HXDLIN( 309)									while((_g < _g1)){
HXLINE( 309)										_g = (_g + 1);
HXDLIN( 309)										int y = (_g - 1);
HXDLIN( 309)										{
HXLINE( 309)											int _g2 = 0;
HXDLIN( 309)											int _g3 = b->width;
HXDLIN( 309)											while((_g2 < _g3)){
HXLINE( 309)												_g2 = (_g2 + 1);
HXDLIN( 309)												int x = (_g2 - 1);
HXDLIN( 309)												{
HXLINE( 309)													w = (w + 1);
HXDLIN( 309)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w = (w + 1);
HXDLIN( 309)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w = (w + 1);
HXDLIN( 309)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w = (w + 1);
HXDLIN( 309)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 309)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 309)						{
HXLINE( 309)							a->width = width;
HXDLIN( 309)							a->height = height;
HXDLIN( 309)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 309)							{
HXLINE( 309)								int _g4 = 0;
HXDLIN( 309)								int _g5 = a->length;
HXDLIN( 309)								while((_g4 < _g5)){
HXLINE( 309)									_g4 = (_g4 + 1);
HXDLIN( 309)									int i = (_g4 - 1);
HXDLIN( 309)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 309)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 309)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 309)						{
HXLINE( 309)							b1->width = width;
HXDLIN( 309)							b1->height = height;
HXDLIN( 309)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 309)							int size = (b1->length * 4);
HXDLIN( 309)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 309)							{
HXLINE( 309)								int _g6 = 0;
HXDLIN( 309)								int _g7 = b1->length;
HXDLIN( 309)								while((_g6 < _g7)){
HXLINE( 309)									_g6 = (_g6 + 1);
HXDLIN( 309)									int i1 = (_g6 - 1);
HXDLIN( 309)									{
HXLINE( 309)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 309)										bool undoImage2;
HXDLIN( 309)										if ((i1 >= 0)) {
HXLINE( 309)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 309)											undoImage2 = false;
            										}
HXDLIN( 309)										if (undoImage2) {
HXLINE( 309)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 309)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 309)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 309)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 309)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 309)						{
HXLINE( 309)							v->width = width;
HXDLIN( 309)							v->height = height;
HXDLIN( 309)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 309)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 309)							{
HXLINE( 309)								int _g8 = 0;
HXDLIN( 309)								int _g9 = v->length;
HXDLIN( 309)								while((_g8 < _g9)){
HXLINE( 309)									_g8 = (_g8 + 1);
HXDLIN( 309)									int i2 = (_g8 - 1);
HXDLIN( 309)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 309)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 309)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 309)						{
HXLINE( 309)							b2->width = width;
HXDLIN( 309)							b2->height = height;
HXDLIN( 309)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 309)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)							{
HXLINE( 309)								int len1 = b2->length;
HXDLIN( 309)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 309)								if (::hx::IsNull( d->head )) {
HXLINE( 309)									int _g10 = 0;
HXDLIN( 309)									int _g11 = len1;
HXDLIN( 309)									while((_g10 < _g11)){
HXLINE( 309)										_g10 = (_g10 + 1);
HXDLIN( 309)										int i3 = (_g10 - 1);
HXDLIN( 309)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 309)									int _g12 = 0;
HXDLIN( 309)									int _g13 = len1;
HXDLIN( 309)									while((_g12 < _g13)){
HXLINE( 309)										_g12 = (_g12 + 1);
HXDLIN( 309)										int i4 = (_g12 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 309)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 309)											{
HXLINE( 309)												int _g14 = 0;
HXDLIN( 309)												int _g15 = i4;
HXDLIN( 309)												while((_g14 < _g15)){
HXLINE( 309)													_g14 = (_g14 + 1);
HXDLIN( 309)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 309)											if (::hx::IsNull( prev )) {
HXLINE( 309)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 309)												l = null();
            											}
            											else {
HXLINE( 309)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 309)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 309)				this1->image = undoImage1;
HXDLIN( 309)				this1->width = width;
HXDLIN( 309)				this1->height = height;
HXDLIN( 309)				this1->imageType = ( (int)(imageType) );
HXDLIN( 309)				undoImage = this1;
HXDLIN( 309)				{
HXLINE( 309)					int rectLeft = xIter3->start;
HXDLIN( 309)					int rectTop = yIter3->start;
HXDLIN( 309)					int rectRight = xIter3->max;
HXDLIN( 309)					bool forceClear = false;
HXDLIN( 309)					{
HXLINE( 309)						int _g16 = rectTop;
HXDLIN( 309)						int _g17 = yIter3->max;
HXDLIN( 309)						while((_g16 < _g17)){
HXLINE( 309)							_g16 = (_g16 + 1);
HXDLIN( 309)							int dy1 = (_g16 - 1);
HXDLIN( 309)							{
HXLINE( 309)								int _g18 = rectLeft;
HXDLIN( 309)								int _g19 = rectRight;
HXDLIN( 309)								while((_g18 < _g19)){
HXLINE( 309)									_g18 = (_g18 + 1);
HXDLIN( 309)									int dx1 = (_g18 - 1);
HXDLIN( 309)									::Dynamic this3 = pixelImage->image;
HXDLIN( 309)									int index;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 309)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 309)									int col;
HXDLIN( 309)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 309)										col = c;
            									}
HXDLIN( 309)									bool _hx_tmp;
HXDLIN( 309)									if (pixelImage->useMask) {
HXLINE( 309)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 309)										_hx_tmp = false;
            									}
HXDLIN( 309)									if (_hx_tmp) {
HXLINE( 309)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 309)										::Dynamic this5 = this4->image;
HXDLIN( 309)										int index1;
HXDLIN( 309)										if (this4->useVirtualPos) {
HXLINE( 309)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 309)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 309)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 309)										int v1;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											v1 = c1;
            										}
HXDLIN( 309)										int maskPixel = v1;
HXDLIN( 309)										int this6 = col;
HXDLIN( 309)										if ((maskPixel == 0)) {
HXLINE( 309)											col = this6;
            										}
            										else {
HXLINE( 309)											Float m0;
HXDLIN( 309)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 309)											if ((this7 == 0)) {
HXLINE( 309)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m1;
HXDLIN( 309)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 309)											if ((this8 == 0)) {
HXLINE( 309)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m2;
HXDLIN( 309)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 309)											if ((this9 == 0)) {
HXLINE( 309)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m3;
HXDLIN( 309)											int this10 = (maskPixel & 255);
HXDLIN( 309)											if ((this10 == 0)) {
HXLINE( 309)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 309)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 309)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 309)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 309)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 309)									if ((col != 0)) {
HXLINE( 309)										int x1 = (dx1 - rectLeft);
HXDLIN( 309)										int y1 = (dy1 - rectTop);
HXDLIN( 309)										int c2 = col;
HXDLIN( 309)										bool _hx_tmp1;
HXDLIN( 309)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 309)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 309)											_hx_tmp1 = false;
            										}
HXDLIN( 309)										if (_hx_tmp1) {
HXLINE( 309)											int location;
HXDLIN( 309)											if (undoImage->useVirtualPos) {
HXLINE( 309)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 309)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 309)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 309)											int this12;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												this12 = this11;
            											}
HXDLIN( 309)											Float a1;
HXDLIN( 309)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 309)											if ((this13 == 0)) {
HXLINE( 309)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r1;
HXDLIN( 309)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 309)											if ((this14 == 0)) {
HXLINE( 309)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g1;
HXDLIN( 309)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 309)											if ((this15 == 0)) {
HXLINE( 309)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b11;
HXDLIN( 309)											int this16 = (this12 & 255);
HXDLIN( 309)											if ((this16 == 0)) {
HXLINE( 309)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a2;
HXDLIN( 309)											int this17 = ((col >> 24) & 255);
HXDLIN( 309)											if ((this17 == 0)) {
HXLINE( 309)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r2;
HXDLIN( 309)											int this18 = ((col >> 16) & 255);
HXDLIN( 309)											if ((this18 == 0)) {
HXLINE( 309)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g2;
HXDLIN( 309)											int this19 = ((col >> 8) & 255);
HXDLIN( 309)											if ((this19 == 0)) {
HXLINE( 309)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b21;
HXDLIN( 309)											int this20 = (col & 255);
HXDLIN( 309)											if ((this20 == 0)) {
HXLINE( 309)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 309)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 309)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 309)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 309)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 309)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 309)											{
HXLINE( 309)												int _hx_tmp2;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp2 = blended;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 309)											::Dynamic this21 = undoImage->image;
HXDLIN( 309)											int index2;
HXDLIN( 309)											if (undoImage->useVirtualPos) {
HXLINE( 309)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 309)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 309)											int _hx_tmp3;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp3 = c2;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 309)										if (forceClear) {
HXLINE( 309)											::Dynamic this22 = undoImage->image;
HXDLIN( 309)											int x2 = (dx1 - rectLeft);
HXDLIN( 309)											int y2 = (dy1 - rectTop);
HXDLIN( 309)											int index3;
HXDLIN( 309)											if (undoImage->useVirtualPos) {
HXLINE( 309)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 309)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 309)			bool found = false;
HXDLIN( 309)			{
HXLINE( 309)				int _g_min = xIter3->start;
HXDLIN( 309)				int _g_max = xIter3->max;
HXDLIN( 309)				while((_g_min < _g_max)){
HXLINE( 309)					_g_min = (_g_min + 1);
HXDLIN( 309)					int px1 = (_g_min - 1);
HXDLIN( 309)					Float pcx = (( (Float)(px1) ) - bx);
HXLINE( 619)					found = false;
HXLINE( 309)					{
HXLINE( 309)						int _g_min1 = yIter3->start;
HXDLIN( 309)						int _g_max1 = yIter3->max;
HXDLIN( 309)						while((_g_min1 < _g_max1)){
HXLINE( 309)							_g_min1 = (_g_min1 + 1);
HXDLIN( 309)							int py1 = (_g_min1 - 1);
HXDLIN( 309)							Float pcy = (( (Float)(py1) ) - by);
HXDLIN( 309)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 309)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 309)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 309)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 309)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 309)							bool _hx_tmp4;
HXDLIN( 309)							bool _hx_tmp5;
HXDLIN( 309)							if ((ratioA >= 0)) {
HXLINE( 309)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp5 = false;
            							}
HXDLIN( 309)							if (_hx_tmp5) {
HXLINE( 309)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp4 = false;
            							}
HXDLIN( 309)							if (_hx_tmp4) {
HXLINE( 309)								int i6 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 309)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 309)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 309)								int a5 = i6;
HXDLIN( 309)								int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 309)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 309)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 309)								int r3 = i7;
HXDLIN( 309)								int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 309)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 309)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 309)								int g3 = i8;
HXDLIN( 309)								int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 309)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 309)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 309)								int b4 = i9;
HXDLIN( 309)								{
HXLINE( 309)									int location1;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										location1 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 309)									bool _hx_tmp6;
HXDLIN( 309)									if (pixelImage->transparent) {
HXLINE( 309)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE( 309)										_hx_tmp6 = false;
            									}
HXDLIN( 309)									if (_hx_tmp6) {
HXLINE( 309)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 309)										int old;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											old = this23;
            										}
HXDLIN( 309)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 309)										Float a11;
HXDLIN( 309)										int this24 = ((old >> 24) & 255);
HXDLIN( 309)										if ((this24 == 0)) {
HXLINE( 309)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r11;
HXDLIN( 309)										int this25 = ((old >> 16) & 255);
HXDLIN( 309)										if ((this25 == 0)) {
HXLINE( 309)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g11;
HXDLIN( 309)										int this26 = ((old >> 8) & 255);
HXDLIN( 309)										if ((this26 == 0)) {
HXLINE( 309)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b12;
HXDLIN( 309)										int this27 = (old & 255);
HXDLIN( 309)										if ((this27 == 0)) {
HXLINE( 309)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a21;
HXDLIN( 309)										int this28 = ((rhs >> 24) & 255);
HXDLIN( 309)										if ((this28 == 0)) {
HXLINE( 309)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r21;
HXDLIN( 309)										int this29 = ((rhs >> 16) & 255);
HXDLIN( 309)										if ((this29 == 0)) {
HXLINE( 309)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g21;
HXDLIN( 309)										int this30 = ((rhs >> 8) & 255);
HXDLIN( 309)										if ((this30 == 0)) {
HXLINE( 309)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b22;
HXDLIN( 309)										int this31 = (rhs & 255);
HXDLIN( 309)										if ((this31 == 0)) {
HXLINE( 309)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 309)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 309)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 309)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 309)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 309)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 309)										{
HXLINE( 309)											int _hx_tmp7;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp7 = blended1;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE( 309)										int value;
HXDLIN( 309)										if (pixelImage->isLittle) {
HXLINE( 309)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 309)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 309)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
HXLINE( 633)								found = true;
            							}
            							else {
HXLINE( 309)								if (found) {
HXLINE( 309)									goto _hx_goto_248;
            								}
            							}
            						}
            						_hx_goto_248:;
            					}
            				}
            			}
HXDLIN( 309)			{
HXLINE( 309)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,ax,ay,bx,by,true);
HXDLIN( 309)				if (hasUndo) {
HXLINE( 309)					v2->undoImage = undoImage;
HXDLIN( 309)					v2->undoX = xIter3->start;
HXDLIN( 309)					v2->undoY = yIter3->start;
            				}
            			}
            		}
            		else {
HXLINE( 309)			Float bx1 = ax;
HXDLIN( 309)			Float by1 = ay;
HXDLIN( 309)			Float cx1 = bx;
HXDLIN( 309)			Float cy1 = by;
HXDLIN( 309)			bool hasUndo1 = false;
HXDLIN( 309)			bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN( 309)			if (!(adjustWinding)) {
HXLINE( 309)				Float bx_ = bx1;
HXDLIN( 309)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE( 309)			{
HXLINE( 309)				Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN( 309)				Float sx = (cy1 - ey);
HXDLIN( 309)				Float sy = (ex - cx1);
HXDLIN( 309)				Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN( 309)				Float tx = (ey - by1);
HXDLIN( 309)				Float ty = (bx1 - ex);
HXDLIN( 309)				Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 309)				if ((ex > bx1)) {
HXLINE( 309)					if ((ex > cx1)) {
HXLINE( 309)						int min4;
HXDLIN( 309)						if ((bx1 > cx1)) {
HXLINE( 309)							min4 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 309)							min4 = ::Math_obj::floor(bx1);
            						}
HXDLIN( 309)						int ii_min8 = min4;
HXDLIN( 309)						int ii_max8 = ::Math_obj::ceil(ex);
HXDLIN( 309)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 309)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 309)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN( 309)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 309)					if ((bx1 > cx1)) {
HXLINE( 309)						int min5;
HXDLIN( 309)						if ((ex > cx1)) {
HXLINE( 309)							min5 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 309)							min5 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 309)						int ii_min10 = min5;
HXDLIN( 309)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 309)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 309)						int ii_min11 = ::Math_obj::floor(ex);
HXDLIN( 309)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN( 309)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 309)				if ((ey > by1)) {
HXLINE( 309)					if ((ey > cy1)) {
HXLINE( 309)						int min6;
HXDLIN( 309)						if ((by1 > cy1)) {
HXLINE( 309)							min6 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 309)							min6 = ::Math_obj::floor(by1);
            						}
HXDLIN( 309)						int ii_min12 = min6;
HXDLIN( 309)						int ii_max12 = ::Math_obj::ceil(ey);
HXDLIN( 309)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 309)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 309)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN( 309)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 309)					if ((by1 > cy1)) {
HXLINE( 309)						int min7;
HXDLIN( 309)						if ((ey > cy1)) {
HXLINE( 309)							min7 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 309)							min7 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 309)						int ii_min14 = min7;
HXDLIN( 309)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 309)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 309)						int ii_min15 = ::Math_obj::floor(ey);
HXDLIN( 309)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN( 309)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 309)				if (hasUndo1) {
HXLINE( 309)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 309)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 309)					 ::Dynamic imageType1 = null();
HXDLIN( 309)					 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 309)					::Dynamic undoImage4;
HXDLIN( 309)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 309)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 309)							{
HXLINE( 309)								b6->width = width1;
HXDLIN( 309)								b6->height = height1;
HXDLIN( 309)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 309)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 309)								{
HXLINE( 309)									int len2 = b6->length;
HXDLIN( 309)									int w1 = 0;
HXDLIN( 309)									{
HXLINE( 309)										int _g20 = 0;
HXDLIN( 309)										int _g21 = b6->height;
HXDLIN( 309)										while((_g20 < _g21)){
HXLINE( 309)											_g20 = (_g20 + 1);
HXDLIN( 309)											int y3 = (_g20 - 1);
HXDLIN( 309)											{
HXLINE( 309)												int _g22 = 0;
HXDLIN( 309)												int _g23 = b6->width;
HXDLIN( 309)												while((_g22 < _g23)){
HXLINE( 309)													_g22 = (_g22 + 1);
HXDLIN( 309)													int x3 = (_g22 - 1);
HXDLIN( 309)													{
HXLINE( 309)														w1 = (w1 + 1);
HXDLIN( 309)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w1 = (w1 + 1);
HXDLIN( 309)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w1 = (w1 + 1);
HXDLIN( 309)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w1 = (w1 + 1);
HXDLIN( 309)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage4 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE( 309)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 309)							{
HXLINE( 309)								a7->width = width1;
HXDLIN( 309)								a7->height = height1;
HXDLIN( 309)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)								a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 309)								{
HXLINE( 309)									int _g24 = 0;
HXDLIN( 309)									int _g25 = a7->length;
HXDLIN( 309)									while((_g24 < _g25)){
HXLINE( 309)										_g24 = (_g24 + 1);
HXDLIN( 309)										int i10 = (_g24 - 1);
HXDLIN( 309)										a7->data[i10] = 0;
            									}
            								}
            							}
HXDLIN( 309)							undoImage4 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE( 309)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 309)							{
HXLINE( 309)								b7->width = width1;
HXDLIN( 309)								b7->height = height1;
HXDLIN( 309)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 309)								int size1 = (b7->length * 4);
HXDLIN( 309)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 309)								{
HXLINE( 309)									int _g26 = 0;
HXDLIN( 309)									int _g27 = b7->length;
HXDLIN( 309)									while((_g26 < _g27)){
HXLINE( 309)										_g26 = (_g26 + 1);
HXDLIN( 309)										int i11 = (_g26 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN( 309)											bool undoImage5;
HXDLIN( 309)											if ((i11 >= 0)) {
HXLINE( 309)												undoImage5 = (i11 < (this33->byteLength >> 2));
            											}
            											else {
HXLINE( 309)												undoImage5 = false;
            											}
HXDLIN( 309)											if (undoImage5) {
HXLINE( 309)												 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 309)												int pos1 = ((i11 << 2) + this33->byteOffset);
HXDLIN( 309)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 309)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage4 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE( 309)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 309)							{
HXLINE( 309)								v3->width = width1;
HXDLIN( 309)								v3->height = height1;
HXDLIN( 309)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 309)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 309)								{
HXLINE( 309)									int _g28 = 0;
HXDLIN( 309)									int _g29 = v3->length;
HXDLIN( 309)									while((_g28 < _g29)){
HXLINE( 309)										_g28 = (_g28 + 1);
HXDLIN( 309)										int i12 = (_g28 - 1);
HXDLIN( 309)										v3->data->__unsafe_set(i12,0);
            									}
            								}
            							}
HXDLIN( 309)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 309)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 309)							{
HXLINE( 309)								b8->width = width1;
HXDLIN( 309)								b8->height = height1;
HXDLIN( 309)								b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 309)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)								{
HXLINE( 309)									int len3 = b8->length;
HXDLIN( 309)									 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 309)									if (::hx::IsNull( d1->head )) {
HXLINE( 309)										int _g30 = 0;
HXDLIN( 309)										int _g31 = len3;
HXDLIN( 309)										while((_g30 < _g31)){
HXLINE( 309)											_g30 = (_g30 + 1);
HXDLIN( 309)											int i13 = (_g30 - 1);
HXDLIN( 309)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 309)										int _g32 = 0;
HXDLIN( 309)										int _g33 = len3;
HXDLIN( 309)										while((_g32 < _g33)){
HXLINE( 309)											_g32 = (_g32 + 1);
HXDLIN( 309)											int i14 = (_g32 - 1);
HXDLIN( 309)											{
HXLINE( 309)												 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 309)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 309)												{
HXLINE( 309)													int _g34 = 0;
HXDLIN( 309)													int _g35 = i14;
HXDLIN( 309)													while((_g34 < _g35)){
HXLINE( 309)														_g34 = (_g34 + 1);
HXDLIN( 309)														int i15 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 309)												if (::hx::IsNull( prev1 )) {
HXLINE( 309)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 309)													l1 = null();
            												}
            												else {
HXLINE( 309)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 309)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage4 = b8;
            						}
            						break;
            					}
HXDLIN( 309)					this32->image = undoImage4;
HXDLIN( 309)					this32->width = width1;
HXDLIN( 309)					this32->height = height1;
HXDLIN( 309)					this32->imageType = ( (int)(imageType1) );
HXDLIN( 309)					undoImage3 = this32;
HXDLIN( 309)					{
HXLINE( 309)						int rectLeft1 = xIter31->start;
HXDLIN( 309)						int rectTop1 = yIter31->start;
HXDLIN( 309)						int rectRight1 = xIter31->max;
HXDLIN( 309)						bool forceClear1 = false;
HXDLIN( 309)						{
HXLINE( 309)							int _g36 = rectTop1;
HXDLIN( 309)							int _g37 = yIter31->max;
HXDLIN( 309)							while((_g36 < _g37)){
HXLINE( 309)								_g36 = (_g36 + 1);
HXDLIN( 309)								int dy2 = (_g36 - 1);
HXDLIN( 309)								{
HXLINE( 309)									int _g38 = rectLeft1;
HXDLIN( 309)									int _g39 = rectRight1;
HXDLIN( 309)									while((_g38 < _g39)){
HXLINE( 309)										_g38 = (_g38 + 1);
HXDLIN( 309)										int dx2 = (_g38 - 1);
HXDLIN( 309)										::Dynamic this34 = pixelImage->image;
HXDLIN( 309)										int index4;
HXDLIN( 309)										if (pixelImage->useVirtualPos) {
HXLINE( 309)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 309)											index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 309)										int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 309)										int col1;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											col1 = c3;
            										}
HXDLIN( 309)										bool _hx_tmp8;
HXDLIN( 309)										if (pixelImage->useMask) {
HXLINE( 309)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 309)											_hx_tmp8 = false;
            										}
HXDLIN( 309)										if (_hx_tmp8) {
HXLINE( 309)											 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN( 309)											::Dynamic this36 = this35->image;
HXDLIN( 309)											int index5;
HXDLIN( 309)											if (this35->useVirtualPos) {
HXLINE( 309)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            											}
            											else {
HXLINE( 309)												index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            											}
HXDLIN( 309)											int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 309)											int v4;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												v4 = c4;
            											}
HXDLIN( 309)											int maskPixel1 = v4;
HXDLIN( 309)											int this37 = col1;
HXDLIN( 309)											if ((maskPixel1 == 0)) {
HXLINE( 309)												col1 = this37;
            											}
            											else {
HXLINE( 309)												Float m01;
HXDLIN( 309)												int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 309)												if ((this38 == 0)) {
HXLINE( 309)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m11;
HXDLIN( 309)												int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 309)												if ((this39 == 0)) {
HXLINE( 309)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m21;
HXDLIN( 309)												int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 309)												if ((this40 == 0)) {
HXLINE( 309)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m31;
HXDLIN( 309)												int this41 = (maskPixel1 & 255);
HXDLIN( 309)												if ((this41 == 0)) {
HXLINE( 309)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 309)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 309)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 309)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 309)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 309)										if ((col1 != 0)) {
HXLINE( 309)											int x4 = (dx2 - rectLeft1);
HXDLIN( 309)											int y4 = (dy2 - rectTop1);
HXDLIN( 309)											int c5 = col1;
HXDLIN( 309)											bool _hx_tmp9;
HXDLIN( 309)											if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp9 = false;
            											}
HXDLIN( 309)											if (_hx_tmp9) {
HXLINE( 309)												int location2;
HXDLIN( 309)												if (undoImage3->useVirtualPos) {
HXLINE( 309)													location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 309)													location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            												}
HXDLIN( 309)												int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 309)												int this43;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this43 = this42;
            												}
HXDLIN( 309)												Float a12;
HXDLIN( 309)												int this44 = ((this43 >> 24) & 255);
HXDLIN( 309)												if ((this44 == 0)) {
HXLINE( 309)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r12;
HXDLIN( 309)												int this45 = ((this43 >> 16) & 255);
HXDLIN( 309)												if ((this45 == 0)) {
HXLINE( 309)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g12;
HXDLIN( 309)												int this46 = ((this43 >> 8) & 255);
HXDLIN( 309)												if ((this46 == 0)) {
HXLINE( 309)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b13;
HXDLIN( 309)												int this47 = (this43 & 255);
HXDLIN( 309)												if ((this47 == 0)) {
HXLINE( 309)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a22;
HXDLIN( 309)												int this48 = ((col1 >> 24) & 255);
HXDLIN( 309)												if ((this48 == 0)) {
HXLINE( 309)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r22;
HXDLIN( 309)												int this49 = ((col1 >> 16) & 255);
HXDLIN( 309)												if ((this49 == 0)) {
HXLINE( 309)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g22;
HXDLIN( 309)												int this50 = ((col1 >> 8) & 255);
HXDLIN( 309)												if ((this50 == 0)) {
HXLINE( 309)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b23;
HXDLIN( 309)												int this51 = (col1 & 255);
HXDLIN( 309)												if ((this51 == 0)) {
HXLINE( 309)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 309)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 309)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 309)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 309)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 309)												int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp10;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp10 = blended2;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this52 = undoImage3->image;
HXDLIN( 309)												int index6;
HXDLIN( 309)												if (undoImage3->useVirtualPos) {
HXLINE( 309)													index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 309)													index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            												}
HXDLIN( 309)												int _hx_tmp11;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp11 = c5;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 309)											if (forceClear1) {
HXLINE( 309)												::Dynamic this53 = undoImage3->image;
HXDLIN( 309)												int x5 = (dx2 - rectLeft1);
HXDLIN( 309)												int y5 = (dy2 - rectTop1);
HXDLIN( 309)												int index7;
HXDLIN( 309)												if (undoImage3->useVirtualPos) {
HXLINE( 309)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 309)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this53,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 309)				bool found1 = false;
HXDLIN( 309)				Float s = ((Float)0.);
HXDLIN( 309)				Float t = ((Float)0.);
HXDLIN( 309)				Float sxx = ((Float)0.);
HXDLIN( 309)				Float txx = ((Float)0.);
HXDLIN( 309)				{
HXLINE( 309)					int _g_min2 = xIter31->start;
HXDLIN( 309)					int _g_max2 = xIter31->max;
HXDLIN( 309)					while((_g_min2 < _g_max2)){
HXLINE( 309)						_g_min2 = (_g_min2 + 1);
HXDLIN( 309)						int x6 = (_g_min2 - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x6) ));
HXLINE(  61)						txx = (tx * ( (Float)(x6) ));
HXLINE(  62)						found1 = false;
HXLINE( 309)						{
HXLINE( 309)							int _g_min3 = yIter31->start;
HXDLIN( 309)							int _g_max3 = yIter31->max;
HXDLIN( 309)							while((_g_min3 < _g_max3)){
HXLINE( 309)								_g_min3 = (_g_min3 + 1);
HXDLIN( 309)								int y6 = (_g_min3 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y6) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y6) )));
HXLINE( 309)								bool _hx_tmp12;
HXDLIN( 309)								if (!((s <= 0))) {
HXLINE( 309)									_hx_tmp12 = (t <= 0);
            								}
            								else {
HXLINE( 309)									_hx_tmp12 = true;
            								}
HXDLIN( 309)								if (_hx_tmp12) {
HXLINE( 309)									if (found1) {
HXLINE( 309)										goto _hx_goto_260;
            									}
            								}
            								else {
HXLINE( 309)									if (((s + t) < A)) {
HXLINE( 309)										{
HXLINE( 309)											int c6 = color;
HXDLIN( 309)											bool _hx_tmp13;
HXDLIN( 309)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp13 = false;
            											}
HXDLIN( 309)											if (_hx_tmp13) {
HXLINE( 309)												int location3;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x6) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													location3 = ::Std_obj::_hx_int(( (Float)(((y6 * pixelImage->width) + x6)) ));
            												}
HXDLIN( 309)												int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 309)												int this55;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this55 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this55 = this54;
            												}
HXDLIN( 309)												Float a13;
HXDLIN( 309)												int this56 = ((this55 >> 24) & 255);
HXDLIN( 309)												if ((this56 == 0)) {
HXLINE( 309)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a13 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r13;
HXDLIN( 309)												int this57 = ((this55 >> 16) & 255);
HXDLIN( 309)												if ((this57 == 0)) {
HXLINE( 309)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g13;
HXDLIN( 309)												int this58 = ((this55 >> 8) & 255);
HXDLIN( 309)												if ((this58 == 0)) {
HXLINE( 309)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b14;
HXDLIN( 309)												int this59 = (this55 & 255);
HXDLIN( 309)												if ((this59 == 0)) {
HXLINE( 309)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a23;
HXDLIN( 309)												int this60 = ((color >> 24) & 255);
HXDLIN( 309)												if ((this60 == 0)) {
HXLINE( 309)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r23;
HXDLIN( 309)												int this61 = ((color >> 16) & 255);
HXDLIN( 309)												if ((this61 == 0)) {
HXLINE( 309)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g23;
HXDLIN( 309)												int this62 = ((color >> 8) & 255);
HXDLIN( 309)												if ((this62 == 0)) {
HXLINE( 309)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b24;
HXDLIN( 309)												int this63 = (color & 255);
HXDLIN( 309)												if ((this63 == 0)) {
HXLINE( 309)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 309)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 309)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 309)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 309)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 309)												int blended3 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp14;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp14 = blended3;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this64 = pixelImage->image;
HXDLIN( 309)												int index8;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x6) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * pixelImage->width) + x6)) ));
            												}
HXDLIN( 309)												int _hx_tmp15;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp15 = c6;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this64,index8,_hx_tmp15);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE( 309)										if (found1) {
HXLINE( 309)											goto _hx_goto_260;
            										}
            									}
            								}
            							}
            							_hx_goto_260:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 309)		if (softRight) {
HXLINE( 309)			bool hasUndo2 = false;
HXDLIN( 309)			int aA1 = ((color >> 24) & 255);
HXDLIN( 309)			int rA1 = ((color >> 16) & 255);
HXDLIN( 309)			int gA1 = ((color >> 8) & 255);
HXDLIN( 309)			int bA1 = (color & 255);
HXDLIN( 309)			Float bcx1 = (bx - cx);
HXDLIN( 309)			Float bcy1 = (by - cy);
HXDLIN( 309)			Float acx1 = (ex - cx);
HXDLIN( 309)			Float acy1 = (ey - cy);
HXDLIN( 309)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 309)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 309)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 309)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 309)			if ((ex > bx)) {
HXLINE( 309)				if ((ex > cx)) {
HXLINE( 309)					int min8;
HXDLIN( 309)					if ((bx > cx)) {
HXLINE( 309)						min8 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 309)						min8 = ::Math_obj::floor(bx);
            					}
HXDLIN( 309)					int ii_min16 = min8;
HXDLIN( 309)					int ii_max16 = ::Math_obj::ceil(ex);
HXDLIN( 309)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 309)					int ii_min17 = ::Math_obj::floor(bx);
HXDLIN( 309)					int ii_max17 = ::Math_obj::ceil(cx);
HXDLIN( 309)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 309)				if ((bx > cx)) {
HXLINE( 309)					int min9;
HXDLIN( 309)					if ((ex > cx)) {
HXLINE( 309)						min9 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 309)						min9 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 309)					int ii_min18 = min9;
HXDLIN( 309)					int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN( 309)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 309)					int ii_min19 = ::Math_obj::floor(ex);
HXDLIN( 309)					int ii_max19 = ::Math_obj::ceil(cx);
HXDLIN( 309)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 309)			if ((ey > by)) {
HXLINE( 309)				if ((ey > cy)) {
HXLINE( 309)					int min10;
HXDLIN( 309)					if ((by > cy)) {
HXLINE( 309)						min10 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 309)						min10 = ::Math_obj::floor(by);
            					}
HXDLIN( 309)					int ii_min20 = min10;
HXDLIN( 309)					int ii_max20 = ::Math_obj::ceil(ey);
HXDLIN( 309)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 309)					int ii_min21 = ::Math_obj::floor(by);
HXDLIN( 309)					int ii_max21 = ::Math_obj::ceil(cy);
HXDLIN( 309)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 309)				if ((by > cy)) {
HXLINE( 309)					int min11;
HXDLIN( 309)					if ((ey > cy)) {
HXLINE( 309)						min11 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 309)						min11 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 309)					int ii_min22 = min11;
HXDLIN( 309)					int ii_max22 = ::Math_obj::ceil(by);
HXDLIN( 309)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 309)					int ii_min23 = ::Math_obj::floor(ey);
HXDLIN( 309)					int ii_max23 = ::Math_obj::ceil(cy);
HXDLIN( 309)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 309)			if (hasUndo2) {
HXLINE( 309)				int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 309)				int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 309)				 ::Dynamic imageType2 = null();
HXDLIN( 309)				 ::pi_xy::ImageStruct this65 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 309)				::Dynamic undoImage7;
HXDLIN( 309)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 309)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::BytesImg b15 = byt2;
HXDLIN( 309)						{
HXLINE( 309)							b15->width = width2;
HXDLIN( 309)							b15->height = height2;
HXDLIN( 309)							b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 309)							b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN( 309)							{
HXLINE( 309)								int len4 = b15->length;
HXDLIN( 309)								int w2 = 0;
HXDLIN( 309)								{
HXLINE( 309)									int _g40 = 0;
HXDLIN( 309)									int _g41 = b15->height;
HXDLIN( 309)									while((_g40 < _g41)){
HXLINE( 309)										_g40 = (_g40 + 1);
HXDLIN( 309)										int y7 = (_g40 - 1);
HXDLIN( 309)										{
HXLINE( 309)											int _g42 = 0;
HXDLIN( 309)											int _g43 = b15->width;
HXDLIN( 309)											while((_g42 < _g43)){
HXLINE( 309)												_g42 = (_g42 + 1);
HXDLIN( 309)												int x7 = (_g42 - 1);
HXDLIN( 309)												{
HXLINE( 309)													w2 = (w2 + 1);
HXDLIN( 309)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w2 = (w2 + 1);
HXDLIN( 309)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w2 = (w2 + 1);
HXDLIN( 309)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w2 = (w2 + 1);
HXDLIN( 309)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage7 = b15;
            					}
            					break;
            					case (int)1: {
HXLINE( 309)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::ArrIntImg a10 = arrI2;
HXDLIN( 309)						{
HXLINE( 309)							a10->width = width2;
HXDLIN( 309)							a10->height = height2;
HXDLIN( 309)							a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)							a10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 309)							{
HXLINE( 309)								int _g44 = 0;
HXDLIN( 309)								int _g45 = a10->length;
HXDLIN( 309)								while((_g44 < _g45)){
HXLINE( 309)									_g44 = (_g44 + 1);
HXDLIN( 309)									int i16 = (_g44 - 1);
HXDLIN( 309)									a10->data[i16] = 0;
            								}
            							}
            						}
HXDLIN( 309)						undoImage7 = a10;
            					}
            					break;
            					case (int)2: {
HXLINE( 309)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::U32ArrImg b16 = u32a2;
HXDLIN( 309)						{
HXLINE( 309)							b16->width = width2;
HXDLIN( 309)							b16->height = height2;
HXDLIN( 309)							b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 309)							int size2 = (b16->length * 4);
HXDLIN( 309)							b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 309)							{
HXLINE( 309)								int _g46 = 0;
HXDLIN( 309)								int _g47 = b16->length;
HXDLIN( 309)								while((_g46 < _g47)){
HXLINE( 309)									_g46 = (_g46 + 1);
HXDLIN( 309)									int i17 = (_g46 - 1);
HXDLIN( 309)									{
HXLINE( 309)										 ::haxe::io::ArrayBufferViewImpl this66 = b16->data;
HXDLIN( 309)										bool undoImage8;
HXDLIN( 309)										if ((i17 >= 0)) {
HXLINE( 309)											undoImage8 = (i17 < (this66->byteLength >> 2));
            										}
            										else {
HXLINE( 309)											undoImage8 = false;
            										}
HXDLIN( 309)										if (undoImage8) {
HXLINE( 309)											 ::haxe::io::Bytes _this2 = this66->bytes;
HXDLIN( 309)											int pos2 = ((i17 << 2) + this66->byteOffset);
HXDLIN( 309)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 309)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage7 = b16;
            					}
            					break;
            					case (int)3: {
HXLINE( 309)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 309)						{
HXLINE( 309)							v5->width = width2;
HXDLIN( 309)							v5->height = height2;
HXDLIN( 309)							v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 309)							v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 309)							{
HXLINE( 309)								int _g48 = 0;
HXDLIN( 309)								int _g49 = v5->length;
HXDLIN( 309)								while((_g48 < _g49)){
HXLINE( 309)									_g48 = (_g48 + 1);
HXDLIN( 309)									int i18 = (_g48 - 1);
HXDLIN( 309)									v5->data->__unsafe_set(i18,0);
            								}
            							}
            						}
HXDLIN( 309)						undoImage7 = v5;
            					}
            					break;
            					case (int)4: {
HXLINE( 309)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::StackIntImg b17 = sInt2;
HXDLIN( 309)						{
HXLINE( 309)							b17->width = width2;
HXDLIN( 309)							b17->height = height2;
HXDLIN( 309)							b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 309)							b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)							{
HXLINE( 309)								int len5 = b17->length;
HXDLIN( 309)								 ::haxe::ds::GenericStack_Int d2 = b17->data;
HXDLIN( 309)								if (::hx::IsNull( d2->head )) {
HXLINE( 309)									int _g50 = 0;
HXDLIN( 309)									int _g51 = len5;
HXDLIN( 309)									while((_g50 < _g51)){
HXLINE( 309)										_g50 = (_g50 + 1);
HXDLIN( 309)										int i19 = (_g50 - 1);
HXDLIN( 309)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 309)									int _g52 = 0;
HXDLIN( 309)									int _g53 = len5;
HXDLIN( 309)									while((_g52 < _g53)){
HXLINE( 309)										_g52 = (_g52 + 1);
HXDLIN( 309)										int i20 = (_g52 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::ds::GenericCell_Int l2 = b17->data->head;
HXDLIN( 309)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 309)											{
HXLINE( 309)												int _g54 = 0;
HXDLIN( 309)												int _g55 = i20;
HXDLIN( 309)												while((_g54 < _g55)){
HXLINE( 309)													_g54 = (_g54 + 1);
HXDLIN( 309)													int i21 = (_g54 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 309)											if (::hx::IsNull( prev2 )) {
HXLINE( 309)												b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 309)												l2 = null();
            											}
            											else {
HXLINE( 309)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 309)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage7 = b17;
            					}
            					break;
            				}
HXDLIN( 309)				this65->image = undoImage7;
HXDLIN( 309)				this65->width = width2;
HXDLIN( 309)				this65->height = height2;
HXDLIN( 309)				this65->imageType = ( (int)(imageType2) );
HXDLIN( 309)				undoImage6 = this65;
HXDLIN( 309)				{
HXLINE( 309)					int rectLeft2 = xIter32->start;
HXDLIN( 309)					int rectTop2 = yIter32->start;
HXDLIN( 309)					int rectRight2 = xIter32->max;
HXDLIN( 309)					bool forceClear2 = false;
HXDLIN( 309)					{
HXLINE( 309)						int _g56 = rectTop2;
HXDLIN( 309)						int _g57 = yIter32->max;
HXDLIN( 309)						while((_g56 < _g57)){
HXLINE( 309)							_g56 = (_g56 + 1);
HXDLIN( 309)							int dy3 = (_g56 - 1);
HXDLIN( 309)							{
HXLINE( 309)								int _g58 = rectLeft2;
HXDLIN( 309)								int _g59 = rectRight2;
HXDLIN( 309)								while((_g58 < _g59)){
HXLINE( 309)									_g58 = (_g58 + 1);
HXDLIN( 309)									int dx3 = (_g58 - 1);
HXDLIN( 309)									::Dynamic this67 = pixelImage->image;
HXDLIN( 309)									int index9;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										index9 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										index9 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            									}
HXDLIN( 309)									int c7 = ::iterMagic::Iimg_obj::get(this67,index9);
HXDLIN( 309)									int col2;
HXDLIN( 309)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)										col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 309)										col2 = c7;
            									}
HXDLIN( 309)									bool _hx_tmp16;
HXDLIN( 309)									if (pixelImage->useMask) {
HXLINE( 309)										_hx_tmp16 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 309)										_hx_tmp16 = false;
            									}
HXDLIN( 309)									if (_hx_tmp16) {
HXLINE( 309)										 ::pi_xy::ImageStruct this68 = pixelImage->mask;
HXDLIN( 309)										::Dynamic this69 = this68->image;
HXDLIN( 309)										int index10;
HXDLIN( 309)										if (this68->useVirtualPos) {
HXLINE( 309)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx3) - this68->virtualX));
            										}
            										else {
HXLINE( 309)											index10 = ::Std_obj::_hx_int(( (Float)(((dy3 * this68->width) + dx3)) ));
            										}
HXDLIN( 309)										int c8 = ::iterMagic::Iimg_obj::get(this69,index10);
HXDLIN( 309)										int v6;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											v6 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											v6 = c8;
            										}
HXDLIN( 309)										int maskPixel2 = v6;
HXDLIN( 309)										int this70 = col2;
HXDLIN( 309)										if ((maskPixel2 == 0)) {
HXLINE( 309)											col2 = this70;
            										}
            										else {
HXLINE( 309)											Float m02;
HXDLIN( 309)											int this71 = ((maskPixel2 >> 24) & 255);
HXDLIN( 309)											if ((this71 == 0)) {
HXLINE( 309)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m02 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m12;
HXDLIN( 309)											int this72 = ((maskPixel2 >> 16) & 255);
HXDLIN( 309)											if ((this72 == 0)) {
HXLINE( 309)												m12 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m12 = (( (Float)(this72) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m22;
HXDLIN( 309)											int this73 = ((maskPixel2 >> 8) & 255);
HXDLIN( 309)											if ((this73 == 0)) {
HXLINE( 309)												m22 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m22 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m32;
HXDLIN( 309)											int this74 = (maskPixel2 & 255);
HXDLIN( 309)											if ((this74 == 0)) {
HXLINE( 309)												m32 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m32 = (( (Float)(this74) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this70 >> 24) & 255)) )));
HXDLIN( 309)											int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this70 >> 16) & 255)) )));
HXDLIN( 309)											int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this70 >> 8) & 255)) )));
HXDLIN( 309)											int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this70 & 255)) )));
HXDLIN( 309)											col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 309)									if ((col2 != 0)) {
HXLINE( 309)										int x8 = (dx3 - rectLeft2);
HXDLIN( 309)										int y8 = (dy3 - rectTop2);
HXDLIN( 309)										int c9 = col2;
HXDLIN( 309)										bool _hx_tmp17;
HXDLIN( 309)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 309)											_hx_tmp17 = undoImage6->transparent;
            										}
            										else {
HXLINE( 309)											_hx_tmp17 = false;
            										}
HXDLIN( 309)										if (_hx_tmp17) {
HXLINE( 309)											int location4;
HXDLIN( 309)											if (undoImage6->useVirtualPos) {
HXLINE( 309)												location4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 309)												location4 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            											}
HXDLIN( 309)											int this75 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 309)											int this76;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												this76 = ((((((this75 >> 24) & 255) << 24) | ((this75 & 255) << 16)) | (((this75 >> 8) & 255) << 8)) | ((this75 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												this76 = this75;
            											}
HXDLIN( 309)											Float a14;
HXDLIN( 309)											int this77 = ((this76 >> 24) & 255);
HXDLIN( 309)											if ((this77 == 0)) {
HXLINE( 309)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a14 = (( (Float)(this77) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r14;
HXDLIN( 309)											int this78 = ((this76 >> 16) & 255);
HXDLIN( 309)											if ((this78 == 0)) {
HXLINE( 309)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r14 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g14;
HXDLIN( 309)											int this79 = ((this76 >> 8) & 255);
HXDLIN( 309)											if ((this79 == 0)) {
HXLINE( 309)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g14 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b18;
HXDLIN( 309)											int this80 = (this76 & 255);
HXDLIN( 309)											if ((this80 == 0)) {
HXLINE( 309)												b18 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b18 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a24;
HXDLIN( 309)											int this81 = ((col2 >> 24) & 255);
HXDLIN( 309)											if ((this81 == 0)) {
HXLINE( 309)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a24 = (( (Float)(this81) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r24;
HXDLIN( 309)											int this82 = ((col2 >> 16) & 255);
HXDLIN( 309)											if ((this82 == 0)) {
HXLINE( 309)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r24 = (( (Float)(this82) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g24;
HXDLIN( 309)											int this83 = ((col2 >> 8) & 255);
HXDLIN( 309)											if ((this83 == 0)) {
HXLINE( 309)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g24 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b25;
HXDLIN( 309)											int this84 = (col2 & 255);
HXDLIN( 309)											if ((this84 == 0)) {
HXLINE( 309)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b25 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 309)											int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 309)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 309)											int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a34) + (b25 * a24))));
HXDLIN( 309)											int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 309)											int blended4 = ((((a15 << 24) | (r7 << 16)) | (g7 << 8)) | b19);
HXDLIN( 309)											{
HXLINE( 309)												int _hx_tmp18;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp18 = blended4;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            											}
            										}
            										else {
HXLINE( 309)											::Dynamic this85 = undoImage6->image;
HXDLIN( 309)											int index11;
HXDLIN( 309)											if (undoImage6->useVirtualPos) {
HXLINE( 309)												index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 309)												index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            											}
HXDLIN( 309)											int _hx_tmp19;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp19 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp19 = c9;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this85,index11,_hx_tmp19);
            										}
            									}
            									else {
HXLINE( 309)										if (forceClear2) {
HXLINE( 309)											::Dynamic this86 = undoImage6->image;
HXDLIN( 309)											int x9 = (dx3 - rectLeft2);
HXDLIN( 309)											int y9 = (dy3 - rectTop2);
HXDLIN( 309)											int index12;
HXDLIN( 309)											if (undoImage6->useVirtualPos) {
HXLINE( 309)												index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 309)												index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this86,index12,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 309)			bool found2 = false;
HXDLIN( 309)			{
HXLINE( 309)				int _g_min4 = xIter32->start;
HXDLIN( 309)				int _g_max4 = xIter32->max;
HXDLIN( 309)				while((_g_min4 < _g_max4)){
HXLINE( 309)					_g_min4 = (_g_min4 + 1);
HXDLIN( 309)					int px2 = (_g_min4 - 1);
HXDLIN( 309)					Float pcx1 = (( (Float)(px2) ) - cx);
HXLINE( 619)					found2 = false;
HXLINE( 309)					{
HXLINE( 309)						int _g_min5 = yIter32->start;
HXDLIN( 309)						int _g_max5 = yIter32->max;
HXDLIN( 309)						while((_g_min5 < _g_max5)){
HXLINE( 309)							_g_min5 = (_g_min5 + 1);
HXDLIN( 309)							int py2 = (_g_min5 - 1);
HXDLIN( 309)							Float pcy1 = (( (Float)(py2) ) - cy);
HXDLIN( 309)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 309)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 309)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 309)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 309)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 309)							bool _hx_tmp20;
HXDLIN( 309)							bool _hx_tmp21;
HXDLIN( 309)							if ((ratioA1 >= 0)) {
HXLINE( 309)								_hx_tmp21 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp21 = false;
            							}
HXDLIN( 309)							if (_hx_tmp21) {
HXLINE( 309)								_hx_tmp20 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp20 = false;
            							}
HXDLIN( 309)							if (_hx_tmp20) {
HXLINE( 309)								int i22 = ::Std_obj::_hx_int((( (Float)(aA1) ) * (softC * ratioB1)));
HXDLIN( 309)								if ((i22 > 255)) {
HXLINE(  24)									i22 = 255;
            								}
HXLINE( 309)								if ((i22 < 0)) {
HXLINE(  25)									i22 = 0;
            								}
HXLINE( 309)								int a16 = i22;
HXDLIN( 309)								int i23 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 309)								if ((i23 > 255)) {
HXLINE(  24)									i23 = 255;
            								}
HXLINE( 309)								if ((i23 < 0)) {
HXLINE(  25)									i23 = 0;
            								}
HXLINE( 309)								int r8 = i23;
HXDLIN( 309)								int i24 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 309)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE( 309)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE( 309)								int g8 = i24;
HXDLIN( 309)								int i25 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 309)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE( 309)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 309)								int b20 = i25;
HXDLIN( 309)								{
HXLINE( 309)									int location5;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										location5 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										location5 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 309)									bool _hx_tmp22;
HXDLIN( 309)									if (pixelImage->transparent) {
HXLINE( 309)										_hx_tmp22 = (a16 < 254);
            									}
            									else {
HXLINE( 309)										_hx_tmp22 = false;
            									}
HXDLIN( 309)									if (_hx_tmp22) {
HXLINE( 309)										int this87 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 309)										int old1;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											old1 = ((((((this87 >> 24) & 255) << 24) | ((this87 & 255) << 16)) | (((this87 >> 8) & 255) << 8)) | ((this87 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											old1 = this87;
            										}
HXDLIN( 309)										int rhs1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 309)										Float a17;
HXDLIN( 309)										int this88 = ((old1 >> 24) & 255);
HXDLIN( 309)										if ((this88 == 0)) {
HXLINE( 309)											a17 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a17 = (( (Float)(this88) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r15;
HXDLIN( 309)										int this89 = ((old1 >> 16) & 255);
HXDLIN( 309)										if ((this89 == 0)) {
HXLINE( 309)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r15 = (( (Float)(this89) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g15;
HXDLIN( 309)										int this90 = ((old1 >> 8) & 255);
HXDLIN( 309)										if ((this90 == 0)) {
HXLINE( 309)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g15 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b110;
HXDLIN( 309)										int this91 = (old1 & 255);
HXDLIN( 309)										if ((this91 == 0)) {
HXLINE( 309)											b110 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b110 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a25;
HXDLIN( 309)										int this92 = ((rhs1 >> 24) & 255);
HXDLIN( 309)										if ((this92 == 0)) {
HXLINE( 309)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a25 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r25;
HXDLIN( 309)										int this93 = ((rhs1 >> 16) & 255);
HXDLIN( 309)										if ((this93 == 0)) {
HXLINE( 309)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r25 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g25;
HXDLIN( 309)										int this94 = ((rhs1 >> 8) & 255);
HXDLIN( 309)										if ((this94 == 0)) {
HXLINE( 309)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g25 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b26;
HXDLIN( 309)										int this95 = (rhs1 & 255);
HXDLIN( 309)										if ((this95 == 0)) {
HXLINE( 309)											b26 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a35 = (a17 * (( (Float)(1) ) - a25));
HXDLIN( 309)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 309)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 309)										int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b26 * a25))));
HXDLIN( 309)										int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 309)										int blended5 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b27);
HXDLIN( 309)										{
HXLINE( 309)											int _hx_tmp23;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp23 = blended5;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp23);
            										}
            									}
            									else {
HXLINE( 309)										int value1;
HXDLIN( 309)										if (pixelImage->isLittle) {
HXLINE( 309)											value1 = ((((a16 << 24) | (b20 << 16)) | (g8 << 8)) | r8);
            										}
            										else {
HXLINE( 309)											value1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
            										}
HXDLIN( 309)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,value1);
            									}
            								}
HXLINE( 633)								found2 = true;
            							}
            							else {
HXLINE( 309)								if (found2) {
HXLINE( 309)									goto _hx_goto_272;
            								}
            							}
            						}
            						_hx_goto_272:;
            					}
            				}
            			}
HXDLIN( 309)			{
HXLINE( 309)				 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,bx,by,cx,cy,true);
HXDLIN( 309)				if (hasUndo2) {
HXLINE( 309)					v7->undoImage = undoImage6;
HXDLIN( 309)					v7->undoX = xIter32->start;
HXDLIN( 309)					v7->undoY = yIter32->start;
            				}
            			}
            		}
            		else {
HXLINE( 309)			Float bx2 = bx;
HXDLIN( 309)			Float by2 = by;
HXDLIN( 309)			Float cx2 = cx;
HXDLIN( 309)			Float cy2 = cy;
HXDLIN( 309)			bool hasUndo3 = false;
HXDLIN( 309)			bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN( 309)			if (!(adjustWinding1)) {
HXLINE( 309)				Float bx_1 = bx2;
HXDLIN( 309)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE( 309)			{
HXLINE( 309)				Float s01 = ((ey * cx2) - (ex * cy2));
HXDLIN( 309)				Float sx1 = (cy2 - ey);
HXDLIN( 309)				Float sy1 = (ex - cx2);
HXDLIN( 309)				Float t01 = ((ex * by2) - (ey * bx2));
HXDLIN( 309)				Float tx1 = (ey - by2);
HXDLIN( 309)				Float ty1 = (bx2 - ex);
HXDLIN( 309)				Float A1 = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 309)				if ((ex > bx2)) {
HXLINE( 309)					if ((ex > cx2)) {
HXLINE( 309)						int min12;
HXDLIN( 309)						if ((bx2 > cx2)) {
HXLINE( 309)							min12 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 309)							min12 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 309)						int ii_min24 = min12;
HXDLIN( 309)						int ii_max24 = ::Math_obj::ceil(ex);
HXDLIN( 309)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXLINE( 309)						int ii_min25 = ::Math_obj::floor(bx2);
HXDLIN( 309)						int ii_max25 = ::Math_obj::ceil(cx2);
HXDLIN( 309)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
            				else {
HXLINE( 309)					if ((bx2 > cx2)) {
HXLINE( 309)						int min13;
HXDLIN( 309)						if ((ex > cx2)) {
HXLINE( 309)							min13 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 309)							min13 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 309)						int ii_min26 = min13;
HXDLIN( 309)						int ii_max26 = ::Math_obj::ceil(bx2);
HXDLIN( 309)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            					}
            					else {
HXLINE( 309)						int ii_min27 = ::Math_obj::floor(ex);
HXDLIN( 309)						int ii_max27 = ::Math_obj::ceil(cx2);
HXDLIN( 309)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 309)				if ((ey > by2)) {
HXLINE( 309)					if ((ey > cy2)) {
HXLINE( 309)						int min14;
HXDLIN( 309)						if ((by2 > cy2)) {
HXLINE( 309)							min14 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 309)							min14 = ::Math_obj::floor(by2);
            						}
HXDLIN( 309)						int ii_min28 = min14;
HXDLIN( 309)						int ii_max28 = ::Math_obj::ceil(ey);
HXDLIN( 309)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            					}
            					else {
HXLINE( 309)						int ii_min29 = ::Math_obj::floor(by2);
HXDLIN( 309)						int ii_max29 = ::Math_obj::ceil(cy2);
HXDLIN( 309)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            					}
            				}
            				else {
HXLINE( 309)					if ((by2 > cy2)) {
HXLINE( 309)						int min15;
HXDLIN( 309)						if ((ey > cy2)) {
HXLINE( 309)							min15 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 309)							min15 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 309)						int ii_min30 = min15;
HXDLIN( 309)						int ii_max30 = ::Math_obj::ceil(by2);
HXDLIN( 309)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            					}
            					else {
HXLINE( 309)						int ii_min31 = ::Math_obj::floor(ey);
HXDLIN( 309)						int ii_max31 = ::Math_obj::ceil(cy2);
HXDLIN( 309)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 309)				if (hasUndo3) {
HXLINE( 309)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 309)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 309)					 ::Dynamic imageType3 = null();
HXDLIN( 309)					 ::pi_xy::ImageStruct this96 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 309)					::Dynamic undoImage10;
HXDLIN( 309)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 309)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::BytesImg b28 = byt3;
HXDLIN( 309)							{
HXLINE( 309)								b28->width = width3;
HXDLIN( 309)								b28->height = height3;
HXDLIN( 309)								b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 309)								b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN( 309)								{
HXLINE( 309)									int len6 = b28->length;
HXDLIN( 309)									int w3 = 0;
HXDLIN( 309)									{
HXLINE( 309)										int _g60 = 0;
HXDLIN( 309)										int _g61 = b28->height;
HXDLIN( 309)										while((_g60 < _g61)){
HXLINE( 309)											_g60 = (_g60 + 1);
HXDLIN( 309)											int y10 = (_g60 - 1);
HXDLIN( 309)											{
HXLINE( 309)												int _g62 = 0;
HXDLIN( 309)												int _g63 = b28->width;
HXDLIN( 309)												while((_g62 < _g63)){
HXLINE( 309)													_g62 = (_g62 + 1);
HXDLIN( 309)													int x10 = (_g62 - 1);
HXDLIN( 309)													{
HXLINE( 309)														w3 = (w3 + 1);
HXDLIN( 309)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w3 = (w3 + 1);
HXDLIN( 309)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w3 = (w3 + 1);
HXDLIN( 309)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w3 = (w3 + 1);
HXDLIN( 309)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage10 = b28;
            						}
            						break;
            						case (int)1: {
HXLINE( 309)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::ArrIntImg a19 = arrI3;
HXDLIN( 309)							{
HXLINE( 309)								a19->width = width3;
HXDLIN( 309)								a19->height = height3;
HXDLIN( 309)								a19->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)								a19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 309)								{
HXLINE( 309)									int _g64 = 0;
HXDLIN( 309)									int _g65 = a19->length;
HXDLIN( 309)									while((_g64 < _g65)){
HXLINE( 309)										_g64 = (_g64 + 1);
HXDLIN( 309)										int i26 = (_g64 - 1);
HXDLIN( 309)										a19->data[i26] = 0;
            									}
            								}
            							}
HXDLIN( 309)							undoImage10 = a19;
            						}
            						break;
            						case (int)2: {
HXLINE( 309)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::U32ArrImg b29 = u32a3;
HXDLIN( 309)							{
HXLINE( 309)								b29->width = width3;
HXDLIN( 309)								b29->height = height3;
HXDLIN( 309)								b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 309)								int size3 = (b29->length * 4);
HXDLIN( 309)								b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 309)								{
HXLINE( 309)									int _g66 = 0;
HXDLIN( 309)									int _g67 = b29->length;
HXDLIN( 309)									while((_g66 < _g67)){
HXLINE( 309)										_g66 = (_g66 + 1);
HXDLIN( 309)										int i27 = (_g66 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::io::ArrayBufferViewImpl this97 = b29->data;
HXDLIN( 309)											bool undoImage11;
HXDLIN( 309)											if ((i27 >= 0)) {
HXLINE( 309)												undoImage11 = (i27 < (this97->byteLength >> 2));
            											}
            											else {
HXLINE( 309)												undoImage11 = false;
            											}
HXDLIN( 309)											if (undoImage11) {
HXLINE( 309)												 ::haxe::io::Bytes _this3 = this97->bytes;
HXDLIN( 309)												int pos3 = ((i27 << 2) + this97->byteOffset);
HXDLIN( 309)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 309)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage10 = b29;
            						}
            						break;
            						case (int)3: {
HXLINE( 309)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 309)							{
HXLINE( 309)								v8->width = width3;
HXDLIN( 309)								v8->height = height3;
HXDLIN( 309)								v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 309)								v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 309)								{
HXLINE( 309)									int _g68 = 0;
HXDLIN( 309)									int _g69 = v8->length;
HXDLIN( 309)									while((_g68 < _g69)){
HXLINE( 309)										_g68 = (_g68 + 1);
HXDLIN( 309)										int i28 = (_g68 - 1);
HXDLIN( 309)										v8->data->__unsafe_set(i28,0);
            									}
            								}
            							}
HXDLIN( 309)							undoImage10 = v8;
            						}
            						break;
            						case (int)4: {
HXLINE( 309)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::StackIntImg b30 = sInt3;
HXDLIN( 309)							{
HXLINE( 309)								b30->width = width3;
HXDLIN( 309)								b30->height = height3;
HXDLIN( 309)								b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 309)								b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)								{
HXLINE( 309)									int len7 = b30->length;
HXDLIN( 309)									 ::haxe::ds::GenericStack_Int d3 = b30->data;
HXDLIN( 309)									if (::hx::IsNull( d3->head )) {
HXLINE( 309)										int _g70 = 0;
HXDLIN( 309)										int _g71 = len7;
HXDLIN( 309)										while((_g70 < _g71)){
HXLINE( 309)											_g70 = (_g70 + 1);
HXDLIN( 309)											int i29 = (_g70 - 1);
HXDLIN( 309)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 309)										int _g72 = 0;
HXDLIN( 309)										int _g73 = len7;
HXDLIN( 309)										while((_g72 < _g73)){
HXLINE( 309)											_g72 = (_g72 + 1);
HXDLIN( 309)											int i30 = (_g72 - 1);
HXDLIN( 309)											{
HXLINE( 309)												 ::haxe::ds::GenericCell_Int l3 = b30->data->head;
HXDLIN( 309)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 309)												{
HXLINE( 309)													int _g74 = 0;
HXDLIN( 309)													int _g75 = i30;
HXDLIN( 309)													while((_g74 < _g75)){
HXLINE( 309)														_g74 = (_g74 + 1);
HXDLIN( 309)														int i31 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 309)												if (::hx::IsNull( prev3 )) {
HXLINE( 309)													b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 309)													l3 = null();
            												}
            												else {
HXLINE( 309)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 309)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage10 = b30;
            						}
            						break;
            					}
HXDLIN( 309)					this96->image = undoImage10;
HXDLIN( 309)					this96->width = width3;
HXDLIN( 309)					this96->height = height3;
HXDLIN( 309)					this96->imageType = ( (int)(imageType3) );
HXDLIN( 309)					undoImage9 = this96;
HXDLIN( 309)					{
HXLINE( 309)						int rectLeft3 = xIter33->start;
HXDLIN( 309)						int rectTop3 = yIter33->start;
HXDLIN( 309)						int rectRight3 = xIter33->max;
HXDLIN( 309)						bool forceClear3 = false;
HXDLIN( 309)						{
HXLINE( 309)							int _g76 = rectTop3;
HXDLIN( 309)							int _g77 = yIter33->max;
HXDLIN( 309)							while((_g76 < _g77)){
HXLINE( 309)								_g76 = (_g76 + 1);
HXDLIN( 309)								int dy4 = (_g76 - 1);
HXDLIN( 309)								{
HXLINE( 309)									int _g78 = rectLeft3;
HXDLIN( 309)									int _g79 = rectRight3;
HXDLIN( 309)									while((_g78 < _g79)){
HXLINE( 309)										_g78 = (_g78 + 1);
HXDLIN( 309)										int dx4 = (_g78 - 1);
HXDLIN( 309)										::Dynamic this98 = pixelImage->image;
HXDLIN( 309)										int index13;
HXDLIN( 309)										if (pixelImage->useVirtualPos) {
HXLINE( 309)											index13 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 309)											index13 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            										}
HXDLIN( 309)										int c10 = ::iterMagic::Iimg_obj::get(this98,index13);
HXDLIN( 309)										int col3;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											col3 = c10;
            										}
HXDLIN( 309)										bool _hx_tmp24;
HXDLIN( 309)										if (pixelImage->useMask) {
HXLINE( 309)											_hx_tmp24 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 309)											_hx_tmp24 = false;
            										}
HXDLIN( 309)										if (_hx_tmp24) {
HXLINE( 309)											 ::pi_xy::ImageStruct this99 = pixelImage->mask;
HXDLIN( 309)											::Dynamic this100 = this99->image;
HXDLIN( 309)											int index14;
HXDLIN( 309)											if (this99->useVirtualPos) {
HXLINE( 309)												index14 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this99->virtualY) * ( (Float)(this99->width) )) + dx4) - this99->virtualX));
            											}
            											else {
HXLINE( 309)												index14 = ::Std_obj::_hx_int(( (Float)(((dy4 * this99->width) + dx4)) ));
            											}
HXDLIN( 309)											int c11 = ::iterMagic::Iimg_obj::get(this100,index14);
HXDLIN( 309)											int v9;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												v9 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												v9 = c11;
            											}
HXDLIN( 309)											int maskPixel3 = v9;
HXDLIN( 309)											int this101 = col3;
HXDLIN( 309)											if ((maskPixel3 == 0)) {
HXLINE( 309)												col3 = this101;
            											}
            											else {
HXLINE( 309)												Float m03;
HXDLIN( 309)												int this102 = ((maskPixel3 >> 24) & 255);
HXDLIN( 309)												if ((this102 == 0)) {
HXLINE( 309)													m03 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m03 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m13;
HXDLIN( 309)												int this103 = ((maskPixel3 >> 16) & 255);
HXDLIN( 309)												if ((this103 == 0)) {
HXLINE( 309)													m13 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m13 = (( (Float)(this103) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m23;
HXDLIN( 309)												int this104 = ((maskPixel3 >> 8) & 255);
HXDLIN( 309)												if ((this104 == 0)) {
HXLINE( 309)													m23 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m23 = (( (Float)(this104) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m33;
HXDLIN( 309)												int this105 = (maskPixel3 & 255);
HXDLIN( 309)												if ((this105 == 0)) {
HXLINE( 309)													m33 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m33 = (( (Float)(this105) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this101 >> 24) & 255)) )));
HXDLIN( 309)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this101 >> 16) & 255)) )));
HXDLIN( 309)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this101 >> 8) & 255)) )));
HXDLIN( 309)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this101 & 255)) )));
HXDLIN( 309)												col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 309)										if ((col3 != 0)) {
HXLINE( 309)											int x11 = (dx4 - rectLeft3);
HXDLIN( 309)											int y11 = (dy4 - rectTop3);
HXDLIN( 309)											int c12 = col3;
HXDLIN( 309)											bool _hx_tmp25;
HXDLIN( 309)											if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp25 = undoImage9->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp25 = false;
            											}
HXDLIN( 309)											if (_hx_tmp25) {
HXLINE( 309)												int location6;
HXDLIN( 309)												if (undoImage9->useVirtualPos) {
HXLINE( 309)													location6 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 309)													location6 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            												}
HXDLIN( 309)												int this106 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 309)												int this107;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this107 = ((((((this106 >> 24) & 255) << 24) | ((this106 & 255) << 16)) | (((this106 >> 8) & 255) << 8)) | ((this106 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this107 = this106;
            												}
HXDLIN( 309)												Float a110;
HXDLIN( 309)												int this108 = ((this107 >> 24) & 255);
HXDLIN( 309)												if ((this108 == 0)) {
HXLINE( 309)													a110 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a110 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r16;
HXDLIN( 309)												int this109 = ((this107 >> 16) & 255);
HXDLIN( 309)												if ((this109 == 0)) {
HXLINE( 309)													r16 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r16 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g16;
HXDLIN( 309)												int this110 = ((this107 >> 8) & 255);
HXDLIN( 309)												if ((this110 == 0)) {
HXLINE( 309)													g16 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g16 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b111;
HXDLIN( 309)												int this111 = (this107 & 255);
HXDLIN( 309)												if ((this111 == 0)) {
HXLINE( 309)													b111 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b111 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a26;
HXDLIN( 309)												int this112 = ((col3 >> 24) & 255);
HXDLIN( 309)												if ((this112 == 0)) {
HXLINE( 309)													a26 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a26 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r26;
HXDLIN( 309)												int this113 = ((col3 >> 16) & 255);
HXDLIN( 309)												if ((this113 == 0)) {
HXLINE( 309)													r26 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r26 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g26;
HXDLIN( 309)												int this114 = ((col3 >> 8) & 255);
HXDLIN( 309)												if ((this114 == 0)) {
HXLINE( 309)													g26 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g26 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b210;
HXDLIN( 309)												int this115 = (col3 & 255);
HXDLIN( 309)												if ((this115 == 0)) {
HXLINE( 309)													b210 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b210 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a36 = (a110 * (( (Float)(1) ) - a26));
HXDLIN( 309)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 309)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 309)												int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b210 * a26))));
HXDLIN( 309)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 309)												int blended6 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b31);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp26;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp26 = blended6;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this116 = undoImage9->image;
HXDLIN( 309)												int index15;
HXDLIN( 309)												if (undoImage9->useVirtualPos) {
HXLINE( 309)													index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 309)													index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            												}
HXDLIN( 309)												int _hx_tmp27;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp27 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp27 = c12;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this116,index15,_hx_tmp27);
            											}
            										}
            										else {
HXLINE( 309)											if (forceClear3) {
HXLINE( 309)												::Dynamic this117 = undoImage9->image;
HXDLIN( 309)												int x12 = (dx4 - rectLeft3);
HXDLIN( 309)												int y12 = (dy4 - rectTop3);
HXDLIN( 309)												int index16;
HXDLIN( 309)												if (undoImage9->useVirtualPos) {
HXLINE( 309)													index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x12) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 309)													index16 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x12)) ));
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this117,index16,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 309)				bool found3 = false;
HXDLIN( 309)				Float s1 = ((Float)0.);
HXDLIN( 309)				Float t1 = ((Float)0.);
HXDLIN( 309)				Float sxx1 = ((Float)0.);
HXDLIN( 309)				Float txx1 = ((Float)0.);
HXDLIN( 309)				{
HXLINE( 309)					int _g_min6 = xIter33->start;
HXDLIN( 309)					int _g_max6 = xIter33->max;
HXDLIN( 309)					while((_g_min6 < _g_max6)){
HXLINE( 309)						_g_min6 = (_g_min6 + 1);
HXDLIN( 309)						int x13 = (_g_min6 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x13) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x13) ));
HXLINE(  62)						found3 = false;
HXLINE( 309)						{
HXLINE( 309)							int _g_min7 = yIter33->start;
HXDLIN( 309)							int _g_max7 = yIter33->max;
HXDLIN( 309)							while((_g_min7 < _g_max7)){
HXLINE( 309)								_g_min7 = (_g_min7 + 1);
HXDLIN( 309)								int y13 = (_g_min7 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y13) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y13) )));
HXLINE( 309)								bool _hx_tmp28;
HXDLIN( 309)								if (!((s1 <= 0))) {
HXLINE( 309)									_hx_tmp28 = (t1 <= 0);
            								}
            								else {
HXLINE( 309)									_hx_tmp28 = true;
            								}
HXDLIN( 309)								if (_hx_tmp28) {
HXLINE( 309)									if (found3) {
HXLINE( 309)										goto _hx_goto_284;
            									}
            								}
            								else {
HXLINE( 309)									if (((s1 + t1) < A1)) {
HXLINE( 309)										{
HXLINE( 309)											int c13 = color;
HXDLIN( 309)											bool _hx_tmp29;
HXDLIN( 309)											if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp29 = pixelImage->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp29 = false;
            											}
HXDLIN( 309)											if (_hx_tmp29) {
HXLINE( 309)												int location7;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													location7 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x13) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													location7 = ::Std_obj::_hx_int(( (Float)(((y13 * pixelImage->width) + x13)) ));
            												}
HXDLIN( 309)												int this118 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 309)												int this119;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this119 = ((((((this118 >> 24) & 255) << 24) | ((this118 & 255) << 16)) | (((this118 >> 8) & 255) << 8)) | ((this118 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this119 = this118;
            												}
HXDLIN( 309)												Float a111;
HXDLIN( 309)												int this120 = ((this119 >> 24) & 255);
HXDLIN( 309)												if ((this120 == 0)) {
HXLINE( 309)													a111 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a111 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r17;
HXDLIN( 309)												int this121 = ((this119 >> 16) & 255);
HXDLIN( 309)												if ((this121 == 0)) {
HXLINE( 309)													r17 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r17 = (( (Float)(this121) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g17;
HXDLIN( 309)												int this122 = ((this119 >> 8) & 255);
HXDLIN( 309)												if ((this122 == 0)) {
HXLINE( 309)													g17 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g17 = (( (Float)(this122) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b112;
HXDLIN( 309)												int this123 = (this119 & 255);
HXDLIN( 309)												if ((this123 == 0)) {
HXLINE( 309)													b112 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b112 = (( (Float)(this123) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a27;
HXDLIN( 309)												int this124 = ((color >> 24) & 255);
HXDLIN( 309)												if ((this124 == 0)) {
HXLINE( 309)													a27 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a27 = (( (Float)(this124) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r27;
HXDLIN( 309)												int this125 = ((color >> 16) & 255);
HXDLIN( 309)												if ((this125 == 0)) {
HXLINE( 309)													r27 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r27 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g27;
HXDLIN( 309)												int this126 = ((color >> 8) & 255);
HXDLIN( 309)												if ((this126 == 0)) {
HXLINE( 309)													g27 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g27 = (( (Float)(this126) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b211;
HXDLIN( 309)												int this127 = (color & 255);
HXDLIN( 309)												if ((this127 == 0)) {
HXLINE( 309)													b211 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b211 = (( (Float)(this127) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a37 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 309)												int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 309)												int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 309)												int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b211 * a27))));
HXDLIN( 309)												int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 309)												int blended7 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b32);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp30;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp30 = blended7;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp30);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this128 = pixelImage->image;
HXDLIN( 309)												int index17;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x13) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													index17 = ::Std_obj::_hx_int(( (Float)(((y13 * pixelImage->width) + x13)) ));
            												}
HXDLIN( 309)												int _hx_tmp31;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp31 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp31 = c13;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this128,index17,_hx_tmp31);
            											}
            										}
HXLINE(  73)										found3 = true;
            									}
            									else {
HXLINE( 309)										if (found3) {
HXLINE( 309)											goto _hx_goto_284;
            										}
            									}
            								}
            							}
            							_hx_goto_284:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 309)		if (softBottom) {
HXLINE( 309)			bool hasUndo4 = false;
HXDLIN( 309)			int aA2 = ((color >> 24) & 255);
HXDLIN( 309)			int rA2 = ((color >> 16) & 255);
HXDLIN( 309)			int gA2 = ((color >> 8) & 255);
HXDLIN( 309)			int bA2 = (color & 255);
HXDLIN( 309)			Float bcx2 = (cx - dx);
HXDLIN( 309)			Float bcy2 = (cy - dy);
HXDLIN( 309)			Float acx2 = (ex - dx);
HXDLIN( 309)			Float acy2 = (ey - dy);
HXDLIN( 309)			Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 309)			Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 309)			Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 309)			Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 309)			if ((ex > cx)) {
HXLINE( 309)				if ((ex > dx)) {
HXLINE( 309)					int min16;
HXDLIN( 309)					if ((cx > dx)) {
HXLINE( 309)						min16 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 309)						min16 = ::Math_obj::floor(cx);
            					}
HXDLIN( 309)					int ii_min32 = min16;
HXDLIN( 309)					int ii_max32 = ::Math_obj::ceil(ex);
HXDLIN( 309)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            				}
            				else {
HXLINE( 309)					int ii_min33 = ::Math_obj::floor(cx);
HXDLIN( 309)					int ii_max33 = ::Math_obj::ceil(dx);
HXDLIN( 309)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            				}
            			}
            			else {
HXLINE( 309)				if ((cx > dx)) {
HXLINE( 309)					int min17;
HXDLIN( 309)					if ((ex > dx)) {
HXLINE( 309)						min17 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 309)						min17 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 309)					int ii_min34 = min17;
HXDLIN( 309)					int ii_max34 = ::Math_obj::ceil(cx);
HXDLIN( 309)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            				}
            				else {
HXLINE( 309)					int ii_min35 = ::Math_obj::floor(ex);
HXDLIN( 309)					int ii_max35 = ::Math_obj::ceil(dx);
HXDLIN( 309)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 309)			if ((ey > cy)) {
HXLINE( 309)				if ((ey > dy)) {
HXLINE( 309)					int min18;
HXDLIN( 309)					if ((cy > dy)) {
HXLINE( 309)						min18 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 309)						min18 = ::Math_obj::floor(cy);
            					}
HXDLIN( 309)					int ii_min36 = min18;
HXDLIN( 309)					int ii_max36 = ::Math_obj::ceil(ey);
HXDLIN( 309)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            				}
            				else {
HXLINE( 309)					int ii_min37 = ::Math_obj::floor(cy);
HXDLIN( 309)					int ii_max37 = ::Math_obj::ceil(dy);
HXDLIN( 309)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            				}
            			}
            			else {
HXLINE( 309)				if ((cy > dy)) {
HXLINE( 309)					int min19;
HXDLIN( 309)					if ((ey > dy)) {
HXLINE( 309)						min19 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 309)						min19 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 309)					int ii_min38 = min19;
HXDLIN( 309)					int ii_max38 = ::Math_obj::ceil(cy);
HXDLIN( 309)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            				}
            				else {
HXLINE( 309)					int ii_min39 = ::Math_obj::floor(ey);
HXDLIN( 309)					int ii_max39 = ::Math_obj::ceil(dy);
HXDLIN( 309)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 309)			if (hasUndo4) {
HXLINE( 309)				int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 309)				int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 309)				 ::Dynamic imageType4 = null();
HXDLIN( 309)				 ::pi_xy::ImageStruct this129 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)				if (::hx::IsNull( imageType4 )) {
HXLINE(  54)					imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 309)				::Dynamic undoImage13;
HXDLIN( 309)				switch((int)(( (int)(imageType4) ))){
            					case (int)0: {
HXLINE( 309)						 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::BytesImg b33 = byt4;
HXDLIN( 309)						{
HXLINE( 309)							b33->width = width4;
HXDLIN( 309)							b33->height = height4;
HXDLIN( 309)							b33->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 309)							b33->data = ::haxe::io::Bytes_obj::alloc((b33->length * 4));
HXDLIN( 309)							{
HXLINE( 309)								int len8 = b33->length;
HXDLIN( 309)								int w4 = 0;
HXDLIN( 309)								{
HXLINE( 309)									int _g80 = 0;
HXDLIN( 309)									int _g81 = b33->height;
HXDLIN( 309)									while((_g80 < _g81)){
HXLINE( 309)										_g80 = (_g80 + 1);
HXDLIN( 309)										int y14 = (_g80 - 1);
HXDLIN( 309)										{
HXLINE( 309)											int _g82 = 0;
HXDLIN( 309)											int _g83 = b33->width;
HXDLIN( 309)											while((_g82 < _g83)){
HXLINE( 309)												_g82 = (_g82 + 1);
HXDLIN( 309)												int x14 = (_g82 - 1);
HXDLIN( 309)												{
HXLINE( 309)													w4 = (w4 + 1);
HXDLIN( 309)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w4 = (w4 + 1);
HXDLIN( 309)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w4 = (w4 + 1);
HXDLIN( 309)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w4 = (w4 + 1);
HXDLIN( 309)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage13 = b33;
            					}
            					break;
            					case (int)1: {
HXLINE( 309)						 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::ArrIntImg a29 = arrI4;
HXDLIN( 309)						{
HXLINE( 309)							a29->width = width4;
HXDLIN( 309)							a29->height = height4;
HXDLIN( 309)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)							a29->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 309)							{
HXLINE( 309)								int _g84 = 0;
HXDLIN( 309)								int _g85 = a29->length;
HXDLIN( 309)								while((_g84 < _g85)){
HXLINE( 309)									_g84 = (_g84 + 1);
HXDLIN( 309)									int i32 = (_g84 - 1);
HXDLIN( 309)									a29->data[i32] = 0;
            								}
            							}
            						}
HXDLIN( 309)						undoImage13 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 309)						 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::U32ArrImg b34 = u32a4;
HXDLIN( 309)						{
HXLINE( 309)							b34->width = width4;
HXDLIN( 309)							b34->height = height4;
HXDLIN( 309)							b34->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 309)							int size4 = (b34->length * 4);
HXDLIN( 309)							b34->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 309)							{
HXLINE( 309)								int _g86 = 0;
HXDLIN( 309)								int _g87 = b34->length;
HXDLIN( 309)								while((_g86 < _g87)){
HXLINE( 309)									_g86 = (_g86 + 1);
HXDLIN( 309)									int i33 = (_g86 - 1);
HXDLIN( 309)									{
HXLINE( 309)										 ::haxe::io::ArrayBufferViewImpl this130 = b34->data;
HXDLIN( 309)										bool undoImage14;
HXDLIN( 309)										if ((i33 >= 0)) {
HXLINE( 309)											undoImage14 = (i33 < (this130->byteLength >> 2));
            										}
            										else {
HXLINE( 309)											undoImage14 = false;
            										}
HXDLIN( 309)										if (undoImage14) {
HXLINE( 309)											 ::haxe::io::Bytes _this4 = this130->bytes;
HXDLIN( 309)											int pos4 = ((i33 << 2) + this130->byteOffset);
HXDLIN( 309)											_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 309)											_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage13 = b34;
            					}
            					break;
            					case (int)3: {
HXLINE( 309)						 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::VecIntImg v10 = vec4;
HXDLIN( 309)						{
HXLINE( 309)							v10->width = width4;
HXDLIN( 309)							v10->height = height4;
HXDLIN( 309)							v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 309)							v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 309)							{
HXLINE( 309)								int _g88 = 0;
HXDLIN( 309)								int _g89 = v10->length;
HXDLIN( 309)								while((_g88 < _g89)){
HXLINE( 309)									_g88 = (_g88 + 1);
HXDLIN( 309)									int i34 = (_g88 - 1);
HXDLIN( 309)									v10->data->__unsafe_set(i34,0);
            								}
            							}
            						}
HXDLIN( 309)						undoImage13 = v10;
            					}
            					break;
            					case (int)4: {
HXLINE( 309)						 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::StackIntImg b35 = sInt4;
HXDLIN( 309)						{
HXLINE( 309)							b35->width = width4;
HXDLIN( 309)							b35->height = height4;
HXDLIN( 309)							b35->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 309)							b35->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)							{
HXLINE( 309)								int len9 = b35->length;
HXDLIN( 309)								 ::haxe::ds::GenericStack_Int d4 = b35->data;
HXDLIN( 309)								if (::hx::IsNull( d4->head )) {
HXLINE( 309)									int _g90 = 0;
HXDLIN( 309)									int _g91 = len9;
HXDLIN( 309)									while((_g90 < _g91)){
HXLINE( 309)										_g90 = (_g90 + 1);
HXDLIN( 309)										int i35 = (_g90 - 1);
HXDLIN( 309)										d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            									}
            								}
            								else {
HXLINE( 309)									int _g92 = 0;
HXDLIN( 309)									int _g93 = len9;
HXDLIN( 309)									while((_g92 < _g93)){
HXLINE( 309)										_g92 = (_g92 + 1);
HXDLIN( 309)										int i36 = (_g92 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::ds::GenericCell_Int l4 = b35->data->head;
HXDLIN( 309)											 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 309)											{
HXLINE( 309)												int _g94 = 0;
HXDLIN( 309)												int _g95 = i36;
HXDLIN( 309)												while((_g94 < _g95)){
HXLINE( 309)													_g94 = (_g94 + 1);
HXDLIN( 309)													int i37 = (_g94 - 1);
HXLINE( 345)													prev4 = l4;
HXLINE( 346)													l4 = l4->next;
            												}
            											}
HXLINE( 309)											if (::hx::IsNull( prev4 )) {
HXLINE( 309)												b35->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 309)												l4 = null();
            											}
            											else {
HXLINE( 309)												prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 309)												l4 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage13 = b35;
            					}
            					break;
            				}
HXDLIN( 309)				this129->image = undoImage13;
HXDLIN( 309)				this129->width = width4;
HXDLIN( 309)				this129->height = height4;
HXDLIN( 309)				this129->imageType = ( (int)(imageType4) );
HXDLIN( 309)				undoImage12 = this129;
HXDLIN( 309)				{
HXLINE( 309)					int rectLeft4 = xIter34->start;
HXDLIN( 309)					int rectTop4 = yIter34->start;
HXDLIN( 309)					int rectRight4 = xIter34->max;
HXDLIN( 309)					bool forceClear4 = false;
HXDLIN( 309)					{
HXLINE( 309)						int _g96 = rectTop4;
HXDLIN( 309)						int _g97 = yIter34->max;
HXDLIN( 309)						while((_g96 < _g97)){
HXLINE( 309)							_g96 = (_g96 + 1);
HXDLIN( 309)							int dy5 = (_g96 - 1);
HXDLIN( 309)							{
HXLINE( 309)								int _g98 = rectLeft4;
HXDLIN( 309)								int _g99 = rectRight4;
HXDLIN( 309)								while((_g98 < _g99)){
HXLINE( 309)									_g98 = (_g98 + 1);
HXDLIN( 309)									int dx5 = (_g98 - 1);
HXDLIN( 309)									::Dynamic this131 = pixelImage->image;
HXDLIN( 309)									int index18;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										index18 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx5) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										index18 = ::Std_obj::_hx_int(( (Float)(((dy5 * pixelImage->width) + dx5)) ));
            									}
HXDLIN( 309)									int c14 = ::iterMagic::Iimg_obj::get(this131,index18);
HXDLIN( 309)									int col4;
HXDLIN( 309)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)										col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXLINE( 309)										col4 = c14;
            									}
HXDLIN( 309)									bool _hx_tmp32;
HXDLIN( 309)									if (pixelImage->useMask) {
HXLINE( 309)										_hx_tmp32 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 309)										_hx_tmp32 = false;
            									}
HXDLIN( 309)									if (_hx_tmp32) {
HXLINE( 309)										 ::pi_xy::ImageStruct this132 = pixelImage->mask;
HXDLIN( 309)										::Dynamic this133 = this132->image;
HXDLIN( 309)										int index19;
HXDLIN( 309)										if (this132->useVirtualPos) {
HXLINE( 309)											index19 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this132->virtualY) * ( (Float)(this132->width) )) + dx5) - this132->virtualX));
            										}
            										else {
HXLINE( 309)											index19 = ::Std_obj::_hx_int(( (Float)(((dy5 * this132->width) + dx5)) ));
            										}
HXDLIN( 309)										int c15 = ::iterMagic::Iimg_obj::get(this133,index19);
HXDLIN( 309)										int v11;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											v11 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											v11 = c15;
            										}
HXDLIN( 309)										int maskPixel4 = v11;
HXDLIN( 309)										int this134 = col4;
HXDLIN( 309)										if ((maskPixel4 == 0)) {
HXLINE( 309)											col4 = this134;
            										}
            										else {
HXLINE( 309)											Float m04;
HXDLIN( 309)											int this135 = ((maskPixel4 >> 24) & 255);
HXDLIN( 309)											if ((this135 == 0)) {
HXLINE( 309)												m04 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m04 = (( (Float)(this135) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m14;
HXDLIN( 309)											int this136 = ((maskPixel4 >> 16) & 255);
HXDLIN( 309)											if ((this136 == 0)) {
HXLINE( 309)												m14 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m14 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m24;
HXDLIN( 309)											int this137 = ((maskPixel4 >> 8) & 255);
HXDLIN( 309)											if ((this137 == 0)) {
HXLINE( 309)												m24 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m24 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m34;
HXDLIN( 309)											int this138 = (maskPixel4 & 255);
HXDLIN( 309)											if ((this138 == 0)) {
HXLINE( 309)												m34 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m34 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this134 >> 24) & 255)) )));
HXDLIN( 309)											int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this134 >> 16) & 255)) )));
HXDLIN( 309)											int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this134 >> 8) & 255)) )));
HXDLIN( 309)											int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this134 & 255)) )));
HXDLIN( 309)											col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 309)									if ((col4 != 0)) {
HXLINE( 309)										int x15 = (dx5 - rectLeft4);
HXDLIN( 309)										int y15 = (dy5 - rectTop4);
HXDLIN( 309)										int c16 = col4;
HXDLIN( 309)										bool _hx_tmp33;
HXDLIN( 309)										if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 309)											_hx_tmp33 = undoImage12->transparent;
            										}
            										else {
HXLINE( 309)											_hx_tmp33 = false;
            										}
HXDLIN( 309)										if (_hx_tmp33) {
HXLINE( 309)											int location8;
HXDLIN( 309)											if (undoImage12->useVirtualPos) {
HXLINE( 309)												location8 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 309)												location8 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            											}
HXDLIN( 309)											int this139 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 309)											int this140;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												this140 = ((((((this139 >> 24) & 255) << 24) | ((this139 & 255) << 16)) | (((this139 >> 8) & 255) << 8)) | ((this139 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												this140 = this139;
            											}
HXDLIN( 309)											Float a112;
HXDLIN( 309)											int this141 = ((this140 >> 24) & 255);
HXDLIN( 309)											if ((this141 == 0)) {
HXLINE( 309)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a112 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r19;
HXDLIN( 309)											int this142 = ((this140 >> 16) & 255);
HXDLIN( 309)											if ((this142 == 0)) {
HXLINE( 309)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r19 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g19;
HXDLIN( 309)											int this143 = ((this140 >> 8) & 255);
HXDLIN( 309)											if ((this143 == 0)) {
HXLINE( 309)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g19 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b113;
HXDLIN( 309)											int this144 = (this140 & 255);
HXDLIN( 309)											if ((this144 == 0)) {
HXLINE( 309)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b113 = (( (Float)(this144) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a210;
HXDLIN( 309)											int this145 = ((col4 >> 24) & 255);
HXDLIN( 309)											if ((this145 == 0)) {
HXLINE( 309)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a210 = (( (Float)(this145) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r28;
HXDLIN( 309)											int this146 = ((col4 >> 16) & 255);
HXDLIN( 309)											if ((this146 == 0)) {
HXLINE( 309)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r28 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g28;
HXDLIN( 309)											int this147 = ((col4 >> 8) & 255);
HXDLIN( 309)											if ((this147 == 0)) {
HXLINE( 309)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g28 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b212;
HXDLIN( 309)											int this148 = (col4 & 255);
HXDLIN( 309)											if ((this148 == 0)) {
HXLINE( 309)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b212 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 309)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a38) + (r28 * a210))));
HXDLIN( 309)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a38) + (g28 * a210))));
HXDLIN( 309)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a38) + (b212 * a210))));
HXDLIN( 309)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 309)											int blended8 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b36);
HXDLIN( 309)											{
HXLINE( 309)												int _hx_tmp34;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp34 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp34 = blended8;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp34);
            											}
            										}
            										else {
HXLINE( 309)											::Dynamic this149 = undoImage12->image;
HXDLIN( 309)											int index20;
HXDLIN( 309)											if (undoImage12->useVirtualPos) {
HXLINE( 309)												index20 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 309)												index20 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            											}
HXDLIN( 309)											int _hx_tmp35;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp35 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp35 = c16;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this149,index20,_hx_tmp35);
            										}
            									}
            									else {
HXLINE( 309)										if (forceClear4) {
HXLINE( 309)											::Dynamic this150 = undoImage12->image;
HXDLIN( 309)											int x16 = (dx5 - rectLeft4);
HXDLIN( 309)											int y16 = (dy5 - rectTop4);
HXDLIN( 309)											int index21;
HXDLIN( 309)											if (undoImage12->useVirtualPos) {
HXLINE( 309)												index21 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x16) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 309)												index21 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage12->width) + x16)) ));
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this150,index21,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 309)			bool found4 = false;
HXDLIN( 309)			{
HXLINE( 309)				int _g_min8 = xIter34->start;
HXDLIN( 309)				int _g_max8 = xIter34->max;
HXDLIN( 309)				while((_g_min8 < _g_max8)){
HXLINE( 309)					_g_min8 = (_g_min8 + 1);
HXDLIN( 309)					int px3 = (_g_min8 - 1);
HXDLIN( 309)					Float pcx2 = (( (Float)(px3) ) - dx);
HXLINE( 619)					found4 = false;
HXLINE( 309)					{
HXLINE( 309)						int _g_min9 = yIter34->start;
HXDLIN( 309)						int _g_max9 = yIter34->max;
HXDLIN( 309)						while((_g_min9 < _g_max9)){
HXLINE( 309)							_g_min9 = (_g_min9 + 1);
HXDLIN( 309)							int py3 = (_g_min9 - 1);
HXDLIN( 309)							Float pcy2 = (( (Float)(py3) ) - dy);
HXDLIN( 309)							Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 309)							Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 309)							Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 309)							Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 309)							Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 309)							bool _hx_tmp36;
HXDLIN( 309)							bool _hx_tmp37;
HXDLIN( 309)							if ((ratioA2 >= 0)) {
HXLINE( 309)								_hx_tmp37 = (ratioB2 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp37 = false;
            							}
HXDLIN( 309)							if (_hx_tmp37) {
HXLINE( 309)								_hx_tmp36 = (ratioC2 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp36 = false;
            							}
HXDLIN( 309)							if (_hx_tmp36) {
HXLINE( 309)								int i38 = ::Std_obj::_hx_int((( (Float)(aA2) ) * (softC * ratioB2)));
HXDLIN( 309)								if ((i38 > 255)) {
HXLINE(  24)									i38 = 255;
            								}
HXLINE( 309)								if ((i38 < 0)) {
HXLINE(  25)									i38 = 0;
            								}
HXLINE( 309)								int a39 = i38;
HXDLIN( 309)								int i39 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN( 309)								if ((i39 > 255)) {
HXLINE(  24)									i39 = 255;
            								}
HXLINE( 309)								if ((i39 < 0)) {
HXLINE(  25)									i39 = 0;
            								}
HXLINE( 309)								int r29 = i39;
HXDLIN( 309)								int i40 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN( 309)								if ((i40 > 255)) {
HXLINE(  24)									i40 = 255;
            								}
HXLINE( 309)								if ((i40 < 0)) {
HXLINE(  25)									i40 = 0;
            								}
HXLINE( 309)								int g29 = i40;
HXDLIN( 309)								int i41 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN( 309)								if ((i41 > 255)) {
HXLINE(  24)									i41 = 255;
            								}
HXLINE( 309)								if ((i41 < 0)) {
HXLINE(  25)									i41 = 0;
            								}
HXLINE( 309)								int b37 = i41;
HXDLIN( 309)								{
HXLINE( 309)									int location9;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										location9 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										location9 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            									}
HXDLIN( 309)									bool _hx_tmp38;
HXDLIN( 309)									if (pixelImage->transparent) {
HXLINE( 309)										_hx_tmp38 = (a39 < 254);
            									}
            									else {
HXLINE( 309)										_hx_tmp38 = false;
            									}
HXDLIN( 309)									if (_hx_tmp38) {
HXLINE( 309)										int this151 = ::iterMagic::Iimg_obj::get(pixelImage->image,location9);
HXDLIN( 309)										int old2;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											old2 = ((((((this151 >> 24) & 255) << 24) | ((this151 & 255) << 16)) | (((this151 >> 8) & 255) << 8)) | ((this151 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											old2 = this151;
            										}
HXDLIN( 309)										int rhs2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
HXDLIN( 309)										Float a113;
HXDLIN( 309)										int this152 = ((old2 >> 24) & 255);
HXDLIN( 309)										if ((this152 == 0)) {
HXLINE( 309)											a113 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r110;
HXDLIN( 309)										int this153 = ((old2 >> 16) & 255);
HXDLIN( 309)										if ((this153 == 0)) {
HXLINE( 309)											r110 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r110 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g110;
HXDLIN( 309)										int this154 = ((old2 >> 8) & 255);
HXDLIN( 309)										if ((this154 == 0)) {
HXLINE( 309)											g110 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g110 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b114;
HXDLIN( 309)										int this155 = (old2 & 255);
HXDLIN( 309)										if ((this155 == 0)) {
HXLINE( 309)											b114 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b114 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a211;
HXDLIN( 309)										int this156 = ((rhs2 >> 24) & 255);
HXDLIN( 309)										if ((this156 == 0)) {
HXLINE( 309)											a211 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r210;
HXDLIN( 309)										int this157 = ((rhs2 >> 16) & 255);
HXDLIN( 309)										if ((this157 == 0)) {
HXLINE( 309)											r210 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r210 = (( (Float)(this157) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g210;
HXDLIN( 309)										int this158 = ((rhs2 >> 8) & 255);
HXDLIN( 309)										if ((this158 == 0)) {
HXLINE( 309)											g210 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g210 = (( (Float)(this158) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b213;
HXDLIN( 309)										int this159 = (rhs2 & 255);
HXDLIN( 309)										if ((this159 == 0)) {
HXLINE( 309)											b213 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b213 = (( (Float)(this159) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 309)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 309)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 309)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b213 * a211))));
HXDLIN( 309)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 309)										int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b38);
HXDLIN( 309)										{
HXLINE( 309)											int _hx_tmp39;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp39 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp39 = blended9;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(pixelImage->image,location9,_hx_tmp39);
            										}
            									}
            									else {
HXLINE( 309)										int value2;
HXDLIN( 309)										if (pixelImage->isLittle) {
HXLINE( 309)											value2 = ((((a39 << 24) | (b37 << 16)) | (g29 << 8)) | r29);
            										}
            										else {
HXLINE( 309)											value2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
            										}
HXDLIN( 309)										::iterMagic::Iimg_obj::set(pixelImage->image,location9,value2);
            									}
            								}
HXLINE( 633)								found4 = true;
            							}
            							else {
HXLINE( 309)								if (found4) {
HXLINE( 309)									goto _hx_goto_296;
            								}
            							}
            						}
            						_hx_goto_296:;
            					}
            				}
            			}
HXDLIN( 309)			{
HXLINE( 309)				 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,cx,cy,dx,dy,true);
HXDLIN( 309)				if (hasUndo4) {
HXLINE( 309)					v12->undoImage = undoImage12;
HXDLIN( 309)					v12->undoX = xIter34->start;
HXDLIN( 309)					v12->undoY = yIter34->start;
            				}
            			}
            		}
            		else {
HXLINE( 309)			Float bx3 = cx;
HXDLIN( 309)			Float by3 = cy;
HXDLIN( 309)			Float cx3 = dx;
HXDLIN( 309)			Float cy3 = dy;
HXDLIN( 309)			bool hasUndo5 = false;
HXDLIN( 309)			bool adjustWinding2 = (((((ex * by3) - (bx3 * ey)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ey) - (ex * cy3))) > 0);
HXDLIN( 309)			if (!(adjustWinding2)) {
HXLINE( 309)				Float bx_2 = bx3;
HXDLIN( 309)				Float by_2 = by3;
HXLINE(  25)				bx3 = cx3;
HXLINE(  26)				by3 = cy3;
HXLINE(  27)				cx3 = bx_2;
HXLINE(  28)				cy3 = by_2;
            			}
HXLINE( 309)			{
HXLINE( 309)				Float s02 = ((ey * cx3) - (ex * cy3));
HXDLIN( 309)				Float sx2 = (cy3 - ey);
HXDLIN( 309)				Float sy2 = (ex - cx3);
HXDLIN( 309)				Float t02 = ((ex * by3) - (ey * bx3));
HXDLIN( 309)				Float tx2 = (ey - by3);
HXDLIN( 309)				Float ty2 = (bx3 - ex);
HXDLIN( 309)				Float A2 = ((((-(by3) * cx3) + (ey * (-(bx3) + cx3))) + (ex * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 309)				if ((ex > bx3)) {
HXLINE( 309)					if ((ex > cx3)) {
HXLINE( 309)						int min20;
HXDLIN( 309)						if ((bx3 > cx3)) {
HXLINE( 309)							min20 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 309)							min20 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 309)						int ii_min40 = min20;
HXDLIN( 309)						int ii_max40 = ::Math_obj::ceil(ex);
HXDLIN( 309)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            					}
            					else {
HXLINE( 309)						int ii_min41 = ::Math_obj::floor(bx3);
HXDLIN( 309)						int ii_max41 = ::Math_obj::ceil(cx3);
HXDLIN( 309)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            					}
            				}
            				else {
HXLINE( 309)					if ((bx3 > cx3)) {
HXLINE( 309)						int min21;
HXDLIN( 309)						if ((ex > cx3)) {
HXLINE( 309)							min21 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 309)							min21 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 309)						int ii_min42 = min21;
HXDLIN( 309)						int ii_max42 = ::Math_obj::ceil(bx3);
HXDLIN( 309)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            					}
            					else {
HXLINE( 309)						int ii_min43 = ::Math_obj::floor(ex);
HXDLIN( 309)						int ii_max43 = ::Math_obj::ceil(cx3);
HXDLIN( 309)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 309)				if ((ey > by3)) {
HXLINE( 309)					if ((ey > cy3)) {
HXLINE( 309)						int min22;
HXDLIN( 309)						if ((by3 > cy3)) {
HXLINE( 309)							min22 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 309)							min22 = ::Math_obj::floor(by3);
            						}
HXDLIN( 309)						int ii_min44 = min22;
HXDLIN( 309)						int ii_max44 = ::Math_obj::ceil(ey);
HXDLIN( 309)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            					}
            					else {
HXLINE( 309)						int ii_min45 = ::Math_obj::floor(by3);
HXDLIN( 309)						int ii_max45 = ::Math_obj::ceil(cy3);
HXDLIN( 309)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            					}
            				}
            				else {
HXLINE( 309)					if ((by3 > cy3)) {
HXLINE( 309)						int min23;
HXDLIN( 309)						if ((ey > cy3)) {
HXLINE( 309)							min23 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 309)							min23 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 309)						int ii_min46 = min23;
HXDLIN( 309)						int ii_max46 = ::Math_obj::ceil(by3);
HXDLIN( 309)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            					}
            					else {
HXLINE( 309)						int ii_min47 = ::Math_obj::floor(ey);
HXDLIN( 309)						int ii_max47 = ::Math_obj::ceil(cy3);
HXDLIN( 309)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 309)				if (hasUndo5) {
HXLINE( 309)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 309)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 309)					 ::Dynamic imageType5 = null();
HXDLIN( 309)					 ::pi_xy::ImageStruct this160 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 309)					::Dynamic undoImage16;
HXDLIN( 309)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXLINE( 309)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::BytesImg b39 = byt5;
HXDLIN( 309)							{
HXLINE( 309)								b39->width = width5;
HXDLIN( 309)								b39->height = height5;
HXDLIN( 309)								b39->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 309)								b39->data = ::haxe::io::Bytes_obj::alloc((b39->length * 4));
HXDLIN( 309)								{
HXLINE( 309)									int len10 = b39->length;
HXDLIN( 309)									int w5 = 0;
HXDLIN( 309)									{
HXLINE( 309)										int _g100 = 0;
HXDLIN( 309)										int _g101 = b39->height;
HXDLIN( 309)										while((_g100 < _g101)){
HXLINE( 309)											_g100 = (_g100 + 1);
HXDLIN( 309)											int y17 = (_g100 - 1);
HXDLIN( 309)											{
HXLINE( 309)												int _g102 = 0;
HXDLIN( 309)												int _g103 = b39->width;
HXDLIN( 309)												while((_g102 < _g103)){
HXLINE( 309)													_g102 = (_g102 + 1);
HXDLIN( 309)													int x17 = (_g102 - 1);
HXDLIN( 309)													{
HXLINE( 309)														w5 = (w5 + 1);
HXDLIN( 309)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w5 = (w5 + 1);
HXDLIN( 309)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w5 = (w5 + 1);
HXDLIN( 309)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w5 = (w5 + 1);
HXDLIN( 309)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage16 = b39;
            						}
            						break;
            						case (int)1: {
HXLINE( 309)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::ArrIntImg a41 = arrI5;
HXDLIN( 309)							{
HXLINE( 309)								a41->width = width5;
HXDLIN( 309)								a41->height = height5;
HXDLIN( 309)								a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)								a41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 309)								{
HXLINE( 309)									int _g104 = 0;
HXDLIN( 309)									int _g105 = a41->length;
HXDLIN( 309)									while((_g104 < _g105)){
HXLINE( 309)										_g104 = (_g104 + 1);
HXDLIN( 309)										int i42 = (_g104 - 1);
HXDLIN( 309)										a41->data[i42] = 0;
            									}
            								}
            							}
HXDLIN( 309)							undoImage16 = a41;
            						}
            						break;
            						case (int)2: {
HXLINE( 309)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::U32ArrImg b40 = u32a5;
HXDLIN( 309)							{
HXLINE( 309)								b40->width = width5;
HXDLIN( 309)								b40->height = height5;
HXDLIN( 309)								b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 309)								int size5 = (b40->length * 4);
HXDLIN( 309)								b40->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 309)								{
HXLINE( 309)									int _g106 = 0;
HXDLIN( 309)									int _g107 = b40->length;
HXDLIN( 309)									while((_g106 < _g107)){
HXLINE( 309)										_g106 = (_g106 + 1);
HXDLIN( 309)										int i43 = (_g106 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::io::ArrayBufferViewImpl this161 = b40->data;
HXDLIN( 309)											bool undoImage17;
HXDLIN( 309)											if ((i43 >= 0)) {
HXLINE( 309)												undoImage17 = (i43 < (this161->byteLength >> 2));
            											}
            											else {
HXLINE( 309)												undoImage17 = false;
            											}
HXDLIN( 309)											if (undoImage17) {
HXLINE( 309)												 ::haxe::io::Bytes _this5 = this161->bytes;
HXDLIN( 309)												int pos5 = ((i43 << 2) + this161->byteOffset);
HXDLIN( 309)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 309)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage16 = b40;
            						}
            						break;
            						case (int)3: {
HXLINE( 309)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::VecIntImg v13 = vec5;
HXDLIN( 309)							{
HXLINE( 309)								v13->width = width5;
HXDLIN( 309)								v13->height = height5;
HXDLIN( 309)								v13->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 309)								v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 309)								{
HXLINE( 309)									int _g108 = 0;
HXDLIN( 309)									int _g109 = v13->length;
HXDLIN( 309)									while((_g108 < _g109)){
HXLINE( 309)										_g108 = (_g108 + 1);
HXDLIN( 309)										int i44 = (_g108 - 1);
HXDLIN( 309)										v13->data->__unsafe_set(i44,0);
            									}
            								}
            							}
HXDLIN( 309)							undoImage16 = v13;
            						}
            						break;
            						case (int)4: {
HXLINE( 309)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::StackIntImg b41 = sInt5;
HXDLIN( 309)							{
HXLINE( 309)								b41->width = width5;
HXDLIN( 309)								b41->height = height5;
HXDLIN( 309)								b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 309)								b41->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)								{
HXLINE( 309)									int len11 = b41->length;
HXDLIN( 309)									 ::haxe::ds::GenericStack_Int d5 = b41->data;
HXDLIN( 309)									if (::hx::IsNull( d5->head )) {
HXLINE( 309)										int _g110 = 0;
HXDLIN( 309)										int _g111 = len11;
HXDLIN( 309)										while((_g110 < _g111)){
HXLINE( 309)											_g110 = (_g110 + 1);
HXDLIN( 309)											int i45 = (_g110 - 1);
HXDLIN( 309)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXLINE( 309)										int _g112 = 0;
HXDLIN( 309)										int _g113 = len11;
HXDLIN( 309)										while((_g112 < _g113)){
HXLINE( 309)											_g112 = (_g112 + 1);
HXDLIN( 309)											int i46 = (_g112 - 1);
HXDLIN( 309)											{
HXLINE( 309)												 ::haxe::ds::GenericCell_Int l5 = b41->data->head;
HXDLIN( 309)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 309)												{
HXLINE( 309)													int _g114 = 0;
HXDLIN( 309)													int _g115 = i46;
HXDLIN( 309)													while((_g114 < _g115)){
HXLINE( 309)														_g114 = (_g114 + 1);
HXDLIN( 309)														int i47 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 309)												if (::hx::IsNull( prev5 )) {
HXLINE( 309)													b41->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 309)													l5 = null();
            												}
            												else {
HXLINE( 309)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 309)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage16 = b41;
            						}
            						break;
            					}
HXDLIN( 309)					this160->image = undoImage16;
HXDLIN( 309)					this160->width = width5;
HXDLIN( 309)					this160->height = height5;
HXDLIN( 309)					this160->imageType = ( (int)(imageType5) );
HXDLIN( 309)					undoImage15 = this160;
HXDLIN( 309)					{
HXLINE( 309)						int rectLeft5 = xIter35->start;
HXDLIN( 309)						int rectTop5 = yIter35->start;
HXDLIN( 309)						int rectRight5 = xIter35->max;
HXDLIN( 309)						bool forceClear5 = false;
HXDLIN( 309)						{
HXLINE( 309)							int _g116 = rectTop5;
HXDLIN( 309)							int _g117 = yIter35->max;
HXDLIN( 309)							while((_g116 < _g117)){
HXLINE( 309)								_g116 = (_g116 + 1);
HXDLIN( 309)								int dy6 = (_g116 - 1);
HXDLIN( 309)								{
HXLINE( 309)									int _g118 = rectLeft5;
HXDLIN( 309)									int _g119 = rectRight5;
HXDLIN( 309)									while((_g118 < _g119)){
HXLINE( 309)										_g118 = (_g118 + 1);
HXDLIN( 309)										int dx6 = (_g118 - 1);
HXDLIN( 309)										::Dynamic this162 = pixelImage->image;
HXDLIN( 309)										int index22;
HXDLIN( 309)										if (pixelImage->useVirtualPos) {
HXLINE( 309)											index22 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx6) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 309)											index22 = ::Std_obj::_hx_int(( (Float)(((dy6 * pixelImage->width) + dx6)) ));
            										}
HXDLIN( 309)										int c17 = ::iterMagic::Iimg_obj::get(this162,index22);
HXDLIN( 309)										int col5;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											col5 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											col5 = c17;
            										}
HXDLIN( 309)										bool _hx_tmp40;
HXDLIN( 309)										if (pixelImage->useMask) {
HXLINE( 309)											_hx_tmp40 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 309)											_hx_tmp40 = false;
            										}
HXDLIN( 309)										if (_hx_tmp40) {
HXLINE( 309)											 ::pi_xy::ImageStruct this163 = pixelImage->mask;
HXDLIN( 309)											::Dynamic this164 = this163->image;
HXDLIN( 309)											int index23;
HXDLIN( 309)											if (this163->useVirtualPos) {
HXLINE( 309)												index23 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this163->virtualY) * ( (Float)(this163->width) )) + dx6) - this163->virtualX));
            											}
            											else {
HXLINE( 309)												index23 = ::Std_obj::_hx_int(( (Float)(((dy6 * this163->width) + dx6)) ));
            											}
HXDLIN( 309)											int c18 = ::iterMagic::Iimg_obj::get(this164,index23);
HXDLIN( 309)											int v14;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												v14 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												v14 = c18;
            											}
HXDLIN( 309)											int maskPixel5 = v14;
HXDLIN( 309)											int this165 = col5;
HXDLIN( 309)											if ((maskPixel5 == 0)) {
HXLINE( 309)												col5 = this165;
            											}
            											else {
HXLINE( 309)												Float m05;
HXDLIN( 309)												int this166 = ((maskPixel5 >> 24) & 255);
HXDLIN( 309)												if ((this166 == 0)) {
HXLINE( 309)													m05 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m05 = (( (Float)(this166) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m15;
HXDLIN( 309)												int this167 = ((maskPixel5 >> 16) & 255);
HXDLIN( 309)												if ((this167 == 0)) {
HXLINE( 309)													m15 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m15 = (( (Float)(this167) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m25;
HXDLIN( 309)												int this168 = ((maskPixel5 >> 8) & 255);
HXDLIN( 309)												if ((this168 == 0)) {
HXLINE( 309)													m25 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m25 = (( (Float)(this168) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m35;
HXDLIN( 309)												int this169 = (maskPixel5 & 255);
HXDLIN( 309)												if ((this169 == 0)) {
HXLINE( 309)													m35 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m35 = (( (Float)(this169) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this165 >> 24) & 255)) )));
HXDLIN( 309)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this165 >> 16) & 255)) )));
HXDLIN( 309)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this165 >> 8) & 255)) )));
HXDLIN( 309)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this165 & 255)) )));
HXDLIN( 309)												col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 309)										if ((col5 != 0)) {
HXLINE( 309)											int x18 = (dx6 - rectLeft5);
HXDLIN( 309)											int y18 = (dy6 - rectTop5);
HXDLIN( 309)											int c19 = col5;
HXDLIN( 309)											bool _hx_tmp41;
HXDLIN( 309)											if ((((c19 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp41 = undoImage15->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp41 = false;
            											}
HXDLIN( 309)											if (_hx_tmp41) {
HXLINE( 309)												int location10;
HXDLIN( 309)												if (undoImage15->useVirtualPos) {
HXLINE( 309)													location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 309)													location10 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            												}
HXDLIN( 309)												int this170 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 309)												int this171;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this171 = ((((((this170 >> 24) & 255) << 24) | ((this170 & 255) << 16)) | (((this170 >> 8) & 255) << 8)) | ((this170 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this171 = this170;
            												}
HXDLIN( 309)												Float a114;
HXDLIN( 309)												int this172 = ((this171 >> 24) & 255);
HXDLIN( 309)												if ((this172 == 0)) {
HXLINE( 309)													a114 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a114 = (( (Float)(this172) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r111;
HXDLIN( 309)												int this173 = ((this171 >> 16) & 255);
HXDLIN( 309)												if ((this173 == 0)) {
HXLINE( 309)													r111 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r111 = (( (Float)(this173) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g111;
HXDLIN( 309)												int this174 = ((this171 >> 8) & 255);
HXDLIN( 309)												if ((this174 == 0)) {
HXLINE( 309)													g111 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g111 = (( (Float)(this174) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b115;
HXDLIN( 309)												int this175 = (this171 & 255);
HXDLIN( 309)												if ((this175 == 0)) {
HXLINE( 309)													b115 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b115 = (( (Float)(this175) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a212;
HXDLIN( 309)												int this176 = ((col5 >> 24) & 255);
HXDLIN( 309)												if ((this176 == 0)) {
HXLINE( 309)													a212 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a212 = (( (Float)(this176) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r211;
HXDLIN( 309)												int this177 = ((col5 >> 16) & 255);
HXDLIN( 309)												if ((this177 == 0)) {
HXLINE( 309)													r211 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r211 = (( (Float)(this177) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g211;
HXDLIN( 309)												int this178 = ((col5 >> 8) & 255);
HXDLIN( 309)												if ((this178 == 0)) {
HXLINE( 309)													g211 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g211 = (( (Float)(this178) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b214;
HXDLIN( 309)												int this179 = (col5 & 255);
HXDLIN( 309)												if ((this179 == 0)) {
HXLINE( 309)													b214 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b214 = (( (Float)(this179) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 309)												int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 309)												int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 309)												int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b214 * a212))));
HXDLIN( 309)												int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 309)												int blended10 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b42);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp42;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp42 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp42 = blended10;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp42);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this180 = undoImage15->image;
HXDLIN( 309)												int index24;
HXDLIN( 309)												if (undoImage15->useVirtualPos) {
HXLINE( 309)													index24 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 309)													index24 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            												}
HXDLIN( 309)												int _hx_tmp43;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp43 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp43 = c19;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this180,index24,_hx_tmp43);
            											}
            										}
            										else {
HXLINE( 309)											if (forceClear5) {
HXLINE( 309)												::Dynamic this181 = undoImage15->image;
HXDLIN( 309)												int x19 = (dx6 - rectLeft5);
HXDLIN( 309)												int y19 = (dy6 - rectTop5);
HXDLIN( 309)												int index25;
HXDLIN( 309)												if (undoImage15->useVirtualPos) {
HXLINE( 309)													index25 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x19) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 309)													index25 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage15->width) + x19)) ));
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this181,index25,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 309)				bool found5 = false;
HXDLIN( 309)				Float s2 = ((Float)0.);
HXDLIN( 309)				Float t2 = ((Float)0.);
HXDLIN( 309)				Float sxx2 = ((Float)0.);
HXDLIN( 309)				Float txx2 = ((Float)0.);
HXDLIN( 309)				{
HXLINE( 309)					int _g_min10 = xIter35->start;
HXDLIN( 309)					int _g_max10 = xIter35->max;
HXDLIN( 309)					while((_g_min10 < _g_max10)){
HXLINE( 309)						_g_min10 = (_g_min10 + 1);
HXDLIN( 309)						int x20 = (_g_min10 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x20) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x20) ));
HXLINE(  62)						found5 = false;
HXLINE( 309)						{
HXLINE( 309)							int _g_min11 = yIter35->start;
HXDLIN( 309)							int _g_max11 = yIter35->max;
HXDLIN( 309)							while((_g_min11 < _g_max11)){
HXLINE( 309)								_g_min11 = (_g_min11 + 1);
HXDLIN( 309)								int y20 = (_g_min11 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y20) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y20) )));
HXLINE( 309)								bool _hx_tmp44;
HXDLIN( 309)								if (!((s2 <= 0))) {
HXLINE( 309)									_hx_tmp44 = (t2 <= 0);
            								}
            								else {
HXLINE( 309)									_hx_tmp44 = true;
            								}
HXDLIN( 309)								if (_hx_tmp44) {
HXLINE( 309)									if (found5) {
HXLINE( 309)										goto _hx_goto_308;
            									}
            								}
            								else {
HXLINE( 309)									if (((s2 + t2) < A2)) {
HXLINE( 309)										{
HXLINE( 309)											int c20 = color;
HXDLIN( 309)											bool _hx_tmp45;
HXDLIN( 309)											if ((((c20 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp45 = pixelImage->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp45 = false;
            											}
HXDLIN( 309)											if (_hx_tmp45) {
HXLINE( 309)												int location11;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x20) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													location11 = ::Std_obj::_hx_int(( (Float)(((y20 * pixelImage->width) + x20)) ));
            												}
HXDLIN( 309)												int this182 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 309)												int this183;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this183 = ((((((this182 >> 24) & 255) << 24) | ((this182 & 255) << 16)) | (((this182 >> 8) & 255) << 8)) | ((this182 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this183 = this182;
            												}
HXDLIN( 309)												Float a115;
HXDLIN( 309)												int this184 = ((this183 >> 24) & 255);
HXDLIN( 309)												if ((this184 == 0)) {
HXLINE( 309)													a115 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a115 = (( (Float)(this184) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r112;
HXDLIN( 309)												int this185 = ((this183 >> 16) & 255);
HXDLIN( 309)												if ((this185 == 0)) {
HXLINE( 309)													r112 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r112 = (( (Float)(this185) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g112;
HXDLIN( 309)												int this186 = ((this183 >> 8) & 255);
HXDLIN( 309)												if ((this186 == 0)) {
HXLINE( 309)													g112 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g112 = (( (Float)(this186) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b116;
HXDLIN( 309)												int this187 = (this183 & 255);
HXDLIN( 309)												if ((this187 == 0)) {
HXLINE( 309)													b116 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b116 = (( (Float)(this187) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a213;
HXDLIN( 309)												int this188 = ((color >> 24) & 255);
HXDLIN( 309)												if ((this188 == 0)) {
HXLINE( 309)													a213 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a213 = (( (Float)(this188) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r212;
HXDLIN( 309)												int this189 = ((color >> 16) & 255);
HXDLIN( 309)												if ((this189 == 0)) {
HXLINE( 309)													r212 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r212 = (( (Float)(this189) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g212;
HXDLIN( 309)												int this190 = ((color >> 8) & 255);
HXDLIN( 309)												if ((this190 == 0)) {
HXLINE( 309)													g212 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g212 = (( (Float)(this190) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b215;
HXDLIN( 309)												int this191 = (color & 255);
HXDLIN( 309)												if ((this191 == 0)) {
HXLINE( 309)													b215 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b215 = (( (Float)(this191) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 309)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 309)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 309)												int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b215 * a213))));
HXDLIN( 309)												int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 309)												int blended11 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b43);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp46;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp46 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp46 = blended11;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp46);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this192 = pixelImage->image;
HXDLIN( 309)												int index26;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													index26 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x20) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													index26 = ::Std_obj::_hx_int(( (Float)(((y20 * pixelImage->width) + x20)) ));
            												}
HXDLIN( 309)												int _hx_tmp47;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp47 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp47 = c20;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this192,index26,_hx_tmp47);
            											}
            										}
HXLINE(  73)										found5 = true;
            									}
            									else {
HXLINE( 309)										if (found5) {
HXLINE( 309)											goto _hx_goto_308;
            										}
            									}
            								}
            							}
            							_hx_goto_308:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 309)		if (softLeft) {
HXLINE( 309)			bool hasUndo6 = false;
HXDLIN( 309)			int aA3 = ((color >> 24) & 255);
HXDLIN( 309)			int rA3 = ((color >> 16) & 255);
HXDLIN( 309)			int gA3 = ((color >> 8) & 255);
HXDLIN( 309)			int bA3 = (color & 255);
HXDLIN( 309)			Float bcx3 = (dx - ax);
HXDLIN( 309)			Float bcy3 = (dy - ay);
HXDLIN( 309)			Float acx3 = (ex - ax);
HXDLIN( 309)			Float acy3 = (ey - ay);
HXDLIN( 309)			Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 309)			Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 309)			Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 309)			Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 309)			if ((ex > dx)) {
HXLINE( 309)				if ((ex > ax)) {
HXLINE( 309)					int min24;
HXDLIN( 309)					if ((dx > ax)) {
HXLINE( 309)						min24 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 309)						min24 = ::Math_obj::floor(dx);
            					}
HXDLIN( 309)					int ii_min48 = min24;
HXDLIN( 309)					int ii_max48 = ::Math_obj::ceil(ex);
HXDLIN( 309)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            				}
            				else {
HXLINE( 309)					int ii_min49 = ::Math_obj::floor(dx);
HXDLIN( 309)					int ii_max49 = ::Math_obj::ceil(ax);
HXDLIN( 309)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            				}
            			}
            			else {
HXLINE( 309)				if ((dx > ax)) {
HXLINE( 309)					int min25;
HXDLIN( 309)					if ((ex > ax)) {
HXLINE( 309)						min25 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 309)						min25 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 309)					int ii_min50 = min25;
HXDLIN( 309)					int ii_max50 = ::Math_obj::ceil(dx);
HXDLIN( 309)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            				}
            				else {
HXLINE( 309)					int ii_min51 = ::Math_obj::floor(ex);
HXDLIN( 309)					int ii_max51 = ::Math_obj::ceil(ax);
HXDLIN( 309)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 309)			if ((ey > dy)) {
HXLINE( 309)				if ((ey > ay)) {
HXLINE( 309)					int min26;
HXDLIN( 309)					if ((dy > ay)) {
HXLINE( 309)						min26 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 309)						min26 = ::Math_obj::floor(dy);
            					}
HXDLIN( 309)					int ii_min52 = min26;
HXDLIN( 309)					int ii_max52 = ::Math_obj::ceil(ey);
HXDLIN( 309)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            				}
            				else {
HXLINE( 309)					int ii_min53 = ::Math_obj::floor(dy);
HXDLIN( 309)					int ii_max53 = ::Math_obj::ceil(ay);
HXDLIN( 309)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            				}
            			}
            			else {
HXLINE( 309)				if ((dy > ay)) {
HXLINE( 309)					int min27;
HXDLIN( 309)					if ((ey > ay)) {
HXLINE( 309)						min27 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 309)						min27 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 309)					int ii_min54 = min27;
HXDLIN( 309)					int ii_max54 = ::Math_obj::ceil(dy);
HXDLIN( 309)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            				}
            				else {
HXLINE( 309)					int ii_min55 = ::Math_obj::floor(ey);
HXDLIN( 309)					int ii_max55 = ::Math_obj::ceil(ay);
HXDLIN( 309)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            				}
            			}
HXDLIN( 309)			 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 309)			if (hasUndo6) {
HXLINE( 309)				int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 309)				int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 309)				 ::Dynamic imageType6 = null();
HXDLIN( 309)				 ::pi_xy::ImageStruct this193 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)				if (::hx::IsNull( imageType6 )) {
HXLINE(  54)					imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 309)				::Dynamic undoImage19;
HXDLIN( 309)				switch((int)(( (int)(imageType6) ))){
            					case (int)0: {
HXLINE( 309)						 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::BytesImg b44 = byt6;
HXDLIN( 309)						{
HXLINE( 309)							b44->width = width6;
HXDLIN( 309)							b44->height = height6;
HXDLIN( 309)							b44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 309)							b44->data = ::haxe::io::Bytes_obj::alloc((b44->length * 4));
HXDLIN( 309)							{
HXLINE( 309)								int len12 = b44->length;
HXDLIN( 309)								int w6 = 0;
HXDLIN( 309)								{
HXLINE( 309)									int _g120 = 0;
HXDLIN( 309)									int _g121 = b44->height;
HXDLIN( 309)									while((_g120 < _g121)){
HXLINE( 309)										_g120 = (_g120 + 1);
HXDLIN( 309)										int y21 = (_g120 - 1);
HXDLIN( 309)										{
HXLINE( 309)											int _g122 = 0;
HXDLIN( 309)											int _g123 = b44->width;
HXDLIN( 309)											while((_g122 < _g123)){
HXLINE( 309)												_g122 = (_g122 + 1);
HXDLIN( 309)												int x21 = (_g122 - 1);
HXDLIN( 309)												{
HXLINE( 309)													w6 = (w6 + 1);
HXDLIN( 309)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w6 = (w6 + 1);
HXDLIN( 309)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w6 = (w6 + 1);
HXDLIN( 309)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 309)												{
HXLINE( 309)													w6 = (w6 + 1);
HXDLIN( 309)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage19 = b44;
            					}
            					break;
            					case (int)1: {
HXLINE( 309)						 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::ArrIntImg a44 = arrI6;
HXDLIN( 309)						{
HXLINE( 309)							a44->width = width6;
HXDLIN( 309)							a44->height = height6;
HXDLIN( 309)							a44->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)							a44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 309)							{
HXLINE( 309)								int _g124 = 0;
HXDLIN( 309)								int _g125 = a44->length;
HXDLIN( 309)								while((_g124 < _g125)){
HXLINE( 309)									_g124 = (_g124 + 1);
HXDLIN( 309)									int i48 = (_g124 - 1);
HXDLIN( 309)									a44->data[i48] = 0;
            								}
            							}
            						}
HXDLIN( 309)						undoImage19 = a44;
            					}
            					break;
            					case (int)2: {
HXLINE( 309)						 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::U32ArrImg b45 = u32a6;
HXDLIN( 309)						{
HXLINE( 309)							b45->width = width6;
HXDLIN( 309)							b45->height = height6;
HXDLIN( 309)							b45->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 309)							int size6 = (b45->length * 4);
HXDLIN( 309)							b45->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 309)							{
HXLINE( 309)								int _g126 = 0;
HXDLIN( 309)								int _g127 = b45->length;
HXDLIN( 309)								while((_g126 < _g127)){
HXLINE( 309)									_g126 = (_g126 + 1);
HXDLIN( 309)									int i49 = (_g126 - 1);
HXDLIN( 309)									{
HXLINE( 309)										 ::haxe::io::ArrayBufferViewImpl this194 = b45->data;
HXDLIN( 309)										bool undoImage20;
HXDLIN( 309)										if ((i49 >= 0)) {
HXLINE( 309)											undoImage20 = (i49 < (this194->byteLength >> 2));
            										}
            										else {
HXLINE( 309)											undoImage20 = false;
            										}
HXDLIN( 309)										if (undoImage20) {
HXLINE( 309)											 ::haxe::io::Bytes _this6 = this194->bytes;
HXDLIN( 309)											int pos6 = ((i49 << 2) + this194->byteOffset);
HXDLIN( 309)											_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 309)											_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)											_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage19 = b45;
            					}
            					break;
            					case (int)3: {
HXLINE( 309)						 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::VecIntImg v15 = vec6;
HXDLIN( 309)						{
HXLINE( 309)							v15->width = width6;
HXDLIN( 309)							v15->height = height6;
HXDLIN( 309)							v15->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 309)							v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN( 309)							{
HXLINE( 309)								int _g128 = 0;
HXDLIN( 309)								int _g129 = v15->length;
HXDLIN( 309)								while((_g128 < _g129)){
HXLINE( 309)									_g128 = (_g128 + 1);
HXDLIN( 309)									int i50 = (_g128 - 1);
HXDLIN( 309)									v15->data->__unsafe_set(i50,0);
            								}
            							}
            						}
HXDLIN( 309)						undoImage19 = v15;
            					}
            					break;
            					case (int)4: {
HXLINE( 309)						 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)						 ::iterMagic::StackIntImg b46 = sInt6;
HXDLIN( 309)						{
HXLINE( 309)							b46->width = width6;
HXDLIN( 309)							b46->height = height6;
HXDLIN( 309)							b46->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 309)							b46->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)							{
HXLINE( 309)								int len13 = b46->length;
HXDLIN( 309)								 ::haxe::ds::GenericStack_Int d6 = b46->data;
HXDLIN( 309)								if (::hx::IsNull( d6->head )) {
HXLINE( 309)									int _g130 = 0;
HXDLIN( 309)									int _g131 = len13;
HXDLIN( 309)									while((_g130 < _g131)){
HXLINE( 309)										_g130 = (_g130 + 1);
HXDLIN( 309)										int i51 = (_g130 - 1);
HXDLIN( 309)										d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            									}
            								}
            								else {
HXLINE( 309)									int _g132 = 0;
HXDLIN( 309)									int _g133 = len13;
HXDLIN( 309)									while((_g132 < _g133)){
HXLINE( 309)										_g132 = (_g132 + 1);
HXDLIN( 309)										int i52 = (_g132 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::ds::GenericCell_Int l6 = b46->data->head;
HXDLIN( 309)											 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 309)											{
HXLINE( 309)												int _g134 = 0;
HXDLIN( 309)												int _g135 = i52;
HXDLIN( 309)												while((_g134 < _g135)){
HXLINE( 309)													_g134 = (_g134 + 1);
HXDLIN( 309)													int i53 = (_g134 - 1);
HXLINE( 345)													prev6 = l6;
HXLINE( 346)													l6 = l6->next;
            												}
            											}
HXLINE( 309)											if (::hx::IsNull( prev6 )) {
HXLINE( 309)												b46->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 309)												l6 = null();
            											}
            											else {
HXLINE( 309)												prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 309)												l6 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 309)						undoImage19 = b46;
            					}
            					break;
            				}
HXDLIN( 309)				this193->image = undoImage19;
HXDLIN( 309)				this193->width = width6;
HXDLIN( 309)				this193->height = height6;
HXDLIN( 309)				this193->imageType = ( (int)(imageType6) );
HXDLIN( 309)				undoImage18 = this193;
HXDLIN( 309)				{
HXLINE( 309)					int rectLeft6 = xIter36->start;
HXDLIN( 309)					int rectTop6 = yIter36->start;
HXDLIN( 309)					int rectRight6 = xIter36->max;
HXDLIN( 309)					bool forceClear6 = false;
HXDLIN( 309)					{
HXLINE( 309)						int _g136 = rectTop6;
HXDLIN( 309)						int _g137 = yIter36->max;
HXDLIN( 309)						while((_g136 < _g137)){
HXLINE( 309)							_g136 = (_g136 + 1);
HXDLIN( 309)							int dy7 = (_g136 - 1);
HXDLIN( 309)							{
HXLINE( 309)								int _g138 = rectLeft6;
HXDLIN( 309)								int _g139 = rectRight6;
HXDLIN( 309)								while((_g138 < _g139)){
HXLINE( 309)									_g138 = (_g138 + 1);
HXDLIN( 309)									int dx7 = (_g138 - 1);
HXDLIN( 309)									::Dynamic this195 = pixelImage->image;
HXDLIN( 309)									int index27;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										index27 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx7) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										index27 = ::Std_obj::_hx_int(( (Float)(((dy7 * pixelImage->width) + dx7)) ));
            									}
HXDLIN( 309)									int c21 = ::iterMagic::Iimg_obj::get(this195,index27);
HXDLIN( 309)									int col6;
HXDLIN( 309)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)										col6 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXLINE( 309)										col6 = c21;
            									}
HXDLIN( 309)									bool _hx_tmp48;
HXDLIN( 309)									if (pixelImage->useMask) {
HXLINE( 309)										_hx_tmp48 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 309)										_hx_tmp48 = false;
            									}
HXDLIN( 309)									if (_hx_tmp48) {
HXLINE( 309)										 ::pi_xy::ImageStruct this196 = pixelImage->mask;
HXDLIN( 309)										::Dynamic this197 = this196->image;
HXDLIN( 309)										int index28;
HXDLIN( 309)										if (this196->useVirtualPos) {
HXLINE( 309)											index28 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this196->virtualY) * ( (Float)(this196->width) )) + dx7) - this196->virtualX));
            										}
            										else {
HXLINE( 309)											index28 = ::Std_obj::_hx_int(( (Float)(((dy7 * this196->width) + dx7)) ));
            										}
HXDLIN( 309)										int c22 = ::iterMagic::Iimg_obj::get(this197,index28);
HXDLIN( 309)										int v16;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											v16 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											v16 = c22;
            										}
HXDLIN( 309)										int maskPixel6 = v16;
HXDLIN( 309)										int this198 = col6;
HXDLIN( 309)										if ((maskPixel6 == 0)) {
HXLINE( 309)											col6 = this198;
            										}
            										else {
HXLINE( 309)											Float m06;
HXDLIN( 309)											int this199 = ((maskPixel6 >> 24) & 255);
HXDLIN( 309)											if ((this199 == 0)) {
HXLINE( 309)												m06 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m06 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m16;
HXDLIN( 309)											int this200 = ((maskPixel6 >> 16) & 255);
HXDLIN( 309)											if ((this200 == 0)) {
HXLINE( 309)												m16 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m16 = (( (Float)(this200) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m26;
HXDLIN( 309)											int this201 = ((maskPixel6 >> 8) & 255);
HXDLIN( 309)											if ((this201 == 0)) {
HXLINE( 309)												m26 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m26 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float m36;
HXDLIN( 309)											int this202 = (maskPixel6 & 255);
HXDLIN( 309)											if ((this202 == 0)) {
HXLINE( 309)												m36 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												m36 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this198 >> 24) & 255)) )));
HXDLIN( 309)											int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this198 >> 16) & 255)) )));
HXDLIN( 309)											int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this198 >> 8) & 255)) )));
HXDLIN( 309)											int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this198 & 255)) )));
HXDLIN( 309)											col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 309)									if ((col6 != 0)) {
HXLINE( 309)										int x22 = (dx7 - rectLeft6);
HXDLIN( 309)										int y22 = (dy7 - rectTop6);
HXDLIN( 309)										int c23 = col6;
HXDLIN( 309)										bool _hx_tmp49;
HXDLIN( 309)										if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 309)											_hx_tmp49 = undoImage18->transparent;
            										}
            										else {
HXLINE( 309)											_hx_tmp49 = false;
            										}
HXDLIN( 309)										if (_hx_tmp49) {
HXLINE( 309)											int location12;
HXDLIN( 309)											if (undoImage18->useVirtualPos) {
HXLINE( 309)												location12 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x22) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 309)												location12 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage18->width) + x22)) ));
            											}
HXDLIN( 309)											int this203 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 309)											int this204;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												this204 = ((((((this203 >> 24) & 255) << 24) | ((this203 & 255) << 16)) | (((this203 >> 8) & 255) << 8)) | ((this203 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												this204 = this203;
            											}
HXDLIN( 309)											Float a116;
HXDLIN( 309)											int this205 = ((this204 >> 24) & 255);
HXDLIN( 309)											if ((this205 == 0)) {
HXLINE( 309)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a116 = (( (Float)(this205) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r113;
HXDLIN( 309)											int this206 = ((this204 >> 16) & 255);
HXDLIN( 309)											if ((this206 == 0)) {
HXLINE( 309)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r113 = (( (Float)(this206) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g113;
HXDLIN( 309)											int this207 = ((this204 >> 8) & 255);
HXDLIN( 309)											if ((this207 == 0)) {
HXLINE( 309)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g113 = (( (Float)(this207) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b117;
HXDLIN( 309)											int this208 = (this204 & 255);
HXDLIN( 309)											if ((this208 == 0)) {
HXLINE( 309)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b117 = (( (Float)(this208) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a214;
HXDLIN( 309)											int this209 = ((col6 >> 24) & 255);
HXDLIN( 309)											if ((this209 == 0)) {
HXLINE( 309)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												a214 = (( (Float)(this209) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float r213;
HXDLIN( 309)											int this210 = ((col6 >> 16) & 255);
HXDLIN( 309)											if ((this210 == 0)) {
HXLINE( 309)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												r213 = (( (Float)(this210) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float g213;
HXDLIN( 309)											int this211 = ((col6 >> 8) & 255);
HXDLIN( 309)											if ((this211 == 0)) {
HXLINE( 309)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												g213 = (( (Float)(this211) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float b216;
HXDLIN( 309)											int this212 = (col6 & 255);
HXDLIN( 309)											if ((this212 == 0)) {
HXLINE( 309)												b216 = ((Float)0.);
            											}
            											else {
HXLINE( 309)												b216 = (( (Float)(this212) ) / ( (Float)(255) ));
            											}
HXDLIN( 309)											Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 309)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 309)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 309)											int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b216 * a214))));
HXDLIN( 309)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 309)											int blended12 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b47);
HXDLIN( 309)											{
HXLINE( 309)												int _hx_tmp50;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp50 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp50 = blended12;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp50);
            											}
            										}
            										else {
HXLINE( 309)											::Dynamic this213 = undoImage18->image;
HXDLIN( 309)											int index29;
HXDLIN( 309)											if (undoImage18->useVirtualPos) {
HXLINE( 309)												index29 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x22) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 309)												index29 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage18->width) + x22)) ));
            											}
HXDLIN( 309)											int _hx_tmp51;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp51 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp51 = c23;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this213,index29,_hx_tmp51);
            										}
            									}
            									else {
HXLINE( 309)										if (forceClear6) {
HXLINE( 309)											::Dynamic this214 = undoImage18->image;
HXDLIN( 309)											int x23 = (dx7 - rectLeft6);
HXDLIN( 309)											int y23 = (dy7 - rectTop6);
HXDLIN( 309)											int index30;
HXDLIN( 309)											if (undoImage18->useVirtualPos) {
HXLINE( 309)												index30 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x23) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 309)												index30 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage18->width) + x23)) ));
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(this214,index30,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 309)			bool found6 = false;
HXDLIN( 309)			{
HXLINE( 309)				int _g_min12 = xIter36->start;
HXDLIN( 309)				int _g_max12 = xIter36->max;
HXDLIN( 309)				while((_g_min12 < _g_max12)){
HXLINE( 309)					_g_min12 = (_g_min12 + 1);
HXDLIN( 309)					int px4 = (_g_min12 - 1);
HXDLIN( 309)					Float pcx3 = (( (Float)(px4) ) - ax);
HXLINE( 619)					found6 = false;
HXLINE( 309)					{
HXLINE( 309)						int _g_min13 = yIter36->start;
HXDLIN( 309)						int _g_max13 = yIter36->max;
HXDLIN( 309)						while((_g_min13 < _g_max13)){
HXLINE( 309)							_g_min13 = (_g_min13 + 1);
HXDLIN( 309)							int py4 = (_g_min13 - 1);
HXDLIN( 309)							Float pcy3 = (( (Float)(py4) ) - ay);
HXDLIN( 309)							Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 309)							Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 309)							Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 309)							Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 309)							Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 309)							bool _hx_tmp52;
HXDLIN( 309)							bool _hx_tmp53;
HXDLIN( 309)							if ((ratioA3 >= 0)) {
HXLINE( 309)								_hx_tmp53 = (ratioB3 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp53 = false;
            							}
HXDLIN( 309)							if (_hx_tmp53) {
HXLINE( 309)								_hx_tmp52 = (ratioC3 >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp52 = false;
            							}
HXDLIN( 309)							if (_hx_tmp52) {
HXLINE( 309)								int i54 = ::Std_obj::_hx_int((( (Float)(aA3) ) * (softC * ratioB3)));
HXDLIN( 309)								if ((i54 > 255)) {
HXLINE(  24)									i54 = 255;
            								}
HXLINE( 309)								if ((i54 < 0)) {
HXLINE(  25)									i54 = 0;
            								}
HXLINE( 309)								int a46 = i54;
HXDLIN( 309)								int i55 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN( 309)								if ((i55 > 255)) {
HXLINE(  24)									i55 = 255;
            								}
HXLINE( 309)								if ((i55 < 0)) {
HXLINE(  25)									i55 = 0;
            								}
HXLINE( 309)								int r34 = i55;
HXDLIN( 309)								int i56 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN( 309)								if ((i56 > 255)) {
HXLINE(  24)									i56 = 255;
            								}
HXLINE( 309)								if ((i56 < 0)) {
HXLINE(  25)									i56 = 0;
            								}
HXLINE( 309)								int g34 = i56;
HXDLIN( 309)								int i57 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN( 309)								if ((i57 > 255)) {
HXLINE(  24)									i57 = 255;
            								}
HXLINE( 309)								if ((i57 < 0)) {
HXLINE(  25)									i57 = 0;
            								}
HXLINE( 309)								int b48 = i57;
HXDLIN( 309)								{
HXLINE( 309)									int location13;
HXDLIN( 309)									if (pixelImage->useVirtualPos) {
HXLINE( 309)										location13 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 309)										location13 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            									}
HXDLIN( 309)									bool _hx_tmp54;
HXDLIN( 309)									if (pixelImage->transparent) {
HXLINE( 309)										_hx_tmp54 = (a46 < 254);
            									}
            									else {
HXLINE( 309)										_hx_tmp54 = false;
            									}
HXDLIN( 309)									if (_hx_tmp54) {
HXLINE( 309)										int this215 = ::iterMagic::Iimg_obj::get(pixelImage->image,location13);
HXDLIN( 309)										int old3;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											old3 = ((((((this215 >> 24) & 255) << 24) | ((this215 & 255) << 16)) | (((this215 >> 8) & 255) << 8)) | ((this215 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											old3 = this215;
            										}
HXDLIN( 309)										int rhs3 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b48);
HXDLIN( 309)										Float a117;
HXDLIN( 309)										int this216 = ((old3 >> 24) & 255);
HXDLIN( 309)										if ((this216 == 0)) {
HXLINE( 309)											a117 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a117 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r114;
HXDLIN( 309)										int this217 = ((old3 >> 16) & 255);
HXDLIN( 309)										if ((this217 == 0)) {
HXLINE( 309)											r114 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r114 = (( (Float)(this217) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g114;
HXDLIN( 309)										int this218 = ((old3 >> 8) & 255);
HXDLIN( 309)										if ((this218 == 0)) {
HXLINE( 309)											g114 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g114 = (( (Float)(this218) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b118;
HXDLIN( 309)										int this219 = (old3 & 255);
HXDLIN( 309)										if ((this219 == 0)) {
HXLINE( 309)											b118 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b118 = (( (Float)(this219) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a215;
HXDLIN( 309)										int this220 = ((rhs3 >> 24) & 255);
HXDLIN( 309)										if ((this220 == 0)) {
HXLINE( 309)											a215 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											a215 = (( (Float)(this220) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float r214;
HXDLIN( 309)										int this221 = ((rhs3 >> 16) & 255);
HXDLIN( 309)										if ((this221 == 0)) {
HXLINE( 309)											r214 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											r214 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float g214;
HXDLIN( 309)										int this222 = ((rhs3 >> 8) & 255);
HXDLIN( 309)										if ((this222 == 0)) {
HXLINE( 309)											g214 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											g214 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float b217;
HXDLIN( 309)										int this223 = (rhs3 & 255);
HXDLIN( 309)										if ((this223 == 0)) {
HXLINE( 309)											b217 = ((Float)0.);
            										}
            										else {
HXLINE( 309)											b217 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 309)										Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 309)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 309)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 309)										int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b217 * a215))));
HXDLIN( 309)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 309)										int blended13 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b49);
HXDLIN( 309)										{
HXLINE( 309)											int _hx_tmp55;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												_hx_tmp55 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												_hx_tmp55 = blended13;
            											}
HXDLIN( 309)											::iterMagic::Iimg_obj::set(pixelImage->image,location13,_hx_tmp55);
            										}
            									}
            									else {
HXLINE( 309)										int value3;
HXDLIN( 309)										if (pixelImage->isLittle) {
HXLINE( 309)											value3 = ((((a46 << 24) | (b48 << 16)) | (g34 << 8)) | r34);
            										}
            										else {
HXLINE( 309)											value3 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b48);
            										}
HXDLIN( 309)										::iterMagic::Iimg_obj::set(pixelImage->image,location13,value3);
            									}
            								}
HXLINE( 633)								found6 = true;
            							}
            							else {
HXLINE( 309)								if (found6) {
HXLINE( 309)									goto _hx_goto_320;
            								}
            							}
            						}
            						_hx_goto_320:;
            					}
            				}
            			}
HXDLIN( 309)			{
HXLINE( 309)				 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,dx,dy,ax,ay,true);
HXDLIN( 309)				if (hasUndo6) {
HXLINE( 309)					v17->undoImage = undoImage18;
HXDLIN( 309)					v17->undoX = xIter36->start;
HXDLIN( 309)					v17->undoY = yIter36->start;
            				}
            			}
            		}
            		else {
HXLINE( 309)			Float bx4 = dx;
HXDLIN( 309)			Float by4 = dy;
HXDLIN( 309)			Float cx4 = ax;
HXDLIN( 309)			Float cy4 = ay;
HXDLIN( 309)			bool hasUndo7 = false;
HXDLIN( 309)			bool adjustWinding3 = (((((ex * by4) - (bx4 * ey)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ey) - (ex * cy4))) > 0);
HXDLIN( 309)			if (!(adjustWinding3)) {
HXLINE( 309)				Float bx_3 = bx4;
HXDLIN( 309)				Float by_3 = by4;
HXLINE(  25)				bx4 = cx4;
HXLINE(  26)				by4 = cy4;
HXLINE(  27)				cx4 = bx_3;
HXLINE(  28)				cy4 = by_3;
            			}
HXLINE( 309)			{
HXLINE( 309)				Float s03 = ((ey * cx4) - (ex * cy4));
HXDLIN( 309)				Float sx3 = (cy4 - ey);
HXDLIN( 309)				Float sy3 = (ex - cx4);
HXDLIN( 309)				Float t03 = ((ex * by4) - (ey * bx4));
HXDLIN( 309)				Float tx3 = (ey - by4);
HXDLIN( 309)				Float ty3 = (bx4 - ex);
HXDLIN( 309)				Float A3 = ((((-(by4) * cx4) + (ey * (-(bx4) + cx4))) + (ex * (by4 - cy4))) + (bx4 * cy4));
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 309)				if ((ex > bx4)) {
HXLINE( 309)					if ((ex > cx4)) {
HXLINE( 309)						int min28;
HXDLIN( 309)						if ((bx4 > cx4)) {
HXLINE( 309)							min28 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 309)							min28 = ::Math_obj::floor(bx4);
            						}
HXDLIN( 309)						int ii_min56 = min28;
HXDLIN( 309)						int ii_max56 = ::Math_obj::ceil(ex);
HXDLIN( 309)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            					}
            					else {
HXLINE( 309)						int ii_min57 = ::Math_obj::floor(bx4);
HXDLIN( 309)						int ii_max57 = ::Math_obj::ceil(cx4);
HXDLIN( 309)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            					}
            				}
            				else {
HXLINE( 309)					if ((bx4 > cx4)) {
HXLINE( 309)						int min29;
HXDLIN( 309)						if ((ex > cx4)) {
HXLINE( 309)							min29 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 309)							min29 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 309)						int ii_min58 = min29;
HXDLIN( 309)						int ii_max58 = ::Math_obj::ceil(bx4);
HXDLIN( 309)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            					}
            					else {
HXLINE( 309)						int ii_min59 = ::Math_obj::floor(ex);
HXDLIN( 309)						int ii_max59 = ::Math_obj::ceil(cx4);
HXDLIN( 309)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 309)				if ((ey > by4)) {
HXLINE( 309)					if ((ey > cy4)) {
HXLINE( 309)						int min30;
HXDLIN( 309)						if ((by4 > cy4)) {
HXLINE( 309)							min30 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 309)							min30 = ::Math_obj::floor(by4);
            						}
HXDLIN( 309)						int ii_min60 = min30;
HXDLIN( 309)						int ii_max60 = ::Math_obj::ceil(ey);
HXDLIN( 309)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            					}
            					else {
HXLINE( 309)						int ii_min61 = ::Math_obj::floor(by4);
HXDLIN( 309)						int ii_max61 = ::Math_obj::ceil(cy4);
HXDLIN( 309)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            					}
            				}
            				else {
HXLINE( 309)					if ((by4 > cy4)) {
HXLINE( 309)						int min31;
HXDLIN( 309)						if ((ey > cy4)) {
HXLINE( 309)							min31 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 309)							min31 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 309)						int ii_min62 = min31;
HXDLIN( 309)						int ii_max62 = ::Math_obj::ceil(by4);
HXDLIN( 309)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            					}
            					else {
HXLINE( 309)						int ii_min63 = ::Math_obj::floor(ey);
HXDLIN( 309)						int ii_max63 = ::Math_obj::ceil(cy4);
HXDLIN( 309)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            					}
            				}
HXDLIN( 309)				 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 309)				if (hasUndo7) {
HXLINE( 309)					int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 309)					int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 309)					 ::Dynamic imageType7 = null();
HXDLIN( 309)					 ::pi_xy::ImageStruct this224 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 309)					if (::hx::IsNull( imageType7 )) {
HXLINE(  54)						imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 309)					::Dynamic undoImage22;
HXDLIN( 309)					switch((int)(( (int)(imageType7) ))){
            						case (int)0: {
HXLINE( 309)							 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::BytesImg b50 = byt7;
HXDLIN( 309)							{
HXLINE( 309)								b50->width = width7;
HXDLIN( 309)								b50->height = height7;
HXDLIN( 309)								b50->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 309)								b50->data = ::haxe::io::Bytes_obj::alloc((b50->length * 4));
HXDLIN( 309)								{
HXLINE( 309)									int len14 = b50->length;
HXDLIN( 309)									int w7 = 0;
HXDLIN( 309)									{
HXLINE( 309)										int _g140 = 0;
HXDLIN( 309)										int _g141 = b50->height;
HXDLIN( 309)										while((_g140 < _g141)){
HXLINE( 309)											_g140 = (_g140 + 1);
HXDLIN( 309)											int y24 = (_g140 - 1);
HXDLIN( 309)											{
HXLINE( 309)												int _g142 = 0;
HXDLIN( 309)												int _g143 = b50->width;
HXDLIN( 309)												while((_g142 < _g143)){
HXLINE( 309)													_g142 = (_g142 + 1);
HXDLIN( 309)													int x24 = (_g142 - 1);
HXDLIN( 309)													{
HXLINE( 309)														w7 = (w7 + 1);
HXDLIN( 309)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w7 = (w7 + 1);
HXDLIN( 309)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w7 = (w7 + 1);
HXDLIN( 309)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 309)													{
HXLINE( 309)														w7 = (w7 + 1);
HXDLIN( 309)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage22 = b50;
            						}
            						break;
            						case (int)1: {
HXLINE( 309)							 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::ArrIntImg a48 = arrI7;
HXDLIN( 309)							{
HXLINE( 309)								a48->width = width7;
HXDLIN( 309)								a48->height = height7;
HXDLIN( 309)								a48->data = ::Array_obj< int >::__new(0);
HXDLIN( 309)								a48->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 309)								{
HXLINE( 309)									int _g144 = 0;
HXDLIN( 309)									int _g145 = a48->length;
HXDLIN( 309)									while((_g144 < _g145)){
HXLINE( 309)										_g144 = (_g144 + 1);
HXDLIN( 309)										int i58 = (_g144 - 1);
HXDLIN( 309)										a48->data[i58] = 0;
            									}
            								}
            							}
HXDLIN( 309)							undoImage22 = a48;
            						}
            						break;
            						case (int)2: {
HXLINE( 309)							 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::U32ArrImg b51 = u32a7;
HXDLIN( 309)							{
HXLINE( 309)								b51->width = width7;
HXDLIN( 309)								b51->height = height7;
HXDLIN( 309)								b51->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 309)								int size7 = (b51->length * 4);
HXDLIN( 309)								b51->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 309)								{
HXLINE( 309)									int _g146 = 0;
HXDLIN( 309)									int _g147 = b51->length;
HXDLIN( 309)									while((_g146 < _g147)){
HXLINE( 309)										_g146 = (_g146 + 1);
HXDLIN( 309)										int i59 = (_g146 - 1);
HXDLIN( 309)										{
HXLINE( 309)											 ::haxe::io::ArrayBufferViewImpl this225 = b51->data;
HXDLIN( 309)											bool undoImage23;
HXDLIN( 309)											if ((i59 >= 0)) {
HXLINE( 309)												undoImage23 = (i59 < (this225->byteLength >> 2));
            											}
            											else {
HXLINE( 309)												undoImage23 = false;
            											}
HXDLIN( 309)											if (undoImage23) {
HXLINE( 309)												 ::haxe::io::Bytes _this7 = this225->bytes;
HXDLIN( 309)												int pos7 = ((i59 << 2) + this225->byteOffset);
HXDLIN( 309)												_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 309)												_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 309)												_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage22 = b51;
            						}
            						break;
            						case (int)3: {
HXLINE( 309)							 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::VecIntImg v18 = vec7;
HXDLIN( 309)							{
HXLINE( 309)								v18->width = width7;
HXDLIN( 309)								v18->height = height7;
HXDLIN( 309)								v18->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 309)								v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 309)								{
HXLINE( 309)									int _g148 = 0;
HXDLIN( 309)									int _g149 = v18->length;
HXDLIN( 309)									while((_g148 < _g149)){
HXLINE( 309)										_g148 = (_g148 + 1);
HXDLIN( 309)										int i60 = (_g148 - 1);
HXDLIN( 309)										v18->data->__unsafe_set(i60,0);
            									}
            								}
            							}
HXDLIN( 309)							undoImage22 = v18;
            						}
            						break;
            						case (int)4: {
HXLINE( 309)							 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 309)							 ::iterMagic::StackIntImg b52 = sInt7;
HXDLIN( 309)							{
HXLINE( 309)								b52->width = width7;
HXDLIN( 309)								b52->height = height7;
HXDLIN( 309)								b52->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 309)								b52->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 309)								{
HXLINE( 309)									int len15 = b52->length;
HXDLIN( 309)									 ::haxe::ds::GenericStack_Int d7 = b52->data;
HXDLIN( 309)									if (::hx::IsNull( d7->head )) {
HXLINE( 309)										int _g150 = 0;
HXDLIN( 309)										int _g151 = len15;
HXDLIN( 309)										while((_g150 < _g151)){
HXLINE( 309)											_g150 = (_g150 + 1);
HXDLIN( 309)											int i61 = (_g150 - 1);
HXDLIN( 309)											d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            										}
            									}
            									else {
HXLINE( 309)										int _g152 = 0;
HXDLIN( 309)										int _g153 = len15;
HXDLIN( 309)										while((_g152 < _g153)){
HXLINE( 309)											_g152 = (_g152 + 1);
HXDLIN( 309)											int i62 = (_g152 - 1);
HXDLIN( 309)											{
HXLINE( 309)												 ::haxe::ds::GenericCell_Int l7 = b52->data->head;
HXDLIN( 309)												 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 309)												{
HXLINE( 309)													int _g154 = 0;
HXDLIN( 309)													int _g155 = i62;
HXDLIN( 309)													while((_g154 < _g155)){
HXLINE( 309)														_g154 = (_g154 + 1);
HXDLIN( 309)														int i63 = (_g154 - 1);
HXLINE( 345)														prev7 = l7;
HXLINE( 346)														l7 = l7->next;
            													}
            												}
HXLINE( 309)												if (::hx::IsNull( prev7 )) {
HXLINE( 309)													b52->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 309)													l7 = null();
            												}
            												else {
HXLINE( 309)													prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 309)													l7 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 309)							undoImage22 = b52;
            						}
            						break;
            					}
HXDLIN( 309)					this224->image = undoImage22;
HXDLIN( 309)					this224->width = width7;
HXDLIN( 309)					this224->height = height7;
HXDLIN( 309)					this224->imageType = ( (int)(imageType7) );
HXDLIN( 309)					undoImage21 = this224;
HXDLIN( 309)					{
HXLINE( 309)						int rectLeft7 = xIter37->start;
HXDLIN( 309)						int rectTop7 = yIter37->start;
HXDLIN( 309)						int rectRight7 = xIter37->max;
HXDLIN( 309)						bool forceClear7 = false;
HXDLIN( 309)						{
HXLINE( 309)							int _g156 = rectTop7;
HXDLIN( 309)							int _g157 = yIter37->max;
HXDLIN( 309)							while((_g156 < _g157)){
HXLINE( 309)								_g156 = (_g156 + 1);
HXDLIN( 309)								int dy8 = (_g156 - 1);
HXDLIN( 309)								{
HXLINE( 309)									int _g158 = rectLeft7;
HXDLIN( 309)									int _g159 = rectRight7;
HXDLIN( 309)									while((_g158 < _g159)){
HXLINE( 309)										_g158 = (_g158 + 1);
HXDLIN( 309)										int dx8 = (_g158 - 1);
HXDLIN( 309)										::Dynamic this226 = pixelImage->image;
HXDLIN( 309)										int index31;
HXDLIN( 309)										if (pixelImage->useVirtualPos) {
HXLINE( 309)											index31 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx8) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 309)											index31 = ::Std_obj::_hx_int(( (Float)(((dy8 * pixelImage->width) + dx8)) ));
            										}
HXDLIN( 309)										int c24 = ::iterMagic::Iimg_obj::get(this226,index31);
HXDLIN( 309)										int col7;
HXDLIN( 309)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)											col7 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            										}
            										else {
HXLINE( 309)											col7 = c24;
            										}
HXDLIN( 309)										bool _hx_tmp56;
HXDLIN( 309)										if (pixelImage->useMask) {
HXLINE( 309)											_hx_tmp56 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 309)											_hx_tmp56 = false;
            										}
HXDLIN( 309)										if (_hx_tmp56) {
HXLINE( 309)											 ::pi_xy::ImageStruct this227 = pixelImage->mask;
HXDLIN( 309)											::Dynamic this228 = this227->image;
HXDLIN( 309)											int index32;
HXDLIN( 309)											if (this227->useVirtualPos) {
HXLINE( 309)												index32 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this227->virtualY) * ( (Float)(this227->width) )) + dx8) - this227->virtualX));
            											}
            											else {
HXLINE( 309)												index32 = ::Std_obj::_hx_int(( (Float)(((dy8 * this227->width) + dx8)) ));
            											}
HXDLIN( 309)											int c25 = ::iterMagic::Iimg_obj::get(this228,index32);
HXDLIN( 309)											int v19;
HXDLIN( 309)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)												v19 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            											}
            											else {
HXLINE( 309)												v19 = c25;
            											}
HXDLIN( 309)											int maskPixel7 = v19;
HXDLIN( 309)											int this229 = col7;
HXDLIN( 309)											if ((maskPixel7 == 0)) {
HXLINE( 309)												col7 = this229;
            											}
            											else {
HXLINE( 309)												Float m07;
HXDLIN( 309)												int this230 = ((maskPixel7 >> 24) & 255);
HXDLIN( 309)												if ((this230 == 0)) {
HXLINE( 309)													m07 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m07 = (( (Float)(this230) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m17;
HXDLIN( 309)												int this231 = ((maskPixel7 >> 16) & 255);
HXDLIN( 309)												if ((this231 == 0)) {
HXLINE( 309)													m17 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m17 = (( (Float)(this231) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m27;
HXDLIN( 309)												int this232 = ((maskPixel7 >> 8) & 255);
HXDLIN( 309)												if ((this232 == 0)) {
HXLINE( 309)													m27 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m27 = (( (Float)(this232) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float m37;
HXDLIN( 309)												int this233 = (maskPixel7 & 255);
HXDLIN( 309)												if ((this233 == 0)) {
HXLINE( 309)													m37 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													m37 = (( (Float)(this233) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this229 >> 24) & 255)) )));
HXDLIN( 309)												int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this229 >> 16) & 255)) )));
HXDLIN( 309)												int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this229 >> 8) & 255)) )));
HXDLIN( 309)												int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this229 & 255)) )));
HXDLIN( 309)												col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 309)										if ((col7 != 0)) {
HXLINE( 309)											int x25 = (dx8 - rectLeft7);
HXDLIN( 309)											int y25 = (dy8 - rectTop7);
HXDLIN( 309)											int c26 = col7;
HXDLIN( 309)											bool _hx_tmp57;
HXDLIN( 309)											if ((((c26 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp57 = undoImage21->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp57 = false;
            											}
HXDLIN( 309)											if (_hx_tmp57) {
HXLINE( 309)												int location14;
HXDLIN( 309)												if (undoImage21->useVirtualPos) {
HXLINE( 309)													location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x25) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 309)													location14 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage21->width) + x25)) ));
            												}
HXDLIN( 309)												int this234 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN( 309)												int this235;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this235 = ((((((this234 >> 24) & 255) << 24) | ((this234 & 255) << 16)) | (((this234 >> 8) & 255) << 8)) | ((this234 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this235 = this234;
            												}
HXDLIN( 309)												Float a118;
HXDLIN( 309)												int this236 = ((this235 >> 24) & 255);
HXDLIN( 309)												if ((this236 == 0)) {
HXLINE( 309)													a118 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a118 = (( (Float)(this236) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r115;
HXDLIN( 309)												int this237 = ((this235 >> 16) & 255);
HXDLIN( 309)												if ((this237 == 0)) {
HXLINE( 309)													r115 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r115 = (( (Float)(this237) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g115;
HXDLIN( 309)												int this238 = ((this235 >> 8) & 255);
HXDLIN( 309)												if ((this238 == 0)) {
HXLINE( 309)													g115 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g115 = (( (Float)(this238) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b119;
HXDLIN( 309)												int this239 = (this235 & 255);
HXDLIN( 309)												if ((this239 == 0)) {
HXLINE( 309)													b119 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b119 = (( (Float)(this239) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a216;
HXDLIN( 309)												int this240 = ((col7 >> 24) & 255);
HXDLIN( 309)												if ((this240 == 0)) {
HXLINE( 309)													a216 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a216 = (( (Float)(this240) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r215;
HXDLIN( 309)												int this241 = ((col7 >> 16) & 255);
HXDLIN( 309)												if ((this241 == 0)) {
HXLINE( 309)													r215 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r215 = (( (Float)(this241) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g215;
HXDLIN( 309)												int this242 = ((col7 >> 8) & 255);
HXDLIN( 309)												if ((this242 == 0)) {
HXLINE( 309)													g215 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g215 = (( (Float)(this242) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b218;
HXDLIN( 309)												int this243 = (col7 & 255);
HXDLIN( 309)												if ((this243 == 0)) {
HXLINE( 309)													b218 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b218 = (( (Float)(this243) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 309)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 309)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 309)												int b53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b218 * a216))));
HXDLIN( 309)												int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 309)												int blended14 = ((((a49 << 24) | (r36 << 16)) | (g36 << 8)) | b53);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp58;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp58 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp58 = blended14;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp58);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this244 = undoImage21->image;
HXDLIN( 309)												int index33;
HXDLIN( 309)												if (undoImage21->useVirtualPos) {
HXLINE( 309)													index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x25) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 309)													index33 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage21->width) + x25)) ));
            												}
HXDLIN( 309)												int _hx_tmp59;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp59 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp59 = c26;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this244,index33,_hx_tmp59);
            											}
            										}
            										else {
HXLINE( 309)											if (forceClear7) {
HXLINE( 309)												::Dynamic this245 = undoImage21->image;
HXDLIN( 309)												int x26 = (dx8 - rectLeft7);
HXDLIN( 309)												int y26 = (dy8 - rectTop7);
HXDLIN( 309)												int index34;
HXDLIN( 309)												if (undoImage21->useVirtualPos) {
HXLINE( 309)													index34 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x26) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 309)													index34 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage21->width) + x26)) ));
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this245,index34,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 309)				bool found7 = false;
HXDLIN( 309)				Float s3 = ((Float)0.);
HXDLIN( 309)				Float t3 = ((Float)0.);
HXDLIN( 309)				Float sxx3 = ((Float)0.);
HXDLIN( 309)				Float txx3 = ((Float)0.);
HXDLIN( 309)				{
HXLINE( 309)					int _g_min14 = xIter37->start;
HXDLIN( 309)					int _g_max14 = xIter37->max;
HXDLIN( 309)					while((_g_min14 < _g_max14)){
HXLINE( 309)						_g_min14 = (_g_min14 + 1);
HXDLIN( 309)						int x27 = (_g_min14 - 1);
HXLINE(  60)						sxx3 = (sx3 * ( (Float)(x27) ));
HXLINE(  61)						txx3 = (tx3 * ( (Float)(x27) ));
HXLINE(  62)						found7 = false;
HXLINE( 309)						{
HXLINE( 309)							int _g_min15 = yIter37->start;
HXDLIN( 309)							int _g_max15 = yIter37->max;
HXDLIN( 309)							while((_g_min15 < _g_max15)){
HXLINE( 309)								_g_min15 = (_g_min15 + 1);
HXDLIN( 309)								int y27 = (_g_min15 - 1);
HXLINE(  64)								s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y27) )));
HXLINE(  65)								t3 = ((t03 + txx3) + (ty3 * ( (Float)(y27) )));
HXLINE( 309)								bool _hx_tmp60;
HXDLIN( 309)								if (!((s3 <= 0))) {
HXLINE( 309)									_hx_tmp60 = (t3 <= 0);
            								}
            								else {
HXLINE( 309)									_hx_tmp60 = true;
            								}
HXDLIN( 309)								if (_hx_tmp60) {
HXLINE( 309)									if (found7) {
HXLINE( 309)										goto _hx_goto_332;
            									}
            								}
            								else {
HXLINE( 309)									if (((s3 + t3) < A3)) {
HXLINE( 309)										{
HXLINE( 309)											int c27 = color;
HXDLIN( 309)											bool _hx_tmp61;
HXDLIN( 309)											if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 309)												_hx_tmp61 = pixelImage->transparent;
            											}
            											else {
HXLINE( 309)												_hx_tmp61 = false;
            											}
HXDLIN( 309)											if (_hx_tmp61) {
HXLINE( 309)												int location15;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													location15 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x27) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													location15 = ::Std_obj::_hx_int(( (Float)(((y27 * pixelImage->width) + x27)) ));
            												}
HXDLIN( 309)												int this246 = ::iterMagic::Iimg_obj::get(pixelImage->image,location15);
HXDLIN( 309)												int this247;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													this247 = ((((((this246 >> 24) & 255) << 24) | ((this246 & 255) << 16)) | (((this246 >> 8) & 255) << 8)) | ((this246 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													this247 = this246;
            												}
HXDLIN( 309)												Float a119;
HXDLIN( 309)												int this248 = ((this247 >> 24) & 255);
HXDLIN( 309)												if ((this248 == 0)) {
HXLINE( 309)													a119 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a119 = (( (Float)(this248) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r116;
HXDLIN( 309)												int this249 = ((this247 >> 16) & 255);
HXDLIN( 309)												if ((this249 == 0)) {
HXLINE( 309)													r116 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r116 = (( (Float)(this249) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g116;
HXDLIN( 309)												int this250 = ((this247 >> 8) & 255);
HXDLIN( 309)												if ((this250 == 0)) {
HXLINE( 309)													g116 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g116 = (( (Float)(this250) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b120;
HXDLIN( 309)												int this251 = (this247 & 255);
HXDLIN( 309)												if ((this251 == 0)) {
HXLINE( 309)													b120 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b120 = (( (Float)(this251) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a217;
HXDLIN( 309)												int this252 = ((color >> 24) & 255);
HXDLIN( 309)												if ((this252 == 0)) {
HXLINE( 309)													a217 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													a217 = (( (Float)(this252) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float r216;
HXDLIN( 309)												int this253 = ((color >> 16) & 255);
HXDLIN( 309)												if ((this253 == 0)) {
HXLINE( 309)													r216 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													r216 = (( (Float)(this253) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float g216;
HXDLIN( 309)												int this254 = ((color >> 8) & 255);
HXDLIN( 309)												if ((this254 == 0)) {
HXLINE( 309)													g216 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													g216 = (( (Float)(this254) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float b219;
HXDLIN( 309)												int this255 = (color & 255);
HXDLIN( 309)												if ((this255 == 0)) {
HXLINE( 309)													b219 = ((Float)0.);
            												}
            												else {
HXLINE( 309)													b219 = (( (Float)(this255) ) / ( (Float)(255) ));
            												}
HXDLIN( 309)												Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN( 309)												int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 309)												int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 309)												int b54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a316) + (b219 * a217))));
HXDLIN( 309)												int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 309)												int blended15 = ((((a50 << 24) | (r37 << 16)) | (g37 << 8)) | b54);
HXDLIN( 309)												{
HXLINE( 309)													int _hx_tmp62;
HXDLIN( 309)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)														_hx_tmp62 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            													}
            													else {
HXLINE( 309)														_hx_tmp62 = blended15;
            													}
HXDLIN( 309)													::iterMagic::Iimg_obj::set(pixelImage->image,location15,_hx_tmp62);
            												}
            											}
            											else {
HXLINE( 309)												::Dynamic this256 = pixelImage->image;
HXDLIN( 309)												int index35;
HXDLIN( 309)												if (pixelImage->useVirtualPos) {
HXLINE( 309)													index35 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x27) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 309)													index35 = ::Std_obj::_hx_int(( (Float)(((y27 * pixelImage->width) + x27)) ));
            												}
HXDLIN( 309)												int _hx_tmp63;
HXDLIN( 309)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 309)													_hx_tmp63 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            												}
            												else {
HXLINE( 309)													_hx_tmp63 = c27;
            												}
HXDLIN( 309)												::iterMagic::Iimg_obj::set(this256,index35,_hx_tmp63);
            											}
            										}
HXLINE(  73)										found7 = true;
            									}
            									else {
HXLINE( 309)										if (found7) {
HXLINE( 309)											goto _hx_goto_332;
            										}
            									}
            								}
            							}
            							_hx_goto_332:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 309)		if ((hasHit == true)) {
HXLINE( 309)			 ::pi_xy::algo::HitQuad v20 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 309)			return v20;
            		}
            		else {
HXLINE( 309)			return null();
            		}
HXDLIN( 309)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(LinePixel_Fields__obj,rotateSoftLineFlare,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateSoftLineFlarePartial( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick1,Float thick2,Float h,Float theta,int color,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_softTop,::hx::Null< bool >  __o_softRight,::hx::Null< bool >  __o_softBottom,::hx::Null< bool >  __o_softLeft,::hx::Null< bool >  __o_hasHit){
            		Float softC = __o_softC.Default(((Float)10.));
            		bool softTop = __o_softTop.Default(true);
            		bool softRight = __o_softRight.Default(true);
            		bool softBottom = __o_softBottom.Default(true);
            		bool softLeft = __o_softLeft.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_322_rotateSoftLineFlarePartial)
HXLINE( 323)		Float sin = ::Math_obj::sin(theta);
HXLINE( 324)		Float cos = ::Math_obj::cos(theta);
HXLINE( 325)		Float radius1 = (thick1 / ( (Float)(2) ));
HXLINE( 326)		Float radius2 = (thick2 / ( (Float)(2) ));
HXLINE( 327)		Float dx = ((Float)0.1);
HXLINE( 328)		Float dy = radius1;
HXLINE( 329)		Float cx = h;
HXLINE( 330)		Float cy = radius2;
HXLINE( 331)		Float bx = h;
HXLINE( 332)		Float by = -(radius2);
HXLINE( 333)		Float ax = ((Float)0.1);
HXLINE( 334)		Float ay = -(radius1);
HXLINE( 335)		Float temp = ((Float)0.);
HXLINE( 336)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 337)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 338)		ax = temp;
HXLINE( 340)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 341)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 342)		bx = temp;
HXLINE( 344)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 345)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 346)		cx = temp;
HXLINE( 348)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 349)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 350)		dx = temp;
HXLINE( 357)		Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN( 357)		Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN( 357)		if (softTop) {
HXLINE( 357)			bool hasUndo = false;
HXDLIN( 357)			int aA = ((color >> 24) & 255);
HXDLIN( 357)			int rA = ((color >> 16) & 255);
HXDLIN( 357)			int gA = ((color >> 8) & 255);
HXDLIN( 357)			int bA = (color & 255);
HXDLIN( 357)			Float bcx = (ax - bx);
HXDLIN( 357)			Float bcy = (ay - by);
HXDLIN( 357)			Float acx = (ex - bx);
HXDLIN( 357)			Float acy = (ey - by);
HXDLIN( 357)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 357)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 357)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 357)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 357)			if ((ex > ax)) {
HXLINE( 357)				if ((ex > bx)) {
HXLINE( 357)					int min;
HXDLIN( 357)					if ((ax > bx)) {
HXLINE( 357)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 357)						min = ::Math_obj::floor(ax);
            					}
HXDLIN( 357)					int ii_min = min;
HXDLIN( 357)					int ii_max = ::Math_obj::ceil(ex);
HXDLIN( 357)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 357)					int ii_min1 = ::Math_obj::floor(ax);
HXDLIN( 357)					int ii_max1 = ::Math_obj::ceil(bx);
HXDLIN( 357)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 357)				if ((ax > bx)) {
HXLINE( 357)					int min1;
HXDLIN( 357)					if ((ex > bx)) {
HXLINE( 357)						min1 = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 357)						min1 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 357)					int ii_min2 = min1;
HXDLIN( 357)					int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN( 357)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 357)					int ii_min3 = ::Math_obj::floor(ex);
HXDLIN( 357)					int ii_max3 = ::Math_obj::ceil(bx);
HXDLIN( 357)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 357)			if ((ey > ay)) {
HXLINE( 357)				if ((ey > by)) {
HXLINE( 357)					int min2;
HXDLIN( 357)					if ((ay > by)) {
HXLINE( 357)						min2 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 357)						min2 = ::Math_obj::floor(ay);
            					}
HXDLIN( 357)					int ii_min4 = min2;
HXDLIN( 357)					int ii_max4 = ::Math_obj::ceil(ey);
HXDLIN( 357)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 357)					int ii_min5 = ::Math_obj::floor(ay);
HXDLIN( 357)					int ii_max5 = ::Math_obj::ceil(by);
HXDLIN( 357)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 357)				if ((ay > by)) {
HXLINE( 357)					int min3;
HXDLIN( 357)					if ((ey > by)) {
HXLINE( 357)						min3 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 357)						min3 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 357)					int ii_min6 = min3;
HXDLIN( 357)					int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN( 357)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 357)					int ii_min7 = ::Math_obj::floor(ey);
HXDLIN( 357)					int ii_max7 = ::Math_obj::ceil(by);
HXDLIN( 357)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 357)			if (hasUndo) {
HXLINE( 357)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 357)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 357)				 ::Dynamic imageType = null();
HXDLIN( 357)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 357)				::Dynamic undoImage1;
HXDLIN( 357)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 357)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 357)						{
HXLINE( 357)							b->width = width;
HXDLIN( 357)							b->height = height;
HXDLIN( 357)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 357)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 357)							{
HXLINE( 357)								int len = b->length;
HXDLIN( 357)								int w = 0;
HXDLIN( 357)								{
HXLINE( 357)									int _g = 0;
HXDLIN( 357)									int _g1 = b->height;
HXDLIN( 357)									while((_g < _g1)){
HXLINE( 357)										_g = (_g + 1);
HXDLIN( 357)										int y = (_g - 1);
HXDLIN( 357)										{
HXLINE( 357)											int _g2 = 0;
HXDLIN( 357)											int _g3 = b->width;
HXDLIN( 357)											while((_g2 < _g3)){
HXLINE( 357)												_g2 = (_g2 + 1);
HXDLIN( 357)												int x = (_g2 - 1);
HXDLIN( 357)												{
HXLINE( 357)													w = (w + 1);
HXDLIN( 357)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w = (w + 1);
HXDLIN( 357)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w = (w + 1);
HXDLIN( 357)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w = (w + 1);
HXDLIN( 357)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 357)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 357)						{
HXLINE( 357)							a->width = width;
HXDLIN( 357)							a->height = height;
HXDLIN( 357)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 357)							{
HXLINE( 357)								int _g4 = 0;
HXDLIN( 357)								int _g5 = a->length;
HXDLIN( 357)								while((_g4 < _g5)){
HXLINE( 357)									_g4 = (_g4 + 1);
HXDLIN( 357)									int i = (_g4 - 1);
HXDLIN( 357)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 357)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 357)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 357)						{
HXLINE( 357)							b1->width = width;
HXDLIN( 357)							b1->height = height;
HXDLIN( 357)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 357)							int size = (b1->length * 4);
HXDLIN( 357)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 357)							{
HXLINE( 357)								int _g6 = 0;
HXDLIN( 357)								int _g7 = b1->length;
HXDLIN( 357)								while((_g6 < _g7)){
HXLINE( 357)									_g6 = (_g6 + 1);
HXDLIN( 357)									int i1 = (_g6 - 1);
HXDLIN( 357)									{
HXLINE( 357)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 357)										bool undoImage2;
HXDLIN( 357)										if ((i1 >= 0)) {
HXLINE( 357)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 357)											undoImage2 = false;
            										}
HXDLIN( 357)										if (undoImage2) {
HXLINE( 357)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 357)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 357)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 357)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 357)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 357)						{
HXLINE( 357)							v->width = width;
HXDLIN( 357)							v->height = height;
HXDLIN( 357)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 357)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 357)							{
HXLINE( 357)								int _g8 = 0;
HXDLIN( 357)								int _g9 = v->length;
HXDLIN( 357)								while((_g8 < _g9)){
HXLINE( 357)									_g8 = (_g8 + 1);
HXDLIN( 357)									int i2 = (_g8 - 1);
HXDLIN( 357)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 357)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 357)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 357)						{
HXLINE( 357)							b2->width = width;
HXDLIN( 357)							b2->height = height;
HXDLIN( 357)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 357)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)							{
HXLINE( 357)								int len1 = b2->length;
HXDLIN( 357)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 357)								if (::hx::IsNull( d->head )) {
HXLINE( 357)									int _g10 = 0;
HXDLIN( 357)									int _g11 = len1;
HXDLIN( 357)									while((_g10 < _g11)){
HXLINE( 357)										_g10 = (_g10 + 1);
HXDLIN( 357)										int i3 = (_g10 - 1);
HXDLIN( 357)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 357)									int _g12 = 0;
HXDLIN( 357)									int _g13 = len1;
HXDLIN( 357)									while((_g12 < _g13)){
HXLINE( 357)										_g12 = (_g12 + 1);
HXDLIN( 357)										int i4 = (_g12 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 357)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 357)											{
HXLINE( 357)												int _g14 = 0;
HXDLIN( 357)												int _g15 = i4;
HXDLIN( 357)												while((_g14 < _g15)){
HXLINE( 357)													_g14 = (_g14 + 1);
HXDLIN( 357)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 357)											if (::hx::IsNull( prev )) {
HXLINE( 357)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 357)												l = null();
            											}
            											else {
HXLINE( 357)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 357)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 357)				this1->image = undoImage1;
HXDLIN( 357)				this1->width = width;
HXDLIN( 357)				this1->height = height;
HXDLIN( 357)				this1->imageType = ( (int)(imageType) );
HXDLIN( 357)				undoImage = this1;
HXDLIN( 357)				{
HXLINE( 357)					int rectLeft = xIter3->start;
HXDLIN( 357)					int rectTop = yIter3->start;
HXDLIN( 357)					int rectRight = xIter3->max;
HXDLIN( 357)					bool forceClear = false;
HXDLIN( 357)					{
HXLINE( 357)						int _g16 = rectTop;
HXDLIN( 357)						int _g17 = yIter3->max;
HXDLIN( 357)						while((_g16 < _g17)){
HXLINE( 357)							_g16 = (_g16 + 1);
HXDLIN( 357)							int dy1 = (_g16 - 1);
HXDLIN( 357)							{
HXLINE( 357)								int _g18 = rectLeft;
HXDLIN( 357)								int _g19 = rectRight;
HXDLIN( 357)								while((_g18 < _g19)){
HXLINE( 357)									_g18 = (_g18 + 1);
HXDLIN( 357)									int dx1 = (_g18 - 1);
HXDLIN( 357)									::Dynamic this3 = pixelImage->image;
HXDLIN( 357)									int index;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 357)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 357)									int col;
HXDLIN( 357)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 357)										col = c;
            									}
HXDLIN( 357)									bool _hx_tmp;
HXDLIN( 357)									if (pixelImage->useMask) {
HXLINE( 357)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 357)										_hx_tmp = false;
            									}
HXDLIN( 357)									if (_hx_tmp) {
HXLINE( 357)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 357)										::Dynamic this5 = this4->image;
HXDLIN( 357)										int index1;
HXDLIN( 357)										if (this4->useVirtualPos) {
HXLINE( 357)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 357)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 357)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 357)										int v1;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											v1 = c1;
            										}
HXDLIN( 357)										int maskPixel = v1;
HXDLIN( 357)										int this6 = col;
HXDLIN( 357)										if ((maskPixel == 0)) {
HXLINE( 357)											col = this6;
            										}
            										else {
HXLINE( 357)											Float m0;
HXDLIN( 357)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 357)											if ((this7 == 0)) {
HXLINE( 357)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m1;
HXDLIN( 357)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 357)											if ((this8 == 0)) {
HXLINE( 357)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m2;
HXDLIN( 357)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 357)											if ((this9 == 0)) {
HXLINE( 357)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m3;
HXDLIN( 357)											int this10 = (maskPixel & 255);
HXDLIN( 357)											if ((this10 == 0)) {
HXLINE( 357)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 357)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 357)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 357)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 357)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 357)									if ((col != 0)) {
HXLINE( 357)										int x1 = (dx1 - rectLeft);
HXDLIN( 357)										int y1 = (dy1 - rectTop);
HXDLIN( 357)										int c2 = col;
HXDLIN( 357)										bool _hx_tmp1;
HXDLIN( 357)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 357)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 357)											_hx_tmp1 = false;
            										}
HXDLIN( 357)										if (_hx_tmp1) {
HXLINE( 357)											int location;
HXDLIN( 357)											if (undoImage->useVirtualPos) {
HXLINE( 357)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 357)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 357)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 357)											int this12;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												this12 = this11;
            											}
HXDLIN( 357)											Float a1;
HXDLIN( 357)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 357)											if ((this13 == 0)) {
HXLINE( 357)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r1;
HXDLIN( 357)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 357)											if ((this14 == 0)) {
HXLINE( 357)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g1;
HXDLIN( 357)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 357)											if ((this15 == 0)) {
HXLINE( 357)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b11;
HXDLIN( 357)											int this16 = (this12 & 255);
HXDLIN( 357)											if ((this16 == 0)) {
HXLINE( 357)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a2;
HXDLIN( 357)											int this17 = ((col >> 24) & 255);
HXDLIN( 357)											if ((this17 == 0)) {
HXLINE( 357)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r2;
HXDLIN( 357)											int this18 = ((col >> 16) & 255);
HXDLIN( 357)											if ((this18 == 0)) {
HXLINE( 357)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g2;
HXDLIN( 357)											int this19 = ((col >> 8) & 255);
HXDLIN( 357)											if ((this19 == 0)) {
HXLINE( 357)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b21;
HXDLIN( 357)											int this20 = (col & 255);
HXDLIN( 357)											if ((this20 == 0)) {
HXLINE( 357)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 357)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 357)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 357)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 357)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 357)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 357)											{
HXLINE( 357)												int _hx_tmp2;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp2 = blended;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 357)											::Dynamic this21 = undoImage->image;
HXDLIN( 357)											int index2;
HXDLIN( 357)											if (undoImage->useVirtualPos) {
HXLINE( 357)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 357)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 357)											int _hx_tmp3;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp3 = c2;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 357)										if (forceClear) {
HXLINE( 357)											::Dynamic this22 = undoImage->image;
HXDLIN( 357)											int x2 = (dx1 - rectLeft);
HXDLIN( 357)											int y2 = (dy1 - rectTop);
HXDLIN( 357)											int index3;
HXDLIN( 357)											if (undoImage->useVirtualPos) {
HXLINE( 357)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 357)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 357)			bool found = false;
HXDLIN( 357)			{
HXLINE( 357)				int _g_min = xIter3->start;
HXDLIN( 357)				int _g_max = xIter3->max;
HXDLIN( 357)				while((_g_min < _g_max)){
HXLINE( 357)					_g_min = (_g_min + 1);
HXDLIN( 357)					int px1 = (_g_min - 1);
HXDLIN( 357)					Float pcx = (( (Float)(px1) ) - bx);
HXLINE( 619)					found = false;
HXLINE( 357)					{
HXLINE( 357)						int _g_min1 = yIter3->start;
HXDLIN( 357)						int _g_max1 = yIter3->max;
HXDLIN( 357)						while((_g_min1 < _g_max1)){
HXLINE( 357)							_g_min1 = (_g_min1 + 1);
HXDLIN( 357)							int py1 = (_g_min1 - 1);
HXDLIN( 357)							Float pcy = (( (Float)(py1) ) - by);
HXDLIN( 357)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 357)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 357)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 357)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 357)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 357)							bool _hx_tmp4;
HXDLIN( 357)							bool _hx_tmp5;
HXDLIN( 357)							if ((ratioA >= 0)) {
HXLINE( 357)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp5 = false;
            							}
HXDLIN( 357)							if (_hx_tmp5) {
HXLINE( 357)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp4 = false;
            							}
HXDLIN( 357)							if (_hx_tmp4) {
HXLINE( 357)								int i6 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 357)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 357)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 357)								int a5 = i6;
HXDLIN( 357)								int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 357)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 357)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 357)								int r3 = i7;
HXDLIN( 357)								int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 357)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 357)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 357)								int g3 = i8;
HXDLIN( 357)								int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 357)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 357)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 357)								int b4 = i9;
HXDLIN( 357)								{
HXLINE( 357)									int location1;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										location1 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 357)									bool _hx_tmp6;
HXDLIN( 357)									if (pixelImage->transparent) {
HXLINE( 357)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE( 357)										_hx_tmp6 = false;
            									}
HXDLIN( 357)									if (_hx_tmp6) {
HXLINE( 357)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 357)										int old;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											old = this23;
            										}
HXDLIN( 357)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 357)										Float a11;
HXDLIN( 357)										int this24 = ((old >> 24) & 255);
HXDLIN( 357)										if ((this24 == 0)) {
HXLINE( 357)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r11;
HXDLIN( 357)										int this25 = ((old >> 16) & 255);
HXDLIN( 357)										if ((this25 == 0)) {
HXLINE( 357)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g11;
HXDLIN( 357)										int this26 = ((old >> 8) & 255);
HXDLIN( 357)										if ((this26 == 0)) {
HXLINE( 357)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b12;
HXDLIN( 357)										int this27 = (old & 255);
HXDLIN( 357)										if ((this27 == 0)) {
HXLINE( 357)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a21;
HXDLIN( 357)										int this28 = ((rhs >> 24) & 255);
HXDLIN( 357)										if ((this28 == 0)) {
HXLINE( 357)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r21;
HXDLIN( 357)										int this29 = ((rhs >> 16) & 255);
HXDLIN( 357)										if ((this29 == 0)) {
HXLINE( 357)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g21;
HXDLIN( 357)										int this30 = ((rhs >> 8) & 255);
HXDLIN( 357)										if ((this30 == 0)) {
HXLINE( 357)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b22;
HXDLIN( 357)										int this31 = (rhs & 255);
HXDLIN( 357)										if ((this31 == 0)) {
HXLINE( 357)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 357)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 357)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 357)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 357)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 357)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 357)										{
HXLINE( 357)											int _hx_tmp7;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp7 = blended1;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE( 357)										int value;
HXDLIN( 357)										if (pixelImage->isLittle) {
HXLINE( 357)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 357)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 357)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
HXLINE( 633)								found = true;
            							}
            							else {
HXLINE( 357)								if (found) {
HXLINE( 357)									goto _hx_goto_345;
            								}
            							}
            						}
            						_hx_goto_345:;
            					}
            				}
            			}
HXDLIN( 357)			{
HXLINE( 357)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,ax,ay,bx,by,true);
HXDLIN( 357)				if (hasUndo) {
HXLINE( 357)					v2->undoImage = undoImage;
HXDLIN( 357)					v2->undoX = xIter3->start;
HXDLIN( 357)					v2->undoY = yIter3->start;
            				}
            			}
            		}
            		else {
HXLINE( 357)			Float bx1 = ax;
HXDLIN( 357)			Float by1 = ay;
HXDLIN( 357)			Float cx1 = bx;
HXDLIN( 357)			Float cy1 = by;
HXDLIN( 357)			bool hasUndo1 = false;
HXDLIN( 357)			bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN( 357)			if (!(adjustWinding)) {
HXLINE( 357)				Float bx_ = bx1;
HXDLIN( 357)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE( 357)			{
HXLINE( 357)				Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN( 357)				Float sx = (cy1 - ey);
HXDLIN( 357)				Float sy = (ex - cx1);
HXDLIN( 357)				Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN( 357)				Float tx = (ey - by1);
HXDLIN( 357)				Float ty = (bx1 - ex);
HXDLIN( 357)				Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 357)				if ((ex > bx1)) {
HXLINE( 357)					if ((ex > cx1)) {
HXLINE( 357)						int min4;
HXDLIN( 357)						if ((bx1 > cx1)) {
HXLINE( 357)							min4 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 357)							min4 = ::Math_obj::floor(bx1);
            						}
HXDLIN( 357)						int ii_min8 = min4;
HXDLIN( 357)						int ii_max8 = ::Math_obj::ceil(ex);
HXDLIN( 357)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 357)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 357)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN( 357)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 357)					if ((bx1 > cx1)) {
HXLINE( 357)						int min5;
HXDLIN( 357)						if ((ex > cx1)) {
HXLINE( 357)							min5 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 357)							min5 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 357)						int ii_min10 = min5;
HXDLIN( 357)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 357)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 357)						int ii_min11 = ::Math_obj::floor(ex);
HXDLIN( 357)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN( 357)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 357)				if ((ey > by1)) {
HXLINE( 357)					if ((ey > cy1)) {
HXLINE( 357)						int min6;
HXDLIN( 357)						if ((by1 > cy1)) {
HXLINE( 357)							min6 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 357)							min6 = ::Math_obj::floor(by1);
            						}
HXDLIN( 357)						int ii_min12 = min6;
HXDLIN( 357)						int ii_max12 = ::Math_obj::ceil(ey);
HXDLIN( 357)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 357)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 357)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN( 357)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 357)					if ((by1 > cy1)) {
HXLINE( 357)						int min7;
HXDLIN( 357)						if ((ey > cy1)) {
HXLINE( 357)							min7 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 357)							min7 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 357)						int ii_min14 = min7;
HXDLIN( 357)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 357)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 357)						int ii_min15 = ::Math_obj::floor(ey);
HXDLIN( 357)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN( 357)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 357)				if (hasUndo1) {
HXLINE( 357)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 357)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 357)					 ::Dynamic imageType1 = null();
HXDLIN( 357)					 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 357)					::Dynamic undoImage4;
HXDLIN( 357)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 357)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 357)							{
HXLINE( 357)								b6->width = width1;
HXDLIN( 357)								b6->height = height1;
HXDLIN( 357)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 357)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 357)								{
HXLINE( 357)									int len2 = b6->length;
HXDLIN( 357)									int w1 = 0;
HXDLIN( 357)									{
HXLINE( 357)										int _g20 = 0;
HXDLIN( 357)										int _g21 = b6->height;
HXDLIN( 357)										while((_g20 < _g21)){
HXLINE( 357)											_g20 = (_g20 + 1);
HXDLIN( 357)											int y3 = (_g20 - 1);
HXDLIN( 357)											{
HXLINE( 357)												int _g22 = 0;
HXDLIN( 357)												int _g23 = b6->width;
HXDLIN( 357)												while((_g22 < _g23)){
HXLINE( 357)													_g22 = (_g22 + 1);
HXDLIN( 357)													int x3 = (_g22 - 1);
HXDLIN( 357)													{
HXLINE( 357)														w1 = (w1 + 1);
HXDLIN( 357)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w1 = (w1 + 1);
HXDLIN( 357)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w1 = (w1 + 1);
HXDLIN( 357)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w1 = (w1 + 1);
HXDLIN( 357)														b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage4 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE( 357)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 357)							{
HXLINE( 357)								a7->width = width1;
HXDLIN( 357)								a7->height = height1;
HXDLIN( 357)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)								a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 357)								{
HXLINE( 357)									int _g24 = 0;
HXDLIN( 357)									int _g25 = a7->length;
HXDLIN( 357)									while((_g24 < _g25)){
HXLINE( 357)										_g24 = (_g24 + 1);
HXDLIN( 357)										int i10 = (_g24 - 1);
HXDLIN( 357)										a7->data[i10] = 0;
            									}
            								}
            							}
HXDLIN( 357)							undoImage4 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE( 357)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 357)							{
HXLINE( 357)								b7->width = width1;
HXDLIN( 357)								b7->height = height1;
HXDLIN( 357)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 357)								int size1 = (b7->length * 4);
HXDLIN( 357)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 357)								{
HXLINE( 357)									int _g26 = 0;
HXDLIN( 357)									int _g27 = b7->length;
HXDLIN( 357)									while((_g26 < _g27)){
HXLINE( 357)										_g26 = (_g26 + 1);
HXDLIN( 357)										int i11 = (_g26 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN( 357)											bool undoImage5;
HXDLIN( 357)											if ((i11 >= 0)) {
HXLINE( 357)												undoImage5 = (i11 < (this33->byteLength >> 2));
            											}
            											else {
HXLINE( 357)												undoImage5 = false;
            											}
HXDLIN( 357)											if (undoImage5) {
HXLINE( 357)												 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 357)												int pos1 = ((i11 << 2) + this33->byteOffset);
HXDLIN( 357)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 357)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage4 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE( 357)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 357)							{
HXLINE( 357)								v3->width = width1;
HXDLIN( 357)								v3->height = height1;
HXDLIN( 357)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 357)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 357)								{
HXLINE( 357)									int _g28 = 0;
HXDLIN( 357)									int _g29 = v3->length;
HXDLIN( 357)									while((_g28 < _g29)){
HXLINE( 357)										_g28 = (_g28 + 1);
HXDLIN( 357)										int i12 = (_g28 - 1);
HXDLIN( 357)										v3->data->__unsafe_set(i12,0);
            									}
            								}
            							}
HXDLIN( 357)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 357)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 357)							{
HXLINE( 357)								b8->width = width1;
HXDLIN( 357)								b8->height = height1;
HXDLIN( 357)								b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 357)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)								{
HXLINE( 357)									int len3 = b8->length;
HXDLIN( 357)									 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 357)									if (::hx::IsNull( d1->head )) {
HXLINE( 357)										int _g30 = 0;
HXDLIN( 357)										int _g31 = len3;
HXDLIN( 357)										while((_g30 < _g31)){
HXLINE( 357)											_g30 = (_g30 + 1);
HXDLIN( 357)											int i13 = (_g30 - 1);
HXDLIN( 357)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 357)										int _g32 = 0;
HXDLIN( 357)										int _g33 = len3;
HXDLIN( 357)										while((_g32 < _g33)){
HXLINE( 357)											_g32 = (_g32 + 1);
HXDLIN( 357)											int i14 = (_g32 - 1);
HXDLIN( 357)											{
HXLINE( 357)												 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 357)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 357)												{
HXLINE( 357)													int _g34 = 0;
HXDLIN( 357)													int _g35 = i14;
HXDLIN( 357)													while((_g34 < _g35)){
HXLINE( 357)														_g34 = (_g34 + 1);
HXDLIN( 357)														int i15 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 357)												if (::hx::IsNull( prev1 )) {
HXLINE( 357)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 357)													l1 = null();
            												}
            												else {
HXLINE( 357)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 357)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage4 = b8;
            						}
            						break;
            					}
HXDLIN( 357)					this32->image = undoImage4;
HXDLIN( 357)					this32->width = width1;
HXDLIN( 357)					this32->height = height1;
HXDLIN( 357)					this32->imageType = ( (int)(imageType1) );
HXDLIN( 357)					undoImage3 = this32;
HXDLIN( 357)					{
HXLINE( 357)						int rectLeft1 = xIter31->start;
HXDLIN( 357)						int rectTop1 = yIter31->start;
HXDLIN( 357)						int rectRight1 = xIter31->max;
HXDLIN( 357)						bool forceClear1 = false;
HXDLIN( 357)						{
HXLINE( 357)							int _g36 = rectTop1;
HXDLIN( 357)							int _g37 = yIter31->max;
HXDLIN( 357)							while((_g36 < _g37)){
HXLINE( 357)								_g36 = (_g36 + 1);
HXDLIN( 357)								int dy2 = (_g36 - 1);
HXDLIN( 357)								{
HXLINE( 357)									int _g38 = rectLeft1;
HXDLIN( 357)									int _g39 = rectRight1;
HXDLIN( 357)									while((_g38 < _g39)){
HXLINE( 357)										_g38 = (_g38 + 1);
HXDLIN( 357)										int dx2 = (_g38 - 1);
HXDLIN( 357)										::Dynamic this34 = pixelImage->image;
HXDLIN( 357)										int index4;
HXDLIN( 357)										if (pixelImage->useVirtualPos) {
HXLINE( 357)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 357)											index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 357)										int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 357)										int col1;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											col1 = c3;
            										}
HXDLIN( 357)										bool _hx_tmp8;
HXDLIN( 357)										if (pixelImage->useMask) {
HXLINE( 357)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 357)											_hx_tmp8 = false;
            										}
HXDLIN( 357)										if (_hx_tmp8) {
HXLINE( 357)											 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN( 357)											::Dynamic this36 = this35->image;
HXDLIN( 357)											int index5;
HXDLIN( 357)											if (this35->useVirtualPos) {
HXLINE( 357)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            											}
            											else {
HXLINE( 357)												index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            											}
HXDLIN( 357)											int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 357)											int v4;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												v4 = c4;
            											}
HXDLIN( 357)											int maskPixel1 = v4;
HXDLIN( 357)											int this37 = col1;
HXDLIN( 357)											if ((maskPixel1 == 0)) {
HXLINE( 357)												col1 = this37;
            											}
            											else {
HXLINE( 357)												Float m01;
HXDLIN( 357)												int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 357)												if ((this38 == 0)) {
HXLINE( 357)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m11;
HXDLIN( 357)												int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 357)												if ((this39 == 0)) {
HXLINE( 357)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m21;
HXDLIN( 357)												int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 357)												if ((this40 == 0)) {
HXLINE( 357)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m31;
HXDLIN( 357)												int this41 = (maskPixel1 & 255);
HXDLIN( 357)												if ((this41 == 0)) {
HXLINE( 357)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 357)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 357)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 357)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 357)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 357)										if ((col1 != 0)) {
HXLINE( 357)											int x4 = (dx2 - rectLeft1);
HXDLIN( 357)											int y4 = (dy2 - rectTop1);
HXDLIN( 357)											int c5 = col1;
HXDLIN( 357)											bool _hx_tmp9;
HXDLIN( 357)											if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp9 = false;
            											}
HXDLIN( 357)											if (_hx_tmp9) {
HXLINE( 357)												int location2;
HXDLIN( 357)												if (undoImage3->useVirtualPos) {
HXLINE( 357)													location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 357)													location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            												}
HXDLIN( 357)												int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 357)												int this43;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this43 = this42;
            												}
HXDLIN( 357)												Float a12;
HXDLIN( 357)												int this44 = ((this43 >> 24) & 255);
HXDLIN( 357)												if ((this44 == 0)) {
HXLINE( 357)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r12;
HXDLIN( 357)												int this45 = ((this43 >> 16) & 255);
HXDLIN( 357)												if ((this45 == 0)) {
HXLINE( 357)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g12;
HXDLIN( 357)												int this46 = ((this43 >> 8) & 255);
HXDLIN( 357)												if ((this46 == 0)) {
HXLINE( 357)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b13;
HXDLIN( 357)												int this47 = (this43 & 255);
HXDLIN( 357)												if ((this47 == 0)) {
HXLINE( 357)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a22;
HXDLIN( 357)												int this48 = ((col1 >> 24) & 255);
HXDLIN( 357)												if ((this48 == 0)) {
HXLINE( 357)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r22;
HXDLIN( 357)												int this49 = ((col1 >> 16) & 255);
HXDLIN( 357)												if ((this49 == 0)) {
HXLINE( 357)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g22;
HXDLIN( 357)												int this50 = ((col1 >> 8) & 255);
HXDLIN( 357)												if ((this50 == 0)) {
HXLINE( 357)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b23;
HXDLIN( 357)												int this51 = (col1 & 255);
HXDLIN( 357)												if ((this51 == 0)) {
HXLINE( 357)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 357)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 357)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 357)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 357)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 357)												int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp10;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp10 = blended2;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this52 = undoImage3->image;
HXDLIN( 357)												int index6;
HXDLIN( 357)												if (undoImage3->useVirtualPos) {
HXLINE( 357)													index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 357)													index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            												}
HXDLIN( 357)												int _hx_tmp11;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp11 = c5;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 357)											if (forceClear1) {
HXLINE( 357)												::Dynamic this53 = undoImage3->image;
HXDLIN( 357)												int x5 = (dx2 - rectLeft1);
HXDLIN( 357)												int y5 = (dy2 - rectTop1);
HXDLIN( 357)												int index7;
HXDLIN( 357)												if (undoImage3->useVirtualPos) {
HXLINE( 357)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 357)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this53,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 357)				bool found1 = false;
HXDLIN( 357)				Float s = ((Float)0.);
HXDLIN( 357)				Float t = ((Float)0.);
HXDLIN( 357)				Float sxx = ((Float)0.);
HXDLIN( 357)				Float txx = ((Float)0.);
HXDLIN( 357)				{
HXLINE( 357)					int _g_min2 = xIter31->start;
HXDLIN( 357)					int _g_max2 = xIter31->max;
HXDLIN( 357)					while((_g_min2 < _g_max2)){
HXLINE( 357)						_g_min2 = (_g_min2 + 1);
HXDLIN( 357)						int x6 = (_g_min2 - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x6) ));
HXLINE(  61)						txx = (tx * ( (Float)(x6) ));
HXLINE(  62)						found1 = false;
HXLINE( 357)						{
HXLINE( 357)							int _g_min3 = yIter31->start;
HXDLIN( 357)							int _g_max3 = yIter31->max;
HXDLIN( 357)							while((_g_min3 < _g_max3)){
HXLINE( 357)								_g_min3 = (_g_min3 + 1);
HXDLIN( 357)								int y6 = (_g_min3 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y6) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y6) )));
HXLINE( 357)								bool _hx_tmp12;
HXDLIN( 357)								if (!((s <= 0))) {
HXLINE( 357)									_hx_tmp12 = (t <= 0);
            								}
            								else {
HXLINE( 357)									_hx_tmp12 = true;
            								}
HXDLIN( 357)								if (_hx_tmp12) {
HXLINE( 357)									if (found1) {
HXLINE( 357)										goto _hx_goto_357;
            									}
            								}
            								else {
HXLINE( 357)									if (((s + t) < A)) {
HXLINE( 357)										{
HXLINE( 357)											int c6 = color;
HXDLIN( 357)											bool _hx_tmp13;
HXDLIN( 357)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp13 = false;
            											}
HXDLIN( 357)											if (_hx_tmp13) {
HXLINE( 357)												int location3;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x6) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													location3 = ::Std_obj::_hx_int(( (Float)(((y6 * pixelImage->width) + x6)) ));
            												}
HXDLIN( 357)												int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 357)												int this55;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this55 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this55 = this54;
            												}
HXDLIN( 357)												Float a13;
HXDLIN( 357)												int this56 = ((this55 >> 24) & 255);
HXDLIN( 357)												if ((this56 == 0)) {
HXLINE( 357)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a13 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r13;
HXDLIN( 357)												int this57 = ((this55 >> 16) & 255);
HXDLIN( 357)												if ((this57 == 0)) {
HXLINE( 357)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g13;
HXDLIN( 357)												int this58 = ((this55 >> 8) & 255);
HXDLIN( 357)												if ((this58 == 0)) {
HXLINE( 357)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b14;
HXDLIN( 357)												int this59 = (this55 & 255);
HXDLIN( 357)												if ((this59 == 0)) {
HXLINE( 357)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a23;
HXDLIN( 357)												int this60 = ((color >> 24) & 255);
HXDLIN( 357)												if ((this60 == 0)) {
HXLINE( 357)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r23;
HXDLIN( 357)												int this61 = ((color >> 16) & 255);
HXDLIN( 357)												if ((this61 == 0)) {
HXLINE( 357)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g23;
HXDLIN( 357)												int this62 = ((color >> 8) & 255);
HXDLIN( 357)												if ((this62 == 0)) {
HXLINE( 357)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b24;
HXDLIN( 357)												int this63 = (color & 255);
HXDLIN( 357)												if ((this63 == 0)) {
HXLINE( 357)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 357)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 357)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 357)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 357)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 357)												int blended3 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp14;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp14 = blended3;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this64 = pixelImage->image;
HXDLIN( 357)												int index8;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x6) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * pixelImage->width) + x6)) ));
            												}
HXDLIN( 357)												int _hx_tmp15;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp15 = c6;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this64,index8,_hx_tmp15);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE( 357)										if (found1) {
HXLINE( 357)											goto _hx_goto_357;
            										}
            									}
            								}
            							}
            							_hx_goto_357:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 357)		if (softRight) {
HXLINE( 357)			bool hasUndo2 = false;
HXDLIN( 357)			int aA1 = ((color >> 24) & 255);
HXDLIN( 357)			int rA1 = ((color >> 16) & 255);
HXDLIN( 357)			int gA1 = ((color >> 8) & 255);
HXDLIN( 357)			int bA1 = (color & 255);
HXDLIN( 357)			Float bcx1 = (bx - cx);
HXDLIN( 357)			Float bcy1 = (by - cy);
HXDLIN( 357)			Float acx1 = (ex - cx);
HXDLIN( 357)			Float acy1 = (ey - cy);
HXDLIN( 357)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 357)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 357)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 357)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 357)			if ((ex > bx)) {
HXLINE( 357)				if ((ex > cx)) {
HXLINE( 357)					int min8;
HXDLIN( 357)					if ((bx > cx)) {
HXLINE( 357)						min8 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 357)						min8 = ::Math_obj::floor(bx);
            					}
HXDLIN( 357)					int ii_min16 = min8;
HXDLIN( 357)					int ii_max16 = ::Math_obj::ceil(ex);
HXDLIN( 357)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 357)					int ii_min17 = ::Math_obj::floor(bx);
HXDLIN( 357)					int ii_max17 = ::Math_obj::ceil(cx);
HXDLIN( 357)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 357)				if ((bx > cx)) {
HXLINE( 357)					int min9;
HXDLIN( 357)					if ((ex > cx)) {
HXLINE( 357)						min9 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 357)						min9 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 357)					int ii_min18 = min9;
HXDLIN( 357)					int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN( 357)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 357)					int ii_min19 = ::Math_obj::floor(ex);
HXDLIN( 357)					int ii_max19 = ::Math_obj::ceil(cx);
HXDLIN( 357)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 357)			if ((ey > by)) {
HXLINE( 357)				if ((ey > cy)) {
HXLINE( 357)					int min10;
HXDLIN( 357)					if ((by > cy)) {
HXLINE( 357)						min10 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 357)						min10 = ::Math_obj::floor(by);
            					}
HXDLIN( 357)					int ii_min20 = min10;
HXDLIN( 357)					int ii_max20 = ::Math_obj::ceil(ey);
HXDLIN( 357)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 357)					int ii_min21 = ::Math_obj::floor(by);
HXDLIN( 357)					int ii_max21 = ::Math_obj::ceil(cy);
HXDLIN( 357)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 357)				if ((by > cy)) {
HXLINE( 357)					int min11;
HXDLIN( 357)					if ((ey > cy)) {
HXLINE( 357)						min11 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 357)						min11 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 357)					int ii_min22 = min11;
HXDLIN( 357)					int ii_max22 = ::Math_obj::ceil(by);
HXDLIN( 357)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 357)					int ii_min23 = ::Math_obj::floor(ey);
HXDLIN( 357)					int ii_max23 = ::Math_obj::ceil(cy);
HXDLIN( 357)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 357)			if (hasUndo2) {
HXLINE( 357)				int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 357)				int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 357)				 ::Dynamic imageType2 = null();
HXDLIN( 357)				 ::pi_xy::ImageStruct this65 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 357)				::Dynamic undoImage7;
HXDLIN( 357)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 357)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::BytesImg b15 = byt2;
HXDLIN( 357)						{
HXLINE( 357)							b15->width = width2;
HXDLIN( 357)							b15->height = height2;
HXDLIN( 357)							b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 357)							b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN( 357)							{
HXLINE( 357)								int len4 = b15->length;
HXDLIN( 357)								int w2 = 0;
HXDLIN( 357)								{
HXLINE( 357)									int _g40 = 0;
HXDLIN( 357)									int _g41 = b15->height;
HXDLIN( 357)									while((_g40 < _g41)){
HXLINE( 357)										_g40 = (_g40 + 1);
HXDLIN( 357)										int y7 = (_g40 - 1);
HXDLIN( 357)										{
HXLINE( 357)											int _g42 = 0;
HXDLIN( 357)											int _g43 = b15->width;
HXDLIN( 357)											while((_g42 < _g43)){
HXLINE( 357)												_g42 = (_g42 + 1);
HXDLIN( 357)												int x7 = (_g42 - 1);
HXDLIN( 357)												{
HXLINE( 357)													w2 = (w2 + 1);
HXDLIN( 357)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w2 = (w2 + 1);
HXDLIN( 357)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w2 = (w2 + 1);
HXDLIN( 357)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w2 = (w2 + 1);
HXDLIN( 357)													b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage7 = b15;
            					}
            					break;
            					case (int)1: {
HXLINE( 357)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::ArrIntImg a10 = arrI2;
HXDLIN( 357)						{
HXLINE( 357)							a10->width = width2;
HXDLIN( 357)							a10->height = height2;
HXDLIN( 357)							a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)							a10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 357)							{
HXLINE( 357)								int _g44 = 0;
HXDLIN( 357)								int _g45 = a10->length;
HXDLIN( 357)								while((_g44 < _g45)){
HXLINE( 357)									_g44 = (_g44 + 1);
HXDLIN( 357)									int i16 = (_g44 - 1);
HXDLIN( 357)									a10->data[i16] = 0;
            								}
            							}
            						}
HXDLIN( 357)						undoImage7 = a10;
            					}
            					break;
            					case (int)2: {
HXLINE( 357)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::U32ArrImg b16 = u32a2;
HXDLIN( 357)						{
HXLINE( 357)							b16->width = width2;
HXDLIN( 357)							b16->height = height2;
HXDLIN( 357)							b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 357)							int size2 = (b16->length * 4);
HXDLIN( 357)							b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 357)							{
HXLINE( 357)								int _g46 = 0;
HXDLIN( 357)								int _g47 = b16->length;
HXDLIN( 357)								while((_g46 < _g47)){
HXLINE( 357)									_g46 = (_g46 + 1);
HXDLIN( 357)									int i17 = (_g46 - 1);
HXDLIN( 357)									{
HXLINE( 357)										 ::haxe::io::ArrayBufferViewImpl this66 = b16->data;
HXDLIN( 357)										bool undoImage8;
HXDLIN( 357)										if ((i17 >= 0)) {
HXLINE( 357)											undoImage8 = (i17 < (this66->byteLength >> 2));
            										}
            										else {
HXLINE( 357)											undoImage8 = false;
            										}
HXDLIN( 357)										if (undoImage8) {
HXLINE( 357)											 ::haxe::io::Bytes _this2 = this66->bytes;
HXDLIN( 357)											int pos2 = ((i17 << 2) + this66->byteOffset);
HXDLIN( 357)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 357)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage7 = b16;
            					}
            					break;
            					case (int)3: {
HXLINE( 357)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 357)						{
HXLINE( 357)							v5->width = width2;
HXDLIN( 357)							v5->height = height2;
HXDLIN( 357)							v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 357)							v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 357)							{
HXLINE( 357)								int _g48 = 0;
HXDLIN( 357)								int _g49 = v5->length;
HXDLIN( 357)								while((_g48 < _g49)){
HXLINE( 357)									_g48 = (_g48 + 1);
HXDLIN( 357)									int i18 = (_g48 - 1);
HXDLIN( 357)									v5->data->__unsafe_set(i18,0);
            								}
            							}
            						}
HXDLIN( 357)						undoImage7 = v5;
            					}
            					break;
            					case (int)4: {
HXLINE( 357)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::StackIntImg b17 = sInt2;
HXDLIN( 357)						{
HXLINE( 357)							b17->width = width2;
HXDLIN( 357)							b17->height = height2;
HXDLIN( 357)							b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 357)							b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)							{
HXLINE( 357)								int len5 = b17->length;
HXDLIN( 357)								 ::haxe::ds::GenericStack_Int d2 = b17->data;
HXDLIN( 357)								if (::hx::IsNull( d2->head )) {
HXLINE( 357)									int _g50 = 0;
HXDLIN( 357)									int _g51 = len5;
HXDLIN( 357)									while((_g50 < _g51)){
HXLINE( 357)										_g50 = (_g50 + 1);
HXDLIN( 357)										int i19 = (_g50 - 1);
HXDLIN( 357)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 357)									int _g52 = 0;
HXDLIN( 357)									int _g53 = len5;
HXDLIN( 357)									while((_g52 < _g53)){
HXLINE( 357)										_g52 = (_g52 + 1);
HXDLIN( 357)										int i20 = (_g52 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::ds::GenericCell_Int l2 = b17->data->head;
HXDLIN( 357)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 357)											{
HXLINE( 357)												int _g54 = 0;
HXDLIN( 357)												int _g55 = i20;
HXDLIN( 357)												while((_g54 < _g55)){
HXLINE( 357)													_g54 = (_g54 + 1);
HXDLIN( 357)													int i21 = (_g54 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 357)											if (::hx::IsNull( prev2 )) {
HXLINE( 357)												b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 357)												l2 = null();
            											}
            											else {
HXLINE( 357)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 357)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage7 = b17;
            					}
            					break;
            				}
HXDLIN( 357)				this65->image = undoImage7;
HXDLIN( 357)				this65->width = width2;
HXDLIN( 357)				this65->height = height2;
HXDLIN( 357)				this65->imageType = ( (int)(imageType2) );
HXDLIN( 357)				undoImage6 = this65;
HXDLIN( 357)				{
HXLINE( 357)					int rectLeft2 = xIter32->start;
HXDLIN( 357)					int rectTop2 = yIter32->start;
HXDLIN( 357)					int rectRight2 = xIter32->max;
HXDLIN( 357)					bool forceClear2 = false;
HXDLIN( 357)					{
HXLINE( 357)						int _g56 = rectTop2;
HXDLIN( 357)						int _g57 = yIter32->max;
HXDLIN( 357)						while((_g56 < _g57)){
HXLINE( 357)							_g56 = (_g56 + 1);
HXDLIN( 357)							int dy3 = (_g56 - 1);
HXDLIN( 357)							{
HXLINE( 357)								int _g58 = rectLeft2;
HXDLIN( 357)								int _g59 = rectRight2;
HXDLIN( 357)								while((_g58 < _g59)){
HXLINE( 357)									_g58 = (_g58 + 1);
HXDLIN( 357)									int dx3 = (_g58 - 1);
HXDLIN( 357)									::Dynamic this67 = pixelImage->image;
HXDLIN( 357)									int index9;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										index9 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										index9 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            									}
HXDLIN( 357)									int c7 = ::iterMagic::Iimg_obj::get(this67,index9);
HXDLIN( 357)									int col2;
HXDLIN( 357)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)										col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 357)										col2 = c7;
            									}
HXDLIN( 357)									bool _hx_tmp16;
HXDLIN( 357)									if (pixelImage->useMask) {
HXLINE( 357)										_hx_tmp16 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 357)										_hx_tmp16 = false;
            									}
HXDLIN( 357)									if (_hx_tmp16) {
HXLINE( 357)										 ::pi_xy::ImageStruct this68 = pixelImage->mask;
HXDLIN( 357)										::Dynamic this69 = this68->image;
HXDLIN( 357)										int index10;
HXDLIN( 357)										if (this68->useVirtualPos) {
HXLINE( 357)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx3) - this68->virtualX));
            										}
            										else {
HXLINE( 357)											index10 = ::Std_obj::_hx_int(( (Float)(((dy3 * this68->width) + dx3)) ));
            										}
HXDLIN( 357)										int c8 = ::iterMagic::Iimg_obj::get(this69,index10);
HXDLIN( 357)										int v6;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											v6 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											v6 = c8;
            										}
HXDLIN( 357)										int maskPixel2 = v6;
HXDLIN( 357)										int this70 = col2;
HXDLIN( 357)										if ((maskPixel2 == 0)) {
HXLINE( 357)											col2 = this70;
            										}
            										else {
HXLINE( 357)											Float m02;
HXDLIN( 357)											int this71 = ((maskPixel2 >> 24) & 255);
HXDLIN( 357)											if ((this71 == 0)) {
HXLINE( 357)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m02 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m12;
HXDLIN( 357)											int this72 = ((maskPixel2 >> 16) & 255);
HXDLIN( 357)											if ((this72 == 0)) {
HXLINE( 357)												m12 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m12 = (( (Float)(this72) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m22;
HXDLIN( 357)											int this73 = ((maskPixel2 >> 8) & 255);
HXDLIN( 357)											if ((this73 == 0)) {
HXLINE( 357)												m22 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m22 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m32;
HXDLIN( 357)											int this74 = (maskPixel2 & 255);
HXDLIN( 357)											if ((this74 == 0)) {
HXLINE( 357)												m32 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m32 = (( (Float)(this74) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this70 >> 24) & 255)) )));
HXDLIN( 357)											int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this70 >> 16) & 255)) )));
HXDLIN( 357)											int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this70 >> 8) & 255)) )));
HXDLIN( 357)											int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this70 & 255)) )));
HXDLIN( 357)											col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 357)									if ((col2 != 0)) {
HXLINE( 357)										int x8 = (dx3 - rectLeft2);
HXDLIN( 357)										int y8 = (dy3 - rectTop2);
HXDLIN( 357)										int c9 = col2;
HXDLIN( 357)										bool _hx_tmp17;
HXDLIN( 357)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 357)											_hx_tmp17 = undoImage6->transparent;
            										}
            										else {
HXLINE( 357)											_hx_tmp17 = false;
            										}
HXDLIN( 357)										if (_hx_tmp17) {
HXLINE( 357)											int location4;
HXDLIN( 357)											if (undoImage6->useVirtualPos) {
HXLINE( 357)												location4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 357)												location4 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            											}
HXDLIN( 357)											int this75 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 357)											int this76;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												this76 = ((((((this75 >> 24) & 255) << 24) | ((this75 & 255) << 16)) | (((this75 >> 8) & 255) << 8)) | ((this75 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												this76 = this75;
            											}
HXDLIN( 357)											Float a14;
HXDLIN( 357)											int this77 = ((this76 >> 24) & 255);
HXDLIN( 357)											if ((this77 == 0)) {
HXLINE( 357)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a14 = (( (Float)(this77) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r14;
HXDLIN( 357)											int this78 = ((this76 >> 16) & 255);
HXDLIN( 357)											if ((this78 == 0)) {
HXLINE( 357)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r14 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g14;
HXDLIN( 357)											int this79 = ((this76 >> 8) & 255);
HXDLIN( 357)											if ((this79 == 0)) {
HXLINE( 357)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g14 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b18;
HXDLIN( 357)											int this80 = (this76 & 255);
HXDLIN( 357)											if ((this80 == 0)) {
HXLINE( 357)												b18 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b18 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a24;
HXDLIN( 357)											int this81 = ((col2 >> 24) & 255);
HXDLIN( 357)											if ((this81 == 0)) {
HXLINE( 357)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a24 = (( (Float)(this81) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r24;
HXDLIN( 357)											int this82 = ((col2 >> 16) & 255);
HXDLIN( 357)											if ((this82 == 0)) {
HXLINE( 357)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r24 = (( (Float)(this82) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g24;
HXDLIN( 357)											int this83 = ((col2 >> 8) & 255);
HXDLIN( 357)											if ((this83 == 0)) {
HXLINE( 357)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g24 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b25;
HXDLIN( 357)											int this84 = (col2 & 255);
HXDLIN( 357)											if ((this84 == 0)) {
HXLINE( 357)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b25 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 357)											int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 357)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 357)											int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a34) + (b25 * a24))));
HXDLIN( 357)											int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 357)											int blended4 = ((((a15 << 24) | (r7 << 16)) | (g7 << 8)) | b19);
HXDLIN( 357)											{
HXLINE( 357)												int _hx_tmp18;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp18 = blended4;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            											}
            										}
            										else {
HXLINE( 357)											::Dynamic this85 = undoImage6->image;
HXDLIN( 357)											int index11;
HXDLIN( 357)											if (undoImage6->useVirtualPos) {
HXLINE( 357)												index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 357)												index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            											}
HXDLIN( 357)											int _hx_tmp19;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp19 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp19 = c9;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this85,index11,_hx_tmp19);
            										}
            									}
            									else {
HXLINE( 357)										if (forceClear2) {
HXLINE( 357)											::Dynamic this86 = undoImage6->image;
HXDLIN( 357)											int x9 = (dx3 - rectLeft2);
HXDLIN( 357)											int y9 = (dy3 - rectTop2);
HXDLIN( 357)											int index12;
HXDLIN( 357)											if (undoImage6->useVirtualPos) {
HXLINE( 357)												index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 357)												index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this86,index12,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 357)			bool found2 = false;
HXDLIN( 357)			{
HXLINE( 357)				int _g_min4 = xIter32->start;
HXDLIN( 357)				int _g_max4 = xIter32->max;
HXDLIN( 357)				while((_g_min4 < _g_max4)){
HXLINE( 357)					_g_min4 = (_g_min4 + 1);
HXDLIN( 357)					int px2 = (_g_min4 - 1);
HXDLIN( 357)					Float pcx1 = (( (Float)(px2) ) - cx);
HXLINE( 619)					found2 = false;
HXLINE( 357)					{
HXLINE( 357)						int _g_min5 = yIter32->start;
HXDLIN( 357)						int _g_max5 = yIter32->max;
HXDLIN( 357)						while((_g_min5 < _g_max5)){
HXLINE( 357)							_g_min5 = (_g_min5 + 1);
HXDLIN( 357)							int py2 = (_g_min5 - 1);
HXDLIN( 357)							Float pcy1 = (( (Float)(py2) ) - cy);
HXDLIN( 357)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 357)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 357)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 357)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 357)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 357)							bool _hx_tmp20;
HXDLIN( 357)							bool _hx_tmp21;
HXDLIN( 357)							if ((ratioA1 >= 0)) {
HXLINE( 357)								_hx_tmp21 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp21 = false;
            							}
HXDLIN( 357)							if (_hx_tmp21) {
HXLINE( 357)								_hx_tmp20 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp20 = false;
            							}
HXDLIN( 357)							if (_hx_tmp20) {
HXLINE( 357)								int i22 = ::Std_obj::_hx_int((( (Float)(aA1) ) * (softC * ratioB1)));
HXDLIN( 357)								if ((i22 > 255)) {
HXLINE(  24)									i22 = 255;
            								}
HXLINE( 357)								if ((i22 < 0)) {
HXLINE(  25)									i22 = 0;
            								}
HXLINE( 357)								int a16 = i22;
HXDLIN( 357)								int i23 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 357)								if ((i23 > 255)) {
HXLINE(  24)									i23 = 255;
            								}
HXLINE( 357)								if ((i23 < 0)) {
HXLINE(  25)									i23 = 0;
            								}
HXLINE( 357)								int r8 = i23;
HXDLIN( 357)								int i24 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 357)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE( 357)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE( 357)								int g8 = i24;
HXDLIN( 357)								int i25 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 357)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE( 357)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 357)								int b20 = i25;
HXDLIN( 357)								{
HXLINE( 357)									int location5;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										location5 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										location5 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 357)									bool _hx_tmp22;
HXDLIN( 357)									if (pixelImage->transparent) {
HXLINE( 357)										_hx_tmp22 = (a16 < 254);
            									}
            									else {
HXLINE( 357)										_hx_tmp22 = false;
            									}
HXDLIN( 357)									if (_hx_tmp22) {
HXLINE( 357)										int this87 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 357)										int old1;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											old1 = ((((((this87 >> 24) & 255) << 24) | ((this87 & 255) << 16)) | (((this87 >> 8) & 255) << 8)) | ((this87 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											old1 = this87;
            										}
HXDLIN( 357)										int rhs1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 357)										Float a17;
HXDLIN( 357)										int this88 = ((old1 >> 24) & 255);
HXDLIN( 357)										if ((this88 == 0)) {
HXLINE( 357)											a17 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a17 = (( (Float)(this88) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r15;
HXDLIN( 357)										int this89 = ((old1 >> 16) & 255);
HXDLIN( 357)										if ((this89 == 0)) {
HXLINE( 357)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r15 = (( (Float)(this89) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g15;
HXDLIN( 357)										int this90 = ((old1 >> 8) & 255);
HXDLIN( 357)										if ((this90 == 0)) {
HXLINE( 357)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g15 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b110;
HXDLIN( 357)										int this91 = (old1 & 255);
HXDLIN( 357)										if ((this91 == 0)) {
HXLINE( 357)											b110 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b110 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a25;
HXDLIN( 357)										int this92 = ((rhs1 >> 24) & 255);
HXDLIN( 357)										if ((this92 == 0)) {
HXLINE( 357)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a25 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r25;
HXDLIN( 357)										int this93 = ((rhs1 >> 16) & 255);
HXDLIN( 357)										if ((this93 == 0)) {
HXLINE( 357)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r25 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g25;
HXDLIN( 357)										int this94 = ((rhs1 >> 8) & 255);
HXDLIN( 357)										if ((this94 == 0)) {
HXLINE( 357)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g25 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b26;
HXDLIN( 357)										int this95 = (rhs1 & 255);
HXDLIN( 357)										if ((this95 == 0)) {
HXLINE( 357)											b26 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a35 = (a17 * (( (Float)(1) ) - a25));
HXDLIN( 357)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 357)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 357)										int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b26 * a25))));
HXDLIN( 357)										int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 357)										int blended5 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b27);
HXDLIN( 357)										{
HXLINE( 357)											int _hx_tmp23;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp23 = blended5;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp23);
            										}
            									}
            									else {
HXLINE( 357)										int value1;
HXDLIN( 357)										if (pixelImage->isLittle) {
HXLINE( 357)											value1 = ((((a16 << 24) | (b20 << 16)) | (g8 << 8)) | r8);
            										}
            										else {
HXLINE( 357)											value1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
            										}
HXDLIN( 357)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,value1);
            									}
            								}
HXLINE( 633)								found2 = true;
            							}
            							else {
HXLINE( 357)								if (found2) {
HXLINE( 357)									goto _hx_goto_369;
            								}
            							}
            						}
            						_hx_goto_369:;
            					}
            				}
            			}
HXDLIN( 357)			{
HXLINE( 357)				 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,bx,by,cx,cy,true);
HXDLIN( 357)				if (hasUndo2) {
HXLINE( 357)					v7->undoImage = undoImage6;
HXDLIN( 357)					v7->undoX = xIter32->start;
HXDLIN( 357)					v7->undoY = yIter32->start;
            				}
            			}
            		}
            		else {
HXLINE( 357)			Float bx2 = bx;
HXDLIN( 357)			Float by2 = by;
HXDLIN( 357)			Float cx2 = cx;
HXDLIN( 357)			Float cy2 = cy;
HXDLIN( 357)			bool hasUndo3 = false;
HXDLIN( 357)			bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN( 357)			if (!(adjustWinding1)) {
HXLINE( 357)				Float bx_1 = bx2;
HXDLIN( 357)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE( 357)			{
HXLINE( 357)				Float s01 = ((ey * cx2) - (ex * cy2));
HXDLIN( 357)				Float sx1 = (cy2 - ey);
HXDLIN( 357)				Float sy1 = (ex - cx2);
HXDLIN( 357)				Float t01 = ((ex * by2) - (ey * bx2));
HXDLIN( 357)				Float tx1 = (ey - by2);
HXDLIN( 357)				Float ty1 = (bx2 - ex);
HXDLIN( 357)				Float A1 = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 357)				if ((ex > bx2)) {
HXLINE( 357)					if ((ex > cx2)) {
HXLINE( 357)						int min12;
HXDLIN( 357)						if ((bx2 > cx2)) {
HXLINE( 357)							min12 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 357)							min12 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 357)						int ii_min24 = min12;
HXDLIN( 357)						int ii_max24 = ::Math_obj::ceil(ex);
HXDLIN( 357)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXLINE( 357)						int ii_min25 = ::Math_obj::floor(bx2);
HXDLIN( 357)						int ii_max25 = ::Math_obj::ceil(cx2);
HXDLIN( 357)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
            				else {
HXLINE( 357)					if ((bx2 > cx2)) {
HXLINE( 357)						int min13;
HXDLIN( 357)						if ((ex > cx2)) {
HXLINE( 357)							min13 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 357)							min13 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 357)						int ii_min26 = min13;
HXDLIN( 357)						int ii_max26 = ::Math_obj::ceil(bx2);
HXDLIN( 357)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            					}
            					else {
HXLINE( 357)						int ii_min27 = ::Math_obj::floor(ex);
HXDLIN( 357)						int ii_max27 = ::Math_obj::ceil(cx2);
HXDLIN( 357)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 357)				if ((ey > by2)) {
HXLINE( 357)					if ((ey > cy2)) {
HXLINE( 357)						int min14;
HXDLIN( 357)						if ((by2 > cy2)) {
HXLINE( 357)							min14 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 357)							min14 = ::Math_obj::floor(by2);
            						}
HXDLIN( 357)						int ii_min28 = min14;
HXDLIN( 357)						int ii_max28 = ::Math_obj::ceil(ey);
HXDLIN( 357)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            					}
            					else {
HXLINE( 357)						int ii_min29 = ::Math_obj::floor(by2);
HXDLIN( 357)						int ii_max29 = ::Math_obj::ceil(cy2);
HXDLIN( 357)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            					}
            				}
            				else {
HXLINE( 357)					if ((by2 > cy2)) {
HXLINE( 357)						int min15;
HXDLIN( 357)						if ((ey > cy2)) {
HXLINE( 357)							min15 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 357)							min15 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 357)						int ii_min30 = min15;
HXDLIN( 357)						int ii_max30 = ::Math_obj::ceil(by2);
HXDLIN( 357)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            					}
            					else {
HXLINE( 357)						int ii_min31 = ::Math_obj::floor(ey);
HXDLIN( 357)						int ii_max31 = ::Math_obj::ceil(cy2);
HXDLIN( 357)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 357)				if (hasUndo3) {
HXLINE( 357)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 357)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 357)					 ::Dynamic imageType3 = null();
HXDLIN( 357)					 ::pi_xy::ImageStruct this96 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 357)					::Dynamic undoImage10;
HXDLIN( 357)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 357)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::BytesImg b28 = byt3;
HXDLIN( 357)							{
HXLINE( 357)								b28->width = width3;
HXDLIN( 357)								b28->height = height3;
HXDLIN( 357)								b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 357)								b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN( 357)								{
HXLINE( 357)									int len6 = b28->length;
HXDLIN( 357)									int w3 = 0;
HXDLIN( 357)									{
HXLINE( 357)										int _g60 = 0;
HXDLIN( 357)										int _g61 = b28->height;
HXDLIN( 357)										while((_g60 < _g61)){
HXLINE( 357)											_g60 = (_g60 + 1);
HXDLIN( 357)											int y10 = (_g60 - 1);
HXDLIN( 357)											{
HXLINE( 357)												int _g62 = 0;
HXDLIN( 357)												int _g63 = b28->width;
HXDLIN( 357)												while((_g62 < _g63)){
HXLINE( 357)													_g62 = (_g62 + 1);
HXDLIN( 357)													int x10 = (_g62 - 1);
HXDLIN( 357)													{
HXLINE( 357)														w3 = (w3 + 1);
HXDLIN( 357)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w3 = (w3 + 1);
HXDLIN( 357)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w3 = (w3 + 1);
HXDLIN( 357)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w3 = (w3 + 1);
HXDLIN( 357)														b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage10 = b28;
            						}
            						break;
            						case (int)1: {
HXLINE( 357)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::ArrIntImg a19 = arrI3;
HXDLIN( 357)							{
HXLINE( 357)								a19->width = width3;
HXDLIN( 357)								a19->height = height3;
HXDLIN( 357)								a19->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)								a19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 357)								{
HXLINE( 357)									int _g64 = 0;
HXDLIN( 357)									int _g65 = a19->length;
HXDLIN( 357)									while((_g64 < _g65)){
HXLINE( 357)										_g64 = (_g64 + 1);
HXDLIN( 357)										int i26 = (_g64 - 1);
HXDLIN( 357)										a19->data[i26] = 0;
            									}
            								}
            							}
HXDLIN( 357)							undoImage10 = a19;
            						}
            						break;
            						case (int)2: {
HXLINE( 357)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::U32ArrImg b29 = u32a3;
HXDLIN( 357)							{
HXLINE( 357)								b29->width = width3;
HXDLIN( 357)								b29->height = height3;
HXDLIN( 357)								b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 357)								int size3 = (b29->length * 4);
HXDLIN( 357)								b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 357)								{
HXLINE( 357)									int _g66 = 0;
HXDLIN( 357)									int _g67 = b29->length;
HXDLIN( 357)									while((_g66 < _g67)){
HXLINE( 357)										_g66 = (_g66 + 1);
HXDLIN( 357)										int i27 = (_g66 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::io::ArrayBufferViewImpl this97 = b29->data;
HXDLIN( 357)											bool undoImage11;
HXDLIN( 357)											if ((i27 >= 0)) {
HXLINE( 357)												undoImage11 = (i27 < (this97->byteLength >> 2));
            											}
            											else {
HXLINE( 357)												undoImage11 = false;
            											}
HXDLIN( 357)											if (undoImage11) {
HXLINE( 357)												 ::haxe::io::Bytes _this3 = this97->bytes;
HXDLIN( 357)												int pos3 = ((i27 << 2) + this97->byteOffset);
HXDLIN( 357)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 357)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage10 = b29;
            						}
            						break;
            						case (int)3: {
HXLINE( 357)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 357)							{
HXLINE( 357)								v8->width = width3;
HXDLIN( 357)								v8->height = height3;
HXDLIN( 357)								v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 357)								v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 357)								{
HXLINE( 357)									int _g68 = 0;
HXDLIN( 357)									int _g69 = v8->length;
HXDLIN( 357)									while((_g68 < _g69)){
HXLINE( 357)										_g68 = (_g68 + 1);
HXDLIN( 357)										int i28 = (_g68 - 1);
HXDLIN( 357)										v8->data->__unsafe_set(i28,0);
            									}
            								}
            							}
HXDLIN( 357)							undoImage10 = v8;
            						}
            						break;
            						case (int)4: {
HXLINE( 357)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::StackIntImg b30 = sInt3;
HXDLIN( 357)							{
HXLINE( 357)								b30->width = width3;
HXDLIN( 357)								b30->height = height3;
HXDLIN( 357)								b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 357)								b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)								{
HXLINE( 357)									int len7 = b30->length;
HXDLIN( 357)									 ::haxe::ds::GenericStack_Int d3 = b30->data;
HXDLIN( 357)									if (::hx::IsNull( d3->head )) {
HXLINE( 357)										int _g70 = 0;
HXDLIN( 357)										int _g71 = len7;
HXDLIN( 357)										while((_g70 < _g71)){
HXLINE( 357)											_g70 = (_g70 + 1);
HXDLIN( 357)											int i29 = (_g70 - 1);
HXDLIN( 357)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 357)										int _g72 = 0;
HXDLIN( 357)										int _g73 = len7;
HXDLIN( 357)										while((_g72 < _g73)){
HXLINE( 357)											_g72 = (_g72 + 1);
HXDLIN( 357)											int i30 = (_g72 - 1);
HXDLIN( 357)											{
HXLINE( 357)												 ::haxe::ds::GenericCell_Int l3 = b30->data->head;
HXDLIN( 357)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 357)												{
HXLINE( 357)													int _g74 = 0;
HXDLIN( 357)													int _g75 = i30;
HXDLIN( 357)													while((_g74 < _g75)){
HXLINE( 357)														_g74 = (_g74 + 1);
HXDLIN( 357)														int i31 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 357)												if (::hx::IsNull( prev3 )) {
HXLINE( 357)													b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 357)													l3 = null();
            												}
            												else {
HXLINE( 357)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 357)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage10 = b30;
            						}
            						break;
            					}
HXDLIN( 357)					this96->image = undoImage10;
HXDLIN( 357)					this96->width = width3;
HXDLIN( 357)					this96->height = height3;
HXDLIN( 357)					this96->imageType = ( (int)(imageType3) );
HXDLIN( 357)					undoImage9 = this96;
HXDLIN( 357)					{
HXLINE( 357)						int rectLeft3 = xIter33->start;
HXDLIN( 357)						int rectTop3 = yIter33->start;
HXDLIN( 357)						int rectRight3 = xIter33->max;
HXDLIN( 357)						bool forceClear3 = false;
HXDLIN( 357)						{
HXLINE( 357)							int _g76 = rectTop3;
HXDLIN( 357)							int _g77 = yIter33->max;
HXDLIN( 357)							while((_g76 < _g77)){
HXLINE( 357)								_g76 = (_g76 + 1);
HXDLIN( 357)								int dy4 = (_g76 - 1);
HXDLIN( 357)								{
HXLINE( 357)									int _g78 = rectLeft3;
HXDLIN( 357)									int _g79 = rectRight3;
HXDLIN( 357)									while((_g78 < _g79)){
HXLINE( 357)										_g78 = (_g78 + 1);
HXDLIN( 357)										int dx4 = (_g78 - 1);
HXDLIN( 357)										::Dynamic this98 = pixelImage->image;
HXDLIN( 357)										int index13;
HXDLIN( 357)										if (pixelImage->useVirtualPos) {
HXLINE( 357)											index13 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 357)											index13 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            										}
HXDLIN( 357)										int c10 = ::iterMagic::Iimg_obj::get(this98,index13);
HXDLIN( 357)										int col3;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											col3 = c10;
            										}
HXDLIN( 357)										bool _hx_tmp24;
HXDLIN( 357)										if (pixelImage->useMask) {
HXLINE( 357)											_hx_tmp24 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 357)											_hx_tmp24 = false;
            										}
HXDLIN( 357)										if (_hx_tmp24) {
HXLINE( 357)											 ::pi_xy::ImageStruct this99 = pixelImage->mask;
HXDLIN( 357)											::Dynamic this100 = this99->image;
HXDLIN( 357)											int index14;
HXDLIN( 357)											if (this99->useVirtualPos) {
HXLINE( 357)												index14 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this99->virtualY) * ( (Float)(this99->width) )) + dx4) - this99->virtualX));
            											}
            											else {
HXLINE( 357)												index14 = ::Std_obj::_hx_int(( (Float)(((dy4 * this99->width) + dx4)) ));
            											}
HXDLIN( 357)											int c11 = ::iterMagic::Iimg_obj::get(this100,index14);
HXDLIN( 357)											int v9;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												v9 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												v9 = c11;
            											}
HXDLIN( 357)											int maskPixel3 = v9;
HXDLIN( 357)											int this101 = col3;
HXDLIN( 357)											if ((maskPixel3 == 0)) {
HXLINE( 357)												col3 = this101;
            											}
            											else {
HXLINE( 357)												Float m03;
HXDLIN( 357)												int this102 = ((maskPixel3 >> 24) & 255);
HXDLIN( 357)												if ((this102 == 0)) {
HXLINE( 357)													m03 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m03 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m13;
HXDLIN( 357)												int this103 = ((maskPixel3 >> 16) & 255);
HXDLIN( 357)												if ((this103 == 0)) {
HXLINE( 357)													m13 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m13 = (( (Float)(this103) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m23;
HXDLIN( 357)												int this104 = ((maskPixel3 >> 8) & 255);
HXDLIN( 357)												if ((this104 == 0)) {
HXLINE( 357)													m23 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m23 = (( (Float)(this104) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m33;
HXDLIN( 357)												int this105 = (maskPixel3 & 255);
HXDLIN( 357)												if ((this105 == 0)) {
HXLINE( 357)													m33 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m33 = (( (Float)(this105) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this101 >> 24) & 255)) )));
HXDLIN( 357)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this101 >> 16) & 255)) )));
HXDLIN( 357)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this101 >> 8) & 255)) )));
HXDLIN( 357)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this101 & 255)) )));
HXDLIN( 357)												col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 357)										if ((col3 != 0)) {
HXLINE( 357)											int x11 = (dx4 - rectLeft3);
HXDLIN( 357)											int y11 = (dy4 - rectTop3);
HXDLIN( 357)											int c12 = col3;
HXDLIN( 357)											bool _hx_tmp25;
HXDLIN( 357)											if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp25 = undoImage9->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp25 = false;
            											}
HXDLIN( 357)											if (_hx_tmp25) {
HXLINE( 357)												int location6;
HXDLIN( 357)												if (undoImage9->useVirtualPos) {
HXLINE( 357)													location6 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 357)													location6 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            												}
HXDLIN( 357)												int this106 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 357)												int this107;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this107 = ((((((this106 >> 24) & 255) << 24) | ((this106 & 255) << 16)) | (((this106 >> 8) & 255) << 8)) | ((this106 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this107 = this106;
            												}
HXDLIN( 357)												Float a110;
HXDLIN( 357)												int this108 = ((this107 >> 24) & 255);
HXDLIN( 357)												if ((this108 == 0)) {
HXLINE( 357)													a110 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a110 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r16;
HXDLIN( 357)												int this109 = ((this107 >> 16) & 255);
HXDLIN( 357)												if ((this109 == 0)) {
HXLINE( 357)													r16 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r16 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g16;
HXDLIN( 357)												int this110 = ((this107 >> 8) & 255);
HXDLIN( 357)												if ((this110 == 0)) {
HXLINE( 357)													g16 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g16 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b111;
HXDLIN( 357)												int this111 = (this107 & 255);
HXDLIN( 357)												if ((this111 == 0)) {
HXLINE( 357)													b111 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b111 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a26;
HXDLIN( 357)												int this112 = ((col3 >> 24) & 255);
HXDLIN( 357)												if ((this112 == 0)) {
HXLINE( 357)													a26 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a26 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r26;
HXDLIN( 357)												int this113 = ((col3 >> 16) & 255);
HXDLIN( 357)												if ((this113 == 0)) {
HXLINE( 357)													r26 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r26 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g26;
HXDLIN( 357)												int this114 = ((col3 >> 8) & 255);
HXDLIN( 357)												if ((this114 == 0)) {
HXLINE( 357)													g26 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g26 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b210;
HXDLIN( 357)												int this115 = (col3 & 255);
HXDLIN( 357)												if ((this115 == 0)) {
HXLINE( 357)													b210 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b210 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a36 = (a110 * (( (Float)(1) ) - a26));
HXDLIN( 357)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 357)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 357)												int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b210 * a26))));
HXDLIN( 357)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 357)												int blended6 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b31);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp26;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp26 = blended6;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this116 = undoImage9->image;
HXDLIN( 357)												int index15;
HXDLIN( 357)												if (undoImage9->useVirtualPos) {
HXLINE( 357)													index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 357)													index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            												}
HXDLIN( 357)												int _hx_tmp27;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp27 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp27 = c12;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this116,index15,_hx_tmp27);
            											}
            										}
            										else {
HXLINE( 357)											if (forceClear3) {
HXLINE( 357)												::Dynamic this117 = undoImage9->image;
HXDLIN( 357)												int x12 = (dx4 - rectLeft3);
HXDLIN( 357)												int y12 = (dy4 - rectTop3);
HXDLIN( 357)												int index16;
HXDLIN( 357)												if (undoImage9->useVirtualPos) {
HXLINE( 357)													index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x12) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 357)													index16 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x12)) ));
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this117,index16,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 357)				bool found3 = false;
HXDLIN( 357)				Float s1 = ((Float)0.);
HXDLIN( 357)				Float t1 = ((Float)0.);
HXDLIN( 357)				Float sxx1 = ((Float)0.);
HXDLIN( 357)				Float txx1 = ((Float)0.);
HXDLIN( 357)				{
HXLINE( 357)					int _g_min6 = xIter33->start;
HXDLIN( 357)					int _g_max6 = xIter33->max;
HXDLIN( 357)					while((_g_min6 < _g_max6)){
HXLINE( 357)						_g_min6 = (_g_min6 + 1);
HXDLIN( 357)						int x13 = (_g_min6 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x13) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x13) ));
HXLINE(  62)						found3 = false;
HXLINE( 357)						{
HXLINE( 357)							int _g_min7 = yIter33->start;
HXDLIN( 357)							int _g_max7 = yIter33->max;
HXDLIN( 357)							while((_g_min7 < _g_max7)){
HXLINE( 357)								_g_min7 = (_g_min7 + 1);
HXDLIN( 357)								int y13 = (_g_min7 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y13) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y13) )));
HXLINE( 357)								bool _hx_tmp28;
HXDLIN( 357)								if (!((s1 <= 0))) {
HXLINE( 357)									_hx_tmp28 = (t1 <= 0);
            								}
            								else {
HXLINE( 357)									_hx_tmp28 = true;
            								}
HXDLIN( 357)								if (_hx_tmp28) {
HXLINE( 357)									if (found3) {
HXLINE( 357)										goto _hx_goto_381;
            									}
            								}
            								else {
HXLINE( 357)									if (((s1 + t1) < A1)) {
HXLINE( 357)										{
HXLINE( 357)											int c13 = color;
HXDLIN( 357)											bool _hx_tmp29;
HXDLIN( 357)											if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp29 = pixelImage->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp29 = false;
            											}
HXDLIN( 357)											if (_hx_tmp29) {
HXLINE( 357)												int location7;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													location7 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x13) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													location7 = ::Std_obj::_hx_int(( (Float)(((y13 * pixelImage->width) + x13)) ));
            												}
HXDLIN( 357)												int this118 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 357)												int this119;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this119 = ((((((this118 >> 24) & 255) << 24) | ((this118 & 255) << 16)) | (((this118 >> 8) & 255) << 8)) | ((this118 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this119 = this118;
            												}
HXDLIN( 357)												Float a111;
HXDLIN( 357)												int this120 = ((this119 >> 24) & 255);
HXDLIN( 357)												if ((this120 == 0)) {
HXLINE( 357)													a111 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a111 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r17;
HXDLIN( 357)												int this121 = ((this119 >> 16) & 255);
HXDLIN( 357)												if ((this121 == 0)) {
HXLINE( 357)													r17 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r17 = (( (Float)(this121) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g17;
HXDLIN( 357)												int this122 = ((this119 >> 8) & 255);
HXDLIN( 357)												if ((this122 == 0)) {
HXLINE( 357)													g17 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g17 = (( (Float)(this122) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b112;
HXDLIN( 357)												int this123 = (this119 & 255);
HXDLIN( 357)												if ((this123 == 0)) {
HXLINE( 357)													b112 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b112 = (( (Float)(this123) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a27;
HXDLIN( 357)												int this124 = ((color >> 24) & 255);
HXDLIN( 357)												if ((this124 == 0)) {
HXLINE( 357)													a27 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a27 = (( (Float)(this124) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r27;
HXDLIN( 357)												int this125 = ((color >> 16) & 255);
HXDLIN( 357)												if ((this125 == 0)) {
HXLINE( 357)													r27 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r27 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g27;
HXDLIN( 357)												int this126 = ((color >> 8) & 255);
HXDLIN( 357)												if ((this126 == 0)) {
HXLINE( 357)													g27 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g27 = (( (Float)(this126) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b211;
HXDLIN( 357)												int this127 = (color & 255);
HXDLIN( 357)												if ((this127 == 0)) {
HXLINE( 357)													b211 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b211 = (( (Float)(this127) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a37 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 357)												int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 357)												int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 357)												int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b211 * a27))));
HXDLIN( 357)												int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 357)												int blended7 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b32);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp30;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp30 = blended7;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp30);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this128 = pixelImage->image;
HXDLIN( 357)												int index17;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x13) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													index17 = ::Std_obj::_hx_int(( (Float)(((y13 * pixelImage->width) + x13)) ));
            												}
HXDLIN( 357)												int _hx_tmp31;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp31 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp31 = c13;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this128,index17,_hx_tmp31);
            											}
            										}
HXLINE(  73)										found3 = true;
            									}
            									else {
HXLINE( 357)										if (found3) {
HXLINE( 357)											goto _hx_goto_381;
            										}
            									}
            								}
            							}
            							_hx_goto_381:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 357)		if (softBottom) {
HXLINE( 357)			bool hasUndo4 = false;
HXDLIN( 357)			int aA2 = ((color >> 24) & 255);
HXDLIN( 357)			int rA2 = ((color >> 16) & 255);
HXDLIN( 357)			int gA2 = ((color >> 8) & 255);
HXDLIN( 357)			int bA2 = (color & 255);
HXDLIN( 357)			Float bcx2 = (cx - dx);
HXDLIN( 357)			Float bcy2 = (cy - dy);
HXDLIN( 357)			Float acx2 = (ex - dx);
HXDLIN( 357)			Float acy2 = (ey - dy);
HXDLIN( 357)			Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 357)			Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 357)			Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 357)			Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 357)			if ((ex > cx)) {
HXLINE( 357)				if ((ex > dx)) {
HXLINE( 357)					int min16;
HXDLIN( 357)					if ((cx > dx)) {
HXLINE( 357)						min16 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 357)						min16 = ::Math_obj::floor(cx);
            					}
HXDLIN( 357)					int ii_min32 = min16;
HXDLIN( 357)					int ii_max32 = ::Math_obj::ceil(ex);
HXDLIN( 357)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            				}
            				else {
HXLINE( 357)					int ii_min33 = ::Math_obj::floor(cx);
HXDLIN( 357)					int ii_max33 = ::Math_obj::ceil(dx);
HXDLIN( 357)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            				}
            			}
            			else {
HXLINE( 357)				if ((cx > dx)) {
HXLINE( 357)					int min17;
HXDLIN( 357)					if ((ex > dx)) {
HXLINE( 357)						min17 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 357)						min17 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 357)					int ii_min34 = min17;
HXDLIN( 357)					int ii_max34 = ::Math_obj::ceil(cx);
HXDLIN( 357)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            				}
            				else {
HXLINE( 357)					int ii_min35 = ::Math_obj::floor(ex);
HXDLIN( 357)					int ii_max35 = ::Math_obj::ceil(dx);
HXDLIN( 357)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 357)			if ((ey > cy)) {
HXLINE( 357)				if ((ey > dy)) {
HXLINE( 357)					int min18;
HXDLIN( 357)					if ((cy > dy)) {
HXLINE( 357)						min18 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 357)						min18 = ::Math_obj::floor(cy);
            					}
HXDLIN( 357)					int ii_min36 = min18;
HXDLIN( 357)					int ii_max36 = ::Math_obj::ceil(ey);
HXDLIN( 357)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            				}
            				else {
HXLINE( 357)					int ii_min37 = ::Math_obj::floor(cy);
HXDLIN( 357)					int ii_max37 = ::Math_obj::ceil(dy);
HXDLIN( 357)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            				}
            			}
            			else {
HXLINE( 357)				if ((cy > dy)) {
HXLINE( 357)					int min19;
HXDLIN( 357)					if ((ey > dy)) {
HXLINE( 357)						min19 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 357)						min19 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 357)					int ii_min38 = min19;
HXDLIN( 357)					int ii_max38 = ::Math_obj::ceil(cy);
HXDLIN( 357)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            				}
            				else {
HXLINE( 357)					int ii_min39 = ::Math_obj::floor(ey);
HXDLIN( 357)					int ii_max39 = ::Math_obj::ceil(dy);
HXDLIN( 357)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 357)			if (hasUndo4) {
HXLINE( 357)				int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 357)				int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 357)				 ::Dynamic imageType4 = null();
HXDLIN( 357)				 ::pi_xy::ImageStruct this129 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)				if (::hx::IsNull( imageType4 )) {
HXLINE(  54)					imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 357)				::Dynamic undoImage13;
HXDLIN( 357)				switch((int)(( (int)(imageType4) ))){
            					case (int)0: {
HXLINE( 357)						 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::BytesImg b33 = byt4;
HXDLIN( 357)						{
HXLINE( 357)							b33->width = width4;
HXDLIN( 357)							b33->height = height4;
HXDLIN( 357)							b33->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 357)							b33->data = ::haxe::io::Bytes_obj::alloc((b33->length * 4));
HXDLIN( 357)							{
HXLINE( 357)								int len8 = b33->length;
HXDLIN( 357)								int w4 = 0;
HXDLIN( 357)								{
HXLINE( 357)									int _g80 = 0;
HXDLIN( 357)									int _g81 = b33->height;
HXDLIN( 357)									while((_g80 < _g81)){
HXLINE( 357)										_g80 = (_g80 + 1);
HXDLIN( 357)										int y14 = (_g80 - 1);
HXDLIN( 357)										{
HXLINE( 357)											int _g82 = 0;
HXDLIN( 357)											int _g83 = b33->width;
HXDLIN( 357)											while((_g82 < _g83)){
HXLINE( 357)												_g82 = (_g82 + 1);
HXDLIN( 357)												int x14 = (_g82 - 1);
HXDLIN( 357)												{
HXLINE( 357)													w4 = (w4 + 1);
HXDLIN( 357)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w4 = (w4 + 1);
HXDLIN( 357)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w4 = (w4 + 1);
HXDLIN( 357)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w4 = (w4 + 1);
HXDLIN( 357)													b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage13 = b33;
            					}
            					break;
            					case (int)1: {
HXLINE( 357)						 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::ArrIntImg a29 = arrI4;
HXDLIN( 357)						{
HXLINE( 357)							a29->width = width4;
HXDLIN( 357)							a29->height = height4;
HXDLIN( 357)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)							a29->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 357)							{
HXLINE( 357)								int _g84 = 0;
HXDLIN( 357)								int _g85 = a29->length;
HXDLIN( 357)								while((_g84 < _g85)){
HXLINE( 357)									_g84 = (_g84 + 1);
HXDLIN( 357)									int i32 = (_g84 - 1);
HXDLIN( 357)									a29->data[i32] = 0;
            								}
            							}
            						}
HXDLIN( 357)						undoImage13 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 357)						 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::U32ArrImg b34 = u32a4;
HXDLIN( 357)						{
HXLINE( 357)							b34->width = width4;
HXDLIN( 357)							b34->height = height4;
HXDLIN( 357)							b34->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 357)							int size4 = (b34->length * 4);
HXDLIN( 357)							b34->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 357)							{
HXLINE( 357)								int _g86 = 0;
HXDLIN( 357)								int _g87 = b34->length;
HXDLIN( 357)								while((_g86 < _g87)){
HXLINE( 357)									_g86 = (_g86 + 1);
HXDLIN( 357)									int i33 = (_g86 - 1);
HXDLIN( 357)									{
HXLINE( 357)										 ::haxe::io::ArrayBufferViewImpl this130 = b34->data;
HXDLIN( 357)										bool undoImage14;
HXDLIN( 357)										if ((i33 >= 0)) {
HXLINE( 357)											undoImage14 = (i33 < (this130->byteLength >> 2));
            										}
            										else {
HXLINE( 357)											undoImage14 = false;
            										}
HXDLIN( 357)										if (undoImage14) {
HXLINE( 357)											 ::haxe::io::Bytes _this4 = this130->bytes;
HXDLIN( 357)											int pos4 = ((i33 << 2) + this130->byteOffset);
HXDLIN( 357)											_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 357)											_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage13 = b34;
            					}
            					break;
            					case (int)3: {
HXLINE( 357)						 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::VecIntImg v10 = vec4;
HXDLIN( 357)						{
HXLINE( 357)							v10->width = width4;
HXDLIN( 357)							v10->height = height4;
HXDLIN( 357)							v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 357)							v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 357)							{
HXLINE( 357)								int _g88 = 0;
HXDLIN( 357)								int _g89 = v10->length;
HXDLIN( 357)								while((_g88 < _g89)){
HXLINE( 357)									_g88 = (_g88 + 1);
HXDLIN( 357)									int i34 = (_g88 - 1);
HXDLIN( 357)									v10->data->__unsafe_set(i34,0);
            								}
            							}
            						}
HXDLIN( 357)						undoImage13 = v10;
            					}
            					break;
            					case (int)4: {
HXLINE( 357)						 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::StackIntImg b35 = sInt4;
HXDLIN( 357)						{
HXLINE( 357)							b35->width = width4;
HXDLIN( 357)							b35->height = height4;
HXDLIN( 357)							b35->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 357)							b35->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)							{
HXLINE( 357)								int len9 = b35->length;
HXDLIN( 357)								 ::haxe::ds::GenericStack_Int d4 = b35->data;
HXDLIN( 357)								if (::hx::IsNull( d4->head )) {
HXLINE( 357)									int _g90 = 0;
HXDLIN( 357)									int _g91 = len9;
HXDLIN( 357)									while((_g90 < _g91)){
HXLINE( 357)										_g90 = (_g90 + 1);
HXDLIN( 357)										int i35 = (_g90 - 1);
HXDLIN( 357)										d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            									}
            								}
            								else {
HXLINE( 357)									int _g92 = 0;
HXDLIN( 357)									int _g93 = len9;
HXDLIN( 357)									while((_g92 < _g93)){
HXLINE( 357)										_g92 = (_g92 + 1);
HXDLIN( 357)										int i36 = (_g92 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::ds::GenericCell_Int l4 = b35->data->head;
HXDLIN( 357)											 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 357)											{
HXLINE( 357)												int _g94 = 0;
HXDLIN( 357)												int _g95 = i36;
HXDLIN( 357)												while((_g94 < _g95)){
HXLINE( 357)													_g94 = (_g94 + 1);
HXDLIN( 357)													int i37 = (_g94 - 1);
HXLINE( 345)													prev4 = l4;
HXLINE( 346)													l4 = l4->next;
            												}
            											}
HXLINE( 357)											if (::hx::IsNull( prev4 )) {
HXLINE( 357)												b35->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 357)												l4 = null();
            											}
            											else {
HXLINE( 357)												prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 357)												l4 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage13 = b35;
            					}
            					break;
            				}
HXDLIN( 357)				this129->image = undoImage13;
HXDLIN( 357)				this129->width = width4;
HXDLIN( 357)				this129->height = height4;
HXDLIN( 357)				this129->imageType = ( (int)(imageType4) );
HXDLIN( 357)				undoImage12 = this129;
HXDLIN( 357)				{
HXLINE( 357)					int rectLeft4 = xIter34->start;
HXDLIN( 357)					int rectTop4 = yIter34->start;
HXDLIN( 357)					int rectRight4 = xIter34->max;
HXDLIN( 357)					bool forceClear4 = false;
HXDLIN( 357)					{
HXLINE( 357)						int _g96 = rectTop4;
HXDLIN( 357)						int _g97 = yIter34->max;
HXDLIN( 357)						while((_g96 < _g97)){
HXLINE( 357)							_g96 = (_g96 + 1);
HXDLIN( 357)							int dy5 = (_g96 - 1);
HXDLIN( 357)							{
HXLINE( 357)								int _g98 = rectLeft4;
HXDLIN( 357)								int _g99 = rectRight4;
HXDLIN( 357)								while((_g98 < _g99)){
HXLINE( 357)									_g98 = (_g98 + 1);
HXDLIN( 357)									int dx5 = (_g98 - 1);
HXDLIN( 357)									::Dynamic this131 = pixelImage->image;
HXDLIN( 357)									int index18;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										index18 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx5) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										index18 = ::Std_obj::_hx_int(( (Float)(((dy5 * pixelImage->width) + dx5)) ));
            									}
HXDLIN( 357)									int c14 = ::iterMagic::Iimg_obj::get(this131,index18);
HXDLIN( 357)									int col4;
HXDLIN( 357)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)										col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXLINE( 357)										col4 = c14;
            									}
HXDLIN( 357)									bool _hx_tmp32;
HXDLIN( 357)									if (pixelImage->useMask) {
HXLINE( 357)										_hx_tmp32 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 357)										_hx_tmp32 = false;
            									}
HXDLIN( 357)									if (_hx_tmp32) {
HXLINE( 357)										 ::pi_xy::ImageStruct this132 = pixelImage->mask;
HXDLIN( 357)										::Dynamic this133 = this132->image;
HXDLIN( 357)										int index19;
HXDLIN( 357)										if (this132->useVirtualPos) {
HXLINE( 357)											index19 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this132->virtualY) * ( (Float)(this132->width) )) + dx5) - this132->virtualX));
            										}
            										else {
HXLINE( 357)											index19 = ::Std_obj::_hx_int(( (Float)(((dy5 * this132->width) + dx5)) ));
            										}
HXDLIN( 357)										int c15 = ::iterMagic::Iimg_obj::get(this133,index19);
HXDLIN( 357)										int v11;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											v11 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											v11 = c15;
            										}
HXDLIN( 357)										int maskPixel4 = v11;
HXDLIN( 357)										int this134 = col4;
HXDLIN( 357)										if ((maskPixel4 == 0)) {
HXLINE( 357)											col4 = this134;
            										}
            										else {
HXLINE( 357)											Float m04;
HXDLIN( 357)											int this135 = ((maskPixel4 >> 24) & 255);
HXDLIN( 357)											if ((this135 == 0)) {
HXLINE( 357)												m04 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m04 = (( (Float)(this135) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m14;
HXDLIN( 357)											int this136 = ((maskPixel4 >> 16) & 255);
HXDLIN( 357)											if ((this136 == 0)) {
HXLINE( 357)												m14 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m14 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m24;
HXDLIN( 357)											int this137 = ((maskPixel4 >> 8) & 255);
HXDLIN( 357)											if ((this137 == 0)) {
HXLINE( 357)												m24 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m24 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m34;
HXDLIN( 357)											int this138 = (maskPixel4 & 255);
HXDLIN( 357)											if ((this138 == 0)) {
HXLINE( 357)												m34 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m34 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this134 >> 24) & 255)) )));
HXDLIN( 357)											int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this134 >> 16) & 255)) )));
HXDLIN( 357)											int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this134 >> 8) & 255)) )));
HXDLIN( 357)											int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this134 & 255)) )));
HXDLIN( 357)											col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 357)									if ((col4 != 0)) {
HXLINE( 357)										int x15 = (dx5 - rectLeft4);
HXDLIN( 357)										int y15 = (dy5 - rectTop4);
HXDLIN( 357)										int c16 = col4;
HXDLIN( 357)										bool _hx_tmp33;
HXDLIN( 357)										if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 357)											_hx_tmp33 = undoImage12->transparent;
            										}
            										else {
HXLINE( 357)											_hx_tmp33 = false;
            										}
HXDLIN( 357)										if (_hx_tmp33) {
HXLINE( 357)											int location8;
HXDLIN( 357)											if (undoImage12->useVirtualPos) {
HXLINE( 357)												location8 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 357)												location8 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            											}
HXDLIN( 357)											int this139 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 357)											int this140;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												this140 = ((((((this139 >> 24) & 255) << 24) | ((this139 & 255) << 16)) | (((this139 >> 8) & 255) << 8)) | ((this139 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												this140 = this139;
            											}
HXDLIN( 357)											Float a112;
HXDLIN( 357)											int this141 = ((this140 >> 24) & 255);
HXDLIN( 357)											if ((this141 == 0)) {
HXLINE( 357)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a112 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r19;
HXDLIN( 357)											int this142 = ((this140 >> 16) & 255);
HXDLIN( 357)											if ((this142 == 0)) {
HXLINE( 357)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r19 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g19;
HXDLIN( 357)											int this143 = ((this140 >> 8) & 255);
HXDLIN( 357)											if ((this143 == 0)) {
HXLINE( 357)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g19 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b113;
HXDLIN( 357)											int this144 = (this140 & 255);
HXDLIN( 357)											if ((this144 == 0)) {
HXLINE( 357)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b113 = (( (Float)(this144) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a210;
HXDLIN( 357)											int this145 = ((col4 >> 24) & 255);
HXDLIN( 357)											if ((this145 == 0)) {
HXLINE( 357)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a210 = (( (Float)(this145) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r28;
HXDLIN( 357)											int this146 = ((col4 >> 16) & 255);
HXDLIN( 357)											if ((this146 == 0)) {
HXLINE( 357)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r28 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g28;
HXDLIN( 357)											int this147 = ((col4 >> 8) & 255);
HXDLIN( 357)											if ((this147 == 0)) {
HXLINE( 357)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g28 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b212;
HXDLIN( 357)											int this148 = (col4 & 255);
HXDLIN( 357)											if ((this148 == 0)) {
HXLINE( 357)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b212 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 357)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a38) + (r28 * a210))));
HXDLIN( 357)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a38) + (g28 * a210))));
HXDLIN( 357)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a38) + (b212 * a210))));
HXDLIN( 357)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 357)											int blended8 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b36);
HXDLIN( 357)											{
HXLINE( 357)												int _hx_tmp34;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp34 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp34 = blended8;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp34);
            											}
            										}
            										else {
HXLINE( 357)											::Dynamic this149 = undoImage12->image;
HXDLIN( 357)											int index20;
HXDLIN( 357)											if (undoImage12->useVirtualPos) {
HXLINE( 357)												index20 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 357)												index20 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            											}
HXDLIN( 357)											int _hx_tmp35;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp35 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp35 = c16;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this149,index20,_hx_tmp35);
            										}
            									}
            									else {
HXLINE( 357)										if (forceClear4) {
HXLINE( 357)											::Dynamic this150 = undoImage12->image;
HXDLIN( 357)											int x16 = (dx5 - rectLeft4);
HXDLIN( 357)											int y16 = (dy5 - rectTop4);
HXDLIN( 357)											int index21;
HXDLIN( 357)											if (undoImage12->useVirtualPos) {
HXLINE( 357)												index21 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x16) - undoImage12->virtualX));
            											}
            											else {
HXLINE( 357)												index21 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage12->width) + x16)) ));
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this150,index21,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 357)			bool found4 = false;
HXDLIN( 357)			{
HXLINE( 357)				int _g_min8 = xIter34->start;
HXDLIN( 357)				int _g_max8 = xIter34->max;
HXDLIN( 357)				while((_g_min8 < _g_max8)){
HXLINE( 357)					_g_min8 = (_g_min8 + 1);
HXDLIN( 357)					int px3 = (_g_min8 - 1);
HXDLIN( 357)					Float pcx2 = (( (Float)(px3) ) - dx);
HXLINE( 619)					found4 = false;
HXLINE( 357)					{
HXLINE( 357)						int _g_min9 = yIter34->start;
HXDLIN( 357)						int _g_max9 = yIter34->max;
HXDLIN( 357)						while((_g_min9 < _g_max9)){
HXLINE( 357)							_g_min9 = (_g_min9 + 1);
HXDLIN( 357)							int py3 = (_g_min9 - 1);
HXDLIN( 357)							Float pcy2 = (( (Float)(py3) ) - dy);
HXDLIN( 357)							Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 357)							Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 357)							Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 357)							Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 357)							Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 357)							bool _hx_tmp36;
HXDLIN( 357)							bool _hx_tmp37;
HXDLIN( 357)							if ((ratioA2 >= 0)) {
HXLINE( 357)								_hx_tmp37 = (ratioB2 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp37 = false;
            							}
HXDLIN( 357)							if (_hx_tmp37) {
HXLINE( 357)								_hx_tmp36 = (ratioC2 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp36 = false;
            							}
HXDLIN( 357)							if (_hx_tmp36) {
HXLINE( 357)								int i38 = ::Std_obj::_hx_int((( (Float)(aA2) ) * (softC * ratioB2)));
HXDLIN( 357)								if ((i38 > 255)) {
HXLINE(  24)									i38 = 255;
            								}
HXLINE( 357)								if ((i38 < 0)) {
HXLINE(  25)									i38 = 0;
            								}
HXLINE( 357)								int a39 = i38;
HXDLIN( 357)								int i39 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN( 357)								if ((i39 > 255)) {
HXLINE(  24)									i39 = 255;
            								}
HXLINE( 357)								if ((i39 < 0)) {
HXLINE(  25)									i39 = 0;
            								}
HXLINE( 357)								int r29 = i39;
HXDLIN( 357)								int i40 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN( 357)								if ((i40 > 255)) {
HXLINE(  24)									i40 = 255;
            								}
HXLINE( 357)								if ((i40 < 0)) {
HXLINE(  25)									i40 = 0;
            								}
HXLINE( 357)								int g29 = i40;
HXDLIN( 357)								int i41 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN( 357)								if ((i41 > 255)) {
HXLINE(  24)									i41 = 255;
            								}
HXLINE( 357)								if ((i41 < 0)) {
HXLINE(  25)									i41 = 0;
            								}
HXLINE( 357)								int b37 = i41;
HXDLIN( 357)								{
HXLINE( 357)									int location9;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										location9 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										location9 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            									}
HXDLIN( 357)									bool _hx_tmp38;
HXDLIN( 357)									if (pixelImage->transparent) {
HXLINE( 357)										_hx_tmp38 = (a39 < 254);
            									}
            									else {
HXLINE( 357)										_hx_tmp38 = false;
            									}
HXDLIN( 357)									if (_hx_tmp38) {
HXLINE( 357)										int this151 = ::iterMagic::Iimg_obj::get(pixelImage->image,location9);
HXDLIN( 357)										int old2;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											old2 = ((((((this151 >> 24) & 255) << 24) | ((this151 & 255) << 16)) | (((this151 >> 8) & 255) << 8)) | ((this151 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											old2 = this151;
            										}
HXDLIN( 357)										int rhs2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
HXDLIN( 357)										Float a113;
HXDLIN( 357)										int this152 = ((old2 >> 24) & 255);
HXDLIN( 357)										if ((this152 == 0)) {
HXLINE( 357)											a113 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r110;
HXDLIN( 357)										int this153 = ((old2 >> 16) & 255);
HXDLIN( 357)										if ((this153 == 0)) {
HXLINE( 357)											r110 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r110 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g110;
HXDLIN( 357)										int this154 = ((old2 >> 8) & 255);
HXDLIN( 357)										if ((this154 == 0)) {
HXLINE( 357)											g110 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g110 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b114;
HXDLIN( 357)										int this155 = (old2 & 255);
HXDLIN( 357)										if ((this155 == 0)) {
HXLINE( 357)											b114 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b114 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a211;
HXDLIN( 357)										int this156 = ((rhs2 >> 24) & 255);
HXDLIN( 357)										if ((this156 == 0)) {
HXLINE( 357)											a211 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r210;
HXDLIN( 357)										int this157 = ((rhs2 >> 16) & 255);
HXDLIN( 357)										if ((this157 == 0)) {
HXLINE( 357)											r210 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r210 = (( (Float)(this157) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g210;
HXDLIN( 357)										int this158 = ((rhs2 >> 8) & 255);
HXDLIN( 357)										if ((this158 == 0)) {
HXLINE( 357)											g210 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g210 = (( (Float)(this158) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b213;
HXDLIN( 357)										int this159 = (rhs2 & 255);
HXDLIN( 357)										if ((this159 == 0)) {
HXLINE( 357)											b213 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b213 = (( (Float)(this159) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 357)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 357)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 357)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b213 * a211))));
HXDLIN( 357)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 357)										int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b38);
HXDLIN( 357)										{
HXLINE( 357)											int _hx_tmp39;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp39 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp39 = blended9;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(pixelImage->image,location9,_hx_tmp39);
            										}
            									}
            									else {
HXLINE( 357)										int value2;
HXDLIN( 357)										if (pixelImage->isLittle) {
HXLINE( 357)											value2 = ((((a39 << 24) | (b37 << 16)) | (g29 << 8)) | r29);
            										}
            										else {
HXLINE( 357)											value2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
            										}
HXDLIN( 357)										::iterMagic::Iimg_obj::set(pixelImage->image,location9,value2);
            									}
            								}
HXLINE( 633)								found4 = true;
            							}
            							else {
HXLINE( 357)								if (found4) {
HXLINE( 357)									goto _hx_goto_393;
            								}
            							}
            						}
            						_hx_goto_393:;
            					}
            				}
            			}
HXDLIN( 357)			{
HXLINE( 357)				 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,cx,cy,dx,dy,true);
HXDLIN( 357)				if (hasUndo4) {
HXLINE( 357)					v12->undoImage = undoImage12;
HXDLIN( 357)					v12->undoX = xIter34->start;
HXDLIN( 357)					v12->undoY = yIter34->start;
            				}
            			}
            		}
            		else {
HXLINE( 357)			Float bx3 = cx;
HXDLIN( 357)			Float by3 = cy;
HXDLIN( 357)			Float cx3 = dx;
HXDLIN( 357)			Float cy3 = dy;
HXDLIN( 357)			bool hasUndo5 = false;
HXDLIN( 357)			bool adjustWinding2 = (((((ex * by3) - (bx3 * ey)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ey) - (ex * cy3))) > 0);
HXDLIN( 357)			if (!(adjustWinding2)) {
HXLINE( 357)				Float bx_2 = bx3;
HXDLIN( 357)				Float by_2 = by3;
HXLINE(  25)				bx3 = cx3;
HXLINE(  26)				by3 = cy3;
HXLINE(  27)				cx3 = bx_2;
HXLINE(  28)				cy3 = by_2;
            			}
HXLINE( 357)			{
HXLINE( 357)				Float s02 = ((ey * cx3) - (ex * cy3));
HXDLIN( 357)				Float sx2 = (cy3 - ey);
HXDLIN( 357)				Float sy2 = (ex - cx3);
HXDLIN( 357)				Float t02 = ((ex * by3) - (ey * bx3));
HXDLIN( 357)				Float tx2 = (ey - by3);
HXDLIN( 357)				Float ty2 = (bx3 - ex);
HXDLIN( 357)				Float A2 = ((((-(by3) * cx3) + (ey * (-(bx3) + cx3))) + (ex * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 357)				if ((ex > bx3)) {
HXLINE( 357)					if ((ex > cx3)) {
HXLINE( 357)						int min20;
HXDLIN( 357)						if ((bx3 > cx3)) {
HXLINE( 357)							min20 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 357)							min20 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 357)						int ii_min40 = min20;
HXDLIN( 357)						int ii_max40 = ::Math_obj::ceil(ex);
HXDLIN( 357)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            					}
            					else {
HXLINE( 357)						int ii_min41 = ::Math_obj::floor(bx3);
HXDLIN( 357)						int ii_max41 = ::Math_obj::ceil(cx3);
HXDLIN( 357)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            					}
            				}
            				else {
HXLINE( 357)					if ((bx3 > cx3)) {
HXLINE( 357)						int min21;
HXDLIN( 357)						if ((ex > cx3)) {
HXLINE( 357)							min21 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 357)							min21 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 357)						int ii_min42 = min21;
HXDLIN( 357)						int ii_max42 = ::Math_obj::ceil(bx3);
HXDLIN( 357)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            					}
            					else {
HXLINE( 357)						int ii_min43 = ::Math_obj::floor(ex);
HXDLIN( 357)						int ii_max43 = ::Math_obj::ceil(cx3);
HXDLIN( 357)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 357)				if ((ey > by3)) {
HXLINE( 357)					if ((ey > cy3)) {
HXLINE( 357)						int min22;
HXDLIN( 357)						if ((by3 > cy3)) {
HXLINE( 357)							min22 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 357)							min22 = ::Math_obj::floor(by3);
            						}
HXDLIN( 357)						int ii_min44 = min22;
HXDLIN( 357)						int ii_max44 = ::Math_obj::ceil(ey);
HXDLIN( 357)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            					}
            					else {
HXLINE( 357)						int ii_min45 = ::Math_obj::floor(by3);
HXDLIN( 357)						int ii_max45 = ::Math_obj::ceil(cy3);
HXDLIN( 357)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            					}
            				}
            				else {
HXLINE( 357)					if ((by3 > cy3)) {
HXLINE( 357)						int min23;
HXDLIN( 357)						if ((ey > cy3)) {
HXLINE( 357)							min23 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 357)							min23 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 357)						int ii_min46 = min23;
HXDLIN( 357)						int ii_max46 = ::Math_obj::ceil(by3);
HXDLIN( 357)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            					}
            					else {
HXLINE( 357)						int ii_min47 = ::Math_obj::floor(ey);
HXDLIN( 357)						int ii_max47 = ::Math_obj::ceil(cy3);
HXDLIN( 357)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 357)				if (hasUndo5) {
HXLINE( 357)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 357)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 357)					 ::Dynamic imageType5 = null();
HXDLIN( 357)					 ::pi_xy::ImageStruct this160 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 357)					::Dynamic undoImage16;
HXDLIN( 357)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXLINE( 357)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::BytesImg b39 = byt5;
HXDLIN( 357)							{
HXLINE( 357)								b39->width = width5;
HXDLIN( 357)								b39->height = height5;
HXDLIN( 357)								b39->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 357)								b39->data = ::haxe::io::Bytes_obj::alloc((b39->length * 4));
HXDLIN( 357)								{
HXLINE( 357)									int len10 = b39->length;
HXDLIN( 357)									int w5 = 0;
HXDLIN( 357)									{
HXLINE( 357)										int _g100 = 0;
HXDLIN( 357)										int _g101 = b39->height;
HXDLIN( 357)										while((_g100 < _g101)){
HXLINE( 357)											_g100 = (_g100 + 1);
HXDLIN( 357)											int y17 = (_g100 - 1);
HXDLIN( 357)											{
HXLINE( 357)												int _g102 = 0;
HXDLIN( 357)												int _g103 = b39->width;
HXDLIN( 357)												while((_g102 < _g103)){
HXLINE( 357)													_g102 = (_g102 + 1);
HXDLIN( 357)													int x17 = (_g102 - 1);
HXDLIN( 357)													{
HXLINE( 357)														w5 = (w5 + 1);
HXDLIN( 357)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w5 = (w5 + 1);
HXDLIN( 357)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w5 = (w5 + 1);
HXDLIN( 357)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w5 = (w5 + 1);
HXDLIN( 357)														b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage16 = b39;
            						}
            						break;
            						case (int)1: {
HXLINE( 357)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::ArrIntImg a41 = arrI5;
HXDLIN( 357)							{
HXLINE( 357)								a41->width = width5;
HXDLIN( 357)								a41->height = height5;
HXDLIN( 357)								a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)								a41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 357)								{
HXLINE( 357)									int _g104 = 0;
HXDLIN( 357)									int _g105 = a41->length;
HXDLIN( 357)									while((_g104 < _g105)){
HXLINE( 357)										_g104 = (_g104 + 1);
HXDLIN( 357)										int i42 = (_g104 - 1);
HXDLIN( 357)										a41->data[i42] = 0;
            									}
            								}
            							}
HXDLIN( 357)							undoImage16 = a41;
            						}
            						break;
            						case (int)2: {
HXLINE( 357)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::U32ArrImg b40 = u32a5;
HXDLIN( 357)							{
HXLINE( 357)								b40->width = width5;
HXDLIN( 357)								b40->height = height5;
HXDLIN( 357)								b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 357)								int size5 = (b40->length * 4);
HXDLIN( 357)								b40->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 357)								{
HXLINE( 357)									int _g106 = 0;
HXDLIN( 357)									int _g107 = b40->length;
HXDLIN( 357)									while((_g106 < _g107)){
HXLINE( 357)										_g106 = (_g106 + 1);
HXDLIN( 357)										int i43 = (_g106 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::io::ArrayBufferViewImpl this161 = b40->data;
HXDLIN( 357)											bool undoImage17;
HXDLIN( 357)											if ((i43 >= 0)) {
HXLINE( 357)												undoImage17 = (i43 < (this161->byteLength >> 2));
            											}
            											else {
HXLINE( 357)												undoImage17 = false;
            											}
HXDLIN( 357)											if (undoImage17) {
HXLINE( 357)												 ::haxe::io::Bytes _this5 = this161->bytes;
HXDLIN( 357)												int pos5 = ((i43 << 2) + this161->byteOffset);
HXDLIN( 357)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 357)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage16 = b40;
            						}
            						break;
            						case (int)3: {
HXLINE( 357)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::VecIntImg v13 = vec5;
HXDLIN( 357)							{
HXLINE( 357)								v13->width = width5;
HXDLIN( 357)								v13->height = height5;
HXDLIN( 357)								v13->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 357)								v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 357)								{
HXLINE( 357)									int _g108 = 0;
HXDLIN( 357)									int _g109 = v13->length;
HXDLIN( 357)									while((_g108 < _g109)){
HXLINE( 357)										_g108 = (_g108 + 1);
HXDLIN( 357)										int i44 = (_g108 - 1);
HXDLIN( 357)										v13->data->__unsafe_set(i44,0);
            									}
            								}
            							}
HXDLIN( 357)							undoImage16 = v13;
            						}
            						break;
            						case (int)4: {
HXLINE( 357)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::StackIntImg b41 = sInt5;
HXDLIN( 357)							{
HXLINE( 357)								b41->width = width5;
HXDLIN( 357)								b41->height = height5;
HXDLIN( 357)								b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 357)								b41->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)								{
HXLINE( 357)									int len11 = b41->length;
HXDLIN( 357)									 ::haxe::ds::GenericStack_Int d5 = b41->data;
HXDLIN( 357)									if (::hx::IsNull( d5->head )) {
HXLINE( 357)										int _g110 = 0;
HXDLIN( 357)										int _g111 = len11;
HXDLIN( 357)										while((_g110 < _g111)){
HXLINE( 357)											_g110 = (_g110 + 1);
HXDLIN( 357)											int i45 = (_g110 - 1);
HXDLIN( 357)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXLINE( 357)										int _g112 = 0;
HXDLIN( 357)										int _g113 = len11;
HXDLIN( 357)										while((_g112 < _g113)){
HXLINE( 357)											_g112 = (_g112 + 1);
HXDLIN( 357)											int i46 = (_g112 - 1);
HXDLIN( 357)											{
HXLINE( 357)												 ::haxe::ds::GenericCell_Int l5 = b41->data->head;
HXDLIN( 357)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 357)												{
HXLINE( 357)													int _g114 = 0;
HXDLIN( 357)													int _g115 = i46;
HXDLIN( 357)													while((_g114 < _g115)){
HXLINE( 357)														_g114 = (_g114 + 1);
HXDLIN( 357)														int i47 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 357)												if (::hx::IsNull( prev5 )) {
HXLINE( 357)													b41->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 357)													l5 = null();
            												}
            												else {
HXLINE( 357)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 357)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage16 = b41;
            						}
            						break;
            					}
HXDLIN( 357)					this160->image = undoImage16;
HXDLIN( 357)					this160->width = width5;
HXDLIN( 357)					this160->height = height5;
HXDLIN( 357)					this160->imageType = ( (int)(imageType5) );
HXDLIN( 357)					undoImage15 = this160;
HXDLIN( 357)					{
HXLINE( 357)						int rectLeft5 = xIter35->start;
HXDLIN( 357)						int rectTop5 = yIter35->start;
HXDLIN( 357)						int rectRight5 = xIter35->max;
HXDLIN( 357)						bool forceClear5 = false;
HXDLIN( 357)						{
HXLINE( 357)							int _g116 = rectTop5;
HXDLIN( 357)							int _g117 = yIter35->max;
HXDLIN( 357)							while((_g116 < _g117)){
HXLINE( 357)								_g116 = (_g116 + 1);
HXDLIN( 357)								int dy6 = (_g116 - 1);
HXDLIN( 357)								{
HXLINE( 357)									int _g118 = rectLeft5;
HXDLIN( 357)									int _g119 = rectRight5;
HXDLIN( 357)									while((_g118 < _g119)){
HXLINE( 357)										_g118 = (_g118 + 1);
HXDLIN( 357)										int dx6 = (_g118 - 1);
HXDLIN( 357)										::Dynamic this162 = pixelImage->image;
HXDLIN( 357)										int index22;
HXDLIN( 357)										if (pixelImage->useVirtualPos) {
HXLINE( 357)											index22 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx6) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 357)											index22 = ::Std_obj::_hx_int(( (Float)(((dy6 * pixelImage->width) + dx6)) ));
            										}
HXDLIN( 357)										int c17 = ::iterMagic::Iimg_obj::get(this162,index22);
HXDLIN( 357)										int col5;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											col5 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											col5 = c17;
            										}
HXDLIN( 357)										bool _hx_tmp40;
HXDLIN( 357)										if (pixelImage->useMask) {
HXLINE( 357)											_hx_tmp40 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 357)											_hx_tmp40 = false;
            										}
HXDLIN( 357)										if (_hx_tmp40) {
HXLINE( 357)											 ::pi_xy::ImageStruct this163 = pixelImage->mask;
HXDLIN( 357)											::Dynamic this164 = this163->image;
HXDLIN( 357)											int index23;
HXDLIN( 357)											if (this163->useVirtualPos) {
HXLINE( 357)												index23 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this163->virtualY) * ( (Float)(this163->width) )) + dx6) - this163->virtualX));
            											}
            											else {
HXLINE( 357)												index23 = ::Std_obj::_hx_int(( (Float)(((dy6 * this163->width) + dx6)) ));
            											}
HXDLIN( 357)											int c18 = ::iterMagic::Iimg_obj::get(this164,index23);
HXDLIN( 357)											int v14;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												v14 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												v14 = c18;
            											}
HXDLIN( 357)											int maskPixel5 = v14;
HXDLIN( 357)											int this165 = col5;
HXDLIN( 357)											if ((maskPixel5 == 0)) {
HXLINE( 357)												col5 = this165;
            											}
            											else {
HXLINE( 357)												Float m05;
HXDLIN( 357)												int this166 = ((maskPixel5 >> 24) & 255);
HXDLIN( 357)												if ((this166 == 0)) {
HXLINE( 357)													m05 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m05 = (( (Float)(this166) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m15;
HXDLIN( 357)												int this167 = ((maskPixel5 >> 16) & 255);
HXDLIN( 357)												if ((this167 == 0)) {
HXLINE( 357)													m15 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m15 = (( (Float)(this167) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m25;
HXDLIN( 357)												int this168 = ((maskPixel5 >> 8) & 255);
HXDLIN( 357)												if ((this168 == 0)) {
HXLINE( 357)													m25 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m25 = (( (Float)(this168) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m35;
HXDLIN( 357)												int this169 = (maskPixel5 & 255);
HXDLIN( 357)												if ((this169 == 0)) {
HXLINE( 357)													m35 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m35 = (( (Float)(this169) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this165 >> 24) & 255)) )));
HXDLIN( 357)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this165 >> 16) & 255)) )));
HXDLIN( 357)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this165 >> 8) & 255)) )));
HXDLIN( 357)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this165 & 255)) )));
HXDLIN( 357)												col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 357)										if ((col5 != 0)) {
HXLINE( 357)											int x18 = (dx6 - rectLeft5);
HXDLIN( 357)											int y18 = (dy6 - rectTop5);
HXDLIN( 357)											int c19 = col5;
HXDLIN( 357)											bool _hx_tmp41;
HXDLIN( 357)											if ((((c19 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp41 = undoImage15->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp41 = false;
            											}
HXDLIN( 357)											if (_hx_tmp41) {
HXLINE( 357)												int location10;
HXDLIN( 357)												if (undoImage15->useVirtualPos) {
HXLINE( 357)													location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 357)													location10 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            												}
HXDLIN( 357)												int this170 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 357)												int this171;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this171 = ((((((this170 >> 24) & 255) << 24) | ((this170 & 255) << 16)) | (((this170 >> 8) & 255) << 8)) | ((this170 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this171 = this170;
            												}
HXDLIN( 357)												Float a114;
HXDLIN( 357)												int this172 = ((this171 >> 24) & 255);
HXDLIN( 357)												if ((this172 == 0)) {
HXLINE( 357)													a114 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a114 = (( (Float)(this172) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r111;
HXDLIN( 357)												int this173 = ((this171 >> 16) & 255);
HXDLIN( 357)												if ((this173 == 0)) {
HXLINE( 357)													r111 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r111 = (( (Float)(this173) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g111;
HXDLIN( 357)												int this174 = ((this171 >> 8) & 255);
HXDLIN( 357)												if ((this174 == 0)) {
HXLINE( 357)													g111 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g111 = (( (Float)(this174) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b115;
HXDLIN( 357)												int this175 = (this171 & 255);
HXDLIN( 357)												if ((this175 == 0)) {
HXLINE( 357)													b115 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b115 = (( (Float)(this175) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a212;
HXDLIN( 357)												int this176 = ((col5 >> 24) & 255);
HXDLIN( 357)												if ((this176 == 0)) {
HXLINE( 357)													a212 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a212 = (( (Float)(this176) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r211;
HXDLIN( 357)												int this177 = ((col5 >> 16) & 255);
HXDLIN( 357)												if ((this177 == 0)) {
HXLINE( 357)													r211 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r211 = (( (Float)(this177) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g211;
HXDLIN( 357)												int this178 = ((col5 >> 8) & 255);
HXDLIN( 357)												if ((this178 == 0)) {
HXLINE( 357)													g211 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g211 = (( (Float)(this178) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b214;
HXDLIN( 357)												int this179 = (col5 & 255);
HXDLIN( 357)												if ((this179 == 0)) {
HXLINE( 357)													b214 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b214 = (( (Float)(this179) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 357)												int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 357)												int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 357)												int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b214 * a212))));
HXDLIN( 357)												int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 357)												int blended10 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b42);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp42;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp42 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp42 = blended10;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp42);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this180 = undoImage15->image;
HXDLIN( 357)												int index24;
HXDLIN( 357)												if (undoImage15->useVirtualPos) {
HXLINE( 357)													index24 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 357)													index24 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            												}
HXDLIN( 357)												int _hx_tmp43;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp43 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp43 = c19;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this180,index24,_hx_tmp43);
            											}
            										}
            										else {
HXLINE( 357)											if (forceClear5) {
HXLINE( 357)												::Dynamic this181 = undoImage15->image;
HXDLIN( 357)												int x19 = (dx6 - rectLeft5);
HXDLIN( 357)												int y19 = (dy6 - rectTop5);
HXDLIN( 357)												int index25;
HXDLIN( 357)												if (undoImage15->useVirtualPos) {
HXLINE( 357)													index25 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x19) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 357)													index25 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage15->width) + x19)) ));
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this181,index25,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 357)				bool found5 = false;
HXDLIN( 357)				Float s2 = ((Float)0.);
HXDLIN( 357)				Float t2 = ((Float)0.);
HXDLIN( 357)				Float sxx2 = ((Float)0.);
HXDLIN( 357)				Float txx2 = ((Float)0.);
HXDLIN( 357)				{
HXLINE( 357)					int _g_min10 = xIter35->start;
HXDLIN( 357)					int _g_max10 = xIter35->max;
HXDLIN( 357)					while((_g_min10 < _g_max10)){
HXLINE( 357)						_g_min10 = (_g_min10 + 1);
HXDLIN( 357)						int x20 = (_g_min10 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x20) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x20) ));
HXLINE(  62)						found5 = false;
HXLINE( 357)						{
HXLINE( 357)							int _g_min11 = yIter35->start;
HXDLIN( 357)							int _g_max11 = yIter35->max;
HXDLIN( 357)							while((_g_min11 < _g_max11)){
HXLINE( 357)								_g_min11 = (_g_min11 + 1);
HXDLIN( 357)								int y20 = (_g_min11 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y20) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y20) )));
HXLINE( 357)								bool _hx_tmp44;
HXDLIN( 357)								if (!((s2 <= 0))) {
HXLINE( 357)									_hx_tmp44 = (t2 <= 0);
            								}
            								else {
HXLINE( 357)									_hx_tmp44 = true;
            								}
HXDLIN( 357)								if (_hx_tmp44) {
HXLINE( 357)									if (found5) {
HXLINE( 357)										goto _hx_goto_405;
            									}
            								}
            								else {
HXLINE( 357)									if (((s2 + t2) < A2)) {
HXLINE( 357)										{
HXLINE( 357)											int c20 = color;
HXDLIN( 357)											bool _hx_tmp45;
HXDLIN( 357)											if ((((c20 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp45 = pixelImage->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp45 = false;
            											}
HXDLIN( 357)											if (_hx_tmp45) {
HXLINE( 357)												int location11;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x20) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													location11 = ::Std_obj::_hx_int(( (Float)(((y20 * pixelImage->width) + x20)) ));
            												}
HXDLIN( 357)												int this182 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 357)												int this183;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this183 = ((((((this182 >> 24) & 255) << 24) | ((this182 & 255) << 16)) | (((this182 >> 8) & 255) << 8)) | ((this182 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this183 = this182;
            												}
HXDLIN( 357)												Float a115;
HXDLIN( 357)												int this184 = ((this183 >> 24) & 255);
HXDLIN( 357)												if ((this184 == 0)) {
HXLINE( 357)													a115 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a115 = (( (Float)(this184) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r112;
HXDLIN( 357)												int this185 = ((this183 >> 16) & 255);
HXDLIN( 357)												if ((this185 == 0)) {
HXLINE( 357)													r112 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r112 = (( (Float)(this185) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g112;
HXDLIN( 357)												int this186 = ((this183 >> 8) & 255);
HXDLIN( 357)												if ((this186 == 0)) {
HXLINE( 357)													g112 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g112 = (( (Float)(this186) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b116;
HXDLIN( 357)												int this187 = (this183 & 255);
HXDLIN( 357)												if ((this187 == 0)) {
HXLINE( 357)													b116 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b116 = (( (Float)(this187) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a213;
HXDLIN( 357)												int this188 = ((color >> 24) & 255);
HXDLIN( 357)												if ((this188 == 0)) {
HXLINE( 357)													a213 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a213 = (( (Float)(this188) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r212;
HXDLIN( 357)												int this189 = ((color >> 16) & 255);
HXDLIN( 357)												if ((this189 == 0)) {
HXLINE( 357)													r212 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r212 = (( (Float)(this189) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g212;
HXDLIN( 357)												int this190 = ((color >> 8) & 255);
HXDLIN( 357)												if ((this190 == 0)) {
HXLINE( 357)													g212 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g212 = (( (Float)(this190) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b215;
HXDLIN( 357)												int this191 = (color & 255);
HXDLIN( 357)												if ((this191 == 0)) {
HXLINE( 357)													b215 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b215 = (( (Float)(this191) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 357)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 357)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 357)												int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b215 * a213))));
HXDLIN( 357)												int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 357)												int blended11 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b43);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp46;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp46 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp46 = blended11;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp46);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this192 = pixelImage->image;
HXDLIN( 357)												int index26;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													index26 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x20) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													index26 = ::Std_obj::_hx_int(( (Float)(((y20 * pixelImage->width) + x20)) ));
            												}
HXDLIN( 357)												int _hx_tmp47;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp47 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp47 = c20;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this192,index26,_hx_tmp47);
            											}
            										}
HXLINE(  73)										found5 = true;
            									}
            									else {
HXLINE( 357)										if (found5) {
HXLINE( 357)											goto _hx_goto_405;
            										}
            									}
            								}
            							}
            							_hx_goto_405:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 357)		if (softLeft) {
HXLINE( 357)			bool hasUndo6 = false;
HXDLIN( 357)			int aA3 = ((color >> 24) & 255);
HXDLIN( 357)			int rA3 = ((color >> 16) & 255);
HXDLIN( 357)			int gA3 = ((color >> 8) & 255);
HXDLIN( 357)			int bA3 = (color & 255);
HXDLIN( 357)			Float bcx3 = (dx - ax);
HXDLIN( 357)			Float bcy3 = (dy - ay);
HXDLIN( 357)			Float acx3 = (ex - ax);
HXDLIN( 357)			Float acy3 = (ey - ay);
HXDLIN( 357)			Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 357)			Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 357)			Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 357)			Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 357)			if ((ex > dx)) {
HXLINE( 357)				if ((ex > ax)) {
HXLINE( 357)					int min24;
HXDLIN( 357)					if ((dx > ax)) {
HXLINE( 357)						min24 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 357)						min24 = ::Math_obj::floor(dx);
            					}
HXDLIN( 357)					int ii_min48 = min24;
HXDLIN( 357)					int ii_max48 = ::Math_obj::ceil(ex);
HXDLIN( 357)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            				}
            				else {
HXLINE( 357)					int ii_min49 = ::Math_obj::floor(dx);
HXDLIN( 357)					int ii_max49 = ::Math_obj::ceil(ax);
HXDLIN( 357)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            				}
            			}
            			else {
HXLINE( 357)				if ((dx > ax)) {
HXLINE( 357)					int min25;
HXDLIN( 357)					if ((ex > ax)) {
HXLINE( 357)						min25 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 357)						min25 = ::Math_obj::ceil(ex);
            					}
HXDLIN( 357)					int ii_min50 = min25;
HXDLIN( 357)					int ii_max50 = ::Math_obj::ceil(dx);
HXDLIN( 357)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            				}
            				else {
HXLINE( 357)					int ii_min51 = ::Math_obj::floor(ex);
HXDLIN( 357)					int ii_max51 = ::Math_obj::ceil(ax);
HXDLIN( 357)					xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 357)			if ((ey > dy)) {
HXLINE( 357)				if ((ey > ay)) {
HXLINE( 357)					int min26;
HXDLIN( 357)					if ((dy > ay)) {
HXLINE( 357)						min26 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 357)						min26 = ::Math_obj::floor(dy);
            					}
HXDLIN( 357)					int ii_min52 = min26;
HXDLIN( 357)					int ii_max52 = ::Math_obj::ceil(ey);
HXDLIN( 357)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            				}
            				else {
HXLINE( 357)					int ii_min53 = ::Math_obj::floor(dy);
HXDLIN( 357)					int ii_max53 = ::Math_obj::ceil(ay);
HXDLIN( 357)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            				}
            			}
            			else {
HXLINE( 357)				if ((dy > ay)) {
HXLINE( 357)					int min27;
HXDLIN( 357)					if ((ey > ay)) {
HXLINE( 357)						min27 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 357)						min27 = ::Math_obj::ceil(ey);
            					}
HXDLIN( 357)					int ii_min54 = min27;
HXDLIN( 357)					int ii_max54 = ::Math_obj::ceil(dy);
HXDLIN( 357)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            				}
            				else {
HXLINE( 357)					int ii_min55 = ::Math_obj::floor(ey);
HXDLIN( 357)					int ii_max55 = ::Math_obj::ceil(ay);
HXDLIN( 357)					yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            				}
            			}
HXDLIN( 357)			 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 357)			if (hasUndo6) {
HXLINE( 357)				int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 357)				int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 357)				 ::Dynamic imageType6 = null();
HXDLIN( 357)				 ::pi_xy::ImageStruct this193 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)				if (::hx::IsNull( imageType6 )) {
HXLINE(  54)					imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 357)				::Dynamic undoImage19;
HXDLIN( 357)				switch((int)(( (int)(imageType6) ))){
            					case (int)0: {
HXLINE( 357)						 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::BytesImg b44 = byt6;
HXDLIN( 357)						{
HXLINE( 357)							b44->width = width6;
HXDLIN( 357)							b44->height = height6;
HXDLIN( 357)							b44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 357)							b44->data = ::haxe::io::Bytes_obj::alloc((b44->length * 4));
HXDLIN( 357)							{
HXLINE( 357)								int len12 = b44->length;
HXDLIN( 357)								int w6 = 0;
HXDLIN( 357)								{
HXLINE( 357)									int _g120 = 0;
HXDLIN( 357)									int _g121 = b44->height;
HXDLIN( 357)									while((_g120 < _g121)){
HXLINE( 357)										_g120 = (_g120 + 1);
HXDLIN( 357)										int y21 = (_g120 - 1);
HXDLIN( 357)										{
HXLINE( 357)											int _g122 = 0;
HXDLIN( 357)											int _g123 = b44->width;
HXDLIN( 357)											while((_g122 < _g123)){
HXLINE( 357)												_g122 = (_g122 + 1);
HXDLIN( 357)												int x21 = (_g122 - 1);
HXDLIN( 357)												{
HXLINE( 357)													w6 = (w6 + 1);
HXDLIN( 357)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w6 = (w6 + 1);
HXDLIN( 357)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w6 = (w6 + 1);
HXDLIN( 357)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 357)												{
HXLINE( 357)													w6 = (w6 + 1);
HXDLIN( 357)													b44->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage19 = b44;
            					}
            					break;
            					case (int)1: {
HXLINE( 357)						 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::ArrIntImg a44 = arrI6;
HXDLIN( 357)						{
HXLINE( 357)							a44->width = width6;
HXDLIN( 357)							a44->height = height6;
HXDLIN( 357)							a44->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)							a44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 357)							{
HXLINE( 357)								int _g124 = 0;
HXDLIN( 357)								int _g125 = a44->length;
HXDLIN( 357)								while((_g124 < _g125)){
HXLINE( 357)									_g124 = (_g124 + 1);
HXDLIN( 357)									int i48 = (_g124 - 1);
HXDLIN( 357)									a44->data[i48] = 0;
            								}
            							}
            						}
HXDLIN( 357)						undoImage19 = a44;
            					}
            					break;
            					case (int)2: {
HXLINE( 357)						 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::U32ArrImg b45 = u32a6;
HXDLIN( 357)						{
HXLINE( 357)							b45->width = width6;
HXDLIN( 357)							b45->height = height6;
HXDLIN( 357)							b45->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 357)							int size6 = (b45->length * 4);
HXDLIN( 357)							b45->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 357)							{
HXLINE( 357)								int _g126 = 0;
HXDLIN( 357)								int _g127 = b45->length;
HXDLIN( 357)								while((_g126 < _g127)){
HXLINE( 357)									_g126 = (_g126 + 1);
HXDLIN( 357)									int i49 = (_g126 - 1);
HXDLIN( 357)									{
HXLINE( 357)										 ::haxe::io::ArrayBufferViewImpl this194 = b45->data;
HXDLIN( 357)										bool undoImage20;
HXDLIN( 357)										if ((i49 >= 0)) {
HXLINE( 357)											undoImage20 = (i49 < (this194->byteLength >> 2));
            										}
            										else {
HXLINE( 357)											undoImage20 = false;
            										}
HXDLIN( 357)										if (undoImage20) {
HXLINE( 357)											 ::haxe::io::Bytes _this6 = this194->bytes;
HXDLIN( 357)											int pos6 = ((i49 << 2) + this194->byteOffset);
HXDLIN( 357)											_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 357)											_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)											_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage19 = b45;
            					}
            					break;
            					case (int)3: {
HXLINE( 357)						 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::VecIntImg v15 = vec6;
HXDLIN( 357)						{
HXLINE( 357)							v15->width = width6;
HXDLIN( 357)							v15->height = height6;
HXDLIN( 357)							v15->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 357)							v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN( 357)							{
HXLINE( 357)								int _g128 = 0;
HXDLIN( 357)								int _g129 = v15->length;
HXDLIN( 357)								while((_g128 < _g129)){
HXLINE( 357)									_g128 = (_g128 + 1);
HXDLIN( 357)									int i50 = (_g128 - 1);
HXDLIN( 357)									v15->data->__unsafe_set(i50,0);
            								}
            							}
            						}
HXDLIN( 357)						undoImage19 = v15;
            					}
            					break;
            					case (int)4: {
HXLINE( 357)						 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)						 ::iterMagic::StackIntImg b46 = sInt6;
HXDLIN( 357)						{
HXLINE( 357)							b46->width = width6;
HXDLIN( 357)							b46->height = height6;
HXDLIN( 357)							b46->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 357)							b46->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)							{
HXLINE( 357)								int len13 = b46->length;
HXDLIN( 357)								 ::haxe::ds::GenericStack_Int d6 = b46->data;
HXDLIN( 357)								if (::hx::IsNull( d6->head )) {
HXLINE( 357)									int _g130 = 0;
HXDLIN( 357)									int _g131 = len13;
HXDLIN( 357)									while((_g130 < _g131)){
HXLINE( 357)										_g130 = (_g130 + 1);
HXDLIN( 357)										int i51 = (_g130 - 1);
HXDLIN( 357)										d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            									}
            								}
            								else {
HXLINE( 357)									int _g132 = 0;
HXDLIN( 357)									int _g133 = len13;
HXDLIN( 357)									while((_g132 < _g133)){
HXLINE( 357)										_g132 = (_g132 + 1);
HXDLIN( 357)										int i52 = (_g132 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::ds::GenericCell_Int l6 = b46->data->head;
HXDLIN( 357)											 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 357)											{
HXLINE( 357)												int _g134 = 0;
HXDLIN( 357)												int _g135 = i52;
HXDLIN( 357)												while((_g134 < _g135)){
HXLINE( 357)													_g134 = (_g134 + 1);
HXDLIN( 357)													int i53 = (_g134 - 1);
HXLINE( 345)													prev6 = l6;
HXLINE( 346)													l6 = l6->next;
            												}
            											}
HXLINE( 357)											if (::hx::IsNull( prev6 )) {
HXLINE( 357)												b46->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 357)												l6 = null();
            											}
            											else {
HXLINE( 357)												prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 357)												l6 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 357)						undoImage19 = b46;
            					}
            					break;
            				}
HXDLIN( 357)				this193->image = undoImage19;
HXDLIN( 357)				this193->width = width6;
HXDLIN( 357)				this193->height = height6;
HXDLIN( 357)				this193->imageType = ( (int)(imageType6) );
HXDLIN( 357)				undoImage18 = this193;
HXDLIN( 357)				{
HXLINE( 357)					int rectLeft6 = xIter36->start;
HXDLIN( 357)					int rectTop6 = yIter36->start;
HXDLIN( 357)					int rectRight6 = xIter36->max;
HXDLIN( 357)					bool forceClear6 = false;
HXDLIN( 357)					{
HXLINE( 357)						int _g136 = rectTop6;
HXDLIN( 357)						int _g137 = yIter36->max;
HXDLIN( 357)						while((_g136 < _g137)){
HXLINE( 357)							_g136 = (_g136 + 1);
HXDLIN( 357)							int dy7 = (_g136 - 1);
HXDLIN( 357)							{
HXLINE( 357)								int _g138 = rectLeft6;
HXDLIN( 357)								int _g139 = rectRight6;
HXDLIN( 357)								while((_g138 < _g139)){
HXLINE( 357)									_g138 = (_g138 + 1);
HXDLIN( 357)									int dx7 = (_g138 - 1);
HXDLIN( 357)									::Dynamic this195 = pixelImage->image;
HXDLIN( 357)									int index27;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										index27 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx7) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										index27 = ::Std_obj::_hx_int(( (Float)(((dy7 * pixelImage->width) + dx7)) ));
            									}
HXDLIN( 357)									int c21 = ::iterMagic::Iimg_obj::get(this195,index27);
HXDLIN( 357)									int col6;
HXDLIN( 357)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)										col6 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXLINE( 357)										col6 = c21;
            									}
HXDLIN( 357)									bool _hx_tmp48;
HXDLIN( 357)									if (pixelImage->useMask) {
HXLINE( 357)										_hx_tmp48 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 357)										_hx_tmp48 = false;
            									}
HXDLIN( 357)									if (_hx_tmp48) {
HXLINE( 357)										 ::pi_xy::ImageStruct this196 = pixelImage->mask;
HXDLIN( 357)										::Dynamic this197 = this196->image;
HXDLIN( 357)										int index28;
HXDLIN( 357)										if (this196->useVirtualPos) {
HXLINE( 357)											index28 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this196->virtualY) * ( (Float)(this196->width) )) + dx7) - this196->virtualX));
            										}
            										else {
HXLINE( 357)											index28 = ::Std_obj::_hx_int(( (Float)(((dy7 * this196->width) + dx7)) ));
            										}
HXDLIN( 357)										int c22 = ::iterMagic::Iimg_obj::get(this197,index28);
HXDLIN( 357)										int v16;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											v16 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											v16 = c22;
            										}
HXDLIN( 357)										int maskPixel6 = v16;
HXDLIN( 357)										int this198 = col6;
HXDLIN( 357)										if ((maskPixel6 == 0)) {
HXLINE( 357)											col6 = this198;
            										}
            										else {
HXLINE( 357)											Float m06;
HXDLIN( 357)											int this199 = ((maskPixel6 >> 24) & 255);
HXDLIN( 357)											if ((this199 == 0)) {
HXLINE( 357)												m06 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m06 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m16;
HXDLIN( 357)											int this200 = ((maskPixel6 >> 16) & 255);
HXDLIN( 357)											if ((this200 == 0)) {
HXLINE( 357)												m16 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m16 = (( (Float)(this200) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m26;
HXDLIN( 357)											int this201 = ((maskPixel6 >> 8) & 255);
HXDLIN( 357)											if ((this201 == 0)) {
HXLINE( 357)												m26 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m26 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float m36;
HXDLIN( 357)											int this202 = (maskPixel6 & 255);
HXDLIN( 357)											if ((this202 == 0)) {
HXLINE( 357)												m36 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												m36 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this198 >> 24) & 255)) )));
HXDLIN( 357)											int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this198 >> 16) & 255)) )));
HXDLIN( 357)											int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this198 >> 8) & 255)) )));
HXDLIN( 357)											int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this198 & 255)) )));
HXDLIN( 357)											col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 357)									if ((col6 != 0)) {
HXLINE( 357)										int x22 = (dx7 - rectLeft6);
HXDLIN( 357)										int y22 = (dy7 - rectTop6);
HXDLIN( 357)										int c23 = col6;
HXDLIN( 357)										bool _hx_tmp49;
HXDLIN( 357)										if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 357)											_hx_tmp49 = undoImage18->transparent;
            										}
            										else {
HXLINE( 357)											_hx_tmp49 = false;
            										}
HXDLIN( 357)										if (_hx_tmp49) {
HXLINE( 357)											int location12;
HXDLIN( 357)											if (undoImage18->useVirtualPos) {
HXLINE( 357)												location12 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x22) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 357)												location12 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage18->width) + x22)) ));
            											}
HXDLIN( 357)											int this203 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 357)											int this204;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												this204 = ((((((this203 >> 24) & 255) << 24) | ((this203 & 255) << 16)) | (((this203 >> 8) & 255) << 8)) | ((this203 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												this204 = this203;
            											}
HXDLIN( 357)											Float a116;
HXDLIN( 357)											int this205 = ((this204 >> 24) & 255);
HXDLIN( 357)											if ((this205 == 0)) {
HXLINE( 357)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a116 = (( (Float)(this205) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r113;
HXDLIN( 357)											int this206 = ((this204 >> 16) & 255);
HXDLIN( 357)											if ((this206 == 0)) {
HXLINE( 357)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r113 = (( (Float)(this206) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g113;
HXDLIN( 357)											int this207 = ((this204 >> 8) & 255);
HXDLIN( 357)											if ((this207 == 0)) {
HXLINE( 357)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g113 = (( (Float)(this207) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b117;
HXDLIN( 357)											int this208 = (this204 & 255);
HXDLIN( 357)											if ((this208 == 0)) {
HXLINE( 357)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b117 = (( (Float)(this208) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a214;
HXDLIN( 357)											int this209 = ((col6 >> 24) & 255);
HXDLIN( 357)											if ((this209 == 0)) {
HXLINE( 357)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												a214 = (( (Float)(this209) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float r213;
HXDLIN( 357)											int this210 = ((col6 >> 16) & 255);
HXDLIN( 357)											if ((this210 == 0)) {
HXLINE( 357)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												r213 = (( (Float)(this210) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float g213;
HXDLIN( 357)											int this211 = ((col6 >> 8) & 255);
HXDLIN( 357)											if ((this211 == 0)) {
HXLINE( 357)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												g213 = (( (Float)(this211) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float b216;
HXDLIN( 357)											int this212 = (col6 & 255);
HXDLIN( 357)											if ((this212 == 0)) {
HXLINE( 357)												b216 = ((Float)0.);
            											}
            											else {
HXLINE( 357)												b216 = (( (Float)(this212) ) / ( (Float)(255) ));
            											}
HXDLIN( 357)											Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 357)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 357)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 357)											int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b216 * a214))));
HXDLIN( 357)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 357)											int blended12 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b47);
HXDLIN( 357)											{
HXLINE( 357)												int _hx_tmp50;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp50 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp50 = blended12;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp50);
            											}
            										}
            										else {
HXLINE( 357)											::Dynamic this213 = undoImage18->image;
HXDLIN( 357)											int index29;
HXDLIN( 357)											if (undoImage18->useVirtualPos) {
HXLINE( 357)												index29 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x22) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 357)												index29 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage18->width) + x22)) ));
            											}
HXDLIN( 357)											int _hx_tmp51;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp51 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp51 = c23;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this213,index29,_hx_tmp51);
            										}
            									}
            									else {
HXLINE( 357)										if (forceClear6) {
HXLINE( 357)											::Dynamic this214 = undoImage18->image;
HXDLIN( 357)											int x23 = (dx7 - rectLeft6);
HXDLIN( 357)											int y23 = (dy7 - rectTop6);
HXDLIN( 357)											int index30;
HXDLIN( 357)											if (undoImage18->useVirtualPos) {
HXLINE( 357)												index30 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x23) - undoImage18->virtualX));
            											}
            											else {
HXLINE( 357)												index30 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage18->width) + x23)) ));
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(this214,index30,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 357)			bool found6 = false;
HXDLIN( 357)			{
HXLINE( 357)				int _g_min12 = xIter36->start;
HXDLIN( 357)				int _g_max12 = xIter36->max;
HXDLIN( 357)				while((_g_min12 < _g_max12)){
HXLINE( 357)					_g_min12 = (_g_min12 + 1);
HXDLIN( 357)					int px4 = (_g_min12 - 1);
HXDLIN( 357)					Float pcx3 = (( (Float)(px4) ) - ax);
HXLINE( 619)					found6 = false;
HXLINE( 357)					{
HXLINE( 357)						int _g_min13 = yIter36->start;
HXDLIN( 357)						int _g_max13 = yIter36->max;
HXDLIN( 357)						while((_g_min13 < _g_max13)){
HXLINE( 357)							_g_min13 = (_g_min13 + 1);
HXDLIN( 357)							int py4 = (_g_min13 - 1);
HXDLIN( 357)							Float pcy3 = (( (Float)(py4) ) - ay);
HXDLIN( 357)							Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 357)							Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 357)							Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 357)							Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 357)							Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 357)							bool _hx_tmp52;
HXDLIN( 357)							bool _hx_tmp53;
HXDLIN( 357)							if ((ratioA3 >= 0)) {
HXLINE( 357)								_hx_tmp53 = (ratioB3 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp53 = false;
            							}
HXDLIN( 357)							if (_hx_tmp53) {
HXLINE( 357)								_hx_tmp52 = (ratioC3 >= 0);
            							}
            							else {
HXLINE( 357)								_hx_tmp52 = false;
            							}
HXDLIN( 357)							if (_hx_tmp52) {
HXLINE( 357)								int i54 = ::Std_obj::_hx_int((( (Float)(aA3) ) * (softC * ratioB3)));
HXDLIN( 357)								if ((i54 > 255)) {
HXLINE(  24)									i54 = 255;
            								}
HXLINE( 357)								if ((i54 < 0)) {
HXLINE(  25)									i54 = 0;
            								}
HXLINE( 357)								int a46 = i54;
HXDLIN( 357)								int i55 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN( 357)								if ((i55 > 255)) {
HXLINE(  24)									i55 = 255;
            								}
HXLINE( 357)								if ((i55 < 0)) {
HXLINE(  25)									i55 = 0;
            								}
HXLINE( 357)								int r34 = i55;
HXDLIN( 357)								int i56 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN( 357)								if ((i56 > 255)) {
HXLINE(  24)									i56 = 255;
            								}
HXLINE( 357)								if ((i56 < 0)) {
HXLINE(  25)									i56 = 0;
            								}
HXLINE( 357)								int g34 = i56;
HXDLIN( 357)								int i57 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN( 357)								if ((i57 > 255)) {
HXLINE(  24)									i57 = 255;
            								}
HXLINE( 357)								if ((i57 < 0)) {
HXLINE(  25)									i57 = 0;
            								}
HXLINE( 357)								int b48 = i57;
HXDLIN( 357)								{
HXLINE( 357)									int location13;
HXDLIN( 357)									if (pixelImage->useVirtualPos) {
HXLINE( 357)										location13 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 357)										location13 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            									}
HXDLIN( 357)									bool _hx_tmp54;
HXDLIN( 357)									if (pixelImage->transparent) {
HXLINE( 357)										_hx_tmp54 = (a46 < 254);
            									}
            									else {
HXLINE( 357)										_hx_tmp54 = false;
            									}
HXDLIN( 357)									if (_hx_tmp54) {
HXLINE( 357)										int this215 = ::iterMagic::Iimg_obj::get(pixelImage->image,location13);
HXDLIN( 357)										int old3;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											old3 = ((((((this215 >> 24) & 255) << 24) | ((this215 & 255) << 16)) | (((this215 >> 8) & 255) << 8)) | ((this215 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											old3 = this215;
            										}
HXDLIN( 357)										int rhs3 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b48);
HXDLIN( 357)										Float a117;
HXDLIN( 357)										int this216 = ((old3 >> 24) & 255);
HXDLIN( 357)										if ((this216 == 0)) {
HXLINE( 357)											a117 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a117 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r114;
HXDLIN( 357)										int this217 = ((old3 >> 16) & 255);
HXDLIN( 357)										if ((this217 == 0)) {
HXLINE( 357)											r114 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r114 = (( (Float)(this217) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g114;
HXDLIN( 357)										int this218 = ((old3 >> 8) & 255);
HXDLIN( 357)										if ((this218 == 0)) {
HXLINE( 357)											g114 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g114 = (( (Float)(this218) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b118;
HXDLIN( 357)										int this219 = (old3 & 255);
HXDLIN( 357)										if ((this219 == 0)) {
HXLINE( 357)											b118 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b118 = (( (Float)(this219) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a215;
HXDLIN( 357)										int this220 = ((rhs3 >> 24) & 255);
HXDLIN( 357)										if ((this220 == 0)) {
HXLINE( 357)											a215 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											a215 = (( (Float)(this220) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float r214;
HXDLIN( 357)										int this221 = ((rhs3 >> 16) & 255);
HXDLIN( 357)										if ((this221 == 0)) {
HXLINE( 357)											r214 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											r214 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float g214;
HXDLIN( 357)										int this222 = ((rhs3 >> 8) & 255);
HXDLIN( 357)										if ((this222 == 0)) {
HXLINE( 357)											g214 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											g214 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float b217;
HXDLIN( 357)										int this223 = (rhs3 & 255);
HXDLIN( 357)										if ((this223 == 0)) {
HXLINE( 357)											b217 = ((Float)0.);
            										}
            										else {
HXLINE( 357)											b217 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 357)										Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 357)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 357)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 357)										int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b217 * a215))));
HXDLIN( 357)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 357)										int blended13 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b49);
HXDLIN( 357)										{
HXLINE( 357)											int _hx_tmp55;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												_hx_tmp55 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												_hx_tmp55 = blended13;
            											}
HXDLIN( 357)											::iterMagic::Iimg_obj::set(pixelImage->image,location13,_hx_tmp55);
            										}
            									}
            									else {
HXLINE( 357)										int value3;
HXDLIN( 357)										if (pixelImage->isLittle) {
HXLINE( 357)											value3 = ((((a46 << 24) | (b48 << 16)) | (g34 << 8)) | r34);
            										}
            										else {
HXLINE( 357)											value3 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b48);
            										}
HXDLIN( 357)										::iterMagic::Iimg_obj::set(pixelImage->image,location13,value3);
            									}
            								}
HXLINE( 633)								found6 = true;
            							}
            							else {
HXLINE( 357)								if (found6) {
HXLINE( 357)									goto _hx_goto_417;
            								}
            							}
            						}
            						_hx_goto_417:;
            					}
            				}
            			}
HXDLIN( 357)			{
HXLINE( 357)				 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ex,ey,dx,dy,ax,ay,true);
HXDLIN( 357)				if (hasUndo6) {
HXLINE( 357)					v17->undoImage = undoImage18;
HXDLIN( 357)					v17->undoX = xIter36->start;
HXDLIN( 357)					v17->undoY = yIter36->start;
            				}
            			}
            		}
            		else {
HXLINE( 357)			Float bx4 = dx;
HXDLIN( 357)			Float by4 = dy;
HXDLIN( 357)			Float cx4 = ax;
HXDLIN( 357)			Float cy4 = ay;
HXDLIN( 357)			bool hasUndo7 = false;
HXDLIN( 357)			bool adjustWinding3 = (((((ex * by4) - (bx4 * ey)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ey) - (ex * cy4))) > 0);
HXDLIN( 357)			if (!(adjustWinding3)) {
HXLINE( 357)				Float bx_3 = bx4;
HXDLIN( 357)				Float by_3 = by4;
HXLINE(  25)				bx4 = cx4;
HXLINE(  26)				by4 = cy4;
HXLINE(  27)				cx4 = bx_3;
HXLINE(  28)				cy4 = by_3;
            			}
HXLINE( 357)			{
HXLINE( 357)				Float s03 = ((ey * cx4) - (ex * cy4));
HXDLIN( 357)				Float sx3 = (cy4 - ey);
HXDLIN( 357)				Float sy3 = (ex - cx4);
HXDLIN( 357)				Float t03 = ((ex * by4) - (ey * bx4));
HXDLIN( 357)				Float tx3 = (ey - by4);
HXDLIN( 357)				Float ty3 = (bx4 - ex);
HXDLIN( 357)				Float A3 = ((((-(by4) * cx4) + (ey * (-(bx4) + cx4))) + (ex * (by4 - cy4))) + (bx4 * cy4));
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 357)				if ((ex > bx4)) {
HXLINE( 357)					if ((ex > cx4)) {
HXLINE( 357)						int min28;
HXDLIN( 357)						if ((bx4 > cx4)) {
HXLINE( 357)							min28 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 357)							min28 = ::Math_obj::floor(bx4);
            						}
HXDLIN( 357)						int ii_min56 = min28;
HXDLIN( 357)						int ii_max56 = ::Math_obj::ceil(ex);
HXDLIN( 357)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            					}
            					else {
HXLINE( 357)						int ii_min57 = ::Math_obj::floor(bx4);
HXDLIN( 357)						int ii_max57 = ::Math_obj::ceil(cx4);
HXDLIN( 357)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            					}
            				}
            				else {
HXLINE( 357)					if ((bx4 > cx4)) {
HXLINE( 357)						int min29;
HXDLIN( 357)						if ((ex > cx4)) {
HXLINE( 357)							min29 = ::Math_obj::floor(cx4);
            						}
            						else {
HXLINE( 357)							min29 = ::Math_obj::ceil(ex);
            						}
HXDLIN( 357)						int ii_min58 = min29;
HXDLIN( 357)						int ii_max58 = ::Math_obj::ceil(bx4);
HXDLIN( 357)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            					}
            					else {
HXLINE( 357)						int ii_min59 = ::Math_obj::floor(ex);
HXDLIN( 357)						int ii_max59 = ::Math_obj::ceil(cx4);
HXDLIN( 357)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 357)				if ((ey > by4)) {
HXLINE( 357)					if ((ey > cy4)) {
HXLINE( 357)						int min30;
HXDLIN( 357)						if ((by4 > cy4)) {
HXLINE( 357)							min30 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 357)							min30 = ::Math_obj::floor(by4);
            						}
HXDLIN( 357)						int ii_min60 = min30;
HXDLIN( 357)						int ii_max60 = ::Math_obj::ceil(ey);
HXDLIN( 357)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            					}
            					else {
HXLINE( 357)						int ii_min61 = ::Math_obj::floor(by4);
HXDLIN( 357)						int ii_max61 = ::Math_obj::ceil(cy4);
HXDLIN( 357)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            					}
            				}
            				else {
HXLINE( 357)					if ((by4 > cy4)) {
HXLINE( 357)						int min31;
HXDLIN( 357)						if ((ey > cy4)) {
HXLINE( 357)							min31 = ::Math_obj::floor(cy4);
            						}
            						else {
HXLINE( 357)							min31 = ::Math_obj::ceil(ey);
            						}
HXDLIN( 357)						int ii_min62 = min31;
HXDLIN( 357)						int ii_max62 = ::Math_obj::ceil(by4);
HXDLIN( 357)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            					}
            					else {
HXLINE( 357)						int ii_min63 = ::Math_obj::floor(ey);
HXDLIN( 357)						int ii_max63 = ::Math_obj::ceil(cy4);
HXDLIN( 357)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            					}
            				}
HXDLIN( 357)				 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 357)				if (hasUndo7) {
HXLINE( 357)					int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 357)					int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 357)					 ::Dynamic imageType7 = null();
HXDLIN( 357)					 ::pi_xy::ImageStruct this224 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 357)					if (::hx::IsNull( imageType7 )) {
HXLINE(  54)						imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 357)					::Dynamic undoImage22;
HXDLIN( 357)					switch((int)(( (int)(imageType7) ))){
            						case (int)0: {
HXLINE( 357)							 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::BytesImg b50 = byt7;
HXDLIN( 357)							{
HXLINE( 357)								b50->width = width7;
HXDLIN( 357)								b50->height = height7;
HXDLIN( 357)								b50->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 357)								b50->data = ::haxe::io::Bytes_obj::alloc((b50->length * 4));
HXDLIN( 357)								{
HXLINE( 357)									int len14 = b50->length;
HXDLIN( 357)									int w7 = 0;
HXDLIN( 357)									{
HXLINE( 357)										int _g140 = 0;
HXDLIN( 357)										int _g141 = b50->height;
HXDLIN( 357)										while((_g140 < _g141)){
HXLINE( 357)											_g140 = (_g140 + 1);
HXDLIN( 357)											int y24 = (_g140 - 1);
HXDLIN( 357)											{
HXLINE( 357)												int _g142 = 0;
HXDLIN( 357)												int _g143 = b50->width;
HXDLIN( 357)												while((_g142 < _g143)){
HXLINE( 357)													_g142 = (_g142 + 1);
HXDLIN( 357)													int x24 = (_g142 - 1);
HXDLIN( 357)													{
HXLINE( 357)														w7 = (w7 + 1);
HXDLIN( 357)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w7 = (w7 + 1);
HXDLIN( 357)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w7 = (w7 + 1);
HXDLIN( 357)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 357)													{
HXLINE( 357)														w7 = (w7 + 1);
HXDLIN( 357)														b50->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage22 = b50;
            						}
            						break;
            						case (int)1: {
HXLINE( 357)							 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::ArrIntImg a48 = arrI7;
HXDLIN( 357)							{
HXLINE( 357)								a48->width = width7;
HXDLIN( 357)								a48->height = height7;
HXDLIN( 357)								a48->data = ::Array_obj< int >::__new(0);
HXDLIN( 357)								a48->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 357)								{
HXLINE( 357)									int _g144 = 0;
HXDLIN( 357)									int _g145 = a48->length;
HXDLIN( 357)									while((_g144 < _g145)){
HXLINE( 357)										_g144 = (_g144 + 1);
HXDLIN( 357)										int i58 = (_g144 - 1);
HXDLIN( 357)										a48->data[i58] = 0;
            									}
            								}
            							}
HXDLIN( 357)							undoImage22 = a48;
            						}
            						break;
            						case (int)2: {
HXLINE( 357)							 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::U32ArrImg b51 = u32a7;
HXDLIN( 357)							{
HXLINE( 357)								b51->width = width7;
HXDLIN( 357)								b51->height = height7;
HXDLIN( 357)								b51->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 357)								int size7 = (b51->length * 4);
HXDLIN( 357)								b51->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 357)								{
HXLINE( 357)									int _g146 = 0;
HXDLIN( 357)									int _g147 = b51->length;
HXDLIN( 357)									while((_g146 < _g147)){
HXLINE( 357)										_g146 = (_g146 + 1);
HXDLIN( 357)										int i59 = (_g146 - 1);
HXDLIN( 357)										{
HXLINE( 357)											 ::haxe::io::ArrayBufferViewImpl this225 = b51->data;
HXDLIN( 357)											bool undoImage23;
HXDLIN( 357)											if ((i59 >= 0)) {
HXLINE( 357)												undoImage23 = (i59 < (this225->byteLength >> 2));
            											}
            											else {
HXLINE( 357)												undoImage23 = false;
            											}
HXDLIN( 357)											if (undoImage23) {
HXLINE( 357)												 ::haxe::io::Bytes _this7 = this225->bytes;
HXDLIN( 357)												int pos7 = ((i59 << 2) + this225->byteOffset);
HXDLIN( 357)												_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 357)												_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 357)												_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage22 = b51;
            						}
            						break;
            						case (int)3: {
HXLINE( 357)							 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::VecIntImg v18 = vec7;
HXDLIN( 357)							{
HXLINE( 357)								v18->width = width7;
HXDLIN( 357)								v18->height = height7;
HXDLIN( 357)								v18->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 357)								v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 357)								{
HXLINE( 357)									int _g148 = 0;
HXDLIN( 357)									int _g149 = v18->length;
HXDLIN( 357)									while((_g148 < _g149)){
HXLINE( 357)										_g148 = (_g148 + 1);
HXDLIN( 357)										int i60 = (_g148 - 1);
HXDLIN( 357)										v18->data->__unsafe_set(i60,0);
            									}
            								}
            							}
HXDLIN( 357)							undoImage22 = v18;
            						}
            						break;
            						case (int)4: {
HXLINE( 357)							 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 357)							 ::iterMagic::StackIntImg b52 = sInt7;
HXDLIN( 357)							{
HXLINE( 357)								b52->width = width7;
HXDLIN( 357)								b52->height = height7;
HXDLIN( 357)								b52->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 357)								b52->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 357)								{
HXLINE( 357)									int len15 = b52->length;
HXDLIN( 357)									 ::haxe::ds::GenericStack_Int d7 = b52->data;
HXDLIN( 357)									if (::hx::IsNull( d7->head )) {
HXLINE( 357)										int _g150 = 0;
HXDLIN( 357)										int _g151 = len15;
HXDLIN( 357)										while((_g150 < _g151)){
HXLINE( 357)											_g150 = (_g150 + 1);
HXDLIN( 357)											int i61 = (_g150 - 1);
HXDLIN( 357)											d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            										}
            									}
            									else {
HXLINE( 357)										int _g152 = 0;
HXDLIN( 357)										int _g153 = len15;
HXDLIN( 357)										while((_g152 < _g153)){
HXLINE( 357)											_g152 = (_g152 + 1);
HXDLIN( 357)											int i62 = (_g152 - 1);
HXDLIN( 357)											{
HXLINE( 357)												 ::haxe::ds::GenericCell_Int l7 = b52->data->head;
HXDLIN( 357)												 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 357)												{
HXLINE( 357)													int _g154 = 0;
HXDLIN( 357)													int _g155 = i62;
HXDLIN( 357)													while((_g154 < _g155)){
HXLINE( 357)														_g154 = (_g154 + 1);
HXDLIN( 357)														int i63 = (_g154 - 1);
HXLINE( 345)														prev7 = l7;
HXLINE( 346)														l7 = l7->next;
            													}
            												}
HXLINE( 357)												if (::hx::IsNull( prev7 )) {
HXLINE( 357)													b52->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 357)													l7 = null();
            												}
            												else {
HXLINE( 357)													prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 357)													l7 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 357)							undoImage22 = b52;
            						}
            						break;
            					}
HXDLIN( 357)					this224->image = undoImage22;
HXDLIN( 357)					this224->width = width7;
HXDLIN( 357)					this224->height = height7;
HXDLIN( 357)					this224->imageType = ( (int)(imageType7) );
HXDLIN( 357)					undoImage21 = this224;
HXDLIN( 357)					{
HXLINE( 357)						int rectLeft7 = xIter37->start;
HXDLIN( 357)						int rectTop7 = yIter37->start;
HXDLIN( 357)						int rectRight7 = xIter37->max;
HXDLIN( 357)						bool forceClear7 = false;
HXDLIN( 357)						{
HXLINE( 357)							int _g156 = rectTop7;
HXDLIN( 357)							int _g157 = yIter37->max;
HXDLIN( 357)							while((_g156 < _g157)){
HXLINE( 357)								_g156 = (_g156 + 1);
HXDLIN( 357)								int dy8 = (_g156 - 1);
HXDLIN( 357)								{
HXLINE( 357)									int _g158 = rectLeft7;
HXDLIN( 357)									int _g159 = rectRight7;
HXDLIN( 357)									while((_g158 < _g159)){
HXLINE( 357)										_g158 = (_g158 + 1);
HXDLIN( 357)										int dx8 = (_g158 - 1);
HXDLIN( 357)										::Dynamic this226 = pixelImage->image;
HXDLIN( 357)										int index31;
HXDLIN( 357)										if (pixelImage->useVirtualPos) {
HXLINE( 357)											index31 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx8) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 357)											index31 = ::Std_obj::_hx_int(( (Float)(((dy8 * pixelImage->width) + dx8)) ));
            										}
HXDLIN( 357)										int c24 = ::iterMagic::Iimg_obj::get(this226,index31);
HXDLIN( 357)										int col7;
HXDLIN( 357)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)											col7 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            										}
            										else {
HXLINE( 357)											col7 = c24;
            										}
HXDLIN( 357)										bool _hx_tmp56;
HXDLIN( 357)										if (pixelImage->useMask) {
HXLINE( 357)											_hx_tmp56 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 357)											_hx_tmp56 = false;
            										}
HXDLIN( 357)										if (_hx_tmp56) {
HXLINE( 357)											 ::pi_xy::ImageStruct this227 = pixelImage->mask;
HXDLIN( 357)											::Dynamic this228 = this227->image;
HXDLIN( 357)											int index32;
HXDLIN( 357)											if (this227->useVirtualPos) {
HXLINE( 357)												index32 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this227->virtualY) * ( (Float)(this227->width) )) + dx8) - this227->virtualX));
            											}
            											else {
HXLINE( 357)												index32 = ::Std_obj::_hx_int(( (Float)(((dy8 * this227->width) + dx8)) ));
            											}
HXDLIN( 357)											int c25 = ::iterMagic::Iimg_obj::get(this228,index32);
HXDLIN( 357)											int v19;
HXDLIN( 357)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)												v19 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            											}
            											else {
HXLINE( 357)												v19 = c25;
            											}
HXDLIN( 357)											int maskPixel7 = v19;
HXDLIN( 357)											int this229 = col7;
HXDLIN( 357)											if ((maskPixel7 == 0)) {
HXLINE( 357)												col7 = this229;
            											}
            											else {
HXLINE( 357)												Float m07;
HXDLIN( 357)												int this230 = ((maskPixel7 >> 24) & 255);
HXDLIN( 357)												if ((this230 == 0)) {
HXLINE( 357)													m07 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m07 = (( (Float)(this230) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m17;
HXDLIN( 357)												int this231 = ((maskPixel7 >> 16) & 255);
HXDLIN( 357)												if ((this231 == 0)) {
HXLINE( 357)													m17 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m17 = (( (Float)(this231) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m27;
HXDLIN( 357)												int this232 = ((maskPixel7 >> 8) & 255);
HXDLIN( 357)												if ((this232 == 0)) {
HXLINE( 357)													m27 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m27 = (( (Float)(this232) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float m37;
HXDLIN( 357)												int this233 = (maskPixel7 & 255);
HXDLIN( 357)												if ((this233 == 0)) {
HXLINE( 357)													m37 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													m37 = (( (Float)(this233) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this229 >> 24) & 255)) )));
HXDLIN( 357)												int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this229 >> 16) & 255)) )));
HXDLIN( 357)												int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this229 >> 8) & 255)) )));
HXDLIN( 357)												int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this229 & 255)) )));
HXDLIN( 357)												col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 357)										if ((col7 != 0)) {
HXLINE( 357)											int x25 = (dx8 - rectLeft7);
HXDLIN( 357)											int y25 = (dy8 - rectTop7);
HXDLIN( 357)											int c26 = col7;
HXDLIN( 357)											bool _hx_tmp57;
HXDLIN( 357)											if ((((c26 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp57 = undoImage21->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp57 = false;
            											}
HXDLIN( 357)											if (_hx_tmp57) {
HXLINE( 357)												int location14;
HXDLIN( 357)												if (undoImage21->useVirtualPos) {
HXLINE( 357)													location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x25) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 357)													location14 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage21->width) + x25)) ));
            												}
HXDLIN( 357)												int this234 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN( 357)												int this235;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this235 = ((((((this234 >> 24) & 255) << 24) | ((this234 & 255) << 16)) | (((this234 >> 8) & 255) << 8)) | ((this234 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this235 = this234;
            												}
HXDLIN( 357)												Float a118;
HXDLIN( 357)												int this236 = ((this235 >> 24) & 255);
HXDLIN( 357)												if ((this236 == 0)) {
HXLINE( 357)													a118 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a118 = (( (Float)(this236) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r115;
HXDLIN( 357)												int this237 = ((this235 >> 16) & 255);
HXDLIN( 357)												if ((this237 == 0)) {
HXLINE( 357)													r115 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r115 = (( (Float)(this237) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g115;
HXDLIN( 357)												int this238 = ((this235 >> 8) & 255);
HXDLIN( 357)												if ((this238 == 0)) {
HXLINE( 357)													g115 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g115 = (( (Float)(this238) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b119;
HXDLIN( 357)												int this239 = (this235 & 255);
HXDLIN( 357)												if ((this239 == 0)) {
HXLINE( 357)													b119 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b119 = (( (Float)(this239) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a216;
HXDLIN( 357)												int this240 = ((col7 >> 24) & 255);
HXDLIN( 357)												if ((this240 == 0)) {
HXLINE( 357)													a216 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a216 = (( (Float)(this240) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r215;
HXDLIN( 357)												int this241 = ((col7 >> 16) & 255);
HXDLIN( 357)												if ((this241 == 0)) {
HXLINE( 357)													r215 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r215 = (( (Float)(this241) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g215;
HXDLIN( 357)												int this242 = ((col7 >> 8) & 255);
HXDLIN( 357)												if ((this242 == 0)) {
HXLINE( 357)													g215 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g215 = (( (Float)(this242) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b218;
HXDLIN( 357)												int this243 = (col7 & 255);
HXDLIN( 357)												if ((this243 == 0)) {
HXLINE( 357)													b218 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b218 = (( (Float)(this243) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 357)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 357)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 357)												int b53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b218 * a216))));
HXDLIN( 357)												int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 357)												int blended14 = ((((a49 << 24) | (r36 << 16)) | (g36 << 8)) | b53);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp58;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp58 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp58 = blended14;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp58);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this244 = undoImage21->image;
HXDLIN( 357)												int index33;
HXDLIN( 357)												if (undoImage21->useVirtualPos) {
HXLINE( 357)													index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x25) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 357)													index33 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage21->width) + x25)) ));
            												}
HXDLIN( 357)												int _hx_tmp59;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp59 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp59 = c26;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this244,index33,_hx_tmp59);
            											}
            										}
            										else {
HXLINE( 357)											if (forceClear7) {
HXLINE( 357)												::Dynamic this245 = undoImage21->image;
HXDLIN( 357)												int x26 = (dx8 - rectLeft7);
HXDLIN( 357)												int y26 = (dy8 - rectTop7);
HXDLIN( 357)												int index34;
HXDLIN( 357)												if (undoImage21->useVirtualPos) {
HXLINE( 357)													index34 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x26) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 357)													index34 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage21->width) + x26)) ));
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this245,index34,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 357)				bool found7 = false;
HXDLIN( 357)				Float s3 = ((Float)0.);
HXDLIN( 357)				Float t3 = ((Float)0.);
HXDLIN( 357)				Float sxx3 = ((Float)0.);
HXDLIN( 357)				Float txx3 = ((Float)0.);
HXDLIN( 357)				{
HXLINE( 357)					int _g_min14 = xIter37->start;
HXDLIN( 357)					int _g_max14 = xIter37->max;
HXDLIN( 357)					while((_g_min14 < _g_max14)){
HXLINE( 357)						_g_min14 = (_g_min14 + 1);
HXDLIN( 357)						int x27 = (_g_min14 - 1);
HXLINE(  60)						sxx3 = (sx3 * ( (Float)(x27) ));
HXLINE(  61)						txx3 = (tx3 * ( (Float)(x27) ));
HXLINE(  62)						found7 = false;
HXLINE( 357)						{
HXLINE( 357)							int _g_min15 = yIter37->start;
HXDLIN( 357)							int _g_max15 = yIter37->max;
HXDLIN( 357)							while((_g_min15 < _g_max15)){
HXLINE( 357)								_g_min15 = (_g_min15 + 1);
HXDLIN( 357)								int y27 = (_g_min15 - 1);
HXLINE(  64)								s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y27) )));
HXLINE(  65)								t3 = ((t03 + txx3) + (ty3 * ( (Float)(y27) )));
HXLINE( 357)								bool _hx_tmp60;
HXDLIN( 357)								if (!((s3 <= 0))) {
HXLINE( 357)									_hx_tmp60 = (t3 <= 0);
            								}
            								else {
HXLINE( 357)									_hx_tmp60 = true;
            								}
HXDLIN( 357)								if (_hx_tmp60) {
HXLINE( 357)									if (found7) {
HXLINE( 357)										goto _hx_goto_429;
            									}
            								}
            								else {
HXLINE( 357)									if (((s3 + t3) < A3)) {
HXLINE( 357)										{
HXLINE( 357)											int c27 = color;
HXDLIN( 357)											bool _hx_tmp61;
HXDLIN( 357)											if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 357)												_hx_tmp61 = pixelImage->transparent;
            											}
            											else {
HXLINE( 357)												_hx_tmp61 = false;
            											}
HXDLIN( 357)											if (_hx_tmp61) {
HXLINE( 357)												int location15;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													location15 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x27) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													location15 = ::Std_obj::_hx_int(( (Float)(((y27 * pixelImage->width) + x27)) ));
            												}
HXDLIN( 357)												int this246 = ::iterMagic::Iimg_obj::get(pixelImage->image,location15);
HXDLIN( 357)												int this247;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													this247 = ((((((this246 >> 24) & 255) << 24) | ((this246 & 255) << 16)) | (((this246 >> 8) & 255) << 8)) | ((this246 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													this247 = this246;
            												}
HXDLIN( 357)												Float a119;
HXDLIN( 357)												int this248 = ((this247 >> 24) & 255);
HXDLIN( 357)												if ((this248 == 0)) {
HXLINE( 357)													a119 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a119 = (( (Float)(this248) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r116;
HXDLIN( 357)												int this249 = ((this247 >> 16) & 255);
HXDLIN( 357)												if ((this249 == 0)) {
HXLINE( 357)													r116 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r116 = (( (Float)(this249) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g116;
HXDLIN( 357)												int this250 = ((this247 >> 8) & 255);
HXDLIN( 357)												if ((this250 == 0)) {
HXLINE( 357)													g116 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g116 = (( (Float)(this250) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b120;
HXDLIN( 357)												int this251 = (this247 & 255);
HXDLIN( 357)												if ((this251 == 0)) {
HXLINE( 357)													b120 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b120 = (( (Float)(this251) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a217;
HXDLIN( 357)												int this252 = ((color >> 24) & 255);
HXDLIN( 357)												if ((this252 == 0)) {
HXLINE( 357)													a217 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													a217 = (( (Float)(this252) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float r216;
HXDLIN( 357)												int this253 = ((color >> 16) & 255);
HXDLIN( 357)												if ((this253 == 0)) {
HXLINE( 357)													r216 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													r216 = (( (Float)(this253) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float g216;
HXDLIN( 357)												int this254 = ((color >> 8) & 255);
HXDLIN( 357)												if ((this254 == 0)) {
HXLINE( 357)													g216 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													g216 = (( (Float)(this254) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float b219;
HXDLIN( 357)												int this255 = (color & 255);
HXDLIN( 357)												if ((this255 == 0)) {
HXLINE( 357)													b219 = ((Float)0.);
            												}
            												else {
HXLINE( 357)													b219 = (( (Float)(this255) ) / ( (Float)(255) ));
            												}
HXDLIN( 357)												Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN( 357)												int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 357)												int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 357)												int b54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a316) + (b219 * a217))));
HXDLIN( 357)												int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 357)												int blended15 = ((((a50 << 24) | (r37 << 16)) | (g37 << 8)) | b54);
HXDLIN( 357)												{
HXLINE( 357)													int _hx_tmp62;
HXDLIN( 357)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)														_hx_tmp62 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            													}
            													else {
HXLINE( 357)														_hx_tmp62 = blended15;
            													}
HXDLIN( 357)													::iterMagic::Iimg_obj::set(pixelImage->image,location15,_hx_tmp62);
            												}
            											}
            											else {
HXLINE( 357)												::Dynamic this256 = pixelImage->image;
HXDLIN( 357)												int index35;
HXDLIN( 357)												if (pixelImage->useVirtualPos) {
HXLINE( 357)													index35 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x27) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 357)													index35 = ::Std_obj::_hx_int(( (Float)(((y27 * pixelImage->width) + x27)) ));
            												}
HXDLIN( 357)												int _hx_tmp63;
HXDLIN( 357)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)													_hx_tmp63 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            												}
            												else {
HXLINE( 357)													_hx_tmp63 = c27;
            												}
HXDLIN( 357)												::iterMagic::Iimg_obj::set(this256,index35,_hx_tmp63);
            											}
            										}
HXLINE(  73)										found7 = true;
            									}
            									else {
HXLINE( 357)										if (found7) {
HXLINE( 357)											goto _hx_goto_429;
            										}
            									}
            								}
            							}
            							_hx_goto_429:;
            						}
            					}
            				}
            			}
            		}
HXDLIN( 357)		if ((hasHit == true)) {
HXLINE( 357)			 ::pi_xy::algo::HitQuad v20 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 357)			return v20;
            		}
            		else {
HXLINE( 357)			return null();
            		}
HXDLIN( 357)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(LinePixel_Fields__obj,rotateSoftLineFlarePartial,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateTileLine( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_367_rotateTileLine)
HXLINE( 368)		Float sin = ::Math_obj::sin(theta);
HXLINE( 369)		Float cos = ::Math_obj::cos(theta);
HXLINE( 370)		Float radius = (thick / ( (Float)(2) ));
HXLINE( 371)		Float dx = ((Float)0.1);
HXLINE( 372)		Float dy = radius;
HXLINE( 373)		Float cx = h;
HXLINE( 374)		Float cy = radius;
HXLINE( 375)		Float bx = h;
HXLINE( 376)		Float by = -(radius);
HXLINE( 377)		Float ax = ((Float)0.1);
HXLINE( 378)		Float ay = -(radius);
HXLINE( 379)		Float temp = ((Float)0.);
HXLINE( 380)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 381)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 382)		ax = temp;
HXLINE( 384)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 385)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 386)		bx = temp;
HXLINE( 388)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 389)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 390)		cx = temp;
HXLINE( 392)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 393)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 394)		dx = temp;
HXLINE( 401)		if (( (bool)(debugCorners) )) {
HXLINE( 402)			{
HXLINE( 402)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN( 402)				{
HXLINE( 402)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN( 402)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN( 402)					int r_w = 12;
HXDLIN( 402)					int r_h = 12;
HXDLIN( 402)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 402)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 402)					int ii_min = r_x;
HXDLIN( 402)					int ii_max = xmax;
HXDLIN( 402)					int xRange__start = ii_min;
HXDLIN( 402)					int xRange__max = ii_max;
HXDLIN( 402)					int ii_min1 = r_y;
HXDLIN( 402)					int ii_max1 = ymax;
HXDLIN( 402)					int yRange__start = ii_min1;
HXDLIN( 402)					int yRange__max = ii_max1;
HXDLIN( 402)					int range_x = xRange__start;
HXDLIN( 402)					int range_y = (yRange__start - 1);
HXDLIN( 402)					int range_xReset = range_x;
HXDLIN( 402)					int range_yReset = range_y;
HXDLIN( 402)					int range_xMax = (xRange__max - 2);
HXDLIN( 402)					int range_yMax = (yRange__max - 2);
HXDLIN( 402)					int _this_min = 0;
HXDLIN( 402)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 402)					while((_this_min < _this_max)){
HXLINE( 402)						_this_min = (_this_min + 1);
HXDLIN( 402)						int i = (_this_min - 1);
HXDLIN( 402)						if ((range_y > range_yMax)) {
HXLINE( 402)							range_y = range_yReset;
HXDLIN( 402)							range_x = (range_x + 1);
            						}
HXDLIN( 402)						range_y = (range_y + 1);
HXDLIN( 402)						int i1 = i;
HXDLIN( 402)						{
HXLINE( 402)							int x = range_x;
HXDLIN( 402)							int y = range_y;
HXDLIN( 402)							int c = -65536;
HXDLIN( 402)							bool _hx_tmp;
HXDLIN( 402)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 402)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 402)								_hx_tmp = false;
            							}
HXDLIN( 402)							if (_hx_tmp) {
HXLINE( 402)								int location;
HXDLIN( 402)								if (this1->useVirtualPos) {
HXLINE( 402)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 402)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 402)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 402)								int this3;
HXDLIN( 402)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 402)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 402)									this3 = this2;
            								}
HXDLIN( 402)								Float a1;
HXDLIN( 402)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 402)								if ((this4 == 0)) {
HXLINE( 402)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float r1;
HXDLIN( 402)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 402)								if ((this5 == 0)) {
HXLINE( 402)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float g1;
HXDLIN( 402)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 402)								if ((this6 == 0)) {
HXLINE( 402)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float b1;
HXDLIN( 402)								int this7 = (this3 & 255);
HXDLIN( 402)								if ((this7 == 0)) {
HXLINE( 402)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float a2;
HXDLIN( 402)								int this8 = ((-65536 >> 24) & 255);
HXDLIN( 402)								if ((this8 == 0)) {
HXLINE( 402)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float r2;
HXDLIN( 402)								int this9 = ((-65536 >> 16) & 255);
HXDLIN( 402)								if ((this9 == 0)) {
HXLINE( 402)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float g2;
HXDLIN( 402)								int this10 = ((-65536 >> 8) & 255);
HXDLIN( 402)								if ((this10 == 0)) {
HXLINE( 402)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float b2;
HXDLIN( 402)								int this11 = (-65536 & 255);
HXDLIN( 402)								if ((this11 == 0)) {
HXLINE( 402)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 402)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 402)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 402)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 402)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 402)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 402)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 402)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 402)								{
HXLINE( 402)									int _hx_tmp1;
HXDLIN( 402)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 402)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 402)										_hx_tmp1 = blended;
            									}
HXDLIN( 402)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 402)								::Dynamic this12 = this1->image;
HXDLIN( 402)								int index;
HXDLIN( 402)								if (this1->useVirtualPos) {
HXLINE( 402)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 402)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 402)								int _hx_tmp2;
HXDLIN( 402)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 402)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 402)									_hx_tmp2 = c;
            								}
HXDLIN( 402)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE( 403)			{
HXLINE( 403)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN( 403)				{
HXLINE( 403)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN( 403)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN( 403)					int r_w1 = 12;
HXDLIN( 403)					int r_h1 = 12;
HXDLIN( 403)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 403)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 403)					int ii_min2 = r_x1;
HXDLIN( 403)					int ii_max2 = xmax1;
HXDLIN( 403)					int xRange__start1 = ii_min2;
HXDLIN( 403)					int xRange__max1 = ii_max2;
HXDLIN( 403)					int ii_min3 = r_y1;
HXDLIN( 403)					int ii_max3 = ymax1;
HXDLIN( 403)					int yRange__start1 = ii_min3;
HXDLIN( 403)					int yRange__max1 = ii_max3;
HXDLIN( 403)					int range_x1 = xRange__start1;
HXDLIN( 403)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 403)					int range_xReset1 = range_x1;
HXDLIN( 403)					int range_yReset1 = range_y1;
HXDLIN( 403)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 403)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 403)					int _this_min1 = 0;
HXDLIN( 403)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 403)					while((_this_min1 < _this_max1)){
HXLINE( 403)						_this_min1 = (_this_min1 + 1);
HXDLIN( 403)						int i2 = (_this_min1 - 1);
HXDLIN( 403)						if ((range_y1 > range_yMax1)) {
HXLINE( 403)							range_y1 = range_yReset1;
HXDLIN( 403)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 403)						range_y1 = (range_y1 + 1);
HXDLIN( 403)						int i3 = i2;
HXDLIN( 403)						{
HXLINE( 403)							int x1 = range_x1;
HXDLIN( 403)							int y1 = range_y1;
HXDLIN( 403)							int c1 = -16711936;
HXDLIN( 403)							bool _hx_tmp3;
HXDLIN( 403)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 403)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE( 403)								_hx_tmp3 = false;
            							}
HXDLIN( 403)							if (_hx_tmp3) {
HXLINE( 403)								int location1;
HXDLIN( 403)								if (this13->useVirtualPos) {
HXLINE( 403)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 403)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 403)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN( 403)								int this15;
HXDLIN( 403)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 403)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE( 403)									this15 = this14;
            								}
HXDLIN( 403)								Float a11;
HXDLIN( 403)								int this16 = ((this15 >> 24) & 255);
HXDLIN( 403)								if ((this16 == 0)) {
HXLINE( 403)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float r11;
HXDLIN( 403)								int this17 = ((this15 >> 16) & 255);
HXDLIN( 403)								if ((this17 == 0)) {
HXLINE( 403)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float g11;
HXDLIN( 403)								int this18 = ((this15 >> 8) & 255);
HXDLIN( 403)								if ((this18 == 0)) {
HXLINE( 403)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float b11;
HXDLIN( 403)								int this19 = (this15 & 255);
HXDLIN( 403)								if ((this19 == 0)) {
HXLINE( 403)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float a21;
HXDLIN( 403)								int this20 = ((-16711936 >> 24) & 255);
HXDLIN( 403)								if ((this20 == 0)) {
HXLINE( 403)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float r21;
HXDLIN( 403)								int this21 = ((-16711936 >> 16) & 255);
HXDLIN( 403)								if ((this21 == 0)) {
HXLINE( 403)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float g21;
HXDLIN( 403)								int this22 = ((-16711936 >> 8) & 255);
HXDLIN( 403)								if ((this22 == 0)) {
HXLINE( 403)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float b21;
HXDLIN( 403)								int this23 = (-16711936 & 255);
HXDLIN( 403)								if ((this23 == 0)) {
HXLINE( 403)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 403)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN( 403)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 403)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 403)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 403)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 403)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 403)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 403)								{
HXLINE( 403)									int _hx_tmp4;
HXDLIN( 403)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 403)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 403)										_hx_tmp4 = blended1;
            									}
HXDLIN( 403)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 403)								::Dynamic this24 = this13->image;
HXDLIN( 403)								int index1;
HXDLIN( 403)								if (this13->useVirtualPos) {
HXLINE( 403)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 403)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 403)								int _hx_tmp5;
HXDLIN( 403)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 403)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 403)									_hx_tmp5 = c1;
            								}
HXDLIN( 403)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE( 404)			{
HXLINE( 404)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN( 404)				{
HXLINE( 404)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN( 404)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN( 404)					int r_w2 = 12;
HXDLIN( 404)					int r_h2 = 12;
HXDLIN( 404)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 404)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 404)					int ii_min4 = r_x2;
HXDLIN( 404)					int ii_max4 = xmax2;
HXDLIN( 404)					int xRange__start2 = ii_min4;
HXDLIN( 404)					int xRange__max2 = ii_max4;
HXDLIN( 404)					int ii_min5 = r_y2;
HXDLIN( 404)					int ii_max5 = ymax2;
HXDLIN( 404)					int yRange__start2 = ii_min5;
HXDLIN( 404)					int yRange__max2 = ii_max5;
HXDLIN( 404)					int range_x2 = xRange__start2;
HXDLIN( 404)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 404)					int range_xReset2 = range_x2;
HXDLIN( 404)					int range_yReset2 = range_y2;
HXDLIN( 404)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 404)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 404)					int _this_min2 = 0;
HXDLIN( 404)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 404)					while((_this_min2 < _this_max2)){
HXLINE( 404)						_this_min2 = (_this_min2 + 1);
HXDLIN( 404)						int i4 = (_this_min2 - 1);
HXDLIN( 404)						if ((range_y2 > range_yMax2)) {
HXLINE( 404)							range_y2 = range_yReset2;
HXDLIN( 404)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 404)						range_y2 = (range_y2 + 1);
HXDLIN( 404)						int i5 = i4;
HXDLIN( 404)						{
HXLINE( 404)							int x2 = range_x2;
HXDLIN( 404)							int y2 = range_y2;
HXDLIN( 404)							int c2 = -16776961;
HXDLIN( 404)							bool _hx_tmp6;
HXDLIN( 404)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 404)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE( 404)								_hx_tmp6 = false;
            							}
HXDLIN( 404)							if (_hx_tmp6) {
HXLINE( 404)								int location2;
HXDLIN( 404)								if (this25->useVirtualPos) {
HXLINE( 404)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 404)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 404)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN( 404)								int this27;
HXDLIN( 404)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 404)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE( 404)									this27 = this26;
            								}
HXDLIN( 404)								Float a12;
HXDLIN( 404)								int this28 = ((this27 >> 24) & 255);
HXDLIN( 404)								if ((this28 == 0)) {
HXLINE( 404)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float r12;
HXDLIN( 404)								int this29 = ((this27 >> 16) & 255);
HXDLIN( 404)								if ((this29 == 0)) {
HXLINE( 404)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float g12;
HXDLIN( 404)								int this30 = ((this27 >> 8) & 255);
HXDLIN( 404)								if ((this30 == 0)) {
HXLINE( 404)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float b12;
HXDLIN( 404)								int this31 = (this27 & 255);
HXDLIN( 404)								if ((this31 == 0)) {
HXLINE( 404)									b12 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float a22;
HXDLIN( 404)								int this32 = ((-16776961 >> 24) & 255);
HXDLIN( 404)								if ((this32 == 0)) {
HXLINE( 404)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float r22;
HXDLIN( 404)								int this33 = ((-16776961 >> 16) & 255);
HXDLIN( 404)								if ((this33 == 0)) {
HXLINE( 404)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float g22;
HXDLIN( 404)								int this34 = ((-16776961 >> 8) & 255);
HXDLIN( 404)								if ((this34 == 0)) {
HXLINE( 404)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float b22;
HXDLIN( 404)								int this35 = (-16776961 & 255);
HXDLIN( 404)								if ((this35 == 0)) {
HXLINE( 404)									b22 = ((Float)0.);
            								}
            								else {
HXLINE( 404)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 404)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 404)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 404)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 404)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN( 404)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 404)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN( 404)								{
HXLINE( 404)									int _hx_tmp7;
HXDLIN( 404)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 404)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 404)										_hx_tmp7 = blended2;
            									}
HXDLIN( 404)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE( 404)								::Dynamic this36 = this25->image;
HXDLIN( 404)								int index2;
HXDLIN( 404)								if (this25->useVirtualPos) {
HXLINE( 404)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 404)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 404)								int _hx_tmp8;
HXDLIN( 404)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 404)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE( 404)									_hx_tmp8 = c2;
            								}
HXDLIN( 404)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE( 405)			{
HXLINE( 405)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN( 405)				{
HXLINE( 405)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN( 405)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN( 405)					int r_w3 = 12;
HXDLIN( 405)					int r_h3 = 12;
HXDLIN( 405)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN( 405)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN( 405)					int ii_min6 = r_x3;
HXDLIN( 405)					int ii_max6 = xmax3;
HXDLIN( 405)					int xRange__start3 = ii_min6;
HXDLIN( 405)					int xRange__max3 = ii_max6;
HXDLIN( 405)					int ii_min7 = r_y3;
HXDLIN( 405)					int ii_max7 = ymax3;
HXDLIN( 405)					int yRange__start3 = ii_min7;
HXDLIN( 405)					int yRange__max3 = ii_max7;
HXDLIN( 405)					int range_x3 = xRange__start3;
HXDLIN( 405)					int range_y3 = (yRange__start3 - 1);
HXDLIN( 405)					int range_xReset3 = range_x3;
HXDLIN( 405)					int range_yReset3 = range_y3;
HXDLIN( 405)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN( 405)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN( 405)					int _this_min3 = 0;
HXDLIN( 405)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN( 405)					while((_this_min3 < _this_max3)){
HXLINE( 405)						_this_min3 = (_this_min3 + 1);
HXDLIN( 405)						int i6 = (_this_min3 - 1);
HXDLIN( 405)						if ((range_y3 > range_yMax3)) {
HXLINE( 405)							range_y3 = range_yReset3;
HXDLIN( 405)							range_x3 = (range_x3 + 1);
            						}
HXDLIN( 405)						range_y3 = (range_y3 + 1);
HXDLIN( 405)						int i7 = i6;
HXDLIN( 405)						{
HXLINE( 405)							int x3 = range_x3;
HXDLIN( 405)							int y3 = range_y3;
HXDLIN( 405)							int c3 = -1048336;
HXDLIN( 405)							bool _hx_tmp9;
HXDLIN( 405)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 405)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE( 405)								_hx_tmp9 = false;
            							}
HXDLIN( 405)							if (_hx_tmp9) {
HXLINE( 405)								int location3;
HXDLIN( 405)								if (this37->useVirtualPos) {
HXLINE( 405)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 405)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 405)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 405)								int this39;
HXDLIN( 405)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE( 405)									this39 = this38;
            								}
HXDLIN( 405)								Float a13;
HXDLIN( 405)								int this40 = ((this39 >> 24) & 255);
HXDLIN( 405)								if ((this40 == 0)) {
HXLINE( 405)									a13 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float r13;
HXDLIN( 405)								int this41 = ((this39 >> 16) & 255);
HXDLIN( 405)								if ((this41 == 0)) {
HXLINE( 405)									r13 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float g13;
HXDLIN( 405)								int this42 = ((this39 >> 8) & 255);
HXDLIN( 405)								if ((this42 == 0)) {
HXLINE( 405)									g13 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float b13;
HXDLIN( 405)								int this43 = (this39 & 255);
HXDLIN( 405)								if ((this43 == 0)) {
HXLINE( 405)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float a23;
HXDLIN( 405)								int this44 = ((-1048336 >> 24) & 255);
HXDLIN( 405)								if ((this44 == 0)) {
HXLINE( 405)									a23 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float r23;
HXDLIN( 405)								int this45 = ((-1048336 >> 16) & 255);
HXDLIN( 405)								if ((this45 == 0)) {
HXLINE( 405)									r23 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float g23;
HXDLIN( 405)								int this46 = ((-1048336 >> 8) & 255);
HXDLIN( 405)								if ((this46 == 0)) {
HXLINE( 405)									g23 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float b23;
HXDLIN( 405)								int this47 = (-1048336 & 255);
HXDLIN( 405)								if ((this47 == 0)) {
HXLINE( 405)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 405)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN( 405)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 405)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 405)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 405)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN( 405)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 405)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN( 405)								{
HXLINE( 405)									int _hx_tmp10;
HXDLIN( 405)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE( 405)										_hx_tmp10 = blended3;
            									}
HXDLIN( 405)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE( 405)								::Dynamic this48 = this37->image;
HXDLIN( 405)								int index3;
HXDLIN( 405)								if (this37->useVirtualPos) {
HXLINE( 405)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 405)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 405)								int _hx_tmp11;
HXDLIN( 405)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 405)									_hx_tmp11 = c3;
            								}
HXDLIN( 405)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 407)		{
HXLINE( 407)			Float bx1 = bx;
HXDLIN( 407)			Float by1 = by;
HXDLIN( 407)			Float cx1 = dx;
HXDLIN( 407)			Float cy1 = dy;
HXDLIN( 407)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 407)			if (!(adjustWinding)) {
HXLINE( 407)				Float bx_ = bx1;
HXDLIN( 407)				Float by_ = by1;
HXLINE( 187)				bx1 = cx1;
HXLINE( 188)				by1 = cy1;
HXLINE( 189)				cx1 = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE( 407)			{
HXLINE( 407)				bool hasUndo = false;
HXDLIN( 407)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 407)				Float sx = (cy1 - ay);
HXDLIN( 407)				Float sy = (ax - cx1);
HXDLIN( 407)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 407)				Float tx = (ay - by1);
HXDLIN( 407)				Float ty = (bx1 - ax);
HXDLIN( 407)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 407)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 407)				if ((ax > bx1)) {
HXLINE( 407)					if ((ax > cx1)) {
HXLINE( 407)						int min;
HXDLIN( 407)						if ((bx1 > cx1)) {
HXLINE( 407)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 407)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 407)						int ii_min8 = min;
HXDLIN( 407)						int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 407)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 407)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 407)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN( 407)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 407)					if ((bx1 > cx1)) {
HXLINE( 407)						int min1;
HXDLIN( 407)						if ((ax > cx1)) {
HXLINE( 407)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 407)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 407)						int ii_min10 = min1;
HXDLIN( 407)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 407)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 407)						int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 407)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN( 407)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 407)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 407)				if ((ay > by1)) {
HXLINE( 407)					if ((ay > cy1)) {
HXLINE( 407)						int min2;
HXDLIN( 407)						if ((by1 > cy1)) {
HXLINE( 407)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 407)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 407)						int ii_min12 = min2;
HXDLIN( 407)						int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 407)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 407)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 407)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN( 407)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 407)					if ((by1 > cy1)) {
HXLINE( 407)						int min3;
HXDLIN( 407)						if ((ay > cy1)) {
HXLINE( 407)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 407)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 407)						int ii_min14 = min3;
HXDLIN( 407)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 407)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 407)						int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 407)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN( 407)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 407)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 407)				if (hasUndo) {
HXLINE( 407)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 407)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 407)					 ::Dynamic imageType = null();
HXDLIN( 407)					 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 407)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 407)					::Dynamic undoImage1;
HXDLIN( 407)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 407)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::BytesImg b6 = byt;
HXDLIN( 407)							{
HXLINE( 407)								b6->width = width;
HXDLIN( 407)								b6->height = height;
HXDLIN( 407)								b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 407)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 407)								{
HXLINE( 407)									int len = b6->length;
HXDLIN( 407)									int w = 0;
HXDLIN( 407)									{
HXLINE( 407)										int _g = 0;
HXDLIN( 407)										int _g1 = b6->height;
HXDLIN( 407)										while((_g < _g1)){
HXLINE( 407)											_g = (_g + 1);
HXDLIN( 407)											int y4 = (_g - 1);
HXDLIN( 407)											{
HXLINE( 407)												int _g2 = 0;
HXDLIN( 407)												int _g3 = b6->width;
HXDLIN( 407)												while((_g2 < _g3)){
HXLINE( 407)													_g2 = (_g2 + 1);
HXDLIN( 407)													int x4 = (_g2 - 1);
HXDLIN( 407)													{
HXLINE( 407)														w = (w + 1);
HXDLIN( 407)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w = (w + 1);
HXDLIN( 407)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w = (w + 1);
HXDLIN( 407)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w = (w + 1);
HXDLIN( 407)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage1 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE( 407)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN( 407)							{
HXLINE( 407)								a7->width = width;
HXDLIN( 407)								a7->height = height;
HXDLIN( 407)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 407)								a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 407)								{
HXLINE( 407)									int _g4 = 0;
HXDLIN( 407)									int _g5 = a7->length;
HXDLIN( 407)									while((_g4 < _g5)){
HXLINE( 407)										_g4 = (_g4 + 1);
HXDLIN( 407)										int i8 = (_g4 - 1);
HXDLIN( 407)										a7->data[i8] = 0;
            									}
            								}
            							}
HXDLIN( 407)							undoImage1 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE( 407)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN( 407)							{
HXLINE( 407)								b7->width = width;
HXDLIN( 407)								b7->height = height;
HXDLIN( 407)								b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 407)								int size = (b7->length * 4);
HXDLIN( 407)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 407)								{
HXLINE( 407)									int _g6 = 0;
HXDLIN( 407)									int _g7 = b7->length;
HXDLIN( 407)									while((_g6 < _g7)){
HXLINE( 407)										_g6 = (_g6 + 1);
HXDLIN( 407)										int i9 = (_g6 - 1);
HXDLIN( 407)										{
HXLINE( 407)											 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN( 407)											bool undoImage2;
HXDLIN( 407)											if ((i9 >= 0)) {
HXLINE( 407)												undoImage2 = (i9 < (this50->byteLength >> 2));
            											}
            											else {
HXLINE( 407)												undoImage2 = false;
            											}
HXDLIN( 407)											if (undoImage2) {
HXLINE( 407)												 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN( 407)												int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN( 407)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 407)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 407)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 407)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage1 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE( 407)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 407)							{
HXLINE( 407)								v->width = width;
HXDLIN( 407)								v->height = height;
HXDLIN( 407)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 407)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 407)								{
HXLINE( 407)									int _g8 = 0;
HXDLIN( 407)									int _g9 = v->length;
HXDLIN( 407)									while((_g8 < _g9)){
HXLINE( 407)										_g8 = (_g8 + 1);
HXDLIN( 407)										int i10 = (_g8 - 1);
HXDLIN( 407)										v->data->__unsafe_set(i10,0);
            									}
            								}
            							}
HXDLIN( 407)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 407)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN( 407)							{
HXLINE( 407)								b8->width = width;
HXDLIN( 407)								b8->height = height;
HXDLIN( 407)								b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 407)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 407)								{
HXLINE( 407)									int len1 = b8->length;
HXDLIN( 407)									 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN( 407)									if (::hx::IsNull( d->head )) {
HXLINE( 407)										int _g10 = 0;
HXDLIN( 407)										int _g11 = len1;
HXDLIN( 407)										while((_g10 < _g11)){
HXLINE( 407)											_g10 = (_g10 + 1);
HXDLIN( 407)											int i11 = (_g10 - 1);
HXDLIN( 407)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 407)										int _g12 = 0;
HXDLIN( 407)										int _g13 = len1;
HXDLIN( 407)										while((_g12 < _g13)){
HXLINE( 407)											_g12 = (_g12 + 1);
HXDLIN( 407)											int i12 = (_g12 - 1);
HXDLIN( 407)											{
HXLINE( 407)												 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN( 407)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 407)												{
HXLINE( 407)													int _g14 = 0;
HXDLIN( 407)													int _g15 = i12;
HXDLIN( 407)													while((_g14 < _g15)){
HXLINE( 407)														_g14 = (_g14 + 1);
HXDLIN( 407)														int i13 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 407)												if (::hx::IsNull( prev )) {
HXLINE( 407)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 407)													l = null();
            												}
            												else {
HXLINE( 407)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 407)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage1 = b8;
            						}
            						break;
            					}
HXDLIN( 407)					this49->image = undoImage1;
HXDLIN( 407)					this49->width = width;
HXDLIN( 407)					this49->height = height;
HXDLIN( 407)					this49->imageType = ( (int)(imageType) );
HXDLIN( 407)					undoImage = this49;
HXDLIN( 407)					{
HXLINE( 407)						int rectLeft = xIter3->start;
HXDLIN( 407)						int rectTop = yIter3->start;
HXDLIN( 407)						int rectRight = xIter3->max;
HXDLIN( 407)						bool forceClear = false;
HXDLIN( 407)						{
HXLINE( 407)							int _g16 = rectTop;
HXDLIN( 407)							int _g17 = yIter3->max;
HXDLIN( 407)							while((_g16 < _g17)){
HXLINE( 407)								_g16 = (_g16 + 1);
HXDLIN( 407)								int dy1 = (_g16 - 1);
HXDLIN( 407)								{
HXLINE( 407)									int _g18 = rectLeft;
HXDLIN( 407)									int _g19 = rectRight;
HXDLIN( 407)									while((_g18 < _g19)){
HXLINE( 407)										_g18 = (_g18 + 1);
HXDLIN( 407)										int dx1 = (_g18 - 1);
HXDLIN( 407)										::Dynamic this51 = pixelImage->image;
HXDLIN( 407)										int index4;
HXDLIN( 407)										if (pixelImage->useVirtualPos) {
HXLINE( 407)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 407)											index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 407)										int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN( 407)										int col;
HXDLIN( 407)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)											col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 407)											col = c4;
            										}
HXDLIN( 407)										bool _hx_tmp12;
HXDLIN( 407)										if (pixelImage->useMask) {
HXLINE( 407)											_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 407)											_hx_tmp12 = false;
            										}
HXDLIN( 407)										if (_hx_tmp12) {
HXLINE( 407)											 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN( 407)											::Dynamic this53 = this52->image;
HXDLIN( 407)											int index5;
HXDLIN( 407)											if (this52->useVirtualPos) {
HXLINE( 407)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            											}
            											else {
HXLINE( 407)												index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            											}
HXDLIN( 407)											int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN( 407)											int v1;
HXDLIN( 407)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)												v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 407)												v1 = c5;
            											}
HXDLIN( 407)											int maskPixel = v1;
HXDLIN( 407)											int this54 = col;
HXDLIN( 407)											if ((maskPixel == 0)) {
HXLINE( 407)												col = this54;
            											}
            											else {
HXLINE( 407)												Float m0;
HXDLIN( 407)												int this55 = ((maskPixel >> 24) & 255);
HXDLIN( 407)												if ((this55 == 0)) {
HXLINE( 407)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m1;
HXDLIN( 407)												int this56 = ((maskPixel >> 16) & 255);
HXDLIN( 407)												if ((this56 == 0)) {
HXLINE( 407)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m2;
HXDLIN( 407)												int this57 = ((maskPixel >> 8) & 255);
HXDLIN( 407)												if ((this57 == 0)) {
HXLINE( 407)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m3;
HXDLIN( 407)												int this58 = (maskPixel & 255);
HXDLIN( 407)												if ((this58 == 0)) {
HXLINE( 407)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 407)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 407)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 407)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN( 407)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 407)										if ((col != 0)) {
HXLINE( 407)											int x5 = (dx1 - rectLeft);
HXDLIN( 407)											int y5 = (dy1 - rectTop);
HXDLIN( 407)											int c6 = col;
HXDLIN( 407)											bool _hx_tmp13;
HXDLIN( 407)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 407)												_hx_tmp13 = undoImage->transparent;
            											}
            											else {
HXLINE( 407)												_hx_tmp13 = false;
            											}
HXDLIN( 407)											if (_hx_tmp13) {
HXLINE( 407)												int location4;
HXDLIN( 407)												if (undoImage->useVirtualPos) {
HXLINE( 407)													location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE( 407)													location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN( 407)												int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN( 407)												int this60;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													this60 = this59;
            												}
HXDLIN( 407)												Float a14;
HXDLIN( 407)												int this61 = ((this60 >> 24) & 255);
HXDLIN( 407)												if ((this61 == 0)) {
HXLINE( 407)													a14 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r14;
HXDLIN( 407)												int this62 = ((this60 >> 16) & 255);
HXDLIN( 407)												if ((this62 == 0)) {
HXLINE( 407)													r14 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g14;
HXDLIN( 407)												int this63 = ((this60 >> 8) & 255);
HXDLIN( 407)												if ((this63 == 0)) {
HXLINE( 407)													g14 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b14;
HXDLIN( 407)												int this64 = (this60 & 255);
HXDLIN( 407)												if ((this64 == 0)) {
HXLINE( 407)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a24;
HXDLIN( 407)												int this65 = ((col >> 24) & 255);
HXDLIN( 407)												if ((this65 == 0)) {
HXLINE( 407)													a24 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r24;
HXDLIN( 407)												int this66 = ((col >> 16) & 255);
HXDLIN( 407)												if ((this66 == 0)) {
HXLINE( 407)													r24 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g24;
HXDLIN( 407)												int this67 = ((col >> 8) & 255);
HXDLIN( 407)												if ((this67 == 0)) {
HXLINE( 407)													g24 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b24;
HXDLIN( 407)												int this68 = (col & 255);
HXDLIN( 407)												if ((this68 == 0)) {
HXLINE( 407)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 407)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 407)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 407)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN( 407)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 407)												int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN( 407)												{
HXLINE( 407)													int _hx_tmp14;
HXDLIN( 407)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)														_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE( 407)														_hx_tmp14 = blended4;
            													}
HXDLIN( 407)													::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 407)												::Dynamic this69 = undoImage->image;
HXDLIN( 407)												int index6;
HXDLIN( 407)												if (undoImage->useVirtualPos) {
HXLINE( 407)													index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE( 407)													index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN( 407)												int _hx_tmp15;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													_hx_tmp15 = c6;
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            											}
            										}
            										else {
HXLINE( 407)											if (forceClear) {
HXLINE( 407)												::Dynamic this70 = undoImage->image;
HXDLIN( 407)												int x6 = (dx1 - rectLeft);
HXDLIN( 407)												int y6 = (dy1 - rectTop);
HXDLIN( 407)												int index7;
HXDLIN( 407)												if (undoImage->useVirtualPos) {
HXLINE( 407)													index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            												}
            												else {
HXLINE( 407)													index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this70,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 407)				bool foundY = false;
HXDLIN( 407)				Float s = ((Float)0.);
HXDLIN( 407)				Float t = ((Float)0.);
HXDLIN( 407)				Float sxx = ((Float)0.);
HXDLIN( 407)				Float txx = ((Float)0.);
HXDLIN( 407)				{
HXLINE( 407)					int _g_min = xIter3->start;
HXDLIN( 407)					int _g_max = xIter3->max;
HXDLIN( 407)					while((_g_min < _g_max)){
HXLINE( 407)						_g_min = (_g_min + 1);
HXDLIN( 407)						int x7 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x7) ));
HXLINE( 223)						txx = (tx * ( (Float)(x7) ));
HXLINE( 224)						foundY = false;
HXLINE( 407)						{
HXLINE( 407)							int _g_min1 = yIter3->start;
HXDLIN( 407)							int _g_max1 = yIter3->max;
HXDLIN( 407)							while((_g_min1 < _g_max1)){
HXLINE( 407)								_g_min1 = (_g_min1 + 1);
HXDLIN( 407)								int y7 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y7) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y7) )));
HXLINE( 407)								bool _hx_tmp16;
HXDLIN( 407)								if (!((s <= 0))) {
HXLINE( 407)									_hx_tmp16 = (t <= 0);
            								}
            								else {
HXLINE( 407)									_hx_tmp16 = true;
            								}
HXDLIN( 407)								if (_hx_tmp16) {
HXLINE( 407)									if (foundY) {
HXLINE( 407)										goto _hx_goto_446;
            									}
            								}
            								else {
HXLINE( 407)									if (((s + t) < A)) {
HXLINE( 407)										int x8 = ::hx::Mod(x7,tileImage->width);
HXDLIN( 407)										int y8 = ::hx::Mod(y7,tileImage->height);
HXDLIN( 407)										::Dynamic this71 = tileImage->image;
HXDLIN( 407)										int index8;
HXDLIN( 407)										if (tileImage->useVirtualPos) {
HXLINE( 407)											index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x8) - tileImage->virtualX));
            										}
            										else {
HXLINE( 407)											index8 = ::Std_obj::_hx_int(( (Float)(((y8 * tileImage->width) + x8)) ));
            										}
HXDLIN( 407)										int c7 = ::iterMagic::Iimg_obj::get(this71,index8);
HXDLIN( 407)										int color;
HXDLIN( 407)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)											color = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 407)											color = c7;
            										}
HXDLIN( 407)										{
HXLINE( 407)											int c8 = color;
HXDLIN( 407)											bool _hx_tmp17;
HXDLIN( 407)											if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 407)												_hx_tmp17 = pixelImage->transparent;
            											}
            											else {
HXLINE( 407)												_hx_tmp17 = false;
            											}
HXDLIN( 407)											if (_hx_tmp17) {
HXLINE( 407)												int location5;
HXDLIN( 407)												if (pixelImage->useVirtualPos) {
HXLINE( 407)													location5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 407)													location5 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN( 407)												int this72 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 407)												int this73;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													this73 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													this73 = this72;
            												}
HXDLIN( 407)												Float a15;
HXDLIN( 407)												int this74 = ((this73 >> 24) & 255);
HXDLIN( 407)												if ((this74 == 0)) {
HXLINE( 407)													a15 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a15 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r15;
HXDLIN( 407)												int this75 = ((this73 >> 16) & 255);
HXDLIN( 407)												if ((this75 == 0)) {
HXLINE( 407)													r15 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r15 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g15;
HXDLIN( 407)												int this76 = ((this73 >> 8) & 255);
HXDLIN( 407)												if ((this76 == 0)) {
HXLINE( 407)													g15 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g15 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b15;
HXDLIN( 407)												int this77 = (this73 & 255);
HXDLIN( 407)												if ((this77 == 0)) {
HXLINE( 407)													b15 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b15 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a25;
HXDLIN( 407)												int this78 = ((color >> 24) & 255);
HXDLIN( 407)												if ((this78 == 0)) {
HXLINE( 407)													a25 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a25 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r25;
HXDLIN( 407)												int this79 = ((color >> 16) & 255);
HXDLIN( 407)												if ((this79 == 0)) {
HXLINE( 407)													r25 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r25 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g25;
HXDLIN( 407)												int this80 = ((color >> 8) & 255);
HXDLIN( 407)												if ((this80 == 0)) {
HXLINE( 407)													g25 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g25 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b25;
HXDLIN( 407)												int this81 = (color & 255);
HXDLIN( 407)												if ((this81 == 0)) {
HXLINE( 407)													b25 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b25 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 407)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 407)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 407)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN( 407)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 407)												int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 407)												{
HXLINE( 407)													int _hx_tmp18;
HXDLIN( 407)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)														_hx_tmp18 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE( 407)														_hx_tmp18 = blended5;
            													}
HXDLIN( 407)													::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp18);
            												}
            											}
            											else {
HXLINE( 407)												::Dynamic this82 = pixelImage->image;
HXDLIN( 407)												int index9;
HXDLIN( 407)												if (pixelImage->useVirtualPos) {
HXLINE( 407)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 407)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN( 407)												int _hx_tmp19;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													_hx_tmp19 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													_hx_tmp19 = c8;
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this82,index9,_hx_tmp19);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE( 407)										if (foundY) {
HXLINE( 407)											goto _hx_goto_446;
            										}
            									}
            								}
            							}
            							_hx_goto_446:;
            						}
            					}
            				}
HXDLIN( 407)				if ((hasHit == false)) {
HXLINE( 407)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 407)					if (hasUndo) {
HXLINE( 407)						v2->undoImage = undoImage;
HXDLIN( 407)						v2->undoX = xIter3->start;
HXDLIN( 407)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN( 407)		{
HXLINE( 407)			Float bx2 = cx;
HXDLIN( 407)			Float by2 = cy;
HXDLIN( 407)			Float cx2 = dx;
HXDLIN( 407)			Float cy2 = dy;
HXDLIN( 407)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN( 407)			if (!(adjustWinding1)) {
HXLINE( 407)				Float bx_1 = bx2;
HXDLIN( 407)				Float by_1 = by2;
HXLINE( 187)				bx2 = cx2;
HXLINE( 188)				by2 = cy2;
HXLINE( 189)				cx2 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE( 407)			{
HXLINE( 407)				bool hasUndo1 = false;
HXDLIN( 407)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN( 407)				Float sx1 = (cy2 - by);
HXDLIN( 407)				Float sy1 = (bx - cx2);
HXDLIN( 407)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN( 407)				Float tx1 = (by - by2);
HXDLIN( 407)				Float ty1 = (bx2 - bx);
HXDLIN( 407)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 407)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 407)				if ((bx > bx2)) {
HXLINE( 407)					if ((bx > cx2)) {
HXLINE( 407)						int min4;
HXDLIN( 407)						if ((bx2 > cx2)) {
HXLINE( 407)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 407)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 407)						int ii_min16 = min4;
HXDLIN( 407)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 407)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE( 407)						int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN( 407)						int ii_max17 = ::Math_obj::ceil(cx2);
HXDLIN( 407)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE( 407)					if ((bx2 > cx2)) {
HXLINE( 407)						int min5;
HXDLIN( 407)						if ((bx > cx2)) {
HXLINE( 407)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 407)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 407)						int ii_min18 = min5;
HXDLIN( 407)						int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN( 407)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE( 407)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 407)						int ii_max19 = ::Math_obj::ceil(cx2);
HXDLIN( 407)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN( 407)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 407)				if ((by > by2)) {
HXLINE( 407)					if ((by > cy2)) {
HXLINE( 407)						int min6;
HXDLIN( 407)						if ((by2 > cy2)) {
HXLINE( 407)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 407)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN( 407)						int ii_min20 = min6;
HXDLIN( 407)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 407)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE( 407)						int ii_min21 = ::Math_obj::floor(by2);
HXDLIN( 407)						int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN( 407)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE( 407)					if ((by2 > cy2)) {
HXLINE( 407)						int min7;
HXDLIN( 407)						if ((by > cy2)) {
HXLINE( 407)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 407)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN( 407)						int ii_min22 = min7;
HXDLIN( 407)						int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN( 407)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE( 407)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 407)						int ii_max23 = ::Math_obj::ceil(cy2);
HXDLIN( 407)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN( 407)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 407)				if (hasUndo1) {
HXLINE( 407)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 407)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 407)					 ::Dynamic imageType1 = null();
HXDLIN( 407)					 ::pi_xy::ImageStruct this83 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 407)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 407)					::Dynamic undoImage4;
HXDLIN( 407)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 407)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::BytesImg b16 = byt1;
HXDLIN( 407)							{
HXLINE( 407)								b16->width = width1;
HXDLIN( 407)								b16->height = height1;
HXDLIN( 407)								b16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 407)								b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN( 407)								{
HXLINE( 407)									int len2 = b16->length;
HXDLIN( 407)									int w1 = 0;
HXDLIN( 407)									{
HXLINE( 407)										int _g20 = 0;
HXDLIN( 407)										int _g21 = b16->height;
HXDLIN( 407)										while((_g20 < _g21)){
HXLINE( 407)											_g20 = (_g20 + 1);
HXDLIN( 407)											int y9 = (_g20 - 1);
HXDLIN( 407)											{
HXLINE( 407)												int _g22 = 0;
HXDLIN( 407)												int _g23 = b16->width;
HXDLIN( 407)												while((_g22 < _g23)){
HXLINE( 407)													_g22 = (_g22 + 1);
HXDLIN( 407)													int x9 = (_g22 - 1);
HXDLIN( 407)													{
HXLINE( 407)														w1 = (w1 + 1);
HXDLIN( 407)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w1 = (w1 + 1);
HXDLIN( 407)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w1 = (w1 + 1);
HXDLIN( 407)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 407)													{
HXLINE( 407)														w1 = (w1 + 1);
HXDLIN( 407)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage4 = b16;
            						}
            						break;
            						case (int)1: {
HXLINE( 407)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::ArrIntImg a10 = arrI1;
HXDLIN( 407)							{
HXLINE( 407)								a10->width = width1;
HXDLIN( 407)								a10->height = height1;
HXDLIN( 407)								a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 407)								a10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 407)								{
HXLINE( 407)									int _g24 = 0;
HXDLIN( 407)									int _g25 = a10->length;
HXDLIN( 407)									while((_g24 < _g25)){
HXLINE( 407)										_g24 = (_g24 + 1);
HXDLIN( 407)										int i14 = (_g24 - 1);
HXDLIN( 407)										a10->data[i14] = 0;
            									}
            								}
            							}
HXDLIN( 407)							undoImage4 = a10;
            						}
            						break;
            						case (int)2: {
HXLINE( 407)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::U32ArrImg b17 = u32a1;
HXDLIN( 407)							{
HXLINE( 407)								b17->width = width1;
HXDLIN( 407)								b17->height = height1;
HXDLIN( 407)								b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 407)								int size1 = (b17->length * 4);
HXDLIN( 407)								b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 407)								{
HXLINE( 407)									int _g26 = 0;
HXDLIN( 407)									int _g27 = b17->length;
HXDLIN( 407)									while((_g26 < _g27)){
HXLINE( 407)										_g26 = (_g26 + 1);
HXDLIN( 407)										int i15 = (_g26 - 1);
HXDLIN( 407)										{
HXLINE( 407)											 ::haxe::io::ArrayBufferViewImpl this84 = b17->data;
HXDLIN( 407)											bool undoImage5;
HXDLIN( 407)											if ((i15 >= 0)) {
HXLINE( 407)												undoImage5 = (i15 < (this84->byteLength >> 2));
            											}
            											else {
HXLINE( 407)												undoImage5 = false;
            											}
HXDLIN( 407)											if (undoImage5) {
HXLINE( 407)												 ::haxe::io::Bytes _this1 = this84->bytes;
HXDLIN( 407)												int pos1 = ((i15 << 2) + this84->byteOffset);
HXDLIN( 407)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 407)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 407)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 407)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage4 = b17;
            						}
            						break;
            						case (int)3: {
HXLINE( 407)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 407)							{
HXLINE( 407)								v3->width = width1;
HXDLIN( 407)								v3->height = height1;
HXDLIN( 407)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 407)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 407)								{
HXLINE( 407)									int _g28 = 0;
HXDLIN( 407)									int _g29 = v3->length;
HXDLIN( 407)									while((_g28 < _g29)){
HXLINE( 407)										_g28 = (_g28 + 1);
HXDLIN( 407)										int i16 = (_g28 - 1);
HXDLIN( 407)										v3->data->__unsafe_set(i16,0);
            									}
            								}
            							}
HXDLIN( 407)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 407)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 407)							 ::iterMagic::StackIntImg b18 = sInt1;
HXDLIN( 407)							{
HXLINE( 407)								b18->width = width1;
HXDLIN( 407)								b18->height = height1;
HXDLIN( 407)								b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 407)								b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 407)								{
HXLINE( 407)									int len3 = b18->length;
HXDLIN( 407)									 ::haxe::ds::GenericStack_Int d1 = b18->data;
HXDLIN( 407)									if (::hx::IsNull( d1->head )) {
HXLINE( 407)										int _g30 = 0;
HXDLIN( 407)										int _g31 = len3;
HXDLIN( 407)										while((_g30 < _g31)){
HXLINE( 407)											_g30 = (_g30 + 1);
HXDLIN( 407)											int i17 = (_g30 - 1);
HXDLIN( 407)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 407)										int _g32 = 0;
HXDLIN( 407)										int _g33 = len3;
HXDLIN( 407)										while((_g32 < _g33)){
HXLINE( 407)											_g32 = (_g32 + 1);
HXDLIN( 407)											int i18 = (_g32 - 1);
HXDLIN( 407)											{
HXLINE( 407)												 ::haxe::ds::GenericCell_Int l1 = b18->data->head;
HXDLIN( 407)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 407)												{
HXLINE( 407)													int _g34 = 0;
HXDLIN( 407)													int _g35 = i18;
HXDLIN( 407)													while((_g34 < _g35)){
HXLINE( 407)														_g34 = (_g34 + 1);
HXDLIN( 407)														int i19 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 407)												if (::hx::IsNull( prev1 )) {
HXLINE( 407)													b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 407)													l1 = null();
            												}
            												else {
HXLINE( 407)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 407)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 407)							undoImage4 = b18;
            						}
            						break;
            					}
HXDLIN( 407)					this83->image = undoImage4;
HXDLIN( 407)					this83->width = width1;
HXDLIN( 407)					this83->height = height1;
HXDLIN( 407)					this83->imageType = ( (int)(imageType1) );
HXDLIN( 407)					undoImage3 = this83;
HXDLIN( 407)					{
HXLINE( 407)						int rectLeft1 = xIter31->start;
HXDLIN( 407)						int rectTop1 = yIter31->start;
HXDLIN( 407)						int rectRight1 = xIter31->max;
HXDLIN( 407)						bool forceClear1 = false;
HXDLIN( 407)						{
HXLINE( 407)							int _g36 = rectTop1;
HXDLIN( 407)							int _g37 = yIter31->max;
HXDLIN( 407)							while((_g36 < _g37)){
HXLINE( 407)								_g36 = (_g36 + 1);
HXDLIN( 407)								int dy2 = (_g36 - 1);
HXDLIN( 407)								{
HXLINE( 407)									int _g38 = rectLeft1;
HXDLIN( 407)									int _g39 = rectRight1;
HXDLIN( 407)									while((_g38 < _g39)){
HXLINE( 407)										_g38 = (_g38 + 1);
HXDLIN( 407)										int dx2 = (_g38 - 1);
HXDLIN( 407)										::Dynamic this85 = pixelImage->image;
HXDLIN( 407)										int index10;
HXDLIN( 407)										if (pixelImage->useVirtualPos) {
HXLINE( 407)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 407)											index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 407)										int c9 = ::iterMagic::Iimg_obj::get(this85,index10);
HXDLIN( 407)										int col1;
HXDLIN( 407)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)											col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXLINE( 407)											col1 = c9;
            										}
HXDLIN( 407)										bool _hx_tmp20;
HXDLIN( 407)										if (pixelImage->useMask) {
HXLINE( 407)											_hx_tmp20 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 407)											_hx_tmp20 = false;
            										}
HXDLIN( 407)										if (_hx_tmp20) {
HXLINE( 407)											 ::pi_xy::ImageStruct this86 = pixelImage->mask;
HXDLIN( 407)											::Dynamic this87 = this86->image;
HXDLIN( 407)											int index11;
HXDLIN( 407)											if (this86->useVirtualPos) {
HXLINE( 407)												index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this86->virtualY) * ( (Float)(this86->width) )) + dx2) - this86->virtualX));
            											}
            											else {
HXLINE( 407)												index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this86->width) + dx2)) ));
            											}
HXDLIN( 407)											int c10 = ::iterMagic::Iimg_obj::get(this87,index11);
HXDLIN( 407)											int v4;
HXDLIN( 407)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)												v4 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            											}
            											else {
HXLINE( 407)												v4 = c10;
            											}
HXDLIN( 407)											int maskPixel1 = v4;
HXDLIN( 407)											int this88 = col1;
HXDLIN( 407)											if ((maskPixel1 == 0)) {
HXLINE( 407)												col1 = this88;
            											}
            											else {
HXLINE( 407)												Float m01;
HXDLIN( 407)												int this89 = ((maskPixel1 >> 24) & 255);
HXDLIN( 407)												if ((this89 == 0)) {
HXLINE( 407)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m01 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m11;
HXDLIN( 407)												int this90 = ((maskPixel1 >> 16) & 255);
HXDLIN( 407)												if ((this90 == 0)) {
HXLINE( 407)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m11 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m21;
HXDLIN( 407)												int this91 = ((maskPixel1 >> 8) & 255);
HXDLIN( 407)												if ((this91 == 0)) {
HXLINE( 407)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m21 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float m31;
HXDLIN( 407)												int this92 = (maskPixel1 & 255);
HXDLIN( 407)												if ((this92 == 0)) {
HXLINE( 407)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													m31 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this88 >> 24) & 255)) )));
HXDLIN( 407)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this88 >> 16) & 255)) )));
HXDLIN( 407)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this88 >> 8) & 255)) )));
HXDLIN( 407)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this88 & 255)) )));
HXDLIN( 407)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 407)										if ((col1 != 0)) {
HXLINE( 407)											int x10 = (dx2 - rectLeft1);
HXDLIN( 407)											int y10 = (dy2 - rectTop1);
HXDLIN( 407)											int c11 = col1;
HXDLIN( 407)											bool _hx_tmp21;
HXDLIN( 407)											if ((((c11 >> 24) & 255) < 254)) {
HXLINE( 407)												_hx_tmp21 = undoImage3->transparent;
            											}
            											else {
HXLINE( 407)												_hx_tmp21 = false;
            											}
HXDLIN( 407)											if (_hx_tmp21) {
HXLINE( 407)												int location6;
HXDLIN( 407)												if (undoImage3->useVirtualPos) {
HXLINE( 407)													location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 407)													location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN( 407)												int this93 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN( 407)												int this94;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													this94 = ((((((this93 >> 24) & 255) << 24) | ((this93 & 255) << 16)) | (((this93 >> 8) & 255) << 8)) | ((this93 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													this94 = this93;
            												}
HXDLIN( 407)												Float a16;
HXDLIN( 407)												int this95 = ((this94 >> 24) & 255);
HXDLIN( 407)												if ((this95 == 0)) {
HXLINE( 407)													a16 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a16 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r16;
HXDLIN( 407)												int this96 = ((this94 >> 16) & 255);
HXDLIN( 407)												if ((this96 == 0)) {
HXLINE( 407)													r16 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r16 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g16;
HXDLIN( 407)												int this97 = ((this94 >> 8) & 255);
HXDLIN( 407)												if ((this97 == 0)) {
HXLINE( 407)													g16 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g16 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b19;
HXDLIN( 407)												int this98 = (this94 & 255);
HXDLIN( 407)												if ((this98 == 0)) {
HXLINE( 407)													b19 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b19 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a26;
HXDLIN( 407)												int this99 = ((col1 >> 24) & 255);
HXDLIN( 407)												if ((this99 == 0)) {
HXLINE( 407)													a26 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a26 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r26;
HXDLIN( 407)												int this100 = ((col1 >> 16) & 255);
HXDLIN( 407)												if ((this100 == 0)) {
HXLINE( 407)													r26 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r26 = (( (Float)(this100) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g26;
HXDLIN( 407)												int this101 = ((col1 >> 8) & 255);
HXDLIN( 407)												if ((this101 == 0)) {
HXLINE( 407)													g26 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g26 = (( (Float)(this101) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b26;
HXDLIN( 407)												int this102 = (col1 & 255);
HXDLIN( 407)												if ((this102 == 0)) {
HXLINE( 407)													b26 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b26 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 407)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 407)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 407)												int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a36) + (b26 * a26))));
HXDLIN( 407)												int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 407)												int blended6 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 407)												{
HXLINE( 407)													int _hx_tmp22;
HXDLIN( 407)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)														_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE( 407)														_hx_tmp22 = blended6;
            													}
HXDLIN( 407)													::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            												}
            											}
            											else {
HXLINE( 407)												::Dynamic this103 = undoImage3->image;
HXDLIN( 407)												int index12;
HXDLIN( 407)												if (undoImage3->useVirtualPos) {
HXLINE( 407)													index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 407)													index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN( 407)												int _hx_tmp23;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													_hx_tmp23 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													_hx_tmp23 = c11;
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this103,index12,_hx_tmp23);
            											}
            										}
            										else {
HXLINE( 407)											if (forceClear1) {
HXLINE( 407)												::Dynamic this104 = undoImage3->image;
HXDLIN( 407)												int x11 = (dx2 - rectLeft1);
HXDLIN( 407)												int y11 = (dy2 - rectTop1);
HXDLIN( 407)												int index13;
HXDLIN( 407)												if (undoImage3->useVirtualPos) {
HXLINE( 407)													index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x11) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 407)													index13 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage3->width) + x11)) ));
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this104,index13,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 407)				bool foundY1 = false;
HXDLIN( 407)				Float s1 = ((Float)0.);
HXDLIN( 407)				Float t1 = ((Float)0.);
HXDLIN( 407)				Float sxx1 = ((Float)0.);
HXDLIN( 407)				Float txx1 = ((Float)0.);
HXDLIN( 407)				{
HXLINE( 407)					int _g_min2 = xIter31->start;
HXDLIN( 407)					int _g_max2 = xIter31->max;
HXDLIN( 407)					while((_g_min2 < _g_max2)){
HXLINE( 407)						_g_min2 = (_g_min2 + 1);
HXDLIN( 407)						int x12 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x12) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x12) ));
HXLINE( 224)						foundY1 = false;
HXLINE( 407)						{
HXLINE( 407)							int _g_min3 = yIter31->start;
HXDLIN( 407)							int _g_max3 = yIter31->max;
HXDLIN( 407)							while((_g_min3 < _g_max3)){
HXLINE( 407)								_g_min3 = (_g_min3 + 1);
HXDLIN( 407)								int y12 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y12) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y12) )));
HXLINE( 407)								bool _hx_tmp24;
HXDLIN( 407)								if (!((s1 <= 0))) {
HXLINE( 407)									_hx_tmp24 = (t1 <= 0);
            								}
            								else {
HXLINE( 407)									_hx_tmp24 = true;
            								}
HXDLIN( 407)								if (_hx_tmp24) {
HXLINE( 407)									if (foundY1) {
HXLINE( 407)										goto _hx_goto_458;
            									}
            								}
            								else {
HXLINE( 407)									if (((s1 + t1) < A1)) {
HXLINE( 407)										int x13 = ::hx::Mod(x12,tileImage->width);
HXDLIN( 407)										int y13 = ::hx::Mod(y12,tileImage->height);
HXDLIN( 407)										::Dynamic this105 = tileImage->image;
HXDLIN( 407)										int index14;
HXDLIN( 407)										if (tileImage->useVirtualPos) {
HXLINE( 407)											index14 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x13) - tileImage->virtualX));
            										}
            										else {
HXLINE( 407)											index14 = ::Std_obj::_hx_int(( (Float)(((y13 * tileImage->width) + x13)) ));
            										}
HXDLIN( 407)										int c12 = ::iterMagic::Iimg_obj::get(this105,index14);
HXDLIN( 407)										int color1;
HXDLIN( 407)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)											color1 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE( 407)											color1 = c12;
            										}
HXDLIN( 407)										{
HXLINE( 407)											int c13 = color1;
HXDLIN( 407)											bool _hx_tmp25;
HXDLIN( 407)											if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 407)												_hx_tmp25 = pixelImage->transparent;
            											}
            											else {
HXLINE( 407)												_hx_tmp25 = false;
            											}
HXDLIN( 407)											if (_hx_tmp25) {
HXLINE( 407)												int location7;
HXDLIN( 407)												if (pixelImage->useVirtualPos) {
HXLINE( 407)													location7 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x12) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 407)													location7 = ::Std_obj::_hx_int(( (Float)(((y12 * pixelImage->width) + x12)) ));
            												}
HXDLIN( 407)												int this106 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 407)												int this107;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													this107 = ((((((this106 >> 24) & 255) << 24) | ((this106 & 255) << 16)) | (((this106 >> 8) & 255) << 8)) | ((this106 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													this107 = this106;
            												}
HXDLIN( 407)												Float a18;
HXDLIN( 407)												int this108 = ((this107 >> 24) & 255);
HXDLIN( 407)												if ((this108 == 0)) {
HXLINE( 407)													a18 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a18 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r17;
HXDLIN( 407)												int this109 = ((this107 >> 16) & 255);
HXDLIN( 407)												if ((this109 == 0)) {
HXLINE( 407)													r17 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r17 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g17;
HXDLIN( 407)												int this110 = ((this107 >> 8) & 255);
HXDLIN( 407)												if ((this110 == 0)) {
HXLINE( 407)													g17 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g17 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b110;
HXDLIN( 407)												int this111 = (this107 & 255);
HXDLIN( 407)												if ((this111 == 0)) {
HXLINE( 407)													b110 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b110 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a27;
HXDLIN( 407)												int this112 = ((color1 >> 24) & 255);
HXDLIN( 407)												if ((this112 == 0)) {
HXLINE( 407)													a27 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													a27 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float r27;
HXDLIN( 407)												int this113 = ((color1 >> 16) & 255);
HXDLIN( 407)												if ((this113 == 0)) {
HXLINE( 407)													r27 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													r27 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float g27;
HXDLIN( 407)												int this114 = ((color1 >> 8) & 255);
HXDLIN( 407)												if ((this114 == 0)) {
HXLINE( 407)													g27 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													g27 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float b27;
HXDLIN( 407)												int this115 = (color1 & 255);
HXDLIN( 407)												if ((this115 == 0)) {
HXLINE( 407)													b27 = ((Float)0.);
            												}
            												else {
HXLINE( 407)													b27 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 407)												Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 407)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 407)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 407)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b27 * a27))));
HXDLIN( 407)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 407)												int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b28);
HXDLIN( 407)												{
HXLINE( 407)													int _hx_tmp26;
HXDLIN( 407)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)														_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE( 407)														_hx_tmp26 = blended7;
            													}
HXDLIN( 407)													::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp26);
            												}
            											}
            											else {
HXLINE( 407)												::Dynamic this116 = pixelImage->image;
HXDLIN( 407)												int index15;
HXDLIN( 407)												if (pixelImage->useVirtualPos) {
HXLINE( 407)													index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x12) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 407)													index15 = ::Std_obj::_hx_int(( (Float)(((y12 * pixelImage->width) + x12)) ));
            												}
HXDLIN( 407)												int _hx_tmp27;
HXDLIN( 407)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 407)													_hx_tmp27 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE( 407)													_hx_tmp27 = c13;
            												}
HXDLIN( 407)												::iterMagic::Iimg_obj::set(this116,index15,_hx_tmp27);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXLINE( 407)										if (foundY1) {
HXLINE( 407)											goto _hx_goto_458;
            										}
            									}
            								}
            							}
            							_hx_goto_458:;
            						}
            					}
            				}
HXDLIN( 407)				if ((hasHit == false)) {
HXLINE( 407)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN( 407)					if (hasUndo1) {
HXLINE( 407)						v5->undoImage = undoImage3;
HXDLIN( 407)						v5->undoX = xIter31->start;
HXDLIN( 407)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN( 407)		if ((hasHit == true)) {
HXLINE( 407)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 407)			return v6;
            		}
            		else {
HXLINE( 407)			return null();
            		}
HXDLIN( 407)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(LinePixel_Fields__obj,rotateTileLine,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateTileLineFlare( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick1,Float thick2,Float h,Float theta, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_416_rotateTileLineFlare)
HXLINE( 417)		Float sin = ::Math_obj::sin(theta);
HXLINE( 418)		Float cos = ::Math_obj::cos(theta);
HXLINE( 419)		Float radius1 = (thick1 / ( (Float)(2) ));
HXLINE( 420)		Float radius2 = (thick2 / ( (Float)(2) ));
HXLINE( 421)		Float dx = ((Float)0.1);
HXLINE( 422)		Float dy = radius1;
HXLINE( 423)		Float cx = h;
HXLINE( 424)		Float cy = radius2;
HXLINE( 425)		Float bx = h;
HXLINE( 426)		Float by = -(radius2);
HXLINE( 427)		Float ax = ((Float)0.1);
HXLINE( 428)		Float ay = -(radius1);
HXLINE( 429)		Float temp = ((Float)0.);
HXLINE( 430)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 431)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 432)		ax = temp;
HXLINE( 434)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 435)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 436)		bx = temp;
HXLINE( 438)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 439)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 440)		cx = temp;
HXLINE( 442)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 443)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 444)		dx = temp;
HXLINE( 451)		{
HXLINE( 451)			Float bx1 = bx;
HXDLIN( 451)			Float by1 = by;
HXDLIN( 451)			Float cx1 = dx;
HXDLIN( 451)			Float cy1 = dy;
HXDLIN( 451)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 451)			if (!(adjustWinding)) {
HXLINE( 451)				Float bx_ = bx1;
HXDLIN( 451)				Float by_ = by1;
HXLINE( 187)				bx1 = cx1;
HXLINE( 188)				by1 = cy1;
HXLINE( 189)				cx1 = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE( 451)			{
HXLINE( 451)				bool hasUndo = false;
HXDLIN( 451)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 451)				Float sx = (cy1 - ay);
HXDLIN( 451)				Float sy = (ax - cx1);
HXDLIN( 451)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 451)				Float tx = (ay - by1);
HXDLIN( 451)				Float ty = (bx1 - ax);
HXDLIN( 451)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 451)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 451)				if ((ax > bx1)) {
HXLINE( 451)					if ((ax > cx1)) {
HXLINE( 451)						int min;
HXDLIN( 451)						if ((bx1 > cx1)) {
HXLINE( 451)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 451)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 451)						int ii_min = min;
HXDLIN( 451)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 451)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 451)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 451)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 451)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 451)					if ((bx1 > cx1)) {
HXLINE( 451)						int min1;
HXDLIN( 451)						if ((ax > cx1)) {
HXLINE( 451)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 451)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 451)						int ii_min2 = min1;
HXDLIN( 451)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 451)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 451)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 451)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 451)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 451)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 451)				if ((ay > by1)) {
HXLINE( 451)					if ((ay > cy1)) {
HXLINE( 451)						int min2;
HXDLIN( 451)						if ((by1 > cy1)) {
HXLINE( 451)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 451)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 451)						int ii_min4 = min2;
HXDLIN( 451)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 451)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 451)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 451)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 451)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 451)					if ((by1 > cy1)) {
HXLINE( 451)						int min3;
HXDLIN( 451)						if ((ay > cy1)) {
HXLINE( 451)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 451)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 451)						int ii_min6 = min3;
HXDLIN( 451)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 451)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 451)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 451)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 451)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 451)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 451)				if (hasUndo) {
HXLINE( 451)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 451)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 451)					 ::Dynamic imageType = null();
HXDLIN( 451)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 451)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 451)					::Dynamic undoImage1;
HXDLIN( 451)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 451)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 451)							{
HXLINE( 451)								b->width = width;
HXDLIN( 451)								b->height = height;
HXDLIN( 451)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 451)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 451)								{
HXLINE( 451)									int len = b->length;
HXDLIN( 451)									int w = 0;
HXDLIN( 451)									{
HXLINE( 451)										int _g = 0;
HXDLIN( 451)										int _g1 = b->height;
HXDLIN( 451)										while((_g < _g1)){
HXLINE( 451)											_g = (_g + 1);
HXDLIN( 451)											int y = (_g - 1);
HXDLIN( 451)											{
HXLINE( 451)												int _g2 = 0;
HXDLIN( 451)												int _g3 = b->width;
HXDLIN( 451)												while((_g2 < _g3)){
HXLINE( 451)													_g2 = (_g2 + 1);
HXDLIN( 451)													int x = (_g2 - 1);
HXDLIN( 451)													{
HXLINE( 451)														w = (w + 1);
HXDLIN( 451)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w = (w + 1);
HXDLIN( 451)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w = (w + 1);
HXDLIN( 451)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w = (w + 1);
HXDLIN( 451)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 451)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 451)							{
HXLINE( 451)								a->width = width;
HXDLIN( 451)								a->height = height;
HXDLIN( 451)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 451)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 451)								{
HXLINE( 451)									int _g4 = 0;
HXDLIN( 451)									int _g5 = a->length;
HXDLIN( 451)									while((_g4 < _g5)){
HXLINE( 451)										_g4 = (_g4 + 1);
HXDLIN( 451)										int i = (_g4 - 1);
HXDLIN( 451)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 451)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 451)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 451)							{
HXLINE( 451)								b1->width = width;
HXDLIN( 451)								b1->height = height;
HXDLIN( 451)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 451)								int size = (b1->length * 4);
HXDLIN( 451)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 451)								{
HXLINE( 451)									int _g6 = 0;
HXDLIN( 451)									int _g7 = b1->length;
HXDLIN( 451)									while((_g6 < _g7)){
HXLINE( 451)										_g6 = (_g6 + 1);
HXDLIN( 451)										int i1 = (_g6 - 1);
HXDLIN( 451)										{
HXLINE( 451)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 451)											bool undoImage2;
HXDLIN( 451)											if ((i1 >= 0)) {
HXLINE( 451)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE( 451)												undoImage2 = false;
            											}
HXDLIN( 451)											if (undoImage2) {
HXLINE( 451)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 451)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 451)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 451)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 451)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 451)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 451)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 451)							{
HXLINE( 451)								v->width = width;
HXDLIN( 451)								v->height = height;
HXDLIN( 451)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 451)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 451)								{
HXLINE( 451)									int _g8 = 0;
HXDLIN( 451)									int _g9 = v->length;
HXDLIN( 451)									while((_g8 < _g9)){
HXLINE( 451)										_g8 = (_g8 + 1);
HXDLIN( 451)										int i2 = (_g8 - 1);
HXDLIN( 451)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 451)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 451)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 451)							{
HXLINE( 451)								b2->width = width;
HXDLIN( 451)								b2->height = height;
HXDLIN( 451)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 451)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 451)								{
HXLINE( 451)									int len1 = b2->length;
HXDLIN( 451)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 451)									if (::hx::IsNull( d->head )) {
HXLINE( 451)										int _g10 = 0;
HXDLIN( 451)										int _g11 = len1;
HXDLIN( 451)										while((_g10 < _g11)){
HXLINE( 451)											_g10 = (_g10 + 1);
HXDLIN( 451)											int i3 = (_g10 - 1);
HXDLIN( 451)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 451)										int _g12 = 0;
HXDLIN( 451)										int _g13 = len1;
HXDLIN( 451)										while((_g12 < _g13)){
HXLINE( 451)											_g12 = (_g12 + 1);
HXDLIN( 451)											int i4 = (_g12 - 1);
HXDLIN( 451)											{
HXLINE( 451)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 451)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 451)												{
HXLINE( 451)													int _g14 = 0;
HXDLIN( 451)													int _g15 = i4;
HXDLIN( 451)													while((_g14 < _g15)){
HXLINE( 451)														_g14 = (_g14 + 1);
HXDLIN( 451)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 451)												if (::hx::IsNull( prev )) {
HXLINE( 451)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 451)													l = null();
            												}
            												else {
HXLINE( 451)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 451)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 451)					this1->image = undoImage1;
HXDLIN( 451)					this1->width = width;
HXDLIN( 451)					this1->height = height;
HXDLIN( 451)					this1->imageType = ( (int)(imageType) );
HXDLIN( 451)					undoImage = this1;
HXDLIN( 451)					{
HXLINE( 451)						int rectLeft = xIter3->start;
HXDLIN( 451)						int rectTop = yIter3->start;
HXDLIN( 451)						int rectRight = xIter3->max;
HXDLIN( 451)						bool forceClear = false;
HXDLIN( 451)						{
HXLINE( 451)							int _g16 = rectTop;
HXDLIN( 451)							int _g17 = yIter3->max;
HXDLIN( 451)							while((_g16 < _g17)){
HXLINE( 451)								_g16 = (_g16 + 1);
HXDLIN( 451)								int dy1 = (_g16 - 1);
HXDLIN( 451)								{
HXLINE( 451)									int _g18 = rectLeft;
HXDLIN( 451)									int _g19 = rectRight;
HXDLIN( 451)									while((_g18 < _g19)){
HXLINE( 451)										_g18 = (_g18 + 1);
HXDLIN( 451)										int dx1 = (_g18 - 1);
HXDLIN( 451)										::Dynamic this3 = pixelImage->image;
HXDLIN( 451)										int index;
HXDLIN( 451)										if (pixelImage->useVirtualPos) {
HXLINE( 451)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 451)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 451)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 451)										int col;
HXDLIN( 451)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 451)											col = c;
            										}
HXDLIN( 451)										bool _hx_tmp;
HXDLIN( 451)										if (pixelImage->useMask) {
HXLINE( 451)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 451)											_hx_tmp = false;
            										}
HXDLIN( 451)										if (_hx_tmp) {
HXLINE( 451)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 451)											::Dynamic this5 = this4->image;
HXDLIN( 451)											int index1;
HXDLIN( 451)											if (this4->useVirtualPos) {
HXLINE( 451)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE( 451)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN( 451)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 451)											int v1;
HXDLIN( 451)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 451)												v1 = c1;
            											}
HXDLIN( 451)											int maskPixel = v1;
HXDLIN( 451)											int this6 = col;
HXDLIN( 451)											if ((maskPixel == 0)) {
HXLINE( 451)												col = this6;
            											}
            											else {
HXLINE( 451)												Float m0;
HXDLIN( 451)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 451)												if ((this7 == 0)) {
HXLINE( 451)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m1;
HXDLIN( 451)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 451)												if ((this8 == 0)) {
HXLINE( 451)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m2;
HXDLIN( 451)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 451)												if ((this9 == 0)) {
HXLINE( 451)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m3;
HXDLIN( 451)												int this10 = (maskPixel & 255);
HXDLIN( 451)												if ((this10 == 0)) {
HXLINE( 451)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 451)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 451)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 451)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 451)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 451)										if ((col != 0)) {
HXLINE( 451)											int x1 = (dx1 - rectLeft);
HXDLIN( 451)											int y1 = (dy1 - rectTop);
HXDLIN( 451)											int c2 = col;
HXDLIN( 451)											bool _hx_tmp1;
HXDLIN( 451)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 451)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 451)												_hx_tmp1 = false;
            											}
HXDLIN( 451)											if (_hx_tmp1) {
HXLINE( 451)												int location;
HXDLIN( 451)												if (undoImage->useVirtualPos) {
HXLINE( 451)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 451)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 451)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 451)												int this12;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													this12 = this11;
            												}
HXDLIN( 451)												Float a1;
HXDLIN( 451)												int this13 = ((this12 >> 24) & 255);
HXDLIN( 451)												if ((this13 == 0)) {
HXLINE( 451)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r1;
HXDLIN( 451)												int this14 = ((this12 >> 16) & 255);
HXDLIN( 451)												if ((this14 == 0)) {
HXLINE( 451)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g1;
HXDLIN( 451)												int this15 = ((this12 >> 8) & 255);
HXDLIN( 451)												if ((this15 == 0)) {
HXLINE( 451)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b11;
HXDLIN( 451)												int this16 = (this12 & 255);
HXDLIN( 451)												if ((this16 == 0)) {
HXLINE( 451)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a2;
HXDLIN( 451)												int this17 = ((col >> 24) & 255);
HXDLIN( 451)												if ((this17 == 0)) {
HXLINE( 451)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r2;
HXDLIN( 451)												int this18 = ((col >> 16) & 255);
HXDLIN( 451)												if ((this18 == 0)) {
HXLINE( 451)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g2;
HXDLIN( 451)												int this19 = ((col >> 8) & 255);
HXDLIN( 451)												if ((this19 == 0)) {
HXLINE( 451)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b21;
HXDLIN( 451)												int this20 = (col & 255);
HXDLIN( 451)												if ((this20 == 0)) {
HXLINE( 451)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 451)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 451)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 451)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 451)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 451)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 451)												{
HXLINE( 451)													int _hx_tmp2;
HXDLIN( 451)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 451)														_hx_tmp2 = blended;
            													}
HXDLIN( 451)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 451)												::Dynamic this21 = undoImage->image;
HXDLIN( 451)												int index2;
HXDLIN( 451)												if (undoImage->useVirtualPos) {
HXLINE( 451)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 451)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 451)												int _hx_tmp3;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													_hx_tmp3 = c2;
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 451)											if (forceClear) {
HXLINE( 451)												::Dynamic this22 = undoImage->image;
HXDLIN( 451)												int x2 = (dx1 - rectLeft);
HXDLIN( 451)												int y2 = (dy1 - rectTop);
HXDLIN( 451)												int index3;
HXDLIN( 451)												if (undoImage->useVirtualPos) {
HXLINE( 451)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 451)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 451)				bool foundY = false;
HXDLIN( 451)				Float s = ((Float)0.);
HXDLIN( 451)				Float t = ((Float)0.);
HXDLIN( 451)				Float sxx = ((Float)0.);
HXDLIN( 451)				Float txx = ((Float)0.);
HXDLIN( 451)				{
HXLINE( 451)					int _g_min = xIter3->start;
HXDLIN( 451)					int _g_max = xIter3->max;
HXDLIN( 451)					while((_g_min < _g_max)){
HXLINE( 451)						_g_min = (_g_min + 1);
HXDLIN( 451)						int x3 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)						txx = (tx * ( (Float)(x3) ));
HXLINE( 224)						foundY = false;
HXLINE( 451)						{
HXLINE( 451)							int _g_min1 = yIter3->start;
HXDLIN( 451)							int _g_max1 = yIter3->max;
HXDLIN( 451)							while((_g_min1 < _g_max1)){
HXLINE( 451)								_g_min1 = (_g_min1 + 1);
HXDLIN( 451)								int y3 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 451)								bool _hx_tmp4;
HXDLIN( 451)								if (!((s <= 0))) {
HXLINE( 451)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE( 451)									_hx_tmp4 = true;
            								}
HXDLIN( 451)								if (_hx_tmp4) {
HXLINE( 451)									if (foundY) {
HXLINE( 451)										goto _hx_goto_471;
            									}
            								}
            								else {
HXLINE( 451)									if (((s + t) < A)) {
HXLINE( 451)										int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 451)										int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 451)										::Dynamic this23 = tileImage->image;
HXDLIN( 451)										int index4;
HXDLIN( 451)										if (tileImage->useVirtualPos) {
HXLINE( 451)											index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            										}
            										else {
HXLINE( 451)											index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            										}
HXDLIN( 451)										int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 451)										int color;
HXDLIN( 451)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)											color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 451)											color = c3;
            										}
HXDLIN( 451)										{
HXLINE( 451)											int c4 = color;
HXDLIN( 451)											bool _hx_tmp5;
HXDLIN( 451)											if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 451)												_hx_tmp5 = pixelImage->transparent;
            											}
            											else {
HXLINE( 451)												_hx_tmp5 = false;
            											}
HXDLIN( 451)											if (_hx_tmp5) {
HXLINE( 451)												int location1;
HXDLIN( 451)												if (pixelImage->useVirtualPos) {
HXLINE( 451)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 451)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 451)												int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 451)												int this25;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													this25 = this24;
            												}
HXDLIN( 451)												Float a11;
HXDLIN( 451)												int this26 = ((this25 >> 24) & 255);
HXDLIN( 451)												if ((this26 == 0)) {
HXLINE( 451)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r11;
HXDLIN( 451)												int this27 = ((this25 >> 16) & 255);
HXDLIN( 451)												if ((this27 == 0)) {
HXLINE( 451)													r11 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g11;
HXDLIN( 451)												int this28 = ((this25 >> 8) & 255);
HXDLIN( 451)												if ((this28 == 0)) {
HXLINE( 451)													g11 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b12;
HXDLIN( 451)												int this29 = (this25 & 255);
HXDLIN( 451)												if ((this29 == 0)) {
HXLINE( 451)													b12 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a21;
HXDLIN( 451)												int this30 = ((color >> 24) & 255);
HXDLIN( 451)												if ((this30 == 0)) {
HXLINE( 451)													a21 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r21;
HXDLIN( 451)												int this31 = ((color >> 16) & 255);
HXDLIN( 451)												if ((this31 == 0)) {
HXLINE( 451)													r21 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g21;
HXDLIN( 451)												int this32 = ((color >> 8) & 255);
HXDLIN( 451)												if ((this32 == 0)) {
HXLINE( 451)													g21 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b22;
HXDLIN( 451)												int this33 = (color & 255);
HXDLIN( 451)												if ((this33 == 0)) {
HXLINE( 451)													b22 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 451)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 451)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 451)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 451)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 451)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 451)												{
HXLINE( 451)													int _hx_tmp6;
HXDLIN( 451)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE( 451)														_hx_tmp6 = blended1;
            													}
HXDLIN( 451)													::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE( 451)												::Dynamic this34 = pixelImage->image;
HXDLIN( 451)												int index5;
HXDLIN( 451)												if (pixelImage->useVirtualPos) {
HXLINE( 451)													index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 451)													index5 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 451)												int _hx_tmp7;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													_hx_tmp7 = c4;
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp7);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE( 451)										if (foundY) {
HXLINE( 451)											goto _hx_goto_471;
            										}
            									}
            								}
            							}
            							_hx_goto_471:;
            						}
            					}
            				}
HXDLIN( 451)				if ((hasHit == false)) {
HXLINE( 451)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 451)					if (hasUndo) {
HXLINE( 451)						v2->undoImage = undoImage;
HXDLIN( 451)						v2->undoX = xIter3->start;
HXDLIN( 451)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN( 451)		{
HXLINE( 451)			Float bx2 = cx;
HXDLIN( 451)			Float by2 = cy;
HXDLIN( 451)			Float cx2 = dx;
HXDLIN( 451)			Float cy2 = dy;
HXDLIN( 451)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN( 451)			if (!(adjustWinding1)) {
HXLINE( 451)				Float bx_1 = bx2;
HXDLIN( 451)				Float by_1 = by2;
HXLINE( 187)				bx2 = cx2;
HXLINE( 188)				by2 = cy2;
HXLINE( 189)				cx2 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE( 451)			{
HXLINE( 451)				bool hasUndo1 = false;
HXDLIN( 451)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN( 451)				Float sx1 = (cy2 - by);
HXDLIN( 451)				Float sy1 = (bx - cx2);
HXDLIN( 451)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN( 451)				Float tx1 = (by - by2);
HXDLIN( 451)				Float ty1 = (bx2 - bx);
HXDLIN( 451)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 451)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 451)				if ((bx > bx2)) {
HXLINE( 451)					if ((bx > cx2)) {
HXLINE( 451)						int min4;
HXDLIN( 451)						if ((bx2 > cx2)) {
HXLINE( 451)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 451)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 451)						int ii_min8 = min4;
HXDLIN( 451)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 451)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 451)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN( 451)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 451)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 451)					if ((bx2 > cx2)) {
HXLINE( 451)						int min5;
HXDLIN( 451)						if ((bx > cx2)) {
HXLINE( 451)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 451)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 451)						int ii_min10 = min5;
HXDLIN( 451)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN( 451)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 451)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 451)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 451)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 451)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 451)				if ((by > by2)) {
HXLINE( 451)					if ((by > cy2)) {
HXLINE( 451)						int min6;
HXDLIN( 451)						if ((by2 > cy2)) {
HXLINE( 451)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 451)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN( 451)						int ii_min12 = min6;
HXDLIN( 451)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 451)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 451)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN( 451)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 451)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 451)					if ((by2 > cy2)) {
HXLINE( 451)						int min7;
HXDLIN( 451)						if ((by > cy2)) {
HXLINE( 451)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 451)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN( 451)						int ii_min14 = min7;
HXDLIN( 451)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN( 451)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 451)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 451)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 451)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 451)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 451)				if (hasUndo1) {
HXLINE( 451)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 451)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 451)					 ::Dynamic imageType1 = null();
HXDLIN( 451)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 451)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 451)					::Dynamic undoImage4;
HXDLIN( 451)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 451)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 451)							{
HXLINE( 451)								b5->width = width1;
HXDLIN( 451)								b5->height = height1;
HXDLIN( 451)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 451)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 451)								{
HXLINE( 451)									int len2 = b5->length;
HXDLIN( 451)									int w1 = 0;
HXDLIN( 451)									{
HXLINE( 451)										int _g20 = 0;
HXDLIN( 451)										int _g21 = b5->height;
HXDLIN( 451)										while((_g20 < _g21)){
HXLINE( 451)											_g20 = (_g20 + 1);
HXDLIN( 451)											int y5 = (_g20 - 1);
HXDLIN( 451)											{
HXLINE( 451)												int _g22 = 0;
HXDLIN( 451)												int _g23 = b5->width;
HXDLIN( 451)												while((_g22 < _g23)){
HXLINE( 451)													_g22 = (_g22 + 1);
HXDLIN( 451)													int x5 = (_g22 - 1);
HXDLIN( 451)													{
HXLINE( 451)														w1 = (w1 + 1);
HXDLIN( 451)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w1 = (w1 + 1);
HXDLIN( 451)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w1 = (w1 + 1);
HXDLIN( 451)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 451)													{
HXLINE( 451)														w1 = (w1 + 1);
HXDLIN( 451)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE( 451)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 451)							{
HXLINE( 451)								a6->width = width1;
HXDLIN( 451)								a6->height = height1;
HXDLIN( 451)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 451)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 451)								{
HXLINE( 451)									int _g24 = 0;
HXDLIN( 451)									int _g25 = a6->length;
HXDLIN( 451)									while((_g24 < _g25)){
HXLINE( 451)										_g24 = (_g24 + 1);
HXDLIN( 451)										int i6 = (_g24 - 1);
HXDLIN( 451)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 451)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE( 451)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 451)							{
HXLINE( 451)								b6->width = width1;
HXDLIN( 451)								b6->height = height1;
HXDLIN( 451)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 451)								int size1 = (b6->length * 4);
HXDLIN( 451)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 451)								{
HXLINE( 451)									int _g26 = 0;
HXDLIN( 451)									int _g27 = b6->length;
HXDLIN( 451)									while((_g26 < _g27)){
HXLINE( 451)										_g26 = (_g26 + 1);
HXDLIN( 451)										int i7 = (_g26 - 1);
HXDLIN( 451)										{
HXLINE( 451)											 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 451)											bool undoImage5;
HXDLIN( 451)											if ((i7 >= 0)) {
HXLINE( 451)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXLINE( 451)												undoImage5 = false;
            											}
HXDLIN( 451)											if (undoImage5) {
HXLINE( 451)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 451)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 451)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 451)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 451)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 451)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE( 451)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 451)							{
HXLINE( 451)								v3->width = width1;
HXDLIN( 451)								v3->height = height1;
HXDLIN( 451)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 451)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 451)								{
HXLINE( 451)									int _g28 = 0;
HXDLIN( 451)									int _g29 = v3->length;
HXDLIN( 451)									while((_g28 < _g29)){
HXLINE( 451)										_g28 = (_g28 + 1);
HXDLIN( 451)										int i8 = (_g28 - 1);
HXDLIN( 451)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 451)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 451)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 451)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 451)							{
HXLINE( 451)								b7->width = width1;
HXDLIN( 451)								b7->height = height1;
HXDLIN( 451)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 451)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 451)								{
HXLINE( 451)									int len3 = b7->length;
HXDLIN( 451)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 451)									if (::hx::IsNull( d1->head )) {
HXLINE( 451)										int _g30 = 0;
HXDLIN( 451)										int _g31 = len3;
HXDLIN( 451)										while((_g30 < _g31)){
HXLINE( 451)											_g30 = (_g30 + 1);
HXDLIN( 451)											int i9 = (_g30 - 1);
HXDLIN( 451)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 451)										int _g32 = 0;
HXDLIN( 451)										int _g33 = len3;
HXDLIN( 451)										while((_g32 < _g33)){
HXLINE( 451)											_g32 = (_g32 + 1);
HXDLIN( 451)											int i10 = (_g32 - 1);
HXDLIN( 451)											{
HXLINE( 451)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 451)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 451)												{
HXLINE( 451)													int _g34 = 0;
HXDLIN( 451)													int _g35 = i10;
HXDLIN( 451)													while((_g34 < _g35)){
HXLINE( 451)														_g34 = (_g34 + 1);
HXDLIN( 451)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 451)												if (::hx::IsNull( prev1 )) {
HXLINE( 451)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 451)													l1 = null();
            												}
            												else {
HXLINE( 451)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 451)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 451)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN( 451)					this35->image = undoImage4;
HXDLIN( 451)					this35->width = width1;
HXDLIN( 451)					this35->height = height1;
HXDLIN( 451)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 451)					undoImage3 = this35;
HXDLIN( 451)					{
HXLINE( 451)						int rectLeft1 = xIter31->start;
HXDLIN( 451)						int rectTop1 = yIter31->start;
HXDLIN( 451)						int rectRight1 = xIter31->max;
HXDLIN( 451)						bool forceClear1 = false;
HXDLIN( 451)						{
HXLINE( 451)							int _g36 = rectTop1;
HXDLIN( 451)							int _g37 = yIter31->max;
HXDLIN( 451)							while((_g36 < _g37)){
HXLINE( 451)								_g36 = (_g36 + 1);
HXDLIN( 451)								int dy2 = (_g36 - 1);
HXDLIN( 451)								{
HXLINE( 451)									int _g38 = rectLeft1;
HXDLIN( 451)									int _g39 = rectRight1;
HXDLIN( 451)									while((_g38 < _g39)){
HXLINE( 451)										_g38 = (_g38 + 1);
HXDLIN( 451)										int dx2 = (_g38 - 1);
HXDLIN( 451)										::Dynamic this37 = pixelImage->image;
HXDLIN( 451)										int index6;
HXDLIN( 451)										if (pixelImage->useVirtualPos) {
HXLINE( 451)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 451)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 451)										int c5 = ::iterMagic::Iimg_obj::get(this37,index6);
HXDLIN( 451)										int col1;
HXDLIN( 451)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 451)											col1 = c5;
            										}
HXDLIN( 451)										bool _hx_tmp8;
HXDLIN( 451)										if (pixelImage->useMask) {
HXLINE( 451)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 451)											_hx_tmp8 = false;
            										}
HXDLIN( 451)										if (_hx_tmp8) {
HXLINE( 451)											 ::pi_xy::ImageStruct this38 = pixelImage->mask;
HXDLIN( 451)											::Dynamic this39 = this38->image;
HXDLIN( 451)											int index7;
HXDLIN( 451)											if (this38->useVirtualPos) {
HXLINE( 451)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXLINE( 451)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 451)											int c6 = ::iterMagic::Iimg_obj::get(this39,index7);
HXDLIN( 451)											int v4;
HXDLIN( 451)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)												v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 451)												v4 = c6;
            											}
HXDLIN( 451)											int maskPixel1 = v4;
HXDLIN( 451)											int this40 = col1;
HXDLIN( 451)											if ((maskPixel1 == 0)) {
HXLINE( 451)												col1 = this40;
            											}
            											else {
HXLINE( 451)												Float m01;
HXDLIN( 451)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 451)												if ((this41 == 0)) {
HXLINE( 451)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m11;
HXDLIN( 451)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 451)												if ((this42 == 0)) {
HXLINE( 451)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m21;
HXDLIN( 451)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 451)												if ((this43 == 0)) {
HXLINE( 451)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float m31;
HXDLIN( 451)												int this44 = (maskPixel1 & 255);
HXDLIN( 451)												if ((this44 == 0)) {
HXLINE( 451)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 451)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 451)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 451)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 451)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 451)										if ((col1 != 0)) {
HXLINE( 451)											int x6 = (dx2 - rectLeft1);
HXDLIN( 451)											int y6 = (dy2 - rectTop1);
HXDLIN( 451)											int c7 = col1;
HXDLIN( 451)											bool _hx_tmp9;
HXDLIN( 451)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 451)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE( 451)												_hx_tmp9 = false;
            											}
HXDLIN( 451)											if (_hx_tmp9) {
HXLINE( 451)												int location2;
HXDLIN( 451)												if (undoImage3->useVirtualPos) {
HXLINE( 451)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 451)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 451)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 451)												int this46;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													this46 = this45;
            												}
HXDLIN( 451)												Float a12;
HXDLIN( 451)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 451)												if ((this47 == 0)) {
HXLINE( 451)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r12;
HXDLIN( 451)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 451)												if ((this48 == 0)) {
HXLINE( 451)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g12;
HXDLIN( 451)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 451)												if ((this49 == 0)) {
HXLINE( 451)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b13;
HXDLIN( 451)												int this50 = (this46 & 255);
HXDLIN( 451)												if ((this50 == 0)) {
HXLINE( 451)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a22;
HXDLIN( 451)												int this51 = ((col1 >> 24) & 255);
HXDLIN( 451)												if ((this51 == 0)) {
HXLINE( 451)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r22;
HXDLIN( 451)												int this52 = ((col1 >> 16) & 255);
HXDLIN( 451)												if ((this52 == 0)) {
HXLINE( 451)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g22;
HXDLIN( 451)												int this53 = ((col1 >> 8) & 255);
HXDLIN( 451)												if ((this53 == 0)) {
HXLINE( 451)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b23;
HXDLIN( 451)												int this54 = (col1 & 255);
HXDLIN( 451)												if ((this54 == 0)) {
HXLINE( 451)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 451)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 451)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 451)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 451)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 451)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 451)												{
HXLINE( 451)													int _hx_tmp10;
HXDLIN( 451)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 451)														_hx_tmp10 = blended2;
            													}
HXDLIN( 451)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE( 451)												::Dynamic this55 = undoImage3->image;
HXDLIN( 451)												int index8;
HXDLIN( 451)												if (undoImage3->useVirtualPos) {
HXLINE( 451)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 451)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 451)												int _hx_tmp11;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													_hx_tmp11 = c7;
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this55,index8,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 451)											if (forceClear1) {
HXLINE( 451)												::Dynamic this56 = undoImage3->image;
HXDLIN( 451)												int x7 = (dx2 - rectLeft1);
HXDLIN( 451)												int y7 = (dy2 - rectTop1);
HXDLIN( 451)												int index9;
HXDLIN( 451)												if (undoImage3->useVirtualPos) {
HXLINE( 451)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 451)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this56,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 451)				bool foundY1 = false;
HXDLIN( 451)				Float s1 = ((Float)0.);
HXDLIN( 451)				Float t1 = ((Float)0.);
HXDLIN( 451)				Float sxx1 = ((Float)0.);
HXDLIN( 451)				Float txx1 = ((Float)0.);
HXDLIN( 451)				{
HXLINE( 451)					int _g_min2 = xIter31->start;
HXDLIN( 451)					int _g_max2 = xIter31->max;
HXDLIN( 451)					while((_g_min2 < _g_max2)){
HXLINE( 451)						_g_min2 = (_g_min2 + 1);
HXDLIN( 451)						int x8 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)						foundY1 = false;
HXLINE( 451)						{
HXLINE( 451)							int _g_min3 = yIter31->start;
HXDLIN( 451)							int _g_max3 = yIter31->max;
HXDLIN( 451)							while((_g_min3 < _g_max3)){
HXLINE( 451)								_g_min3 = (_g_min3 + 1);
HXDLIN( 451)								int y8 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 451)								bool _hx_tmp12;
HXDLIN( 451)								if (!((s1 <= 0))) {
HXLINE( 451)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXLINE( 451)									_hx_tmp12 = true;
            								}
HXDLIN( 451)								if (_hx_tmp12) {
HXLINE( 451)									if (foundY1) {
HXLINE( 451)										goto _hx_goto_483;
            									}
            								}
            								else {
HXLINE( 451)									if (((s1 + t1) < A1)) {
HXLINE( 451)										int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 451)										int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 451)										::Dynamic this57 = tileImage->image;
HXDLIN( 451)										int index10;
HXDLIN( 451)										if (tileImage->useVirtualPos) {
HXLINE( 451)											index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            										}
            										else {
HXLINE( 451)											index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            										}
HXDLIN( 451)										int c8 = ::iterMagic::Iimg_obj::get(this57,index10);
HXDLIN( 451)										int color1;
HXDLIN( 451)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)											color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 451)											color1 = c8;
            										}
HXDLIN( 451)										{
HXLINE( 451)											int c9 = color1;
HXDLIN( 451)											bool _hx_tmp13;
HXDLIN( 451)											if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 451)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE( 451)												_hx_tmp13 = false;
            											}
HXDLIN( 451)											if (_hx_tmp13) {
HXLINE( 451)												int location3;
HXDLIN( 451)												if (pixelImage->useVirtualPos) {
HXLINE( 451)													location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x8) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 451)													location3 = ::Std_obj::_hx_int(( (Float)(((y8 * pixelImage->width) + x8)) ));
            												}
HXDLIN( 451)												int this58 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 451)												int this59;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													this59 = this58;
            												}
HXDLIN( 451)												Float a13;
HXDLIN( 451)												int this60 = ((this59 >> 24) & 255);
HXDLIN( 451)												if ((this60 == 0)) {
HXLINE( 451)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r13;
HXDLIN( 451)												int this61 = ((this59 >> 16) & 255);
HXDLIN( 451)												if ((this61 == 0)) {
HXLINE( 451)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g13;
HXDLIN( 451)												int this62 = ((this59 >> 8) & 255);
HXDLIN( 451)												if ((this62 == 0)) {
HXLINE( 451)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b14;
HXDLIN( 451)												int this63 = (this59 & 255);
HXDLIN( 451)												if ((this63 == 0)) {
HXLINE( 451)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a23;
HXDLIN( 451)												int this64 = ((color1 >> 24) & 255);
HXDLIN( 451)												if ((this64 == 0)) {
HXLINE( 451)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float r23;
HXDLIN( 451)												int this65 = ((color1 >> 16) & 255);
HXDLIN( 451)												if ((this65 == 0)) {
HXLINE( 451)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float g23;
HXDLIN( 451)												int this66 = ((color1 >> 8) & 255);
HXDLIN( 451)												if ((this66 == 0)) {
HXLINE( 451)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float b24;
HXDLIN( 451)												int this67 = (color1 & 255);
HXDLIN( 451)												if ((this67 == 0)) {
HXLINE( 451)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 451)													b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN( 451)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 451)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 451)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 451)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 451)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 451)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 451)												{
HXLINE( 451)													int _hx_tmp14;
HXDLIN( 451)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 451)														_hx_tmp14 = blended3;
            													}
HXDLIN( 451)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 451)												::Dynamic this68 = pixelImage->image;
HXDLIN( 451)												int index11;
HXDLIN( 451)												if (pixelImage->useVirtualPos) {
HXLINE( 451)													index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x8) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 451)													index11 = ::Std_obj::_hx_int(( (Float)(((y8 * pixelImage->width) + x8)) ));
            												}
HXDLIN( 451)												int _hx_tmp15;
HXDLIN( 451)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 451)													_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 451)													_hx_tmp15 = c9;
            												}
HXDLIN( 451)												::iterMagic::Iimg_obj::set(this68,index11,_hx_tmp15);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXLINE( 451)										if (foundY1) {
HXLINE( 451)											goto _hx_goto_483;
            										}
            									}
            								}
            							}
            							_hx_goto_483:;
            						}
            					}
            				}
HXDLIN( 451)				if ((hasHit == false)) {
HXLINE( 451)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN( 451)					if (hasUndo1) {
HXLINE( 451)						v5->undoImage = undoImage3;
HXDLIN( 451)						v5->undoX = xIter31->start;
HXDLIN( 451)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN( 451)		if ((hasHit == true)) {
HXLINE( 451)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 451)			return v6;
            		}
            		else {
HXLINE( 451)			return null();
            		}
HXDLIN( 451)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(LinePixel_Fields__obj,rotateTileLineFlare,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateGradLine( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick,Float h,Float theta,int colorA,int colorB,int colorC,int colorD,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_461_rotateGradLine)
HXLINE( 462)		Float sin = ::Math_obj::sin(theta);
HXLINE( 463)		Float cos = ::Math_obj::cos(theta);
HXLINE( 464)		Float radius = (thick / ( (Float)(2) ));
HXLINE( 465)		Float dx = ((Float)0.1);
HXLINE( 466)		Float dy = radius;
HXLINE( 467)		Float cx = h;
HXLINE( 468)		Float cy = radius;
HXLINE( 469)		Float bx = h;
HXLINE( 470)		Float by = -(radius);
HXLINE( 471)		Float ax = ((Float)0.1);
HXLINE( 472)		Float ay = -(radius);
HXLINE( 473)		Float temp = ((Float)0.);
HXLINE( 474)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)		ax = temp;
HXLINE( 478)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)		bx = temp;
HXLINE( 482)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)		cx = temp;
HXLINE( 486)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)		dx = temp;
HXLINE( 495)		if (( (bool)(debugCorners) )) {
HXLINE( 496)			{
HXLINE( 496)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN( 496)				{
HXLINE( 496)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN( 496)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN( 496)					int r_w = 12;
HXDLIN( 496)					int r_h = 12;
HXDLIN( 496)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 496)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 496)					int ii_min = r_x;
HXDLIN( 496)					int ii_max = xmax;
HXDLIN( 496)					int xRange__start = ii_min;
HXDLIN( 496)					int xRange__max = ii_max;
HXDLIN( 496)					int ii_min1 = r_y;
HXDLIN( 496)					int ii_max1 = ymax;
HXDLIN( 496)					int yRange__start = ii_min1;
HXDLIN( 496)					int yRange__max = ii_max1;
HXDLIN( 496)					int range_x = xRange__start;
HXDLIN( 496)					int range_y = (yRange__start - 1);
HXDLIN( 496)					int range_xReset = range_x;
HXDLIN( 496)					int range_yReset = range_y;
HXDLIN( 496)					int range_xMax = (xRange__max - 2);
HXDLIN( 496)					int range_yMax = (yRange__max - 2);
HXDLIN( 496)					int _this_min = 0;
HXDLIN( 496)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 496)					while((_this_min < _this_max)){
HXLINE( 496)						_this_min = (_this_min + 1);
HXDLIN( 496)						int i = (_this_min - 1);
HXDLIN( 496)						if ((range_y > range_yMax)) {
HXLINE( 496)							range_y = range_yReset;
HXDLIN( 496)							range_x = (range_x + 1);
            						}
HXDLIN( 496)						range_y = (range_y + 1);
HXDLIN( 496)						int i1 = i;
HXDLIN( 496)						{
HXLINE( 496)							int x = range_x;
HXDLIN( 496)							int y = range_y;
HXDLIN( 496)							int c = colorA;
HXDLIN( 496)							bool _hx_tmp;
HXDLIN( 496)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 496)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 496)								_hx_tmp = false;
            							}
HXDLIN( 496)							if (_hx_tmp) {
HXLINE( 496)								int location;
HXDLIN( 496)								if (this1->useVirtualPos) {
HXLINE( 496)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 496)									location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 496)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 496)								int this3;
HXDLIN( 496)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 496)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 496)									this3 = this2;
            								}
HXDLIN( 496)								Float a1;
HXDLIN( 496)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 496)								if ((this4 == 0)) {
HXLINE( 496)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float r1;
HXDLIN( 496)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 496)								if ((this5 == 0)) {
HXLINE( 496)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float g1;
HXDLIN( 496)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 496)								if ((this6 == 0)) {
HXLINE( 496)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float b1;
HXDLIN( 496)								int this7 = (this3 & 255);
HXDLIN( 496)								if ((this7 == 0)) {
HXLINE( 496)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float a2;
HXDLIN( 496)								int this8 = ((colorA >> 24) & 255);
HXDLIN( 496)								if ((this8 == 0)) {
HXLINE( 496)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float r2;
HXDLIN( 496)								int this9 = ((colorA >> 16) & 255);
HXDLIN( 496)								if ((this9 == 0)) {
HXLINE( 496)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float g2;
HXDLIN( 496)								int this10 = ((colorA >> 8) & 255);
HXDLIN( 496)								if ((this10 == 0)) {
HXLINE( 496)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float b2;
HXDLIN( 496)								int this11 = (colorA & 255);
HXDLIN( 496)								if ((this11 == 0)) {
HXLINE( 496)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 496)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 496)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 496)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 496)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 496)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 496)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 496)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 496)								{
HXLINE( 496)									int _hx_tmp1;
HXDLIN( 496)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 496)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 496)										_hx_tmp1 = blended;
            									}
HXDLIN( 496)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 496)								::Dynamic this12 = this1->image;
HXDLIN( 496)								int index;
HXDLIN( 496)								if (this1->useVirtualPos) {
HXLINE( 496)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE( 496)									index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            								}
HXDLIN( 496)								int _hx_tmp2;
HXDLIN( 496)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 496)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 496)									_hx_tmp2 = c;
            								}
HXDLIN( 496)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE( 497)			{
HXLINE( 497)				 ::pi_xy::ImageStruct this13 = pixelImage;
HXDLIN( 497)				{
HXLINE( 497)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN( 497)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN( 497)					int r_w1 = 12;
HXDLIN( 497)					int r_h1 = 12;
HXDLIN( 497)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 497)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 497)					int ii_min2 = r_x1;
HXDLIN( 497)					int ii_max2 = xmax1;
HXDLIN( 497)					int xRange__start1 = ii_min2;
HXDLIN( 497)					int xRange__max1 = ii_max2;
HXDLIN( 497)					int ii_min3 = r_y1;
HXDLIN( 497)					int ii_max3 = ymax1;
HXDLIN( 497)					int yRange__start1 = ii_min3;
HXDLIN( 497)					int yRange__max1 = ii_max3;
HXDLIN( 497)					int range_x1 = xRange__start1;
HXDLIN( 497)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 497)					int range_xReset1 = range_x1;
HXDLIN( 497)					int range_yReset1 = range_y1;
HXDLIN( 497)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 497)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 497)					int _this_min1 = 0;
HXDLIN( 497)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 497)					while((_this_min1 < _this_max1)){
HXLINE( 497)						_this_min1 = (_this_min1 + 1);
HXDLIN( 497)						int i2 = (_this_min1 - 1);
HXDLIN( 497)						if ((range_y1 > range_yMax1)) {
HXLINE( 497)							range_y1 = range_yReset1;
HXDLIN( 497)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 497)						range_y1 = (range_y1 + 1);
HXDLIN( 497)						int i3 = i2;
HXDLIN( 497)						{
HXLINE( 497)							int x1 = range_x1;
HXDLIN( 497)							int y1 = range_y1;
HXDLIN( 497)							int c1 = colorB;
HXDLIN( 497)							bool _hx_tmp3;
HXDLIN( 497)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 497)								_hx_tmp3 = this13->transparent;
            							}
            							else {
HXLINE( 497)								_hx_tmp3 = false;
            							}
HXDLIN( 497)							if (_hx_tmp3) {
HXLINE( 497)								int location1;
HXDLIN( 497)								if (this13->useVirtualPos) {
HXLINE( 497)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 497)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 497)								int this14 = ::iterMagic::Iimg_obj::get(this13->image,location1);
HXDLIN( 497)								int this15;
HXDLIN( 497)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 497)									this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            								}
            								else {
HXLINE( 497)									this15 = this14;
            								}
HXDLIN( 497)								Float a11;
HXDLIN( 497)								int this16 = ((this15 >> 24) & 255);
HXDLIN( 497)								if ((this16 == 0)) {
HXLINE( 497)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float r11;
HXDLIN( 497)								int this17 = ((this15 >> 16) & 255);
HXDLIN( 497)								if ((this17 == 0)) {
HXLINE( 497)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									r11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float g11;
HXDLIN( 497)								int this18 = ((this15 >> 8) & 255);
HXDLIN( 497)								if ((this18 == 0)) {
HXLINE( 497)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									g11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float b11;
HXDLIN( 497)								int this19 = (this15 & 255);
HXDLIN( 497)								if ((this19 == 0)) {
HXLINE( 497)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float a21;
HXDLIN( 497)								int this20 = ((colorB >> 24) & 255);
HXDLIN( 497)								if ((this20 == 0)) {
HXLINE( 497)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									a21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float r21;
HXDLIN( 497)								int this21 = ((colorB >> 16) & 255);
HXDLIN( 497)								if ((this21 == 0)) {
HXLINE( 497)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									r21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float g21;
HXDLIN( 497)								int this22 = ((colorB >> 8) & 255);
HXDLIN( 497)								if ((this22 == 0)) {
HXLINE( 497)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									g21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float b21;
HXDLIN( 497)								int this23 = (colorB & 255);
HXDLIN( 497)								if ((this23 == 0)) {
HXLINE( 497)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 497)									b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN( 497)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 497)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 497)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 497)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 497)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 497)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 497)								{
HXLINE( 497)									int _hx_tmp4;
HXDLIN( 497)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 497)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 497)										_hx_tmp4 = blended1;
            									}
HXDLIN( 497)									::iterMagic::Iimg_obj::set(this13->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 497)								::Dynamic this24 = this13->image;
HXDLIN( 497)								int index1;
HXDLIN( 497)								if (this13->useVirtualPos) {
HXLINE( 497)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this13->virtualY) * ( (Float)(this13->width) )) + x1) - this13->virtualX));
            								}
            								else {
HXLINE( 497)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this13->width) + x1)) ));
            								}
HXDLIN( 497)								int _hx_tmp5;
HXDLIN( 497)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 497)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 497)									_hx_tmp5 = c1;
            								}
HXDLIN( 497)								::iterMagic::Iimg_obj::set(this24,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXLINE( 498)			{
HXLINE( 498)				 ::pi_xy::ImageStruct this25 = pixelImage;
HXDLIN( 498)				{
HXLINE( 498)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN( 498)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN( 498)					int r_w2 = 12;
HXDLIN( 498)					int r_h2 = 12;
HXDLIN( 498)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 498)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 498)					int ii_min4 = r_x2;
HXDLIN( 498)					int ii_max4 = xmax2;
HXDLIN( 498)					int xRange__start2 = ii_min4;
HXDLIN( 498)					int xRange__max2 = ii_max4;
HXDLIN( 498)					int ii_min5 = r_y2;
HXDLIN( 498)					int ii_max5 = ymax2;
HXDLIN( 498)					int yRange__start2 = ii_min5;
HXDLIN( 498)					int yRange__max2 = ii_max5;
HXDLIN( 498)					int range_x2 = xRange__start2;
HXDLIN( 498)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 498)					int range_xReset2 = range_x2;
HXDLIN( 498)					int range_yReset2 = range_y2;
HXDLIN( 498)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 498)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 498)					int _this_min2 = 0;
HXDLIN( 498)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 498)					while((_this_min2 < _this_max2)){
HXLINE( 498)						_this_min2 = (_this_min2 + 1);
HXDLIN( 498)						int i4 = (_this_min2 - 1);
HXDLIN( 498)						if ((range_y2 > range_yMax2)) {
HXLINE( 498)							range_y2 = range_yReset2;
HXDLIN( 498)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 498)						range_y2 = (range_y2 + 1);
HXDLIN( 498)						int i5 = i4;
HXDLIN( 498)						{
HXLINE( 498)							int x2 = range_x2;
HXDLIN( 498)							int y2 = range_y2;
HXDLIN( 498)							int c2 = colorC;
HXDLIN( 498)							bool _hx_tmp6;
HXDLIN( 498)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 498)								_hx_tmp6 = this25->transparent;
            							}
            							else {
HXLINE( 498)								_hx_tmp6 = false;
            							}
HXDLIN( 498)							if (_hx_tmp6) {
HXLINE( 498)								int location2;
HXDLIN( 498)								if (this25->useVirtualPos) {
HXLINE( 498)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 498)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 498)								int this26 = ::iterMagic::Iimg_obj::get(this25->image,location2);
HXDLIN( 498)								int this27;
HXDLIN( 498)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 498)									this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            								}
            								else {
HXLINE( 498)									this27 = this26;
            								}
HXDLIN( 498)								Float a12;
HXDLIN( 498)								int this28 = ((this27 >> 24) & 255);
HXDLIN( 498)								if ((this28 == 0)) {
HXLINE( 498)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									a12 = (( (Float)(this28) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float r12;
HXDLIN( 498)								int this29 = ((this27 >> 16) & 255);
HXDLIN( 498)								if ((this29 == 0)) {
HXLINE( 498)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									r12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float g12;
HXDLIN( 498)								int this30 = ((this27 >> 8) & 255);
HXDLIN( 498)								if ((this30 == 0)) {
HXLINE( 498)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									g12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float b12;
HXDLIN( 498)								int this31 = (this27 & 255);
HXDLIN( 498)								if ((this31 == 0)) {
HXLINE( 498)									b12 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float a22;
HXDLIN( 498)								int this32 = ((colorC >> 24) & 255);
HXDLIN( 498)								if ((this32 == 0)) {
HXLINE( 498)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									a22 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float r22;
HXDLIN( 498)								int this33 = ((colorC >> 16) & 255);
HXDLIN( 498)								if ((this33 == 0)) {
HXLINE( 498)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									r22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float g22;
HXDLIN( 498)								int this34 = ((colorC >> 8) & 255);
HXDLIN( 498)								if ((this34 == 0)) {
HXLINE( 498)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									g22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float b22;
HXDLIN( 498)								int this35 = (colorC & 255);
HXDLIN( 498)								if ((this35 == 0)) {
HXLINE( 498)									b22 = ((Float)0.);
            								}
            								else {
HXLINE( 498)									b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 498)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 498)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 498)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 498)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN( 498)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 498)								int blended2 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN( 498)								{
HXLINE( 498)									int _hx_tmp7;
HXDLIN( 498)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 498)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 498)										_hx_tmp7 = blended2;
            									}
HXDLIN( 498)									::iterMagic::Iimg_obj::set(this25->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE( 498)								::Dynamic this36 = this25->image;
HXDLIN( 498)								int index2;
HXDLIN( 498)								if (this25->useVirtualPos) {
HXLINE( 498)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this25->virtualY) * ( (Float)(this25->width) )) + x2) - this25->virtualX));
            								}
            								else {
HXLINE( 498)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this25->width) + x2)) ));
            								}
HXDLIN( 498)								int _hx_tmp8;
HXDLIN( 498)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 498)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE( 498)									_hx_tmp8 = c2;
            								}
HXDLIN( 498)								::iterMagic::Iimg_obj::set(this36,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXLINE( 499)			{
HXLINE( 499)				 ::pi_xy::ImageStruct this37 = pixelImage;
HXDLIN( 499)				{
HXLINE( 499)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN( 499)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN( 499)					int r_w3 = 12;
HXDLIN( 499)					int r_h3 = 12;
HXDLIN( 499)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN( 499)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN( 499)					int ii_min6 = r_x3;
HXDLIN( 499)					int ii_max6 = xmax3;
HXDLIN( 499)					int xRange__start3 = ii_min6;
HXDLIN( 499)					int xRange__max3 = ii_max6;
HXDLIN( 499)					int ii_min7 = r_y3;
HXDLIN( 499)					int ii_max7 = ymax3;
HXDLIN( 499)					int yRange__start3 = ii_min7;
HXDLIN( 499)					int yRange__max3 = ii_max7;
HXDLIN( 499)					int range_x3 = xRange__start3;
HXDLIN( 499)					int range_y3 = (yRange__start3 - 1);
HXDLIN( 499)					int range_xReset3 = range_x3;
HXDLIN( 499)					int range_yReset3 = range_y3;
HXDLIN( 499)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN( 499)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN( 499)					int _this_min3 = 0;
HXDLIN( 499)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN( 499)					while((_this_min3 < _this_max3)){
HXLINE( 499)						_this_min3 = (_this_min3 + 1);
HXDLIN( 499)						int i6 = (_this_min3 - 1);
HXDLIN( 499)						if ((range_y3 > range_yMax3)) {
HXLINE( 499)							range_y3 = range_yReset3;
HXDLIN( 499)							range_x3 = (range_x3 + 1);
            						}
HXDLIN( 499)						range_y3 = (range_y3 + 1);
HXDLIN( 499)						int i7 = i6;
HXDLIN( 499)						{
HXLINE( 499)							int x3 = range_x3;
HXDLIN( 499)							int y3 = range_y3;
HXDLIN( 499)							int c3 = colorD;
HXDLIN( 499)							bool _hx_tmp9;
HXDLIN( 499)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 499)								_hx_tmp9 = this37->transparent;
            							}
            							else {
HXLINE( 499)								_hx_tmp9 = false;
            							}
HXDLIN( 499)							if (_hx_tmp9) {
HXLINE( 499)								int location3;
HXDLIN( 499)								if (this37->useVirtualPos) {
HXLINE( 499)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 499)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 499)								int this38 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 499)								int this39;
HXDLIN( 499)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 499)									this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            								}
            								else {
HXLINE( 499)									this39 = this38;
            								}
HXDLIN( 499)								Float a13;
HXDLIN( 499)								int this40 = ((this39 >> 24) & 255);
HXDLIN( 499)								if ((this40 == 0)) {
HXLINE( 499)									a13 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float r13;
HXDLIN( 499)								int this41 = ((this39 >> 16) & 255);
HXDLIN( 499)								if ((this41 == 0)) {
HXLINE( 499)									r13 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float g13;
HXDLIN( 499)								int this42 = ((this39 >> 8) & 255);
HXDLIN( 499)								if ((this42 == 0)) {
HXLINE( 499)									g13 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float b13;
HXDLIN( 499)								int this43 = (this39 & 255);
HXDLIN( 499)								if ((this43 == 0)) {
HXLINE( 499)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float a23;
HXDLIN( 499)								int this44 = ((colorD >> 24) & 255);
HXDLIN( 499)								if ((this44 == 0)) {
HXLINE( 499)									a23 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float r23;
HXDLIN( 499)								int this45 = ((colorD >> 16) & 255);
HXDLIN( 499)								if ((this45 == 0)) {
HXLINE( 499)									r23 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float g23;
HXDLIN( 499)								int this46 = ((colorD >> 8) & 255);
HXDLIN( 499)								if ((this46 == 0)) {
HXLINE( 499)									g23 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float b23;
HXDLIN( 499)								int this47 = (colorD & 255);
HXDLIN( 499)								if ((this47 == 0)) {
HXLINE( 499)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 499)									b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN( 499)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 499)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 499)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 499)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN( 499)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 499)								int blended3 = ((((a6 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN( 499)								{
HXLINE( 499)									int _hx_tmp10;
HXDLIN( 499)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 499)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE( 499)										_hx_tmp10 = blended3;
            									}
HXDLIN( 499)									::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE( 499)								::Dynamic this48 = this37->image;
HXDLIN( 499)								int index3;
HXDLIN( 499)								if (this37->useVirtualPos) {
HXLINE( 499)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this37->virtualY) * ( (Float)(this37->width) )) + x3) - this37->virtualX));
            								}
            								else {
HXLINE( 499)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this37->width) + x3)) ));
            								}
HXDLIN( 499)								int _hx_tmp11;
HXDLIN( 499)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 499)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 499)									_hx_tmp11 = c3;
            								}
HXDLIN( 499)								::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 501)		{
HXLINE( 501)			bool hasUndo = false;
HXDLIN( 501)			int aA = ((colorB >> 24) & 255);
HXDLIN( 501)			int rA = ((colorB >> 16) & 255);
HXDLIN( 501)			int gA = ((colorB >> 8) & 255);
HXDLIN( 501)			int bA = (colorB & 255);
HXDLIN( 501)			int aB = ((colorA >> 24) & 255);
HXDLIN( 501)			int rB = ((colorA >> 16) & 255);
HXDLIN( 501)			int gB = ((colorA >> 8) & 255);
HXDLIN( 501)			int bB = (colorA & 255);
HXDLIN( 501)			int aC = ((colorD >> 24) & 255);
HXDLIN( 501)			int rC = ((colorD >> 16) & 255);
HXDLIN( 501)			int gC = ((colorD >> 8) & 255);
HXDLIN( 501)			int bC = (colorD & 255);
HXDLIN( 501)			Float bcx = (bx - dx);
HXDLIN( 501)			Float bcy = (by - dy);
HXDLIN( 501)			Float acx = (ax - dx);
HXDLIN( 501)			Float acy = (ay - dy);
HXDLIN( 501)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 501)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 501)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 501)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 501)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 501)			if ((ax > bx)) {
HXLINE( 501)				if ((ax > dx)) {
HXLINE( 501)					int min;
HXDLIN( 501)					if ((bx > dx)) {
HXLINE( 501)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 501)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 501)					int ii_min8 = min;
HXDLIN( 501)					int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 501)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 501)					int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 501)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 501)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 501)				if ((bx > dx)) {
HXLINE( 501)					int min1;
HXDLIN( 501)					if ((ax > dx)) {
HXLINE( 501)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 501)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 501)					int ii_min10 = min1;
HXDLIN( 501)					int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 501)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 501)					int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 501)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 501)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 501)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 501)			if ((ay > by)) {
HXLINE( 501)				if ((ay > dy)) {
HXLINE( 501)					int min2;
HXDLIN( 501)					if ((by > dy)) {
HXLINE( 501)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 501)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 501)					int ii_min12 = min2;
HXDLIN( 501)					int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 501)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 501)					int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 501)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 501)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 501)				if ((by > dy)) {
HXLINE( 501)					int min3;
HXDLIN( 501)					if ((ay > dy)) {
HXLINE( 501)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 501)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 501)					int ii_min14 = min3;
HXDLIN( 501)					int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 501)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 501)					int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 501)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 501)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 501)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 501)			if (hasUndo) {
HXLINE( 501)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 501)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 501)				 ::Dynamic imageType = null();
HXDLIN( 501)				 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 501)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 501)				::Dynamic undoImage1;
HXDLIN( 501)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 501)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::BytesImg b6 = byt;
HXDLIN( 501)						{
HXLINE( 501)							b6->width = width;
HXDLIN( 501)							b6->height = height;
HXDLIN( 501)							b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 501)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 501)							{
HXLINE( 501)								int len = b6->length;
HXDLIN( 501)								int w = 0;
HXDLIN( 501)								{
HXLINE( 501)									int _g = 0;
HXDLIN( 501)									int _g1 = b6->height;
HXDLIN( 501)									while((_g < _g1)){
HXLINE( 501)										_g = (_g + 1);
HXDLIN( 501)										int y4 = (_g - 1);
HXDLIN( 501)										{
HXLINE( 501)											int _g2 = 0;
HXDLIN( 501)											int _g3 = b6->width;
HXDLIN( 501)											while((_g2 < _g3)){
HXLINE( 501)												_g2 = (_g2 + 1);
HXDLIN( 501)												int x4 = (_g2 - 1);
HXDLIN( 501)												{
HXLINE( 501)													w = (w + 1);
HXDLIN( 501)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w = (w + 1);
HXDLIN( 501)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w = (w + 1);
HXDLIN( 501)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w = (w + 1);
HXDLIN( 501)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage1 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 501)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::ArrIntImg a7 = arrI;
HXDLIN( 501)						{
HXLINE( 501)							a7->width = width;
HXDLIN( 501)							a7->height = height;
HXDLIN( 501)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 501)							a7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 501)							{
HXLINE( 501)								int _g4 = 0;
HXDLIN( 501)								int _g5 = a7->length;
HXDLIN( 501)								while((_g4 < _g5)){
HXLINE( 501)									_g4 = (_g4 + 1);
HXDLIN( 501)									int i8 = (_g4 - 1);
HXDLIN( 501)									a7->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 501)						undoImage1 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 501)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN( 501)						{
HXLINE( 501)							b7->width = width;
HXDLIN( 501)							b7->height = height;
HXDLIN( 501)							b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 501)							int size = (b7->length * 4);
HXDLIN( 501)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 501)							{
HXLINE( 501)								int _g6 = 0;
HXDLIN( 501)								int _g7 = b7->length;
HXDLIN( 501)								while((_g6 < _g7)){
HXLINE( 501)									_g6 = (_g6 + 1);
HXDLIN( 501)									int i9 = (_g6 - 1);
HXDLIN( 501)									{
HXLINE( 501)										 ::haxe::io::ArrayBufferViewImpl this50 = b7->data;
HXDLIN( 501)										bool undoImage2;
HXDLIN( 501)										if ((i9 >= 0)) {
HXLINE( 501)											undoImage2 = (i9 < (this50->byteLength >> 2));
            										}
            										else {
HXLINE( 501)											undoImage2 = false;
            										}
HXDLIN( 501)										if (undoImage2) {
HXLINE( 501)											 ::haxe::io::Bytes _this = this50->bytes;
HXDLIN( 501)											int pos = ((i9 << 2) + this50->byteOffset);
HXDLIN( 501)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 501)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 501)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 501)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage1 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 501)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 501)						{
HXLINE( 501)							v->width = width;
HXDLIN( 501)							v->height = height;
HXDLIN( 501)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 501)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 501)							{
HXLINE( 501)								int _g8 = 0;
HXDLIN( 501)								int _g9 = v->length;
HXDLIN( 501)								while((_g8 < _g9)){
HXLINE( 501)									_g8 = (_g8 + 1);
HXDLIN( 501)									int i10 = (_g8 - 1);
HXDLIN( 501)									v->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 501)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 501)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN( 501)						{
HXLINE( 501)							b8->width = width;
HXDLIN( 501)							b8->height = height;
HXDLIN( 501)							b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 501)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 501)							{
HXLINE( 501)								int len1 = b8->length;
HXDLIN( 501)								 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN( 501)								if (::hx::IsNull( d->head )) {
HXLINE( 501)									int _g10 = 0;
HXDLIN( 501)									int _g11 = len1;
HXDLIN( 501)									while((_g10 < _g11)){
HXLINE( 501)										_g10 = (_g10 + 1);
HXDLIN( 501)										int i11 = (_g10 - 1);
HXDLIN( 501)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 501)									int _g12 = 0;
HXDLIN( 501)									int _g13 = len1;
HXDLIN( 501)									while((_g12 < _g13)){
HXLINE( 501)										_g12 = (_g12 + 1);
HXDLIN( 501)										int i12 = (_g12 - 1);
HXDLIN( 501)										{
HXLINE( 501)											 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN( 501)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 501)											{
HXLINE( 501)												int _g14 = 0;
HXDLIN( 501)												int _g15 = i12;
HXDLIN( 501)												while((_g14 < _g15)){
HXLINE( 501)													_g14 = (_g14 + 1);
HXDLIN( 501)													int i13 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 501)											if (::hx::IsNull( prev )) {
HXLINE( 501)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 501)												l = null();
            											}
            											else {
HXLINE( 501)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 501)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage1 = b8;
            					}
            					break;
            				}
HXDLIN( 501)				this49->image = undoImage1;
HXDLIN( 501)				this49->width = width;
HXDLIN( 501)				this49->height = height;
HXDLIN( 501)				this49->imageType = ( (int)(imageType) );
HXDLIN( 501)				undoImage = this49;
HXDLIN( 501)				{
HXLINE( 501)					int rectLeft = xIter3->start;
HXDLIN( 501)					int rectTop = yIter3->start;
HXDLIN( 501)					int rectRight = xIter3->max;
HXDLIN( 501)					bool forceClear = false;
HXDLIN( 501)					{
HXLINE( 501)						int _g16 = rectTop;
HXDLIN( 501)						int _g17 = yIter3->max;
HXDLIN( 501)						while((_g16 < _g17)){
HXLINE( 501)							_g16 = (_g16 + 1);
HXDLIN( 501)							int dy1 = (_g16 - 1);
HXDLIN( 501)							{
HXLINE( 501)								int _g18 = rectLeft;
HXDLIN( 501)								int _g19 = rectRight;
HXDLIN( 501)								while((_g18 < _g19)){
HXLINE( 501)									_g18 = (_g18 + 1);
HXDLIN( 501)									int dx1 = (_g18 - 1);
HXDLIN( 501)									::Dynamic this51 = pixelImage->image;
HXDLIN( 501)									int index4;
HXDLIN( 501)									if (pixelImage->useVirtualPos) {
HXLINE( 501)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 501)										index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 501)									int c4 = ::iterMagic::Iimg_obj::get(this51,index4);
HXDLIN( 501)									int col;
HXDLIN( 501)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)										col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 501)										col = c4;
            									}
HXDLIN( 501)									bool _hx_tmp12;
HXDLIN( 501)									if (pixelImage->useMask) {
HXLINE( 501)										_hx_tmp12 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 501)										_hx_tmp12 = false;
            									}
HXDLIN( 501)									if (_hx_tmp12) {
HXLINE( 501)										 ::pi_xy::ImageStruct this52 = pixelImage->mask;
HXDLIN( 501)										::Dynamic this53 = this52->image;
HXDLIN( 501)										int index5;
HXDLIN( 501)										if (this52->useVirtualPos) {
HXLINE( 501)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            										}
            										else {
HXLINE( 501)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            										}
HXDLIN( 501)										int c5 = ::iterMagic::Iimg_obj::get(this53,index5);
HXDLIN( 501)										int v1;
HXDLIN( 501)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)											v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 501)											v1 = c5;
            										}
HXDLIN( 501)										int maskPixel = v1;
HXDLIN( 501)										int this54 = col;
HXDLIN( 501)										if ((maskPixel == 0)) {
HXLINE( 501)											col = this54;
            										}
            										else {
HXLINE( 501)											Float m0;
HXDLIN( 501)											int this55 = ((maskPixel >> 24) & 255);
HXDLIN( 501)											if ((this55 == 0)) {
HXLINE( 501)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m0 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m1;
HXDLIN( 501)											int this56 = ((maskPixel >> 16) & 255);
HXDLIN( 501)											if ((this56 == 0)) {
HXLINE( 501)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m1 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m2;
HXDLIN( 501)											int this57 = ((maskPixel >> 8) & 255);
HXDLIN( 501)											if ((this57 == 0)) {
HXLINE( 501)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m2 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m3;
HXDLIN( 501)											int this58 = (maskPixel & 255);
HXDLIN( 501)											if ((this58 == 0)) {
HXLINE( 501)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m3 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 501)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 501)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 501)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this54 & 255)) )));
HXDLIN( 501)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 501)									if ((col != 0)) {
HXLINE( 501)										int x5 = (dx1 - rectLeft);
HXDLIN( 501)										int y5 = (dy1 - rectTop);
HXDLIN( 501)										int c6 = col;
HXDLIN( 501)										bool _hx_tmp13;
HXDLIN( 501)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 501)											_hx_tmp13 = undoImage->transparent;
            										}
            										else {
HXLINE( 501)											_hx_tmp13 = false;
            										}
HXDLIN( 501)										if (_hx_tmp13) {
HXLINE( 501)											int location4;
HXDLIN( 501)											if (undoImage->useVirtualPos) {
HXLINE( 501)												location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 501)												location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 501)											int this59 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN( 501)											int this60;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												this60 = this59;
            											}
HXDLIN( 501)											Float a14;
HXDLIN( 501)											int this61 = ((this60 >> 24) & 255);
HXDLIN( 501)											if ((this61 == 0)) {
HXLINE( 501)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												a14 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float r14;
HXDLIN( 501)											int this62 = ((this60 >> 16) & 255);
HXDLIN( 501)											if ((this62 == 0)) {
HXLINE( 501)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												r14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float g14;
HXDLIN( 501)											int this63 = ((this60 >> 8) & 255);
HXDLIN( 501)											if ((this63 == 0)) {
HXLINE( 501)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												g14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float b14;
HXDLIN( 501)											int this64 = (this60 & 255);
HXDLIN( 501)											if ((this64 == 0)) {
HXLINE( 501)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float a24;
HXDLIN( 501)											int this65 = ((col >> 24) & 255);
HXDLIN( 501)											if ((this65 == 0)) {
HXLINE( 501)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												a24 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float r24;
HXDLIN( 501)											int this66 = ((col >> 16) & 255);
HXDLIN( 501)											if ((this66 == 0)) {
HXLINE( 501)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												r24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float g24;
HXDLIN( 501)											int this67 = ((col >> 8) & 255);
HXDLIN( 501)											if ((this67 == 0)) {
HXLINE( 501)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												g24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float b24;
HXDLIN( 501)											int this68 = (col & 255);
HXDLIN( 501)											if ((this68 == 0)) {
HXLINE( 501)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 501)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 501)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 501)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN( 501)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 501)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN( 501)											{
HXLINE( 501)												int _hx_tmp14;
HXDLIN( 501)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)													_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 501)													_hx_tmp14 = blended4;
            												}
HXDLIN( 501)												::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            											}
            										}
            										else {
HXLINE( 501)											::Dynamic this69 = undoImage->image;
HXDLIN( 501)											int index6;
HXDLIN( 501)											if (undoImage->useVirtualPos) {
HXLINE( 501)												index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE( 501)												index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN( 501)											int _hx_tmp15;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												_hx_tmp15 = c6;
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(this69,index6,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 501)										if (forceClear) {
HXLINE( 501)											::Dynamic this70 = undoImage->image;
HXDLIN( 501)											int x6 = (dx1 - rectLeft);
HXDLIN( 501)											int y6 = (dy1 - rectTop);
HXDLIN( 501)											int index7;
HXDLIN( 501)											if (undoImage->useVirtualPos) {
HXLINE( 501)												index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            											}
            											else {
HXLINE( 501)												index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(this70,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 501)			{
HXLINE( 501)				int _g_min = xIter3->start;
HXDLIN( 501)				int _g_max = xIter3->max;
HXDLIN( 501)				while((_g_min < _g_max)){
HXLINE( 501)					_g_min = (_g_min + 1);
HXDLIN( 501)					int px1 = (_g_min - 1);
HXDLIN( 501)					Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 501)					{
HXLINE( 501)						int _g_min1 = yIter3->start;
HXDLIN( 501)						int _g_max1 = yIter3->max;
HXDLIN( 501)						while((_g_min1 < _g_max1)){
HXLINE( 501)							_g_min1 = (_g_min1 + 1);
HXDLIN( 501)							int py1 = (_g_min1 - 1);
HXDLIN( 501)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 501)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 501)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 501)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 501)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 501)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 501)							bool _hx_tmp16;
HXDLIN( 501)							bool _hx_tmp17;
HXDLIN( 501)							if ((ratioA >= 0)) {
HXLINE( 501)								_hx_tmp17 = (ratioB >= 0);
            							}
            							else {
HXLINE( 501)								_hx_tmp17 = false;
            							}
HXDLIN( 501)							if (_hx_tmp17) {
HXLINE( 501)								_hx_tmp16 = (ratioC >= 0);
            							}
            							else {
HXLINE( 501)								_hx_tmp16 = false;
            							}
HXDLIN( 501)							if (_hx_tmp16) {
HXLINE( 501)								int i14 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 501)								if ((i14 > 255)) {
HXLINE(  24)									i14 = 255;
            								}
HXLINE( 501)								if ((i14 < 0)) {
HXLINE(  25)									i14 = 0;
            								}
HXLINE( 501)								int a9 = i14;
HXDLIN( 501)								int i15 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 501)								if ((i15 > 255)) {
HXLINE(  24)									i15 = 255;
            								}
HXLINE( 501)								if ((i15 < 0)) {
HXLINE(  25)									i15 = 0;
            								}
HXLINE( 501)								int r7 = i15;
HXDLIN( 501)								int i16 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 501)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 501)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 501)								int g7 = i16;
HXDLIN( 501)								int i17 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 501)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 501)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 501)								int b10 = i17;
HXDLIN( 501)								{
HXLINE( 501)									int location5;
HXDLIN( 501)									if (pixelImage->useVirtualPos) {
HXLINE( 501)										location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 501)										location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 501)									bool _hx_tmp18;
HXDLIN( 501)									if (pixelImage->transparent) {
HXLINE( 501)										_hx_tmp18 = (a9 < 254);
            									}
            									else {
HXLINE( 501)										_hx_tmp18 = false;
            									}
HXDLIN( 501)									if (_hx_tmp18) {
HXLINE( 501)										int this71 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 501)										int old;
HXDLIN( 501)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)											old = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            										}
            										else {
HXLINE( 501)											old = this71;
            										}
HXDLIN( 501)										int rhs = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN( 501)										Float a15;
HXDLIN( 501)										int this72 = ((old >> 24) & 255);
HXDLIN( 501)										if ((this72 == 0)) {
HXLINE( 501)											a15 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float r15;
HXDLIN( 501)										int this73 = ((old >> 16) & 255);
HXDLIN( 501)										if ((this73 == 0)) {
HXLINE( 501)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											r15 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float g15;
HXDLIN( 501)										int this74 = ((old >> 8) & 255);
HXDLIN( 501)										if ((this74 == 0)) {
HXLINE( 501)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											g15 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float b15;
HXDLIN( 501)										int this75 = (old & 255);
HXDLIN( 501)										if ((this75 == 0)) {
HXLINE( 501)											b15 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											b15 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float a25;
HXDLIN( 501)										int this76 = ((rhs >> 24) & 255);
HXDLIN( 501)										if ((this76 == 0)) {
HXLINE( 501)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											a25 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float r25;
HXDLIN( 501)										int this77 = ((rhs >> 16) & 255);
HXDLIN( 501)										if ((this77 == 0)) {
HXLINE( 501)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											r25 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float g25;
HXDLIN( 501)										int this78 = ((rhs >> 8) & 255);
HXDLIN( 501)										if ((this78 == 0)) {
HXLINE( 501)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											g25 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float b25;
HXDLIN( 501)										int this79 = (rhs & 255);
HXDLIN( 501)										if ((this79 == 0)) {
HXLINE( 501)											b25 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 501)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 501)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 501)										int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN( 501)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 501)										int blended5 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b16);
HXDLIN( 501)										{
HXLINE( 501)											int _hx_tmp19;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												_hx_tmp19 = blended5;
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp19);
            										}
            									}
            									else {
HXLINE( 501)										int value;
HXDLIN( 501)										if (pixelImage->isLittle) {
HXLINE( 501)											value = ((((a9 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            										}
            										else {
HXLINE( 501)											value = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            										}
HXDLIN( 501)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 501)			if ((hasHit == false)) {
HXLINE( 501)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 501)				if (hasUndo) {
HXLINE( 501)					v2->undoImage = undoImage;
HXDLIN( 501)					v2->undoX = xIter3->start;
HXDLIN( 501)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN( 501)		{
HXLINE( 501)			bool hasHit1 = false;
HXDLIN( 501)			bool hasUndo1 = false;
HXDLIN( 501)			int aA1 = ((colorC >> 24) & 255);
HXDLIN( 501)			int rA1 = ((colorC >> 16) & 255);
HXDLIN( 501)			int gA1 = ((colorC >> 8) & 255);
HXDLIN( 501)			int bA1 = (colorC & 255);
HXDLIN( 501)			int aB1 = ((colorB >> 24) & 255);
HXDLIN( 501)			int rB1 = ((colorB >> 16) & 255);
HXDLIN( 501)			int gB1 = ((colorB >> 8) & 255);
HXDLIN( 501)			int bB1 = (colorB & 255);
HXDLIN( 501)			int aC1 = ((colorD >> 24) & 255);
HXDLIN( 501)			int rC1 = ((colorD >> 16) & 255);
HXDLIN( 501)			int gC1 = ((colorD >> 8) & 255);
HXDLIN( 501)			int bC1 = (colorD & 255);
HXDLIN( 501)			Float bcx1 = (cx - dx);
HXDLIN( 501)			Float bcy1 = (cy - dy);
HXDLIN( 501)			Float acx1 = (bx - dx);
HXDLIN( 501)			Float acy1 = (by - dy);
HXDLIN( 501)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 501)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 501)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 501)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 501)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 501)			if ((bx > cx)) {
HXLINE( 501)				if ((bx > dx)) {
HXLINE( 501)					int min4;
HXDLIN( 501)					if ((cx > dx)) {
HXLINE( 501)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 501)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 501)					int ii_min16 = min4;
HXDLIN( 501)					int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 501)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 501)					int ii_min17 = ::Math_obj::floor(cx);
HXDLIN( 501)					int ii_max17 = ::Math_obj::ceil(dx);
HXDLIN( 501)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 501)				if ((cx > dx)) {
HXLINE( 501)					int min5;
HXDLIN( 501)					if ((bx > dx)) {
HXLINE( 501)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 501)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 501)					int ii_min18 = min5;
HXDLIN( 501)					int ii_max18 = ::Math_obj::ceil(cx);
HXDLIN( 501)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 501)					int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 501)					int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN( 501)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 501)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 501)			if ((by > cy)) {
HXLINE( 501)				if ((by > dy)) {
HXLINE( 501)					int min6;
HXDLIN( 501)					if ((cy > dy)) {
HXLINE( 501)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 501)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 501)					int ii_min20 = min6;
HXDLIN( 501)					int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 501)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 501)					int ii_min21 = ::Math_obj::floor(cy);
HXDLIN( 501)					int ii_max21 = ::Math_obj::ceil(dy);
HXDLIN( 501)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 501)				if ((cy > dy)) {
HXLINE( 501)					int min7;
HXDLIN( 501)					if ((by > dy)) {
HXLINE( 501)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 501)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 501)					int ii_min22 = min7;
HXDLIN( 501)					int ii_max22 = ::Math_obj::ceil(cy);
HXDLIN( 501)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 501)					int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 501)					int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN( 501)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 501)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 501)			if (hasUndo1) {
HXLINE( 501)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 501)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 501)				 ::Dynamic imageType1 = null();
HXDLIN( 501)				 ::pi_xy::ImageStruct this80 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 501)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 501)				::Dynamic undoImage4;
HXDLIN( 501)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 501)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::BytesImg b17 = byt1;
HXDLIN( 501)						{
HXLINE( 501)							b17->width = width1;
HXDLIN( 501)							b17->height = height1;
HXDLIN( 501)							b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 501)							b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 501)							{
HXLINE( 501)								int len2 = b17->length;
HXDLIN( 501)								int w1 = 0;
HXDLIN( 501)								{
HXLINE( 501)									int _g20 = 0;
HXDLIN( 501)									int _g21 = b17->height;
HXDLIN( 501)									while((_g20 < _g21)){
HXLINE( 501)										_g20 = (_g20 + 1);
HXDLIN( 501)										int y7 = (_g20 - 1);
HXDLIN( 501)										{
HXLINE( 501)											int _g22 = 0;
HXDLIN( 501)											int _g23 = b17->width;
HXDLIN( 501)											while((_g22 < _g23)){
HXLINE( 501)												_g22 = (_g22 + 1);
HXDLIN( 501)												int x7 = (_g22 - 1);
HXDLIN( 501)												{
HXLINE( 501)													w1 = (w1 + 1);
HXDLIN( 501)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w1 = (w1 + 1);
HXDLIN( 501)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w1 = (w1 + 1);
HXDLIN( 501)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 501)												{
HXLINE( 501)													w1 = (w1 + 1);
HXDLIN( 501)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage4 = b17;
            					}
            					break;
            					case (int)1: {
HXLINE( 501)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN( 501)						{
HXLINE( 501)							a16->width = width1;
HXDLIN( 501)							a16->height = height1;
HXDLIN( 501)							a16->data = ::Array_obj< int >::__new(0);
HXDLIN( 501)							a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 501)							{
HXLINE( 501)								int _g24 = 0;
HXDLIN( 501)								int _g25 = a16->length;
HXDLIN( 501)								while((_g24 < _g25)){
HXLINE( 501)									_g24 = (_g24 + 1);
HXDLIN( 501)									int i18 = (_g24 - 1);
HXDLIN( 501)									a16->data[i18] = 0;
            								}
            							}
            						}
HXDLIN( 501)						undoImage4 = a16;
            					}
            					break;
            					case (int)2: {
HXLINE( 501)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::U32ArrImg b18 = u32a1;
HXDLIN( 501)						{
HXLINE( 501)							b18->width = width1;
HXDLIN( 501)							b18->height = height1;
HXDLIN( 501)							b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 501)							int size1 = (b18->length * 4);
HXDLIN( 501)							b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 501)							{
HXLINE( 501)								int _g26 = 0;
HXDLIN( 501)								int _g27 = b18->length;
HXDLIN( 501)								while((_g26 < _g27)){
HXLINE( 501)									_g26 = (_g26 + 1);
HXDLIN( 501)									int i19 = (_g26 - 1);
HXDLIN( 501)									{
HXLINE( 501)										 ::haxe::io::ArrayBufferViewImpl this81 = b18->data;
HXDLIN( 501)										bool undoImage5;
HXDLIN( 501)										if ((i19 >= 0)) {
HXLINE( 501)											undoImage5 = (i19 < (this81->byteLength >> 2));
            										}
            										else {
HXLINE( 501)											undoImage5 = false;
            										}
HXDLIN( 501)										if (undoImage5) {
HXLINE( 501)											 ::haxe::io::Bytes _this1 = this81->bytes;
HXDLIN( 501)											int pos1 = ((i19 << 2) + this81->byteOffset);
HXDLIN( 501)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 501)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 501)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 501)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage4 = b18;
            					}
            					break;
            					case (int)3: {
HXLINE( 501)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 501)						{
HXLINE( 501)							v3->width = width1;
HXDLIN( 501)							v3->height = height1;
HXDLIN( 501)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 501)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 501)							{
HXLINE( 501)								int _g28 = 0;
HXDLIN( 501)								int _g29 = v3->length;
HXDLIN( 501)								while((_g28 < _g29)){
HXLINE( 501)									_g28 = (_g28 + 1);
HXDLIN( 501)									int i20 = (_g28 - 1);
HXDLIN( 501)									v3->data->__unsafe_set(i20,0);
            								}
            							}
            						}
HXDLIN( 501)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 501)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 501)						 ::iterMagic::StackIntImg b19 = sInt1;
HXDLIN( 501)						{
HXLINE( 501)							b19->width = width1;
HXDLIN( 501)							b19->height = height1;
HXDLIN( 501)							b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 501)							b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 501)							{
HXLINE( 501)								int len3 = b19->length;
HXDLIN( 501)								 ::haxe::ds::GenericStack_Int d1 = b19->data;
HXDLIN( 501)								if (::hx::IsNull( d1->head )) {
HXLINE( 501)									int _g30 = 0;
HXDLIN( 501)									int _g31 = len3;
HXDLIN( 501)									while((_g30 < _g31)){
HXLINE( 501)										_g30 = (_g30 + 1);
HXDLIN( 501)										int i21 = (_g30 - 1);
HXDLIN( 501)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 501)									int _g32 = 0;
HXDLIN( 501)									int _g33 = len3;
HXDLIN( 501)									while((_g32 < _g33)){
HXLINE( 501)										_g32 = (_g32 + 1);
HXDLIN( 501)										int i22 = (_g32 - 1);
HXDLIN( 501)										{
HXLINE( 501)											 ::haxe::ds::GenericCell_Int l1 = b19->data->head;
HXDLIN( 501)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 501)											{
HXLINE( 501)												int _g34 = 0;
HXDLIN( 501)												int _g35 = i22;
HXDLIN( 501)												while((_g34 < _g35)){
HXLINE( 501)													_g34 = (_g34 + 1);
HXDLIN( 501)													int i23 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 501)											if (::hx::IsNull( prev1 )) {
HXLINE( 501)												b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 501)												l1 = null();
            											}
            											else {
HXLINE( 501)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 501)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 501)						undoImage4 = b19;
            					}
            					break;
            				}
HXDLIN( 501)				this80->image = undoImage4;
HXDLIN( 501)				this80->width = width1;
HXDLIN( 501)				this80->height = height1;
HXDLIN( 501)				this80->imageType = ( (int)(imageType1) );
HXDLIN( 501)				undoImage3 = this80;
HXDLIN( 501)				{
HXLINE( 501)					int rectLeft1 = xIter31->start;
HXDLIN( 501)					int rectTop1 = yIter31->start;
HXDLIN( 501)					int rectRight1 = xIter31->max;
HXDLIN( 501)					bool forceClear1 = false;
HXDLIN( 501)					{
HXLINE( 501)						int _g36 = rectTop1;
HXDLIN( 501)						int _g37 = yIter31->max;
HXDLIN( 501)						while((_g36 < _g37)){
HXLINE( 501)							_g36 = (_g36 + 1);
HXDLIN( 501)							int dy2 = (_g36 - 1);
HXDLIN( 501)							{
HXLINE( 501)								int _g38 = rectLeft1;
HXDLIN( 501)								int _g39 = rectRight1;
HXDLIN( 501)								while((_g38 < _g39)){
HXLINE( 501)									_g38 = (_g38 + 1);
HXDLIN( 501)									int dx2 = (_g38 - 1);
HXDLIN( 501)									::Dynamic this82 = pixelImage->image;
HXDLIN( 501)									int index8;
HXDLIN( 501)									if (pixelImage->useVirtualPos) {
HXLINE( 501)										index8 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 501)										index8 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 501)									int c7 = ::iterMagic::Iimg_obj::get(this82,index8);
HXDLIN( 501)									int col1;
HXDLIN( 501)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)										col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 501)										col1 = c7;
            									}
HXDLIN( 501)									bool _hx_tmp20;
HXDLIN( 501)									if (pixelImage->useMask) {
HXLINE( 501)										_hx_tmp20 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 501)										_hx_tmp20 = false;
            									}
HXDLIN( 501)									if (_hx_tmp20) {
HXLINE( 501)										 ::pi_xy::ImageStruct this83 = pixelImage->mask;
HXDLIN( 501)										::Dynamic this84 = this83->image;
HXDLIN( 501)										int index9;
HXDLIN( 501)										if (this83->useVirtualPos) {
HXLINE( 501)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this83->virtualY) * ( (Float)(this83->width) )) + dx2) - this83->virtualX));
            										}
            										else {
HXLINE( 501)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this83->width) + dx2)) ));
            										}
HXDLIN( 501)										int c8 = ::iterMagic::Iimg_obj::get(this84,index9);
HXDLIN( 501)										int v4;
HXDLIN( 501)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)											v4 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 501)											v4 = c8;
            										}
HXDLIN( 501)										int maskPixel1 = v4;
HXDLIN( 501)										int this85 = col1;
HXDLIN( 501)										if ((maskPixel1 == 0)) {
HXLINE( 501)											col1 = this85;
            										}
            										else {
HXLINE( 501)											Float m01;
HXDLIN( 501)											int this86 = ((maskPixel1 >> 24) & 255);
HXDLIN( 501)											if ((this86 == 0)) {
HXLINE( 501)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m01 = (( (Float)(this86) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m11;
HXDLIN( 501)											int this87 = ((maskPixel1 >> 16) & 255);
HXDLIN( 501)											if ((this87 == 0)) {
HXLINE( 501)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m11 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m21;
HXDLIN( 501)											int this88 = ((maskPixel1 >> 8) & 255);
HXDLIN( 501)											if ((this88 == 0)) {
HXLINE( 501)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m21 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float m31;
HXDLIN( 501)											int this89 = (maskPixel1 & 255);
HXDLIN( 501)											if ((this89 == 0)) {
HXLINE( 501)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												m31 = (( (Float)(this89) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this85 >> 24) & 255)) )));
HXDLIN( 501)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this85 >> 16) & 255)) )));
HXDLIN( 501)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this85 >> 8) & 255)) )));
HXDLIN( 501)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this85 & 255)) )));
HXDLIN( 501)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 501)									if ((col1 != 0)) {
HXLINE( 501)										int x8 = (dx2 - rectLeft1);
HXDLIN( 501)										int y8 = (dy2 - rectTop1);
HXDLIN( 501)										int c9 = col1;
HXDLIN( 501)										bool _hx_tmp21;
HXDLIN( 501)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 501)											_hx_tmp21 = undoImage3->transparent;
            										}
            										else {
HXLINE( 501)											_hx_tmp21 = false;
            										}
HXDLIN( 501)										if (_hx_tmp21) {
HXLINE( 501)											int location6;
HXDLIN( 501)											if (undoImage3->useVirtualPos) {
HXLINE( 501)												location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 501)												location6 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 501)											int this90 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN( 501)											int this91;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												this91 = this90;
            											}
HXDLIN( 501)											Float a17;
HXDLIN( 501)											int this92 = ((this91 >> 24) & 255);
HXDLIN( 501)											if ((this92 == 0)) {
HXLINE( 501)												a17 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float r16;
HXDLIN( 501)											int this93 = ((this91 >> 16) & 255);
HXDLIN( 501)											if ((this93 == 0)) {
HXLINE( 501)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												r16 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float g16;
HXDLIN( 501)											int this94 = ((this91 >> 8) & 255);
HXDLIN( 501)											if ((this94 == 0)) {
HXLINE( 501)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												g16 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float b110;
HXDLIN( 501)											int this95 = (this91 & 255);
HXDLIN( 501)											if ((this95 == 0)) {
HXLINE( 501)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												b110 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float a26;
HXDLIN( 501)											int this96 = ((col1 >> 24) & 255);
HXDLIN( 501)											if ((this96 == 0)) {
HXLINE( 501)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												a26 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float r26;
HXDLIN( 501)											int this97 = ((col1 >> 16) & 255);
HXDLIN( 501)											if ((this97 == 0)) {
HXLINE( 501)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												r26 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float g26;
HXDLIN( 501)											int this98 = ((col1 >> 8) & 255);
HXDLIN( 501)											if ((this98 == 0)) {
HXLINE( 501)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												g26 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float b26;
HXDLIN( 501)											int this99 = (col1 & 255);
HXDLIN( 501)											if ((this99 == 0)) {
HXLINE( 501)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 501)												b26 = (( (Float)(this99) ) / ( (Float)(255) ));
            											}
HXDLIN( 501)											Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 501)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 501)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 501)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b26 * a26))));
HXDLIN( 501)											int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 501)											int blended6 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 501)											{
HXLINE( 501)												int _hx_tmp22;
HXDLIN( 501)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)													_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 501)													_hx_tmp22 = blended6;
            												}
HXDLIN( 501)												::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            											}
            										}
            										else {
HXLINE( 501)											::Dynamic this100 = undoImage3->image;
HXDLIN( 501)											int index10;
HXDLIN( 501)											if (undoImage3->useVirtualPos) {
HXLINE( 501)												index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 501)												index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN( 501)											int _hx_tmp23;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												_hx_tmp23 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												_hx_tmp23 = c9;
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp23);
            										}
            									}
            									else {
HXLINE( 501)										if (forceClear1) {
HXLINE( 501)											::Dynamic this101 = undoImage3->image;
HXDLIN( 501)											int x9 = (dx2 - rectLeft1);
HXDLIN( 501)											int y9 = (dy2 - rectTop1);
HXDLIN( 501)											int index11;
HXDLIN( 501)											if (undoImage3->useVirtualPos) {
HXLINE( 501)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 501)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(this101,index11,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 501)			{
HXLINE( 501)				int _g_min2 = xIter31->start;
HXDLIN( 501)				int _g_max2 = xIter31->max;
HXDLIN( 501)				while((_g_min2 < _g_max2)){
HXLINE( 501)					_g_min2 = (_g_min2 + 1);
HXDLIN( 501)					int px2 = (_g_min2 - 1);
HXDLIN( 501)					Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 501)					{
HXLINE( 501)						int _g_min3 = yIter31->start;
HXDLIN( 501)						int _g_max3 = yIter31->max;
HXDLIN( 501)						while((_g_min3 < _g_max3)){
HXLINE( 501)							_g_min3 = (_g_min3 + 1);
HXDLIN( 501)							int py2 = (_g_min3 - 1);
HXDLIN( 501)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 501)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 501)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 501)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 501)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 501)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 501)							bool _hx_tmp24;
HXDLIN( 501)							bool _hx_tmp25;
HXDLIN( 501)							if ((ratioA1 >= 0)) {
HXLINE( 501)								_hx_tmp25 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 501)								_hx_tmp25 = false;
            							}
HXDLIN( 501)							if (_hx_tmp25) {
HXLINE( 501)								_hx_tmp24 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 501)								_hx_tmp24 = false;
            							}
HXDLIN( 501)							if (_hx_tmp24) {
HXLINE( 501)								int i24 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 501)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE( 501)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE( 501)								int a19 = i24;
HXDLIN( 501)								int i25 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 501)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE( 501)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 501)								int r10 = i25;
HXDLIN( 501)								int i26 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 501)								if ((i26 > 255)) {
HXLINE(  24)									i26 = 255;
            								}
HXLINE( 501)								if ((i26 < 0)) {
HXLINE(  25)									i26 = 0;
            								}
HXLINE( 501)								int g10 = i26;
HXDLIN( 501)								int i27 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 501)								if ((i27 > 255)) {
HXLINE(  24)									i27 = 255;
            								}
HXLINE( 501)								if ((i27 < 0)) {
HXLINE(  25)									i27 = 0;
            								}
HXLINE( 501)								int b27 = i27;
HXDLIN( 501)								{
HXLINE( 501)									int location7;
HXDLIN( 501)									if (pixelImage->useVirtualPos) {
HXLINE( 501)										location7 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 501)										location7 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 501)									bool _hx_tmp26;
HXDLIN( 501)									if (pixelImage->transparent) {
HXLINE( 501)										_hx_tmp26 = (a19 < 254);
            									}
            									else {
HXLINE( 501)										_hx_tmp26 = false;
            									}
HXDLIN( 501)									if (_hx_tmp26) {
HXLINE( 501)										int this102 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 501)										int old1;
HXDLIN( 501)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)											old1 = ((((((this102 >> 24) & 255) << 24) | ((this102 & 255) << 16)) | (((this102 >> 8) & 255) << 8)) | ((this102 >> 16) & 255));
            										}
            										else {
HXLINE( 501)											old1 = this102;
            										}
HXDLIN( 501)										int rhs1 = ((((a19 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
HXDLIN( 501)										Float a110;
HXDLIN( 501)										int this103 = ((old1 >> 24) & 255);
HXDLIN( 501)										if ((this103 == 0)) {
HXLINE( 501)											a110 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											a110 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float r17;
HXDLIN( 501)										int this104 = ((old1 >> 16) & 255);
HXDLIN( 501)										if ((this104 == 0)) {
HXLINE( 501)											r17 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											r17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float g17;
HXDLIN( 501)										int this105 = ((old1 >> 8) & 255);
HXDLIN( 501)										if ((this105 == 0)) {
HXLINE( 501)											g17 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											g17 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float b111;
HXDLIN( 501)										int this106 = (old1 & 255);
HXDLIN( 501)										if ((this106 == 0)) {
HXLINE( 501)											b111 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											b111 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float a27;
HXDLIN( 501)										int this107 = ((rhs1 >> 24) & 255);
HXDLIN( 501)										if ((this107 == 0)) {
HXLINE( 501)											a27 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											a27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float r27;
HXDLIN( 501)										int this108 = ((rhs1 >> 16) & 255);
HXDLIN( 501)										if ((this108 == 0)) {
HXLINE( 501)											r27 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											r27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float g27;
HXDLIN( 501)										int this109 = ((rhs1 >> 8) & 255);
HXDLIN( 501)										if ((this109 == 0)) {
HXLINE( 501)											g27 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											g27 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float b28;
HXDLIN( 501)										int this110 = (rhs1 & 255);
HXDLIN( 501)										if ((this110 == 0)) {
HXLINE( 501)											b28 = ((Float)0.);
            										}
            										else {
HXLINE( 501)											b28 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 501)										Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 501)										int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 501)										int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 501)										int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b28 * a27))));
HXDLIN( 501)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 501)										int blended7 = ((((a20 << 24) | (r18 << 16)) | (g18 << 8)) | b29);
HXDLIN( 501)										{
HXLINE( 501)											int _hx_tmp27;
HXDLIN( 501)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 501)												_hx_tmp27 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXLINE( 501)												_hx_tmp27 = blended7;
            											}
HXDLIN( 501)											::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp27);
            										}
            									}
            									else {
HXLINE( 501)										int value1;
HXDLIN( 501)										if (pixelImage->isLittle) {
HXLINE( 501)											value1 = ((((a19 << 24) | (b27 << 16)) | (g10 << 8)) | r10);
            										}
            										else {
HXLINE( 501)											value1 = ((((a19 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
            										}
HXDLIN( 501)										::iterMagic::Iimg_obj::set(pixelImage->image,location7,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 501)			if ((hasHit1 == false)) {
HXLINE( 501)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 501)				if (hasUndo1) {
HXLINE( 501)					v5->undoImage = undoImage3;
HXDLIN( 501)					v5->undoX = xIter31->start;
HXDLIN( 501)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 501)		if ((hasHit == true)) {
HXLINE( 501)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 501)			return v6;
            		}
            		else {
HXLINE( 501)			return null();
            		}
HXDLIN( 501)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(LinePixel_Fields__obj,rotateGradLine,return )

 ::pi_xy::algo::HitQuad LinePixel_Fields__obj::rotateGradLineFlare( ::pi_xy::ImageStruct pixelImage,Float px,Float py,Float thick1,Float thick2,Float h,Float theta,int colorA,int colorB,int colorC,int colorD,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_03666c1473745a8e_511_rotateGradLineFlare)
HXLINE( 512)		Float sin = ::Math_obj::sin(theta);
HXLINE( 513)		Float cos = ::Math_obj::cos(theta);
HXLINE( 514)		Float radius1 = (thick1 / ( (Float)(2) ));
HXLINE( 515)		Float radius2 = (thick2 / ( (Float)(2) ));
HXLINE( 516)		Float dx = ((Float)0.1);
HXLINE( 517)		Float dy = radius1;
HXLINE( 518)		Float cx = h;
HXLINE( 519)		Float cy = radius2;
HXLINE( 520)		Float bx = h;
HXLINE( 521)		Float by = -(radius2);
HXLINE( 522)		Float ax = ((Float)0.1);
HXLINE( 523)		Float ay = -(radius1);
HXLINE( 524)		Float temp = ((Float)0.);
HXLINE( 525)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 526)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 527)		ax = temp;
HXLINE( 529)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 530)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 531)		bx = temp;
HXLINE( 533)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 534)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 535)		cx = temp;
HXLINE( 537)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 538)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 539)		dx = temp;
HXLINE( 541)		{
HXLINE( 541)			bool hasUndo = false;
HXDLIN( 541)			int aA = ((colorB >> 24) & 255);
HXDLIN( 541)			int rA = ((colorB >> 16) & 255);
HXDLIN( 541)			int gA = ((colorB >> 8) & 255);
HXDLIN( 541)			int bA = (colorB & 255);
HXDLIN( 541)			int aB = ((colorA >> 24) & 255);
HXDLIN( 541)			int rB = ((colorA >> 16) & 255);
HXDLIN( 541)			int gB = ((colorA >> 8) & 255);
HXDLIN( 541)			int bB = (colorA & 255);
HXDLIN( 541)			int aC = ((colorD >> 24) & 255);
HXDLIN( 541)			int rC = ((colorD >> 16) & 255);
HXDLIN( 541)			int gC = ((colorD >> 8) & 255);
HXDLIN( 541)			int bC = (colorD & 255);
HXDLIN( 541)			Float bcx = (bx - dx);
HXDLIN( 541)			Float bcy = (by - dy);
HXDLIN( 541)			Float acx = (ax - dx);
HXDLIN( 541)			Float acy = (ay - dy);
HXDLIN( 541)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 541)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 541)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 541)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 541)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 541)			if ((ax > bx)) {
HXLINE( 541)				if ((ax > dx)) {
HXLINE( 541)					int min;
HXDLIN( 541)					if ((bx > dx)) {
HXLINE( 541)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 541)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 541)					int ii_min = min;
HXDLIN( 541)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 541)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 541)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 541)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 541)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 541)				if ((bx > dx)) {
HXLINE( 541)					int min1;
HXDLIN( 541)					if ((ax > dx)) {
HXLINE( 541)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 541)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 541)					int ii_min2 = min1;
HXDLIN( 541)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 541)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 541)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 541)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 541)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 541)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 541)			if ((ay > by)) {
HXLINE( 541)				if ((ay > dy)) {
HXLINE( 541)					int min2;
HXDLIN( 541)					if ((by > dy)) {
HXLINE( 541)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 541)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 541)					int ii_min4 = min2;
HXDLIN( 541)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 541)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 541)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 541)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 541)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 541)				if ((by > dy)) {
HXLINE( 541)					int min3;
HXDLIN( 541)					if ((ay > dy)) {
HXLINE( 541)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 541)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 541)					int ii_min6 = min3;
HXDLIN( 541)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 541)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 541)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 541)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 541)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 541)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 541)			if (hasUndo) {
HXLINE( 541)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 541)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 541)				 ::Dynamic imageType = null();
HXDLIN( 541)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 541)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 541)				::Dynamic undoImage1;
HXDLIN( 541)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 541)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 541)						{
HXLINE( 541)							b->width = width;
HXDLIN( 541)							b->height = height;
HXDLIN( 541)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 541)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 541)							{
HXLINE( 541)								int len = b->length;
HXDLIN( 541)								int w = 0;
HXDLIN( 541)								{
HXLINE( 541)									int _g = 0;
HXDLIN( 541)									int _g1 = b->height;
HXDLIN( 541)									while((_g < _g1)){
HXLINE( 541)										_g = (_g + 1);
HXDLIN( 541)										int y = (_g - 1);
HXDLIN( 541)										{
HXLINE( 541)											int _g2 = 0;
HXDLIN( 541)											int _g3 = b->width;
HXDLIN( 541)											while((_g2 < _g3)){
HXLINE( 541)												_g2 = (_g2 + 1);
HXDLIN( 541)												int x = (_g2 - 1);
HXDLIN( 541)												{
HXLINE( 541)													w = (w + 1);
HXDLIN( 541)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w = (w + 1);
HXDLIN( 541)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w = (w + 1);
HXDLIN( 541)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w = (w + 1);
HXDLIN( 541)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 541)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 541)						{
HXLINE( 541)							a->width = width;
HXDLIN( 541)							a->height = height;
HXDLIN( 541)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 541)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 541)							{
HXLINE( 541)								int _g4 = 0;
HXDLIN( 541)								int _g5 = a->length;
HXDLIN( 541)								while((_g4 < _g5)){
HXLINE( 541)									_g4 = (_g4 + 1);
HXDLIN( 541)									int i = (_g4 - 1);
HXDLIN( 541)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 541)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 541)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 541)						{
HXLINE( 541)							b1->width = width;
HXDLIN( 541)							b1->height = height;
HXDLIN( 541)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 541)							int size = (b1->length * 4);
HXDLIN( 541)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 541)							{
HXLINE( 541)								int _g6 = 0;
HXDLIN( 541)								int _g7 = b1->length;
HXDLIN( 541)								while((_g6 < _g7)){
HXLINE( 541)									_g6 = (_g6 + 1);
HXDLIN( 541)									int i1 = (_g6 - 1);
HXDLIN( 541)									{
HXLINE( 541)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 541)										bool undoImage2;
HXDLIN( 541)										if ((i1 >= 0)) {
HXLINE( 541)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 541)											undoImage2 = false;
            										}
HXDLIN( 541)										if (undoImage2) {
HXLINE( 541)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 541)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 541)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 541)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 541)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 541)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 541)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 541)						{
HXLINE( 541)							v->width = width;
HXDLIN( 541)							v->height = height;
HXDLIN( 541)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 541)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 541)							{
HXLINE( 541)								int _g8 = 0;
HXDLIN( 541)								int _g9 = v->length;
HXDLIN( 541)								while((_g8 < _g9)){
HXLINE( 541)									_g8 = (_g8 + 1);
HXDLIN( 541)									int i2 = (_g8 - 1);
HXDLIN( 541)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 541)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 541)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 541)						{
HXLINE( 541)							b2->width = width;
HXDLIN( 541)							b2->height = height;
HXDLIN( 541)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 541)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 541)							{
HXLINE( 541)								int len1 = b2->length;
HXDLIN( 541)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 541)								if (::hx::IsNull( d->head )) {
HXLINE( 541)									int _g10 = 0;
HXDLIN( 541)									int _g11 = len1;
HXDLIN( 541)									while((_g10 < _g11)){
HXLINE( 541)										_g10 = (_g10 + 1);
HXDLIN( 541)										int i3 = (_g10 - 1);
HXDLIN( 541)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 541)									int _g12 = 0;
HXDLIN( 541)									int _g13 = len1;
HXDLIN( 541)									while((_g12 < _g13)){
HXLINE( 541)										_g12 = (_g12 + 1);
HXDLIN( 541)										int i4 = (_g12 - 1);
HXDLIN( 541)										{
HXLINE( 541)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 541)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 541)											{
HXLINE( 541)												int _g14 = 0;
HXDLIN( 541)												int _g15 = i4;
HXDLIN( 541)												while((_g14 < _g15)){
HXLINE( 541)													_g14 = (_g14 + 1);
HXDLIN( 541)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 541)											if (::hx::IsNull( prev )) {
HXLINE( 541)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 541)												l = null();
            											}
            											else {
HXLINE( 541)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 541)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 541)				this1->image = undoImage1;
HXDLIN( 541)				this1->width = width;
HXDLIN( 541)				this1->height = height;
HXDLIN( 541)				this1->imageType = ( (int)(imageType) );
HXDLIN( 541)				undoImage = this1;
HXDLIN( 541)				{
HXLINE( 541)					int rectLeft = xIter3->start;
HXDLIN( 541)					int rectTop = yIter3->start;
HXDLIN( 541)					int rectRight = xIter3->max;
HXDLIN( 541)					bool forceClear = false;
HXDLIN( 541)					{
HXLINE( 541)						int _g16 = rectTop;
HXDLIN( 541)						int _g17 = yIter3->max;
HXDLIN( 541)						while((_g16 < _g17)){
HXLINE( 541)							_g16 = (_g16 + 1);
HXDLIN( 541)							int dy1 = (_g16 - 1);
HXDLIN( 541)							{
HXLINE( 541)								int _g18 = rectLeft;
HXDLIN( 541)								int _g19 = rectRight;
HXDLIN( 541)								while((_g18 < _g19)){
HXLINE( 541)									_g18 = (_g18 + 1);
HXDLIN( 541)									int dx1 = (_g18 - 1);
HXDLIN( 541)									::Dynamic this3 = pixelImage->image;
HXDLIN( 541)									int index;
HXDLIN( 541)									if (pixelImage->useVirtualPos) {
HXLINE( 541)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 541)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 541)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 541)									int col;
HXDLIN( 541)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 541)										col = c;
            									}
HXDLIN( 541)									bool _hx_tmp;
HXDLIN( 541)									if (pixelImage->useMask) {
HXLINE( 541)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 541)										_hx_tmp = false;
            									}
HXDLIN( 541)									if (_hx_tmp) {
HXLINE( 541)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 541)										::Dynamic this5 = this4->image;
HXDLIN( 541)										int index1;
HXDLIN( 541)										if (this4->useVirtualPos) {
HXLINE( 541)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 541)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 541)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 541)										int v1;
HXDLIN( 541)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 541)											v1 = c1;
            										}
HXDLIN( 541)										int maskPixel = v1;
HXDLIN( 541)										int this6 = col;
HXDLIN( 541)										if ((maskPixel == 0)) {
HXLINE( 541)											col = this6;
            										}
            										else {
HXLINE( 541)											Float m0;
HXDLIN( 541)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 541)											if ((this7 == 0)) {
HXLINE( 541)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m1;
HXDLIN( 541)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 541)											if ((this8 == 0)) {
HXLINE( 541)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m2;
HXDLIN( 541)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 541)											if ((this9 == 0)) {
HXLINE( 541)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m3;
HXDLIN( 541)											int this10 = (maskPixel & 255);
HXDLIN( 541)											if ((this10 == 0)) {
HXLINE( 541)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 541)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 541)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 541)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 541)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 541)									if ((col != 0)) {
HXLINE( 541)										int x1 = (dx1 - rectLeft);
HXDLIN( 541)										int y1 = (dy1 - rectTop);
HXDLIN( 541)										int c2 = col;
HXDLIN( 541)										bool _hx_tmp1;
HXDLIN( 541)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 541)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 541)											_hx_tmp1 = false;
            										}
HXDLIN( 541)										if (_hx_tmp1) {
HXLINE( 541)											int location;
HXDLIN( 541)											if (undoImage->useVirtualPos) {
HXLINE( 541)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 541)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 541)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 541)											int this12;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												this12 = this11;
            											}
HXDLIN( 541)											Float a1;
HXDLIN( 541)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 541)											if ((this13 == 0)) {
HXLINE( 541)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float r1;
HXDLIN( 541)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 541)											if ((this14 == 0)) {
HXLINE( 541)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float g1;
HXDLIN( 541)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 541)											if ((this15 == 0)) {
HXLINE( 541)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float b11;
HXDLIN( 541)											int this16 = (this12 & 255);
HXDLIN( 541)											if ((this16 == 0)) {
HXLINE( 541)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float a2;
HXDLIN( 541)											int this17 = ((col >> 24) & 255);
HXDLIN( 541)											if ((this17 == 0)) {
HXLINE( 541)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float r2;
HXDLIN( 541)											int this18 = ((col >> 16) & 255);
HXDLIN( 541)											if ((this18 == 0)) {
HXLINE( 541)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float g2;
HXDLIN( 541)											int this19 = ((col >> 8) & 255);
HXDLIN( 541)											if ((this19 == 0)) {
HXLINE( 541)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float b21;
HXDLIN( 541)											int this20 = (col & 255);
HXDLIN( 541)											if ((this20 == 0)) {
HXLINE( 541)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 541)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 541)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 541)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 541)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 541)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 541)											{
HXLINE( 541)												int _hx_tmp2;
HXDLIN( 541)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 541)													_hx_tmp2 = blended;
            												}
HXDLIN( 541)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 541)											::Dynamic this21 = undoImage->image;
HXDLIN( 541)											int index2;
HXDLIN( 541)											if (undoImage->useVirtualPos) {
HXLINE( 541)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 541)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 541)											int _hx_tmp3;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												_hx_tmp3 = c2;
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 541)										if (forceClear) {
HXLINE( 541)											::Dynamic this22 = undoImage->image;
HXDLIN( 541)											int x2 = (dx1 - rectLeft);
HXDLIN( 541)											int y2 = (dy1 - rectTop);
HXDLIN( 541)											int index3;
HXDLIN( 541)											if (undoImage->useVirtualPos) {
HXLINE( 541)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 541)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 541)			{
HXLINE( 541)				int _g_min = xIter3->start;
HXDLIN( 541)				int _g_max = xIter3->max;
HXDLIN( 541)				while((_g_min < _g_max)){
HXLINE( 541)					_g_min = (_g_min + 1);
HXDLIN( 541)					int px1 = (_g_min - 1);
HXDLIN( 541)					Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 541)					{
HXLINE( 541)						int _g_min1 = yIter3->start;
HXDLIN( 541)						int _g_max1 = yIter3->max;
HXDLIN( 541)						while((_g_min1 < _g_max1)){
HXLINE( 541)							_g_min1 = (_g_min1 + 1);
HXDLIN( 541)							int py1 = (_g_min1 - 1);
HXDLIN( 541)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 541)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 541)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 541)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 541)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 541)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 541)							bool _hx_tmp4;
HXDLIN( 541)							bool _hx_tmp5;
HXDLIN( 541)							if ((ratioA >= 0)) {
HXLINE( 541)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 541)								_hx_tmp5 = false;
            							}
HXDLIN( 541)							if (_hx_tmp5) {
HXLINE( 541)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 541)								_hx_tmp4 = false;
            							}
HXDLIN( 541)							if (_hx_tmp4) {
HXLINE( 541)								int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 541)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 541)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 541)								int a5 = i6;
HXDLIN( 541)								int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 541)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 541)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 541)								int r3 = i7;
HXDLIN( 541)								int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 541)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 541)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 541)								int g3 = i8;
HXDLIN( 541)								int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 541)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 541)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 541)								int b4 = i9;
HXDLIN( 541)								{
HXLINE( 541)									int location1;
HXDLIN( 541)									if (pixelImage->useVirtualPos) {
HXLINE( 541)										location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 541)										location1 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 541)									bool _hx_tmp6;
HXDLIN( 541)									if (pixelImage->transparent) {
HXLINE( 541)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE( 541)										_hx_tmp6 = false;
            									}
HXDLIN( 541)									if (_hx_tmp6) {
HXLINE( 541)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 541)										int old;
HXDLIN( 541)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 541)											old = this23;
            										}
HXDLIN( 541)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 541)										Float a11;
HXDLIN( 541)										int this24 = ((old >> 24) & 255);
HXDLIN( 541)										if ((this24 == 0)) {
HXLINE( 541)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float r11;
HXDLIN( 541)										int this25 = ((old >> 16) & 255);
HXDLIN( 541)										if ((this25 == 0)) {
HXLINE( 541)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float g11;
HXDLIN( 541)										int this26 = ((old >> 8) & 255);
HXDLIN( 541)										if ((this26 == 0)) {
HXLINE( 541)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float b12;
HXDLIN( 541)										int this27 = (old & 255);
HXDLIN( 541)										if ((this27 == 0)) {
HXLINE( 541)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float a21;
HXDLIN( 541)										int this28 = ((rhs >> 24) & 255);
HXDLIN( 541)										if ((this28 == 0)) {
HXLINE( 541)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float r21;
HXDLIN( 541)										int this29 = ((rhs >> 16) & 255);
HXDLIN( 541)										if ((this29 == 0)) {
HXLINE( 541)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float g21;
HXDLIN( 541)										int this30 = ((rhs >> 8) & 255);
HXDLIN( 541)										if ((this30 == 0)) {
HXLINE( 541)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float b22;
HXDLIN( 541)										int this31 = (rhs & 255);
HXDLIN( 541)										if ((this31 == 0)) {
HXLINE( 541)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 541)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 541)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 541)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 541)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 541)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 541)										{
HXLINE( 541)											int _hx_tmp7;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												_hx_tmp7 = blended1;
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE( 541)										int value;
HXDLIN( 541)										if (pixelImage->isLittle) {
HXLINE( 541)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 541)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 541)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 541)			if ((hasHit == false)) {
HXLINE( 541)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 541)				if (hasUndo) {
HXLINE( 541)					v2->undoImage = undoImage;
HXDLIN( 541)					v2->undoX = xIter3->start;
HXDLIN( 541)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN( 541)		{
HXLINE( 541)			bool hasHit1 = false;
HXDLIN( 541)			bool hasUndo1 = false;
HXDLIN( 541)			int aA1 = ((colorC >> 24) & 255);
HXDLIN( 541)			int rA1 = ((colorC >> 16) & 255);
HXDLIN( 541)			int gA1 = ((colorC >> 8) & 255);
HXDLIN( 541)			int bA1 = (colorC & 255);
HXDLIN( 541)			int aB1 = ((colorB >> 24) & 255);
HXDLIN( 541)			int rB1 = ((colorB >> 16) & 255);
HXDLIN( 541)			int gB1 = ((colorB >> 8) & 255);
HXDLIN( 541)			int bB1 = (colorB & 255);
HXDLIN( 541)			int aC1 = ((colorD >> 24) & 255);
HXDLIN( 541)			int rC1 = ((colorD >> 16) & 255);
HXDLIN( 541)			int gC1 = ((colorD >> 8) & 255);
HXDLIN( 541)			int bC1 = (colorD & 255);
HXDLIN( 541)			Float bcx1 = (cx - dx);
HXDLIN( 541)			Float bcy1 = (cy - dy);
HXDLIN( 541)			Float acx1 = (bx - dx);
HXDLIN( 541)			Float acy1 = (by - dy);
HXDLIN( 541)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 541)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 541)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 541)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 541)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 541)			if ((bx > cx)) {
HXLINE( 541)				if ((bx > dx)) {
HXLINE( 541)					int min4;
HXDLIN( 541)					if ((cx > dx)) {
HXLINE( 541)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 541)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 541)					int ii_min8 = min4;
HXDLIN( 541)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 541)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 541)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 541)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 541)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 541)				if ((cx > dx)) {
HXLINE( 541)					int min5;
HXDLIN( 541)					if ((bx > dx)) {
HXLINE( 541)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 541)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 541)					int ii_min10 = min5;
HXDLIN( 541)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 541)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 541)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 541)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 541)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 541)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 541)			if ((by > cy)) {
HXLINE( 541)				if ((by > dy)) {
HXLINE( 541)					int min6;
HXDLIN( 541)					if ((cy > dy)) {
HXLINE( 541)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 541)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 541)					int ii_min12 = min6;
HXDLIN( 541)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 541)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 541)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 541)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 541)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 541)				if ((cy > dy)) {
HXLINE( 541)					int min7;
HXDLIN( 541)					if ((by > dy)) {
HXLINE( 541)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 541)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 541)					int ii_min14 = min7;
HXDLIN( 541)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 541)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 541)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 541)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 541)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 541)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 541)			if (hasUndo1) {
HXLINE( 541)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 541)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 541)				 ::Dynamic imageType1 = null();
HXDLIN( 541)				 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 541)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 541)				::Dynamic undoImage4;
HXDLIN( 541)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 541)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 541)						{
HXLINE( 541)							b6->width = width1;
HXDLIN( 541)							b6->height = height1;
HXDLIN( 541)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 541)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 541)							{
HXLINE( 541)								int len2 = b6->length;
HXDLIN( 541)								int w1 = 0;
HXDLIN( 541)								{
HXLINE( 541)									int _g20 = 0;
HXDLIN( 541)									int _g21 = b6->height;
HXDLIN( 541)									while((_g20 < _g21)){
HXLINE( 541)										_g20 = (_g20 + 1);
HXDLIN( 541)										int y3 = (_g20 - 1);
HXDLIN( 541)										{
HXLINE( 541)											int _g22 = 0;
HXDLIN( 541)											int _g23 = b6->width;
HXDLIN( 541)											while((_g22 < _g23)){
HXLINE( 541)												_g22 = (_g22 + 1);
HXDLIN( 541)												int x3 = (_g22 - 1);
HXDLIN( 541)												{
HXLINE( 541)													w1 = (w1 + 1);
HXDLIN( 541)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w1 = (w1 + 1);
HXDLIN( 541)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w1 = (w1 + 1);
HXDLIN( 541)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 541)												{
HXLINE( 541)													w1 = (w1 + 1);
HXDLIN( 541)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 541)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 541)						{
HXLINE( 541)							a7->width = width1;
HXDLIN( 541)							a7->height = height1;
HXDLIN( 541)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 541)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 541)							{
HXLINE( 541)								int _g24 = 0;
HXDLIN( 541)								int _g25 = a7->length;
HXDLIN( 541)								while((_g24 < _g25)){
HXLINE( 541)									_g24 = (_g24 + 1);
HXDLIN( 541)									int i10 = (_g24 - 1);
HXDLIN( 541)									a7->data[i10] = 0;
            								}
            							}
            						}
HXDLIN( 541)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 541)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 541)						{
HXLINE( 541)							b7->width = width1;
HXDLIN( 541)							b7->height = height1;
HXDLIN( 541)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 541)							int size1 = (b7->length * 4);
HXDLIN( 541)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 541)							{
HXLINE( 541)								int _g26 = 0;
HXDLIN( 541)								int _g27 = b7->length;
HXDLIN( 541)								while((_g26 < _g27)){
HXLINE( 541)									_g26 = (_g26 + 1);
HXDLIN( 541)									int i11 = (_g26 - 1);
HXDLIN( 541)									{
HXLINE( 541)										 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN( 541)										bool undoImage5;
HXDLIN( 541)										if ((i11 >= 0)) {
HXLINE( 541)											undoImage5 = (i11 < (this33->byteLength >> 2));
            										}
            										else {
HXLINE( 541)											undoImage5 = false;
            										}
HXDLIN( 541)										if (undoImage5) {
HXLINE( 541)											 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 541)											int pos1 = ((i11 << 2) + this33->byteOffset);
HXDLIN( 541)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 541)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 541)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 541)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 541)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 541)						{
HXLINE( 541)							v3->width = width1;
HXDLIN( 541)							v3->height = height1;
HXDLIN( 541)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 541)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 541)							{
HXLINE( 541)								int _g28 = 0;
HXDLIN( 541)								int _g29 = v3->length;
HXDLIN( 541)								while((_g28 < _g29)){
HXLINE( 541)									_g28 = (_g28 + 1);
HXDLIN( 541)									int i12 = (_g28 - 1);
HXDLIN( 541)									v3->data->__unsafe_set(i12,0);
            								}
            							}
            						}
HXDLIN( 541)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 541)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 541)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 541)						{
HXLINE( 541)							b8->width = width1;
HXDLIN( 541)							b8->height = height1;
HXDLIN( 541)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 541)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 541)							{
HXLINE( 541)								int len3 = b8->length;
HXDLIN( 541)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 541)								if (::hx::IsNull( d1->head )) {
HXLINE( 541)									int _g30 = 0;
HXDLIN( 541)									int _g31 = len3;
HXDLIN( 541)									while((_g30 < _g31)){
HXLINE( 541)										_g30 = (_g30 + 1);
HXDLIN( 541)										int i13 = (_g30 - 1);
HXDLIN( 541)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 541)									int _g32 = 0;
HXDLIN( 541)									int _g33 = len3;
HXDLIN( 541)									while((_g32 < _g33)){
HXLINE( 541)										_g32 = (_g32 + 1);
HXDLIN( 541)										int i14 = (_g32 - 1);
HXDLIN( 541)										{
HXLINE( 541)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 541)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 541)											{
HXLINE( 541)												int _g34 = 0;
HXDLIN( 541)												int _g35 = i14;
HXDLIN( 541)												while((_g34 < _g35)){
HXLINE( 541)													_g34 = (_g34 + 1);
HXDLIN( 541)													int i15 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 541)											if (::hx::IsNull( prev1 )) {
HXLINE( 541)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 541)												l1 = null();
            											}
            											else {
HXLINE( 541)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 541)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 541)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN( 541)				this32->image = undoImage4;
HXDLIN( 541)				this32->width = width1;
HXDLIN( 541)				this32->height = height1;
HXDLIN( 541)				this32->imageType = ( (int)(imageType1) );
HXDLIN( 541)				undoImage3 = this32;
HXDLIN( 541)				{
HXLINE( 541)					int rectLeft1 = xIter31->start;
HXDLIN( 541)					int rectTop1 = yIter31->start;
HXDLIN( 541)					int rectRight1 = xIter31->max;
HXDLIN( 541)					bool forceClear1 = false;
HXDLIN( 541)					{
HXLINE( 541)						int _g36 = rectTop1;
HXDLIN( 541)						int _g37 = yIter31->max;
HXDLIN( 541)						while((_g36 < _g37)){
HXLINE( 541)							_g36 = (_g36 + 1);
HXDLIN( 541)							int dy2 = (_g36 - 1);
HXDLIN( 541)							{
HXLINE( 541)								int _g38 = rectLeft1;
HXDLIN( 541)								int _g39 = rectRight1;
HXDLIN( 541)								while((_g38 < _g39)){
HXLINE( 541)									_g38 = (_g38 + 1);
HXDLIN( 541)									int dx2 = (_g38 - 1);
HXDLIN( 541)									::Dynamic this34 = pixelImage->image;
HXDLIN( 541)									int index4;
HXDLIN( 541)									if (pixelImage->useVirtualPos) {
HXLINE( 541)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 541)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 541)									int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 541)									int col1;
HXDLIN( 541)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 541)										col1 = c3;
            									}
HXDLIN( 541)									bool _hx_tmp8;
HXDLIN( 541)									if (pixelImage->useMask) {
HXLINE( 541)										_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 541)										_hx_tmp8 = false;
            									}
HXDLIN( 541)									if (_hx_tmp8) {
HXLINE( 541)										 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN( 541)										::Dynamic this36 = this35->image;
HXDLIN( 541)										int index5;
HXDLIN( 541)										if (this35->useVirtualPos) {
HXLINE( 541)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            										}
            										else {
HXLINE( 541)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            										}
HXDLIN( 541)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 541)										int v4;
HXDLIN( 541)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 541)											v4 = c4;
            										}
HXDLIN( 541)										int maskPixel1 = v4;
HXDLIN( 541)										int this37 = col1;
HXDLIN( 541)										if ((maskPixel1 == 0)) {
HXLINE( 541)											col1 = this37;
            										}
            										else {
HXLINE( 541)											Float m01;
HXDLIN( 541)											int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 541)											if ((this38 == 0)) {
HXLINE( 541)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m11;
HXDLIN( 541)											int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 541)											if ((this39 == 0)) {
HXLINE( 541)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m21;
HXDLIN( 541)											int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 541)											if ((this40 == 0)) {
HXLINE( 541)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float m31;
HXDLIN( 541)											int this41 = (maskPixel1 & 255);
HXDLIN( 541)											if ((this41 == 0)) {
HXLINE( 541)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 541)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 541)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 541)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 541)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 541)									if ((col1 != 0)) {
HXLINE( 541)										int x4 = (dx2 - rectLeft1);
HXDLIN( 541)										int y4 = (dy2 - rectTop1);
HXDLIN( 541)										int c5 = col1;
HXDLIN( 541)										bool _hx_tmp9;
HXDLIN( 541)										if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 541)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXLINE( 541)											_hx_tmp9 = false;
            										}
HXDLIN( 541)										if (_hx_tmp9) {
HXLINE( 541)											int location2;
HXDLIN( 541)											if (undoImage3->useVirtualPos) {
HXLINE( 541)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 541)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 541)											int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 541)											int this43;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												this43 = this42;
            											}
HXDLIN( 541)											Float a12;
HXDLIN( 541)											int this44 = ((this43 >> 24) & 255);
HXDLIN( 541)											if ((this44 == 0)) {
HXLINE( 541)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float r12;
HXDLIN( 541)											int this45 = ((this43 >> 16) & 255);
HXDLIN( 541)											if ((this45 == 0)) {
HXLINE( 541)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float g12;
HXDLIN( 541)											int this46 = ((this43 >> 8) & 255);
HXDLIN( 541)											if ((this46 == 0)) {
HXLINE( 541)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float b13;
HXDLIN( 541)											int this47 = (this43 & 255);
HXDLIN( 541)											if ((this47 == 0)) {
HXLINE( 541)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float a22;
HXDLIN( 541)											int this48 = ((col1 >> 24) & 255);
HXDLIN( 541)											if ((this48 == 0)) {
HXLINE( 541)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float r22;
HXDLIN( 541)											int this49 = ((col1 >> 16) & 255);
HXDLIN( 541)											if ((this49 == 0)) {
HXLINE( 541)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float g22;
HXDLIN( 541)											int this50 = ((col1 >> 8) & 255);
HXDLIN( 541)											if ((this50 == 0)) {
HXLINE( 541)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float b23;
HXDLIN( 541)											int this51 = (col1 & 255);
HXDLIN( 541)											if ((this51 == 0)) {
HXLINE( 541)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 541)												b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN( 541)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 541)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 541)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 541)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 541)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 541)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 541)											{
HXLINE( 541)												int _hx_tmp10;
HXDLIN( 541)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 541)													_hx_tmp10 = blended2;
            												}
HXDLIN( 541)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXLINE( 541)											::Dynamic this52 = undoImage3->image;
HXDLIN( 541)											int index6;
HXDLIN( 541)											if (undoImage3->useVirtualPos) {
HXLINE( 541)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 541)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 541)											int _hx_tmp11;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												_hx_tmp11 = c5;
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            										}
            									}
            									else {
HXLINE( 541)										if (forceClear1) {
HXLINE( 541)											::Dynamic this53 = undoImage3->image;
HXDLIN( 541)											int x5 = (dx2 - rectLeft1);
HXDLIN( 541)											int y5 = (dy2 - rectTop1);
HXDLIN( 541)											int index7;
HXDLIN( 541)											if (undoImage3->useVirtualPos) {
HXLINE( 541)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 541)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(this53,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 541)			{
HXLINE( 541)				int _g_min2 = xIter31->start;
HXDLIN( 541)				int _g_max2 = xIter31->max;
HXDLIN( 541)				while((_g_min2 < _g_max2)){
HXLINE( 541)					_g_min2 = (_g_min2 + 1);
HXDLIN( 541)					int px2 = (_g_min2 - 1);
HXDLIN( 541)					Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 541)					{
HXLINE( 541)						int _g_min3 = yIter31->start;
HXDLIN( 541)						int _g_max3 = yIter31->max;
HXDLIN( 541)						while((_g_min3 < _g_max3)){
HXLINE( 541)							_g_min3 = (_g_min3 + 1);
HXDLIN( 541)							int py2 = (_g_min3 - 1);
HXDLIN( 541)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 541)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 541)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 541)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 541)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 541)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 541)							bool _hx_tmp12;
HXDLIN( 541)							bool _hx_tmp13;
HXDLIN( 541)							if ((ratioA1 >= 0)) {
HXLINE( 541)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 541)								_hx_tmp13 = false;
            							}
HXDLIN( 541)							if (_hx_tmp13) {
HXLINE( 541)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 541)								_hx_tmp12 = false;
            							}
HXDLIN( 541)							if (_hx_tmp12) {
HXLINE( 541)								int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 541)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 541)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 541)								int a9 = i16;
HXDLIN( 541)								int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 541)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 541)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 541)								int r6 = i17;
HXDLIN( 541)								int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 541)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 541)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 541)								int g6 = i18;
HXDLIN( 541)								int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 541)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 541)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 541)								int b10 = i19;
HXDLIN( 541)								{
HXLINE( 541)									int location3;
HXDLIN( 541)									if (pixelImage->useVirtualPos) {
HXLINE( 541)										location3 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 541)										location3 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            									}
HXDLIN( 541)									bool _hx_tmp14;
HXDLIN( 541)									if (pixelImage->transparent) {
HXLINE( 541)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXLINE( 541)										_hx_tmp14 = false;
            									}
HXDLIN( 541)									if (_hx_tmp14) {
HXLINE( 541)										int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 541)										int old1;
HXDLIN( 541)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)											old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            										}
            										else {
HXLINE( 541)											old1 = this54;
            										}
HXDLIN( 541)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 541)										Float a13;
HXDLIN( 541)										int this55 = ((old1 >> 24) & 255);
HXDLIN( 541)										if ((this55 == 0)) {
HXLINE( 541)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											a13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float r13;
HXDLIN( 541)										int this56 = ((old1 >> 16) & 255);
HXDLIN( 541)										if ((this56 == 0)) {
HXLINE( 541)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float g13;
HXDLIN( 541)										int this57 = ((old1 >> 8) & 255);
HXDLIN( 541)										if ((this57 == 0)) {
HXLINE( 541)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float b14;
HXDLIN( 541)										int this58 = (old1 & 255);
HXDLIN( 541)										if ((this58 == 0)) {
HXLINE( 541)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											b14 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float a23;
HXDLIN( 541)										int this59 = ((rhs1 >> 24) & 255);
HXDLIN( 541)										if ((this59 == 0)) {
HXLINE( 541)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float r23;
HXDLIN( 541)										int this60 = ((rhs1 >> 16) & 255);
HXDLIN( 541)										if ((this60 == 0)) {
HXLINE( 541)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float g23;
HXDLIN( 541)										int this61 = ((rhs1 >> 8) & 255);
HXDLIN( 541)										if ((this61 == 0)) {
HXLINE( 541)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float b24;
HXDLIN( 541)										int this62 = (rhs1 & 255);
HXDLIN( 541)										if ((this62 == 0)) {
HXLINE( 541)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 541)											b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 541)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 541)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 541)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 541)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 541)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 541)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 541)										{
HXLINE( 541)											int _hx_tmp15;
HXDLIN( 541)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 541)												_hx_tmp15 = blended3;
            											}
HXDLIN( 541)											::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 541)										int value1;
HXDLIN( 541)										if (pixelImage->isLittle) {
HXLINE( 541)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXLINE( 541)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN( 541)										::iterMagic::Iimg_obj::set(pixelImage->image,location3,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 541)			if ((hasHit1 == false)) {
HXLINE( 541)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 541)				if (hasUndo1) {
HXLINE( 541)					v5->undoImage = undoImage3;
HXDLIN( 541)					v5->undoX = xIter31->start;
HXDLIN( 541)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 541)		if ((hasHit == true)) {
HXLINE( 541)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 541)			return v6;
            		}
            		else {
HXLINE( 541)			return null();
            		}
HXDLIN( 541)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(LinePixel_Fields__obj,rotateGradLineFlare,return )


LinePixel_Fields__obj::LinePixel_Fields__obj()
{
}

bool LinePixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"rotateLine") ) { outValue = rotateLine_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"rotateSoftLine") ) { outValue = rotateSoftLine_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotateTileLine") ) { outValue = rotateTileLine_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotateGradLine") ) { outValue = rotateGradLine_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"rotateLineFlare") ) { outValue = rotateLineFlare_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"rotateSoftLineFlare") ) { outValue = rotateSoftLineFlare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotateTileLineFlare") ) { outValue = rotateTileLineFlare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotateGradLineFlare") ) { outValue = rotateGradLineFlare_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"rotateSoftLineLuxury") ) { outValue = rotateSoftLineLuxury_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"rotateSoftLinePartial") ) { outValue = rotateSoftLinePartial_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"rotateSoftLineFlarePartial") ) { outValue = rotateSoftLineFlarePartial_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *LinePixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *LinePixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class LinePixel_Fields__obj::__mClass;

static ::String LinePixel_Fields__obj_sStaticFields[] = {
	HX_("rotateLine",ef,53,be,7f),
	HX_("rotateSoftLine",79,73,3e,42),
	HX_("rotateSoftLineLuxury",66,e5,67,61),
	HX_("rotateSoftLinePartial",08,dd,9b,0b),
	HX_("rotateLineFlare",5f,ae,79,73),
	HX_("rotateSoftLineFlare",95,fa,68,de),
	HX_("rotateSoftLineFlarePartial",6c,b1,64,84),
	HX_("rotateTileLine",bd,93,11,45),
	HX_("rotateTileLineFlare",d1,63,86,5a),
	HX_("rotateGradLine",5d,68,6f,da),
	HX_("rotateGradLineFlare",31,cb,a1,d5),
	::String(null())
};

void LinePixel_Fields__obj::__register()
{
	LinePixel_Fields__obj _hx_dummy;
	LinePixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._LinePixel.LinePixel_Fields_",72,b1,b2,cb);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &LinePixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(LinePixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< LinePixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LinePixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LinePixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _LinePixel
