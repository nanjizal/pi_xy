// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__PolyPixel_PolyPixel_Fields_
#include <pi_xy/algo/_PolyPixel/PolyPixel_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_87ef2d4220a4cd37_13_fillPolygonBuild,"pi_xy.algo._PolyPixel.PolyPixel_Fields_","fillPolygonBuild",0x0eae8aa3,"pi_xy.algo._PolyPixel.PolyPixel_Fields_.fillPolygonBuild","pi_xy/algo/PolyPixel.hx",13,0xb2bee0f8)
HX_LOCAL_STACK_FRAME(_hx_pos_87ef2d4220a4cd37_73_softFillPolygonBuild,"pi_xy.algo._PolyPixel.PolyPixel_Fields_","softFillPolygonBuild",0x96c17dad,"pi_xy.algo._PolyPixel.PolyPixel_Fields_.softFillPolygonBuild","pi_xy/algo/PolyPixel.hx",73,0xb2bee0f8)
HX_LOCAL_STACK_FRAME(_hx_pos_87ef2d4220a4cd37_132_tilePolygonBuild,"pi_xy.algo._PolyPixel.PolyPixel_Fields_","tilePolygonBuild",0x0b0d5bce,"pi_xy.algo._PolyPixel.PolyPixel_Fields_.tilePolygonBuild","pi_xy/algo/PolyPixel.hx",132,0xb2bee0f8)
HX_LOCAL_STACK_FRAME(_hx_pos_87ef2d4220a4cd37_192_fillRadialPolyBuild,"pi_xy.algo._PolyPixel.PolyPixel_Fields_","fillRadialPolyBuild",0x8b6e2574,"pi_xy.algo._PolyPixel.PolyPixel_Fields_.fillRadialPolyBuild","pi_xy/algo/PolyPixel.hx",192,0xb2bee0f8)
namespace pi_xy{
namespace algo{
namespace _PolyPixel{

void PolyPixel_Fields__obj::__construct() { }

Dynamic PolyPixel_Fields__obj::__CreateEmpty() { return new PolyPixel_Fields__obj; }

void *PolyPixel_Fields__obj::_hx_vtable = 0;

Dynamic PolyPixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PolyPixel_Fields__obj > _hx_result = new PolyPixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PolyPixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x64dd322c;
}

void PolyPixel_Fields__obj::fillPolygonBuild( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_87ef2d4220a4cd37_13_fillPolygonBuild)
HXLINE(  14)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE(  15)		Float omega;
HXDLIN(  15)		if (cornerUp) {
HXLINE(  15)			omega = ((Float)0.);
            		}
            		else {
HXLINE(  19)			if ((::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(2) ))) == (( (Float)(sides) ) / ( (Float)(2) )))) {
HXLINE(  15)				omega = (::Math_obj::PI / ( (Float)(sides) ));
            			}
            			else {
HXLINE(  22)				Float v = ((( (Float)(sides) ) / ( (Float)(2) )) - ((Float)0.5));
HXLINE(  23)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXLINE(  15)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) )) - ::Math_obj::PI);
            				}
            				else {
HXLINE(  15)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) ));
            				}
            			}
            		}
HXLINE(  32)		Float lastX = ((Float)0.);
HXLINE(  33)		Float lastY = ((Float)0.);
HXLINE(  34)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  35)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  36)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  38)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  39)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE(  41)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  42)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE(  43)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE(  44)			{
HXLINE(  44)				int _g = 0;
HXDLIN(  44)				int _g1 = (sides + 1);
HXDLIN(  44)				while((_g < _g1)){
HXLINE(  44)					_g = (_g + 1);
HXDLIN(  44)					int i = (_g - 1);
HXLINE(  45)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE(  46)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE(  47)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE(  48)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE(  49)					{
HXLINE(  49)						 ::pi_xy::ImageStruct this1 = pixelimage;
HXDLIN(  49)						bool hasHit = false;
HXDLIN(  49)						bool hasUndo = false;
HXDLIN(  49)						{
HXLINE(  49)							Float bx = lastX;
HXDLIN(  49)							Float by = lastY;
HXDLIN(  49)							Float cx1 = nextX;
HXDLIN(  49)							Float cy1 = nextY;
HXDLIN(  49)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  49)							if (!(adjustWinding)) {
HXLINE(  49)								Float bx_ = bx;
HXDLIN(  49)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE(  49)							{
HXLINE(  49)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  49)								Float sx = (cy1 - cy);
HXDLIN(  49)								Float sy = (cx - cx1);
HXDLIN(  49)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  49)								Float tx = (cy - by);
HXDLIN(  49)								Float ty = (bx - cx);
HXDLIN(  49)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  49)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  49)								if ((cx > bx)) {
HXLINE(  49)									if ((cx > cx1)) {
HXLINE(  49)										int min;
HXDLIN(  49)										if ((bx > cx1)) {
HXLINE(  49)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  49)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  49)										int ii_min = min;
HXDLIN(  49)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  49)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE(  49)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  49)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  49)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE(  49)									if ((bx > cx1)) {
HXLINE(  49)										int min1;
HXDLIN(  49)										if ((cx > cx1)) {
HXLINE(  49)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  49)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN(  49)										int ii_min2 = min1;
HXDLIN(  49)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  49)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE(  49)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  49)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  49)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN(  49)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  49)								if ((cy > by)) {
HXLINE(  49)									if ((cy > cy1)) {
HXLINE(  49)										int min2;
HXDLIN(  49)										if ((by > cy1)) {
HXLINE(  49)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  49)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN(  49)										int ii_min4 = min2;
HXDLIN(  49)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  49)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE(  49)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  49)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  49)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE(  49)									if ((by > cy1)) {
HXLINE(  49)										int min3;
HXDLIN(  49)										if ((cy > cy1)) {
HXLINE(  49)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  49)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN(  49)										int ii_min6 = min3;
HXDLIN(  49)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  49)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE(  49)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  49)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  49)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN(  49)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  49)								if (hasUndo) {
HXLINE(  49)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  49)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  49)									 ::Dynamic imageType = null();
HXDLIN(  49)									 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  49)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  49)									::Dynamic undoImage1;
HXDLIN(  49)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE(  49)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  49)											 ::iterMagic::BytesImg b = byt;
HXDLIN(  49)											{
HXLINE(  49)												b->width = width;
HXDLIN(  49)												b->height = height;
HXDLIN(  49)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  49)												{
HXLINE(  49)													int len = b->length;
HXDLIN(  49)													int w = 0;
HXDLIN(  49)													{
HXLINE(  49)														int _g2 = 0;
HXDLIN(  49)														int _g3 = b->height;
HXDLIN(  49)														while((_g2 < _g3)){
HXLINE(  49)															_g2 = (_g2 + 1);
HXDLIN(  49)															int y = (_g2 - 1);
HXDLIN(  49)															{
HXLINE(  49)																int _g4 = 0;
HXDLIN(  49)																int _g5 = b->width;
HXDLIN(  49)																while((_g4 < _g5)){
HXLINE(  49)																	_g4 = (_g4 + 1);
HXDLIN(  49)																	int x = (_g4 - 1);
HXDLIN(  49)																	{
HXLINE(  49)																		w = (w + 1);
HXDLIN(  49)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  49)																	{
HXLINE(  49)																		w = (w + 1);
HXDLIN(  49)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  49)																	{
HXLINE(  49)																		w = (w + 1);
HXDLIN(  49)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  49)																	{
HXLINE(  49)																		w = (w + 1);
HXDLIN(  49)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  49)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE(  49)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  49)											{
HXLINE(  49)												a->width = width;
HXDLIN(  49)												a->height = height;
HXDLIN(  49)												a->data = ::Array_obj< int >::__new(0);
HXDLIN(  49)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)												{
HXLINE(  49)													int _g6 = 0;
HXDLIN(  49)													int _g7 = a->length;
HXDLIN(  49)													while((_g6 < _g7)){
HXLINE(  49)														_g6 = (_g6 + 1);
HXDLIN(  49)														int i1 = (_g6 - 1);
HXDLIN(  49)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN(  49)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE(  49)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  49)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  49)											{
HXLINE(  49)												b1->width = width;
HXDLIN(  49)												b1->height = height;
HXDLIN(  49)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)												int size = (b1->length * 4);
HXDLIN(  49)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  49)												{
HXLINE(  49)													int _g8 = 0;
HXDLIN(  49)													int _g9 = b1->length;
HXDLIN(  49)													while((_g8 < _g9)){
HXLINE(  49)														_g8 = (_g8 + 1);
HXDLIN(  49)														int i2 = (_g8 - 1);
HXDLIN(  49)														{
HXLINE(  49)															 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  49)															bool undoImage2;
HXDLIN(  49)															if ((i2 >= 0)) {
HXLINE(  49)																undoImage2 = (i2 < (this3->byteLength >> 2));
            															}
            															else {
HXLINE(  49)																undoImage2 = false;
            															}
HXDLIN(  49)															if (undoImage2) {
HXLINE(  49)																 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  49)																int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN(  49)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  49)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  49)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  49)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  49)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE(  49)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)											 ::iterMagic::VecIntImg v1 = vec;
HXDLIN(  49)											{
HXLINE(  49)												v1->width = width;
HXDLIN(  49)												v1->height = height;
HXDLIN(  49)												v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)												v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  49)												{
HXLINE(  49)													int _g10 = 0;
HXDLIN(  49)													int _g11 = v1->length;
HXDLIN(  49)													while((_g10 < _g11)){
HXLINE(  49)														_g10 = (_g10 + 1);
HXDLIN(  49)														int i3 = (_g10 - 1);
HXDLIN(  49)														v1->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN(  49)											undoImage1 = v1;
            										}
            										break;
            										case (int)4: {
HXLINE(  49)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  49)											{
HXLINE(  49)												b2->width = width;
HXDLIN(  49)												b2->height = height;
HXDLIN(  49)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  49)												{
HXLINE(  49)													int len1 = b2->length;
HXDLIN(  49)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  49)													if (::hx::IsNull( d->head )) {
HXLINE(  49)														int _g12 = 0;
HXDLIN(  49)														int _g13 = len1;
HXDLIN(  49)														while((_g12 < _g13)){
HXLINE(  49)															_g12 = (_g12 + 1);
HXDLIN(  49)															int i4 = (_g12 - 1);
HXDLIN(  49)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE(  49)														int _g14 = 0;
HXDLIN(  49)														int _g15 = len1;
HXDLIN(  49)														while((_g14 < _g15)){
HXLINE(  49)															_g14 = (_g14 + 1);
HXDLIN(  49)															int i5 = (_g14 - 1);
HXDLIN(  49)															{
HXLINE(  49)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  49)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  49)																{
HXLINE(  49)																	int _g16 = 0;
HXDLIN(  49)																	int _g17 = i5;
HXDLIN(  49)																	while((_g16 < _g17)){
HXLINE(  49)																		_g16 = (_g16 + 1);
HXDLIN(  49)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE(  49)																if (::hx::IsNull( prev )) {
HXLINE(  49)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)																	l = null();
            																}
            																else {
HXLINE(  49)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  49)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN(  49)									this2->image = undoImage1;
HXDLIN(  49)									this2->width = width;
HXDLIN(  49)									this2->height = height;
HXDLIN(  49)									this2->imageType = ( (int)(imageType) );
HXDLIN(  49)									undoImage = this2;
HXDLIN(  49)									{
HXLINE(  49)										int rectLeft = xIter3->start;
HXDLIN(  49)										int rectTop = yIter3->start;
HXDLIN(  49)										int rectRight = xIter3->max;
HXDLIN(  49)										bool forceClear = false;
HXDLIN(  49)										{
HXLINE(  49)											int _g18 = rectTop;
HXDLIN(  49)											int _g19 = yIter3->max;
HXDLIN(  49)											while((_g18 < _g19)){
HXLINE(  49)												_g18 = (_g18 + 1);
HXDLIN(  49)												int dy = (_g18 - 1);
HXDLIN(  49)												{
HXLINE(  49)													int _g20 = rectLeft;
HXDLIN(  49)													int _g21 = rectRight;
HXDLIN(  49)													while((_g20 < _g21)){
HXLINE(  49)														_g20 = (_g20 + 1);
HXDLIN(  49)														int dx = (_g20 - 1);
HXDLIN(  49)														::Dynamic this4 = this1->image;
HXDLIN(  49)														int index;
HXDLIN(  49)														if (this1->useVirtualPos) {
HXLINE(  49)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  49)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  49)														int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  49)														int col;
HXDLIN(  49)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  49)															col = c;
            														}
HXDLIN(  49)														bool _hx_tmp;
HXDLIN(  49)														if (this1->useMask) {
HXLINE(  49)															_hx_tmp = ::hx::IsNotNull( this1->mask );
            														}
            														else {
HXLINE(  49)															_hx_tmp = false;
            														}
HXDLIN(  49)														if (_hx_tmp) {
HXLINE(  49)															 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  49)															::Dynamic this6 = this5->image;
HXDLIN(  49)															int index1;
HXDLIN(  49)															if (this5->useVirtualPos) {
HXLINE(  49)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            															}
            															else {
HXLINE(  49)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            															}
HXDLIN(  49)															int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  49)															int v2;
HXDLIN(  49)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  49)																v2 = c1;
            															}
HXDLIN(  49)															int maskPixel = v2;
HXDLIN(  49)															int this7 = col;
HXDLIN(  49)															if ((maskPixel == 0)) {
HXLINE(  49)																col = this7;
            															}
            															else {
HXLINE(  49)																Float m0;
HXDLIN(  49)																int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  49)																if ((this8 == 0)) {
HXLINE(  49)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float m1;
HXDLIN(  49)																int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  49)																if ((this9 == 0)) {
HXLINE(  49)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float m2;
HXDLIN(  49)																int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  49)																if ((this10 == 0)) {
HXLINE(  49)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float m3;
HXDLIN(  49)																int this11 = (maskPixel & 255);
HXDLIN(  49)																if ((this11 == 0)) {
HXLINE(  49)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  49)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  49)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  49)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  49)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  49)														if ((col != 0)) {
HXLINE(  49)															int x1 = (dx - rectLeft);
HXDLIN(  49)															int y1 = (dy - rectTop);
HXDLIN(  49)															int c2 = col;
HXDLIN(  49)															bool _hx_tmp1;
HXDLIN(  49)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  49)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE(  49)																_hx_tmp1 = false;
            															}
HXDLIN(  49)															if (_hx_tmp1) {
HXLINE(  49)																int location;
HXDLIN(  49)																if (undoImage->useVirtualPos) {
HXLINE(  49)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  49)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  49)																int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  49)																int this13;
HXDLIN(  49)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																	this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            																}
            																else {
HXLINE(  49)																	this13 = this12;
            																}
HXDLIN(  49)																Float a1;
HXDLIN(  49)																int this14 = ((this13 >> 24) & 255);
HXDLIN(  49)																if ((this14 == 0)) {
HXLINE(  49)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float r1;
HXDLIN(  49)																int this15 = ((this13 >> 16) & 255);
HXDLIN(  49)																if ((this15 == 0)) {
HXLINE(  49)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float g1;
HXDLIN(  49)																int this16 = ((this13 >> 8) & 255);
HXDLIN(  49)																if ((this16 == 0)) {
HXLINE(  49)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float b11;
HXDLIN(  49)																int this17 = (this13 & 255);
HXDLIN(  49)																if ((this17 == 0)) {
HXLINE(  49)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float a2;
HXDLIN(  49)																int this18 = ((col >> 24) & 255);
HXDLIN(  49)																if ((this18 == 0)) {
HXLINE(  49)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float r2;
HXDLIN(  49)																int this19 = ((col >> 16) & 255);
HXDLIN(  49)																if ((this19 == 0)) {
HXLINE(  49)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float g2;
HXDLIN(  49)																int this20 = ((col >> 8) & 255);
HXDLIN(  49)																if ((this20 == 0)) {
HXLINE(  49)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float b21;
HXDLIN(  49)																int this21 = (col & 255);
HXDLIN(  49)																if ((this21 == 0)) {
HXLINE(  49)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  49)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  49)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  49)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  49)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  49)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  49)																{
HXLINE(  49)																	int _hx_tmp2;
HXDLIN(  49)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  49)																		_hx_tmp2 = blended;
            																	}
HXDLIN(  49)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE(  49)																::Dynamic this22 = undoImage->image;
HXDLIN(  49)																int index2;
HXDLIN(  49)																if (undoImage->useVirtualPos) {
HXLINE(  49)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  49)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  49)																int _hx_tmp3;
HXDLIN(  49)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE(  49)																	_hx_tmp3 = c2;
            																}
HXDLIN(  49)																::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE(  49)															if (forceClear) {
HXLINE(  49)																::Dynamic this23 = undoImage->image;
HXDLIN(  49)																int x2 = (dx - rectLeft);
HXDLIN(  49)																int y2 = (dy - rectTop);
HXDLIN(  49)																int index3;
HXDLIN(  49)																if (undoImage->useVirtualPos) {
HXLINE(  49)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE(  49)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN(  49)																::iterMagic::Iimg_obj::set(this23,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  49)								bool found = false;
HXDLIN(  49)								Float s = ((Float)0.);
HXDLIN(  49)								Float t = ((Float)0.);
HXDLIN(  49)								Float sxx = ((Float)0.);
HXDLIN(  49)								Float txx = ((Float)0.);
HXDLIN(  49)								{
HXLINE(  49)									int _g_min = xIter3->start;
HXDLIN(  49)									int _g_max = xIter3->max;
HXDLIN(  49)									while((_g_min < _g_max)){
HXLINE(  49)										_g_min = (_g_min + 1);
HXDLIN(  49)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE(  49)										{
HXLINE(  49)											int _g_min1 = yIter3->start;
HXDLIN(  49)											int _g_max1 = yIter3->max;
HXDLIN(  49)											while((_g_min1 < _g_max1)){
HXLINE(  49)												_g_min1 = (_g_min1 + 1);
HXDLIN(  49)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  49)												bool _hx_tmp4;
HXDLIN(  49)												if (!((s <= 0))) {
HXLINE(  49)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXLINE(  49)													_hx_tmp4 = true;
            												}
HXDLIN(  49)												if (_hx_tmp4) {
HXLINE(  49)													if (found) {
HXLINE(  49)														goto _hx_goto_12;
            													}
            												}
            												else {
HXLINE(  49)													if (((s + t) < A)) {
HXLINE(  49)														{
HXLINE(  49)															int c3 = color;
HXDLIN(  49)															bool _hx_tmp5;
HXDLIN(  49)															if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  49)																_hx_tmp5 = this1->transparent;
            															}
            															else {
HXLINE(  49)																_hx_tmp5 = false;
            															}
HXDLIN(  49)															if (_hx_tmp5) {
HXLINE(  49)																int location1;
HXDLIN(  49)																if (this1->useVirtualPos) {
HXLINE(  49)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  49)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  49)																int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  49)																int this25;
HXDLIN(  49)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																	this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            																}
            																else {
HXLINE(  49)																	this25 = this24;
            																}
HXDLIN(  49)																Float a11;
HXDLIN(  49)																int this26 = ((this25 >> 24) & 255);
HXDLIN(  49)																if ((this26 == 0)) {
HXLINE(  49)																	a11 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float r11;
HXDLIN(  49)																int this27 = ((this25 >> 16) & 255);
HXDLIN(  49)																if ((this27 == 0)) {
HXLINE(  49)																	r11 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float g11;
HXDLIN(  49)																int this28 = ((this25 >> 8) & 255);
HXDLIN(  49)																if ((this28 == 0)) {
HXLINE(  49)																	g11 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float b12;
HXDLIN(  49)																int this29 = (this25 & 255);
HXDLIN(  49)																if ((this29 == 0)) {
HXLINE(  49)																	b12 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float a21;
HXDLIN(  49)																int this30 = ((color >> 24) & 255);
HXDLIN(  49)																if ((this30 == 0)) {
HXLINE(  49)																	a21 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float r21;
HXDLIN(  49)																int this31 = ((color >> 16) & 255);
HXDLIN(  49)																if ((this31 == 0)) {
HXLINE(  49)																	r21 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float g21;
HXDLIN(  49)																int this32 = ((color >> 8) & 255);
HXDLIN(  49)																if ((this32 == 0)) {
HXLINE(  49)																	g21 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float b22;
HXDLIN(  49)																int this33 = (color & 255);
HXDLIN(  49)																if ((this33 == 0)) {
HXLINE(  49)																	b22 = ((Float)0.);
            																}
            																else {
HXLINE(  49)																	b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN(  49)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  49)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  49)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  49)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  49)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  49)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  49)																{
HXLINE(  49)																	int _hx_tmp6;
HXDLIN(  49)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXLINE(  49)																		_hx_tmp6 = blended1;
            																	}
HXDLIN(  49)																	::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXLINE(  49)																::Dynamic this34 = this1->image;
HXDLIN(  49)																int index4;
HXDLIN(  49)																if (this1->useVirtualPos) {
HXLINE(  49)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  49)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  49)																int _hx_tmp7;
HXDLIN(  49)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXLINE(  49)																	_hx_tmp7 = c3;
            																}
HXDLIN(  49)																::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXLINE(  49)														if (found) {
HXLINE(  49)															goto _hx_goto_12;
            														}
            													}
            												}
            											}
            											_hx_goto_12:;
            										}
            									}
            								}
HXDLIN(  49)								if ((hasHit == true)) {
HXLINE(  49)									 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  49)									if (hasUndo) {
HXLINE(  49)										v3->undoImage = undoImage;
HXDLIN(  49)										v3->undoX = xIter3->start;
HXDLIN(  49)										v3->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  51)					lastX = nextX;
HXLINE(  52)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE(  55)			int _g22 = 0;
HXDLIN(  55)			int _g23 = (sides + 1);
HXDLIN(  55)			while((_g22 < _g23)){
HXLINE(  55)				_g22 = (_g22 + 1);
HXDLIN(  55)				int i7 = (_g22 - 1);
HXLINE(  56)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXLINE(  57)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXLINE(  58)				{
HXLINE(  58)					 ::pi_xy::ImageStruct this35 = pixelimage;
HXDLIN(  58)					bool hasHit1 = false;
HXDLIN(  58)					bool hasUndo1 = false;
HXDLIN(  58)					{
HXLINE(  58)						Float bx1 = lastX;
HXDLIN(  58)						Float by1 = lastY;
HXDLIN(  58)						Float cx2 = nextX1;
HXDLIN(  58)						Float cy2 = nextY1;
HXDLIN(  58)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  58)						if (!(adjustWinding1)) {
HXLINE(  58)							Float bx_1 = bx1;
HXDLIN(  58)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE(  58)						{
HXLINE(  58)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  58)							Float sx1 = (cy2 - cy);
HXDLIN(  58)							Float sy1 = (cx - cx2);
HXDLIN(  58)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  58)							Float tx1 = (cy - by1);
HXDLIN(  58)							Float ty1 = (bx1 - cx);
HXDLIN(  58)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  58)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  58)							if ((cx > bx1)) {
HXLINE(  58)								if ((cx > cx2)) {
HXLINE(  58)									int min4;
HXDLIN(  58)									if ((bx1 > cx2)) {
HXLINE(  58)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  58)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN(  58)									int ii_min8 = min4;
HXDLIN(  58)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  58)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE(  58)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  58)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  58)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE(  58)								if ((bx1 > cx2)) {
HXLINE(  58)									int min5;
HXDLIN(  58)									if ((cx > cx2)) {
HXLINE(  58)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  58)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN(  58)									int ii_min10 = min5;
HXDLIN(  58)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  58)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE(  58)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  58)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  58)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  58)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  58)							if ((cy > by1)) {
HXLINE(  58)								if ((cy > cy2)) {
HXLINE(  58)									int min6;
HXDLIN(  58)									if ((by1 > cy2)) {
HXLINE(  58)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  58)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN(  58)									int ii_min12 = min6;
HXDLIN(  58)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  58)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE(  58)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  58)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  58)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE(  58)								if ((by1 > cy2)) {
HXLINE(  58)									int min7;
HXDLIN(  58)									if ((cy > cy2)) {
HXLINE(  58)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  58)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN(  58)									int ii_min14 = min7;
HXDLIN(  58)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  58)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE(  58)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  58)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  58)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  58)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  58)							if (hasUndo1) {
HXLINE(  58)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  58)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  58)								 ::Dynamic imageType1 = null();
HXDLIN(  58)								 ::pi_xy::ImageStruct this36 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  58)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  58)								::Dynamic undoImage4;
HXDLIN(  58)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE(  58)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  58)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  58)										{
HXLINE(  58)											b5->width = width1;
HXDLIN(  58)											b5->height = height1;
HXDLIN(  58)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  58)											{
HXLINE(  58)												int len2 = b5->length;
HXDLIN(  58)												int w1 = 0;
HXDLIN(  58)												{
HXLINE(  58)													int _g24 = 0;
HXDLIN(  58)													int _g25 = b5->height;
HXDLIN(  58)													while((_g24 < _g25)){
HXLINE(  58)														_g24 = (_g24 + 1);
HXDLIN(  58)														int y4 = (_g24 - 1);
HXDLIN(  58)														{
HXLINE(  58)															int _g26 = 0;
HXDLIN(  58)															int _g27 = b5->width;
HXDLIN(  58)															while((_g26 < _g27)){
HXLINE(  58)																_g26 = (_g26 + 1);
HXDLIN(  58)																int x4 = (_g26 - 1);
HXDLIN(  58)																{
HXLINE(  58)																	w1 = (w1 + 1);
HXDLIN(  58)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  58)																{
HXLINE(  58)																	w1 = (w1 + 1);
HXDLIN(  58)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  58)																{
HXLINE(  58)																	w1 = (w1 + 1);
HXDLIN(  58)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  58)																{
HXLINE(  58)																	w1 = (w1 + 1);
HXDLIN(  58)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  58)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXLINE(  58)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  58)										{
HXLINE(  58)											a6->width = width1;
HXDLIN(  58)											a6->height = height1;
HXDLIN(  58)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  58)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)											{
HXLINE(  58)												int _g28 = 0;
HXDLIN(  58)												int _g29 = a6->length;
HXDLIN(  58)												while((_g28 < _g29)){
HXLINE(  58)													_g28 = (_g28 + 1);
HXDLIN(  58)													int i8 = (_g28 - 1);
HXDLIN(  58)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  58)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXLINE(  58)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  58)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  58)										{
HXLINE(  58)											b6->width = width1;
HXDLIN(  58)											b6->height = height1;
HXDLIN(  58)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)											int size1 = (b6->length * 4);
HXDLIN(  58)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  58)											{
HXLINE(  58)												int _g30 = 0;
HXDLIN(  58)												int _g31 = b6->length;
HXDLIN(  58)												while((_g30 < _g31)){
HXLINE(  58)													_g30 = (_g30 + 1);
HXDLIN(  58)													int i9 = (_g30 - 1);
HXDLIN(  58)													{
HXLINE(  58)														 ::haxe::io::ArrayBufferViewImpl this37 = b6->data;
HXDLIN(  58)														bool undoImage5;
HXDLIN(  58)														if ((i9 >= 0)) {
HXLINE(  58)															undoImage5 = (i9 < (this37->byteLength >> 2));
            														}
            														else {
HXLINE(  58)															undoImage5 = false;
            														}
HXDLIN(  58)														if (undoImage5) {
HXLINE(  58)															 ::haxe::io::Bytes _this1 = this37->bytes;
HXDLIN(  58)															int pos1 = ((i9 << 2) + this37->byteOffset);
HXDLIN(  58)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  58)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  58)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  58)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  58)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXLINE(  58)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)										 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN(  58)										{
HXLINE(  58)											v4->width = width1;
HXDLIN(  58)											v4->height = height1;
HXDLIN(  58)											v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)											v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  58)											{
HXLINE(  58)												int _g32 = 0;
HXDLIN(  58)												int _g33 = v4->length;
HXDLIN(  58)												while((_g32 < _g33)){
HXLINE(  58)													_g32 = (_g32 + 1);
HXDLIN(  58)													int i10 = (_g32 - 1);
HXDLIN(  58)													v4->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  58)										undoImage4 = v4;
            									}
            									break;
            									case (int)4: {
HXLINE(  58)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  58)										{
HXLINE(  58)											b7->width = width1;
HXDLIN(  58)											b7->height = height1;
HXDLIN(  58)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  58)											{
HXLINE(  58)												int len3 = b7->length;
HXDLIN(  58)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  58)												if (::hx::IsNull( d1->head )) {
HXLINE(  58)													int _g34 = 0;
HXDLIN(  58)													int _g35 = len3;
HXDLIN(  58)													while((_g34 < _g35)){
HXLINE(  58)														_g34 = (_g34 + 1);
HXDLIN(  58)														int i11 = (_g34 - 1);
HXDLIN(  58)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE(  58)													int _g36 = 0;
HXDLIN(  58)													int _g37 = len3;
HXDLIN(  58)													while((_g36 < _g37)){
HXLINE(  58)														_g36 = (_g36 + 1);
HXDLIN(  58)														int i12 = (_g36 - 1);
HXDLIN(  58)														{
HXLINE(  58)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  58)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  58)															{
HXLINE(  58)																int _g38 = 0;
HXDLIN(  58)																int _g39 = i12;
HXDLIN(  58)																while((_g38 < _g39)){
HXLINE(  58)																	_g38 = (_g38 + 1);
HXDLIN(  58)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  58)															if (::hx::IsNull( prev1 )) {
HXLINE(  58)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)																l1 = null();
            															}
            															else {
HXLINE(  58)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  58)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN(  58)								this36->image = undoImage4;
HXDLIN(  58)								this36->width = width1;
HXDLIN(  58)								this36->height = height1;
HXDLIN(  58)								this36->imageType = ( (int)(imageType1) );
HXDLIN(  58)								undoImage3 = this36;
HXDLIN(  58)								{
HXLINE(  58)									int rectLeft1 = xIter31->start;
HXDLIN(  58)									int rectTop1 = yIter31->start;
HXDLIN(  58)									int rectRight1 = xIter31->max;
HXDLIN(  58)									bool forceClear1 = false;
HXDLIN(  58)									{
HXLINE(  58)										int _g40 = rectTop1;
HXDLIN(  58)										int _g41 = yIter31->max;
HXDLIN(  58)										while((_g40 < _g41)){
HXLINE(  58)											_g40 = (_g40 + 1);
HXDLIN(  58)											int dy1 = (_g40 - 1);
HXDLIN(  58)											{
HXLINE(  58)												int _g42 = rectLeft1;
HXDLIN(  58)												int _g43 = rectRight1;
HXDLIN(  58)												while((_g42 < _g43)){
HXLINE(  58)													_g42 = (_g42 + 1);
HXDLIN(  58)													int dx1 = (_g42 - 1);
HXDLIN(  58)													::Dynamic this38 = this35->image;
HXDLIN(  58)													int index5;
HXDLIN(  58)													if (this35->useVirtualPos) {
HXLINE(  58)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx1) - this35->virtualX));
            													}
            													else {
HXLINE(  58)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this35->width) + dx1)) ));
            													}
HXDLIN(  58)													int c4 = ::iterMagic::Iimg_obj::get(this38,index5);
HXDLIN(  58)													int col1;
HXDLIN(  58)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE(  58)														col1 = c4;
            													}
HXDLIN(  58)													bool _hx_tmp8;
HXDLIN(  58)													if (this35->useMask) {
HXLINE(  58)														_hx_tmp8 = ::hx::IsNotNull( this35->mask );
            													}
            													else {
HXLINE(  58)														_hx_tmp8 = false;
            													}
HXDLIN(  58)													if (_hx_tmp8) {
HXLINE(  58)														 ::pi_xy::ImageStruct this39 = this35->mask;
HXDLIN(  58)														::Dynamic this40 = this39->image;
HXDLIN(  58)														int index6;
HXDLIN(  58)														if (this39->useVirtualPos) {
HXLINE(  58)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx1) - this39->virtualX));
            														}
            														else {
HXLINE(  58)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this39->width) + dx1)) ));
            														}
HXDLIN(  58)														int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  58)														int v5;
HXDLIN(  58)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)															v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXLINE(  58)															v5 = c5;
            														}
HXDLIN(  58)														int maskPixel1 = v5;
HXDLIN(  58)														int this41 = col1;
HXDLIN(  58)														if ((maskPixel1 == 0)) {
HXLINE(  58)															col1 = this41;
            														}
            														else {
HXLINE(  58)															Float m01;
HXDLIN(  58)															int this42 = ((maskPixel1 >> 24) & 255);
HXDLIN(  58)															if ((this42 == 0)) {
HXLINE(  58)																m01 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																m01 = (( (Float)(this42) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float m11;
HXDLIN(  58)															int this43 = ((maskPixel1 >> 16) & 255);
HXDLIN(  58)															if ((this43 == 0)) {
HXLINE(  58)																m11 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																m11 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float m21;
HXDLIN(  58)															int this44 = ((maskPixel1 >> 8) & 255);
HXDLIN(  58)															if ((this44 == 0)) {
HXLINE(  58)																m21 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																m21 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float m31;
HXDLIN(  58)															int this45 = (maskPixel1 & 255);
HXDLIN(  58)															if ((this45 == 0)) {
HXLINE(  58)																m31 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																m31 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this41 >> 24) & 255)) )));
HXDLIN(  58)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this41 >> 16) & 255)) )));
HXDLIN(  58)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this41 >> 8) & 255)) )));
HXDLIN(  58)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this41 & 255)) )));
HXDLIN(  58)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  58)													if ((col1 != 0)) {
HXLINE(  58)														int x5 = (dx1 - rectLeft1);
HXDLIN(  58)														int y5 = (dy1 - rectTop1);
HXDLIN(  58)														int c6 = col1;
HXDLIN(  58)														bool _hx_tmp9;
HXDLIN(  58)														if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  58)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXLINE(  58)															_hx_tmp9 = false;
            														}
HXDLIN(  58)														if (_hx_tmp9) {
HXLINE(  58)															int location2;
HXDLIN(  58)															if (undoImage3->useVirtualPos) {
HXLINE(  58)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  58)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN(  58)															int this46 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  58)															int this47;
HXDLIN(  58)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            															}
            															else {
HXLINE(  58)																this47 = this46;
            															}
HXDLIN(  58)															Float a12;
HXDLIN(  58)															int this48 = ((this47 >> 24) & 255);
HXDLIN(  58)															if ((this48 == 0)) {
HXLINE(  58)																a12 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																a12 = (( (Float)(this48) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float r12;
HXDLIN(  58)															int this49 = ((this47 >> 16) & 255);
HXDLIN(  58)															if ((this49 == 0)) {
HXLINE(  58)																r12 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																r12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float g12;
HXDLIN(  58)															int this50 = ((this47 >> 8) & 255);
HXDLIN(  58)															if ((this50 == 0)) {
HXLINE(  58)																g12 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																g12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float b13;
HXDLIN(  58)															int this51 = (this47 & 255);
HXDLIN(  58)															if ((this51 == 0)) {
HXLINE(  58)																b13 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																b13 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float a22;
HXDLIN(  58)															int this52 = ((col1 >> 24) & 255);
HXDLIN(  58)															if ((this52 == 0)) {
HXLINE(  58)																a22 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																a22 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float r22;
HXDLIN(  58)															int this53 = ((col1 >> 16) & 255);
HXDLIN(  58)															if ((this53 == 0)) {
HXLINE(  58)																r22 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																r22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float g22;
HXDLIN(  58)															int this54 = ((col1 >> 8) & 255);
HXDLIN(  58)															if ((this54 == 0)) {
HXLINE(  58)																g22 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																g22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float b23;
HXDLIN(  58)															int this55 = (col1 & 255);
HXDLIN(  58)															if ((this55 == 0)) {
HXLINE(  58)																b23 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																b23 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  58)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  58)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  58)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  58)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  58)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  58)															{
HXLINE(  58)																int _hx_tmp10;
HXDLIN(  58)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXLINE(  58)																	_hx_tmp10 = blended2;
            																}
HXDLIN(  58)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXLINE(  58)															::Dynamic this56 = undoImage3->image;
HXDLIN(  58)															int index7;
HXDLIN(  58)															if (undoImage3->useVirtualPos) {
HXLINE(  58)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  58)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN(  58)															int _hx_tmp11;
HXDLIN(  58)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXLINE(  58)																_hx_tmp11 = c6;
            															}
HXDLIN(  58)															::iterMagic::Iimg_obj::set(this56,index7,_hx_tmp11);
            														}
            													}
            													else {
HXLINE(  58)														if (forceClear1) {
HXLINE(  58)															::Dynamic this57 = undoImage3->image;
HXDLIN(  58)															int x6 = (dx1 - rectLeft1);
HXDLIN(  58)															int y6 = (dy1 - rectTop1);
HXDLIN(  58)															int index8;
HXDLIN(  58)															if (undoImage3->useVirtualPos) {
HXLINE(  58)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  58)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  58)															::iterMagic::Iimg_obj::set(this57,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							bool found1 = false;
HXDLIN(  58)							Float s1 = ((Float)0.);
HXDLIN(  58)							Float t1 = ((Float)0.);
HXDLIN(  58)							Float sxx1 = ((Float)0.);
HXDLIN(  58)							Float txx1 = ((Float)0.);
HXDLIN(  58)							{
HXLINE(  58)								int _g_min2 = xIter31->start;
HXDLIN(  58)								int _g_max2 = xIter31->max;
HXDLIN(  58)								while((_g_min2 < _g_max2)){
HXLINE(  58)									_g_min2 = (_g_min2 + 1);
HXDLIN(  58)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE(  58)									{
HXLINE(  58)										int _g_min3 = yIter31->start;
HXDLIN(  58)										int _g_max3 = yIter31->max;
HXDLIN(  58)										while((_g_min3 < _g_max3)){
HXLINE(  58)											_g_min3 = (_g_min3 + 1);
HXDLIN(  58)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  58)											bool _hx_tmp12;
HXDLIN(  58)											if (!((s1 <= 0))) {
HXLINE(  58)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXLINE(  58)												_hx_tmp12 = true;
            											}
HXDLIN(  58)											if (_hx_tmp12) {
HXLINE(  58)												if (found1) {
HXLINE(  58)													goto _hx_goto_25;
            												}
            											}
            											else {
HXLINE(  58)												if (((s1 + t1) < A1)) {
HXLINE(  58)													{
HXLINE(  58)														int c7 = color;
HXDLIN(  58)														bool _hx_tmp13;
HXDLIN(  58)														if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  58)															_hx_tmp13 = this35->transparent;
            														}
            														else {
HXLINE(  58)															_hx_tmp13 = false;
            														}
HXDLIN(  58)														if (_hx_tmp13) {
HXLINE(  58)															int location3;
HXDLIN(  58)															if (this35->useVirtualPos) {
HXLINE(  58)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this35->virtualY) * ( (Float)(this35->width) )) + x7) - this35->virtualX));
            															}
            															else {
HXLINE(  58)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this35->width) + x7)) ));
            															}
HXDLIN(  58)															int this58 = ::iterMagic::Iimg_obj::get(this35->image,location3);
HXDLIN(  58)															int this59;
HXDLIN(  58)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            															}
            															else {
HXLINE(  58)																this59 = this58;
            															}
HXDLIN(  58)															Float a13;
HXDLIN(  58)															int this60 = ((this59 >> 24) & 255);
HXDLIN(  58)															if ((this60 == 0)) {
HXLINE(  58)																a13 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float r13;
HXDLIN(  58)															int this61 = ((this59 >> 16) & 255);
HXDLIN(  58)															if ((this61 == 0)) {
HXLINE(  58)																r13 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float g13;
HXDLIN(  58)															int this62 = ((this59 >> 8) & 255);
HXDLIN(  58)															if ((this62 == 0)) {
HXLINE(  58)																g13 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float b14;
HXDLIN(  58)															int this63 = (this59 & 255);
HXDLIN(  58)															if ((this63 == 0)) {
HXLINE(  58)																b14 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float a23;
HXDLIN(  58)															int this64 = ((color >> 24) & 255);
HXDLIN(  58)															if ((this64 == 0)) {
HXLINE(  58)																a23 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float r23;
HXDLIN(  58)															int this65 = ((color >> 16) & 255);
HXDLIN(  58)															if ((this65 == 0)) {
HXLINE(  58)																r23 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float g23;
HXDLIN(  58)															int this66 = ((color >> 8) & 255);
HXDLIN(  58)															if ((this66 == 0)) {
HXLINE(  58)																g23 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float b24;
HXDLIN(  58)															int this67 = (color & 255);
HXDLIN(  58)															if ((this67 == 0)) {
HXLINE(  58)																b24 = ((Float)0.);
            															}
            															else {
HXLINE(  58)																b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  58)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  58)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  58)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  58)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  58)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  58)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  58)															{
HXLINE(  58)																int _hx_tmp14;
HXDLIN(  58)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE(  58)																	_hx_tmp14 = blended3;
            																}
HXDLIN(  58)																::iterMagic::Iimg_obj::set(this35->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXLINE(  58)															::Dynamic this68 = this35->image;
HXDLIN(  58)															int index9;
HXDLIN(  58)															if (this35->useVirtualPos) {
HXLINE(  58)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this35->virtualY) * ( (Float)(this35->width) )) + x7) - this35->virtualX));
            															}
            															else {
HXLINE(  58)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this35->width) + x7)) ));
            															}
HXDLIN(  58)															int _hx_tmp15;
HXDLIN(  58)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXLINE(  58)																_hx_tmp15 = c7;
            															}
HXDLIN(  58)															::iterMagic::Iimg_obj::set(this68,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXLINE(  58)													if (found1) {
HXLINE(  58)														goto _hx_goto_25;
            													}
            												}
            											}
            										}
            										_hx_goto_25:;
            									}
            								}
            							}
HXDLIN(  58)							if ((hasHit1 == true)) {
HXLINE(  58)								 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  58)								if (hasUndo1) {
HXLINE(  58)									v6->undoImage = undoImage3;
HXDLIN(  58)									v6->undoX = xIter31->start;
HXDLIN(  58)									v6->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  59)				lastX = nextX1;
HXLINE(  60)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(PolyPixel_Fields__obj,fillPolygonBuild,(void))

void PolyPixel_Fields__obj::softFillPolygonBuild( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		Float softC = __o_softC.Default(10);
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_87ef2d4220a4cd37_73_softFillPolygonBuild)
HXLINE(  74)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE(  75)		Float omega;
HXDLIN(  75)		if (cornerUp) {
HXLINE(  75)			omega = ((Float)0.);
            		}
            		else {
HXLINE(  79)			if ((::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(2) ))) == (( (Float)(sides) ) / ( (Float)(2) )))) {
HXLINE(  75)				omega = (::Math_obj::PI / ( (Float)(sides) ));
            			}
            			else {
HXLINE(  82)				Float v = ((( (Float)(sides) ) / ( (Float)(2) )) - ((Float)0.5));
HXLINE(  83)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXLINE(  75)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) )) - ::Math_obj::PI);
            				}
            				else {
HXLINE(  75)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) ));
            				}
            			}
            		}
HXLINE(  92)		Float lastX = ((Float)0.);
HXLINE(  93)		Float lastY = ((Float)0.);
HXLINE(  94)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  95)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  96)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  98)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  99)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 101)		if (::hx::IsNotEq( phi,0 )) {
HXLINE( 102)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE( 103)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE( 104)			{
HXLINE( 104)				int _g = 0;
HXDLIN( 104)				int _g1 = (sides + 1);
HXDLIN( 104)				while((_g < _g1)){
HXLINE( 104)					_g = (_g + 1);
HXDLIN( 104)					int i = (_g - 1);
HXLINE( 105)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE( 106)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE( 107)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE( 108)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE( 109)					{
HXLINE( 109)						bool hasHit = false;
HXDLIN( 109)						bool hasUndo = false;
HXDLIN( 109)						int aA = ((color >> 24) & 255);
HXDLIN( 109)						int rA = ((color >> 16) & 255);
HXDLIN( 109)						int gA = ((color >> 8) & 255);
HXDLIN( 109)						int bA = (color & 255);
HXDLIN( 109)						Float bcx = (lastX - nextX);
HXDLIN( 109)						Float bcy = (lastY - nextY);
HXDLIN( 109)						Float acx = (cx - nextX);
HXDLIN( 109)						Float acy = (cy - nextY);
HXDLIN( 109)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 109)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 109)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 109)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 109)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 109)						if ((cx > lastX)) {
HXLINE( 109)							if ((cx > nextX)) {
HXLINE( 109)								int min;
HXDLIN( 109)								if ((lastX > nextX)) {
HXLINE( 109)									min = ::Math_obj::floor(nextX);
            								}
            								else {
HXLINE( 109)									min = ::Math_obj::floor(lastX);
            								}
HXDLIN( 109)								int ii_min = min;
HXDLIN( 109)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 109)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            							}
            							else {
HXLINE( 109)								int ii_min1 = ::Math_obj::floor(lastX);
HXDLIN( 109)								int ii_max1 = ::Math_obj::ceil(nextX);
HXDLIN( 109)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            						}
            						else {
HXLINE( 109)							if ((lastX > nextX)) {
HXLINE( 109)								int min1;
HXDLIN( 109)								if ((cx > nextX)) {
HXLINE( 109)									min1 = ::Math_obj::floor(nextX);
            								}
            								else {
HXLINE( 109)									min1 = ::Math_obj::ceil(cx);
            								}
HXDLIN( 109)								int ii_min2 = min1;
HXDLIN( 109)								int ii_max2 = ::Math_obj::ceil(lastX);
HXDLIN( 109)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            							else {
HXLINE( 109)								int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 109)								int ii_max3 = ::Math_obj::ceil(nextX);
HXDLIN( 109)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            							}
            						}
HXDLIN( 109)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 109)						if ((cy > lastY)) {
HXLINE( 109)							if ((cy > nextY)) {
HXLINE( 109)								int min2;
HXDLIN( 109)								if ((lastY > nextY)) {
HXLINE( 109)									min2 = ::Math_obj::floor(nextY);
            								}
            								else {
HXLINE( 109)									min2 = ::Math_obj::floor(lastY);
            								}
HXDLIN( 109)								int ii_min4 = min2;
HXDLIN( 109)								int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 109)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            							}
            							else {
HXLINE( 109)								int ii_min5 = ::Math_obj::floor(lastY);
HXDLIN( 109)								int ii_max5 = ::Math_obj::ceil(nextY);
HXDLIN( 109)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            						}
            						else {
HXLINE( 109)							if ((lastY > nextY)) {
HXLINE( 109)								int min3;
HXDLIN( 109)								if ((cy > nextY)) {
HXLINE( 109)									min3 = ::Math_obj::floor(nextY);
            								}
            								else {
HXLINE( 109)									min3 = ::Math_obj::ceil(cy);
            								}
HXDLIN( 109)								int ii_min6 = min3;
HXDLIN( 109)								int ii_max6 = ::Math_obj::ceil(lastY);
HXDLIN( 109)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            							else {
HXLINE( 109)								int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 109)								int ii_max7 = ::Math_obj::ceil(nextY);
HXDLIN( 109)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            						}
HXDLIN( 109)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 109)						if (hasUndo) {
HXLINE( 109)							int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 109)							int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 109)							 ::Dynamic imageType = null();
HXDLIN( 109)							 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 109)							if (::hx::IsNull( imageType )) {
HXLINE(  54)								imageType = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 109)							::Dynamic undoImage1;
HXDLIN( 109)							switch((int)(( (int)(imageType) ))){
            								case (int)0: {
HXLINE( 109)									 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 109)									 ::iterMagic::BytesImg b = byt;
HXDLIN( 109)									{
HXLINE( 109)										b->width = width;
HXDLIN( 109)										b->height = height;
HXDLIN( 109)										b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)										b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 109)										{
HXLINE( 109)											int len = b->length;
HXDLIN( 109)											int w = 0;
HXDLIN( 109)											{
HXLINE( 109)												int _g2 = 0;
HXDLIN( 109)												int _g3 = b->height;
HXDLIN( 109)												while((_g2 < _g3)){
HXLINE( 109)													_g2 = (_g2 + 1);
HXDLIN( 109)													int y = (_g2 - 1);
HXDLIN( 109)													{
HXLINE( 109)														int _g4 = 0;
HXDLIN( 109)														int _g5 = b->width;
HXDLIN( 109)														while((_g4 < _g5)){
HXLINE( 109)															_g4 = (_g4 + 1);
HXDLIN( 109)															int x = (_g4 - 1);
HXDLIN( 109)															{
HXLINE( 109)																w = (w + 1);
HXDLIN( 109)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 109)															{
HXLINE( 109)																w = (w + 1);
HXDLIN( 109)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 109)															{
HXLINE( 109)																w = (w + 1);
HXDLIN( 109)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 109)															{
HXLINE( 109)																w = (w + 1);
HXDLIN( 109)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 109)									undoImage1 = b;
            								}
            								break;
            								case (int)1: {
HXLINE( 109)									 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)									 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 109)									{
HXLINE( 109)										a->width = width;
HXDLIN( 109)										a->height = height;
HXDLIN( 109)										a->data = ::Array_obj< int >::__new(0);
HXDLIN( 109)										a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)										{
HXLINE( 109)											int _g6 = 0;
HXDLIN( 109)											int _g7 = a->length;
HXDLIN( 109)											while((_g6 < _g7)){
HXLINE( 109)												_g6 = (_g6 + 1);
HXDLIN( 109)												int i1 = (_g6 - 1);
HXDLIN( 109)												a->data[i1] = 0;
            											}
            										}
            									}
HXDLIN( 109)									undoImage1 = a;
            								}
            								break;
            								case (int)2: {
HXLINE( 109)									 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 109)									 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 109)									{
HXLINE( 109)										b1->width = width;
HXDLIN( 109)										b1->height = height;
HXDLIN( 109)										b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)										int size = (b1->length * 4);
HXDLIN( 109)										b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 109)										{
HXLINE( 109)											int _g8 = 0;
HXDLIN( 109)											int _g9 = b1->length;
HXDLIN( 109)											while((_g8 < _g9)){
HXLINE( 109)												_g8 = (_g8 + 1);
HXDLIN( 109)												int i2 = (_g8 - 1);
HXDLIN( 109)												{
HXLINE( 109)													 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 109)													bool undoImage2;
HXDLIN( 109)													if ((i2 >= 0)) {
HXLINE( 109)														undoImage2 = (i2 < (this2->byteLength >> 2));
            													}
            													else {
HXLINE( 109)														undoImage2 = false;
            													}
HXDLIN( 109)													if (undoImage2) {
HXLINE( 109)														 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 109)														int pos = ((i2 << 2) + this2->byteOffset);
HXDLIN( 109)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 109)									undoImage1 = b1;
            								}
            								break;
            								case (int)3: {
HXLINE( 109)									 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)									 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 109)									{
HXLINE( 109)										v1->width = width;
HXDLIN( 109)										v1->height = height;
HXDLIN( 109)										v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)										v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 109)										{
HXLINE( 109)											int _g10 = 0;
HXDLIN( 109)											int _g11 = v1->length;
HXDLIN( 109)											while((_g10 < _g11)){
HXLINE( 109)												_g10 = (_g10 + 1);
HXDLIN( 109)												int i3 = (_g10 - 1);
HXDLIN( 109)												v1->data->__unsafe_set(i3,0);
            											}
            										}
            									}
HXDLIN( 109)									undoImage1 = v1;
            								}
            								break;
            								case (int)4: {
HXLINE( 109)									 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 109)									 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 109)									{
HXLINE( 109)										b2->width = width;
HXDLIN( 109)										b2->height = height;
HXDLIN( 109)										b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 109)										b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 109)										{
HXLINE( 109)											int len1 = b2->length;
HXDLIN( 109)											 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 109)											if (::hx::IsNull( d->head )) {
HXLINE( 109)												int _g12 = 0;
HXDLIN( 109)												int _g13 = len1;
HXDLIN( 109)												while((_g12 < _g13)){
HXLINE( 109)													_g12 = (_g12 + 1);
HXDLIN( 109)													int i4 = (_g12 - 1);
HXDLIN( 109)													d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            												}
            											}
            											else {
HXLINE( 109)												int _g14 = 0;
HXDLIN( 109)												int _g15 = len1;
HXDLIN( 109)												while((_g14 < _g15)){
HXLINE( 109)													_g14 = (_g14 + 1);
HXDLIN( 109)													int i5 = (_g14 - 1);
HXDLIN( 109)													{
HXLINE( 109)														 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 109)														 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 109)														{
HXLINE( 109)															int _g16 = 0;
HXDLIN( 109)															int _g17 = i5;
HXDLIN( 109)															while((_g16 < _g17)){
HXLINE( 109)																_g16 = (_g16 + 1);
HXDLIN( 109)																int i6 = (_g16 - 1);
HXLINE( 345)																prev = l;
HXLINE( 346)																l = l->next;
            															}
            														}
HXLINE( 109)														if (::hx::IsNull( prev )) {
HXLINE( 109)															b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 109)															l = null();
            														}
            														else {
HXLINE( 109)															prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 109)															l = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 109)									undoImage1 = b2;
            								}
            								break;
            							}
HXDLIN( 109)							this1->image = undoImage1;
HXDLIN( 109)							this1->width = width;
HXDLIN( 109)							this1->height = height;
HXDLIN( 109)							this1->imageType = ( (int)(imageType) );
HXDLIN( 109)							undoImage = this1;
HXDLIN( 109)							{
HXLINE( 109)								int rectLeft = xIter3->start;
HXDLIN( 109)								int rectTop = yIter3->start;
HXDLIN( 109)								int rectRight = xIter3->max;
HXDLIN( 109)								bool forceClear = false;
HXDLIN( 109)								{
HXLINE( 109)									int _g18 = rectTop;
HXDLIN( 109)									int _g19 = yIter3->max;
HXDLIN( 109)									while((_g18 < _g19)){
HXLINE( 109)										_g18 = (_g18 + 1);
HXDLIN( 109)										int dy = (_g18 - 1);
HXDLIN( 109)										{
HXLINE( 109)											int _g20 = rectLeft;
HXDLIN( 109)											int _g21 = rectRight;
HXDLIN( 109)											while((_g20 < _g21)){
HXLINE( 109)												_g20 = (_g20 + 1);
HXDLIN( 109)												int dx = (_g20 - 1);
HXDLIN( 109)												::Dynamic this3 = pixelimage->image;
HXDLIN( 109)												int index;
HXDLIN( 109)												if (pixelimage->useVirtualPos) {
HXLINE( 109)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelimage->virtualY) * ( (Float)(pixelimage->width) )) + dx) - pixelimage->virtualX));
            												}
            												else {
HXLINE( 109)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelimage->width) + dx)) ));
            												}
HXDLIN( 109)												int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 109)												int col;
HXDLIN( 109)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 109)													col = c;
            												}
HXDLIN( 109)												bool _hx_tmp;
HXDLIN( 109)												if (pixelimage->useMask) {
HXLINE( 109)													_hx_tmp = ::hx::IsNotNull( pixelimage->mask );
            												}
            												else {
HXLINE( 109)													_hx_tmp = false;
            												}
HXDLIN( 109)												if (_hx_tmp) {
HXLINE( 109)													 ::pi_xy::ImageStruct this4 = pixelimage->mask;
HXDLIN( 109)													::Dynamic this5 = this4->image;
HXDLIN( 109)													int index1;
HXDLIN( 109)													if (this4->useVirtualPos) {
HXLINE( 109)														index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            													}
            													else {
HXLINE( 109)														index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            													}
HXDLIN( 109)													int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 109)													int v2;
HXDLIN( 109)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            													}
            													else {
HXLINE( 109)														v2 = c1;
            													}
HXDLIN( 109)													int maskPixel = v2;
HXDLIN( 109)													int this6 = col;
HXDLIN( 109)													if ((maskPixel == 0)) {
HXLINE( 109)														col = this6;
            													}
            													else {
HXLINE( 109)														Float m0;
HXDLIN( 109)														int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 109)														if ((this7 == 0)) {
HXLINE( 109)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float m1;
HXDLIN( 109)														int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 109)														if ((this8 == 0)) {
HXLINE( 109)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float m2;
HXDLIN( 109)														int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 109)														if ((this9 == 0)) {
HXLINE( 109)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float m3;
HXDLIN( 109)														int this10 = (maskPixel & 255);
HXDLIN( 109)														if ((this10 == 0)) {
HXLINE( 109)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 109)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 109)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 109)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 109)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 109)												if ((col != 0)) {
HXLINE( 109)													int x1 = (dx - rectLeft);
HXDLIN( 109)													int y1 = (dy - rectTop);
HXDLIN( 109)													int c2 = col;
HXDLIN( 109)													bool _hx_tmp1;
HXDLIN( 109)													if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 109)														_hx_tmp1 = undoImage->transparent;
            													}
            													else {
HXLINE( 109)														_hx_tmp1 = false;
            													}
HXDLIN( 109)													if (_hx_tmp1) {
HXLINE( 109)														int location;
HXDLIN( 109)														if (undoImage->useVirtualPos) {
HXLINE( 109)															location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            														}
            														else {
HXLINE( 109)															location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            														}
HXDLIN( 109)														int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 109)														int this12;
HXDLIN( 109)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)															this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            														}
            														else {
HXLINE( 109)															this12 = this11;
            														}
HXDLIN( 109)														Float a1;
HXDLIN( 109)														int this13 = ((this12 >> 24) & 255);
HXDLIN( 109)														if ((this13 == 0)) {
HXLINE( 109)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float r1;
HXDLIN( 109)														int this14 = ((this12 >> 16) & 255);
HXDLIN( 109)														if ((this14 == 0)) {
HXLINE( 109)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float g1;
HXDLIN( 109)														int this15 = ((this12 >> 8) & 255);
HXDLIN( 109)														if ((this15 == 0)) {
HXLINE( 109)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float b11;
HXDLIN( 109)														int this16 = (this12 & 255);
HXDLIN( 109)														if ((this16 == 0)) {
HXLINE( 109)															b11 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float a2;
HXDLIN( 109)														int this17 = ((col >> 24) & 255);
HXDLIN( 109)														if ((this17 == 0)) {
HXLINE( 109)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float r2;
HXDLIN( 109)														int this18 = ((col >> 16) & 255);
HXDLIN( 109)														if ((this18 == 0)) {
HXLINE( 109)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float g2;
HXDLIN( 109)														int this19 = ((col >> 8) & 255);
HXDLIN( 109)														if ((this19 == 0)) {
HXLINE( 109)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float b21;
HXDLIN( 109)														int this20 = (col & 255);
HXDLIN( 109)														if ((this20 == 0)) {
HXLINE( 109)															b21 = ((Float)0.);
            														}
            														else {
HXLINE( 109)															b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            														}
HXDLIN( 109)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 109)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 109)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 109)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 109)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 109)														int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 109)														{
HXLINE( 109)															int _hx_tmp2;
HXDLIN( 109)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)																_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 109)																_hx_tmp2 = blended;
            															}
HXDLIN( 109)															::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            														}
            													}
            													else {
HXLINE( 109)														::Dynamic this21 = undoImage->image;
HXDLIN( 109)														int index2;
HXDLIN( 109)														if (undoImage->useVirtualPos) {
HXLINE( 109)															index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            														}
            														else {
HXLINE( 109)															index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            														}
HXDLIN( 109)														int _hx_tmp3;
HXDLIN( 109)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)															_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            														}
            														else {
HXLINE( 109)															_hx_tmp3 = c2;
            														}
HXDLIN( 109)														::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            													}
            												}
            												else {
HXLINE( 109)													if (forceClear) {
HXLINE( 109)														::Dynamic this22 = undoImage->image;
HXDLIN( 109)														int x2 = (dx - rectLeft);
HXDLIN( 109)														int y2 = (dy - rectTop);
HXDLIN( 109)														int index3;
HXDLIN( 109)														if (undoImage->useVirtualPos) {
HXLINE( 109)															index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            														}
            														else {
HXLINE( 109)															index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            														}
HXDLIN( 109)														::iterMagic::Iimg_obj::set(this22,index3,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 109)						bool found = false;
HXDLIN( 109)						{
HXLINE( 109)							int _g_min = xIter3->start;
HXDLIN( 109)							int _g_max = xIter3->max;
HXDLIN( 109)							while((_g_min < _g_max)){
HXLINE( 109)								_g_min = (_g_min + 1);
HXDLIN( 109)								int px = (_g_min - 1);
HXDLIN( 109)								Float pcx = (( (Float)(px) ) - nextX);
HXLINE( 619)								found = false;
HXLINE( 109)								{
HXLINE( 109)									int _g_min1 = yIter3->start;
HXDLIN( 109)									int _g_max1 = yIter3->max;
HXDLIN( 109)									while((_g_min1 < _g_max1)){
HXLINE( 109)										_g_min1 = (_g_min1 + 1);
HXDLIN( 109)										int py = (_g_min1 - 1);
HXDLIN( 109)										Float pcy = (( (Float)(py) ) - nextY);
HXDLIN( 109)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 109)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 109)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 109)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 109)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 109)										bool _hx_tmp4;
HXDLIN( 109)										bool _hx_tmp5;
HXDLIN( 109)										if ((ratioA >= 0)) {
HXLINE( 109)											_hx_tmp5 = (ratioB >= 0);
            										}
            										else {
HXLINE( 109)											_hx_tmp5 = false;
            										}
HXDLIN( 109)										if (_hx_tmp5) {
HXLINE( 109)											_hx_tmp4 = (ratioC >= 0);
            										}
            										else {
HXLINE( 109)											_hx_tmp4 = false;
            										}
HXDLIN( 109)										if (_hx_tmp4) {
HXLINE( 109)											int i7 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 109)											if ((i7 > 255)) {
HXLINE(  24)												i7 = 255;
            											}
HXLINE( 109)											if ((i7 < 0)) {
HXLINE(  25)												i7 = 0;
            											}
HXLINE( 109)											int a5 = i7;
HXDLIN( 109)											int i8 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 109)											if ((i8 > 255)) {
HXLINE(  24)												i8 = 255;
            											}
HXLINE( 109)											if ((i8 < 0)) {
HXLINE(  25)												i8 = 0;
            											}
HXLINE( 109)											int r3 = i8;
HXDLIN( 109)											int i9 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 109)											if ((i9 > 255)) {
HXLINE(  24)												i9 = 255;
            											}
HXLINE( 109)											if ((i9 < 0)) {
HXLINE(  25)												i9 = 0;
            											}
HXLINE( 109)											int g3 = i9;
HXDLIN( 109)											int i10 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 109)											if ((i10 > 255)) {
HXLINE(  24)												i10 = 255;
            											}
HXLINE( 109)											if ((i10 < 0)) {
HXLINE(  25)												i10 = 0;
            											}
HXLINE( 109)											int b4 = i10;
HXDLIN( 109)											{
HXLINE( 109)												int location1;
HXDLIN( 109)												if (pixelimage->useVirtualPos) {
HXLINE( 109)													location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelimage->virtualY) * ( (Float)(pixelimage->width) )) + px) - pixelimage->virtualX));
            												}
            												else {
HXLINE( 109)													location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelimage->width) + px)) ));
            												}
HXDLIN( 109)												bool _hx_tmp6;
HXDLIN( 109)												if (pixelimage->transparent) {
HXLINE( 109)													_hx_tmp6 = (a5 < 254);
            												}
            												else {
HXLINE( 109)													_hx_tmp6 = false;
            												}
HXDLIN( 109)												if (_hx_tmp6) {
HXLINE( 109)													int this23 = ::iterMagic::Iimg_obj::get(pixelimage->image,location1);
HXDLIN( 109)													int old;
HXDLIN( 109)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            													}
            													else {
HXLINE( 109)														old = this23;
            													}
HXDLIN( 109)													int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 109)													Float a11;
HXDLIN( 109)													int this24 = ((old >> 24) & 255);
HXDLIN( 109)													if ((this24 == 0)) {
HXLINE( 109)														a11 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r11;
HXDLIN( 109)													int this25 = ((old >> 16) & 255);
HXDLIN( 109)													if ((this25 == 0)) {
HXLINE( 109)														r11 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g11;
HXDLIN( 109)													int this26 = ((old >> 8) & 255);
HXDLIN( 109)													if ((this26 == 0)) {
HXLINE( 109)														g11 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b12;
HXDLIN( 109)													int this27 = (old & 255);
HXDLIN( 109)													if ((this27 == 0)) {
HXLINE( 109)														b12 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a21;
HXDLIN( 109)													int this28 = ((rhs >> 24) & 255);
HXDLIN( 109)													if ((this28 == 0)) {
HXLINE( 109)														a21 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r21;
HXDLIN( 109)													int this29 = ((rhs >> 16) & 255);
HXDLIN( 109)													if ((this29 == 0)) {
HXLINE( 109)														r21 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g21;
HXDLIN( 109)													int this30 = ((rhs >> 8) & 255);
HXDLIN( 109)													if ((this30 == 0)) {
HXLINE( 109)														g21 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b22;
HXDLIN( 109)													int this31 = (rhs & 255);
HXDLIN( 109)													if ((this31 == 0)) {
HXLINE( 109)														b22 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 109)													int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 109)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 109)													int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 109)													int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 109)													int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 109)													{
HXLINE( 109)														int _hx_tmp7;
HXDLIN( 109)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)															_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXLINE( 109)															_hx_tmp7 = blended1;
            														}
HXDLIN( 109)														::iterMagic::Iimg_obj::set(pixelimage->image,location1,_hx_tmp7);
            													}
            												}
            												else {
HXLINE( 109)													int value;
HXDLIN( 109)													if (pixelimage->isLittle) {
HXLINE( 109)														value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            													}
            													else {
HXLINE( 109)														value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            													}
HXDLIN( 109)													::iterMagic::Iimg_obj::set(pixelimage->image,location1,value);
            												}
            											}
HXLINE( 633)											found = true;
            										}
            										else {
HXLINE( 109)											if (found) {
HXLINE( 109)												goto _hx_goto_39;
            											}
            										}
            									}
            									_hx_goto_39:;
            								}
            							}
            						}
HXDLIN( 109)						if ((hasHit == false)) {
HXLINE( 109)							 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,lastX,lastY,nextX,nextY,true);
HXDLIN( 109)							if (hasUndo) {
HXLINE( 109)								v3->undoImage = undoImage;
HXDLIN( 109)								v3->undoX = xIter3->start;
HXDLIN( 109)								v3->undoY = yIter3->start;
            							}
            						}
            					}
HXLINE( 110)					lastX = nextX;
HXLINE( 111)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE( 114)			int _g22 = 0;
HXDLIN( 114)			int _g23 = (sides + 1);
HXDLIN( 114)			while((_g22 < _g23)){
HXLINE( 114)				_g22 = (_g22 + 1);
HXDLIN( 114)				int i11 = (_g22 - 1);
HXLINE( 115)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i11) ) * theta) + omega) + ((Float)0.01)))));
HXLINE( 116)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i11) ) * theta) + omega) + ((Float)0.01)))));
HXLINE( 118)				{
HXLINE( 118)					bool hasHit1 = false;
HXDLIN( 118)					bool hasUndo1 = false;
HXDLIN( 118)					int aA1 = ((color >> 24) & 255);
HXDLIN( 118)					int rA1 = ((color >> 16) & 255);
HXDLIN( 118)					int gA1 = ((color >> 8) & 255);
HXDLIN( 118)					int bA1 = (color & 255);
HXDLIN( 118)					Float bcx1 = (lastX - nextX1);
HXDLIN( 118)					Float bcy1 = (lastY - nextY1);
HXDLIN( 118)					Float acx1 = (cx - nextX1);
HXDLIN( 118)					Float acy1 = (cy - nextY1);
HXDLIN( 118)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 118)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 118)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 118)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 118)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 118)					if ((cx > lastX)) {
HXLINE( 118)						if ((cx > nextX1)) {
HXLINE( 118)							int min4;
HXDLIN( 118)							if ((lastX > nextX1)) {
HXLINE( 118)								min4 = ::Math_obj::floor(nextX1);
            							}
            							else {
HXLINE( 118)								min4 = ::Math_obj::floor(lastX);
            							}
HXDLIN( 118)							int ii_min8 = min4;
HXDLIN( 118)							int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 118)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXLINE( 118)							int ii_min9 = ::Math_obj::floor(lastX);
HXDLIN( 118)							int ii_max9 = ::Math_obj::ceil(nextX1);
HXDLIN( 118)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXLINE( 118)						if ((lastX > nextX1)) {
HXLINE( 118)							int min5;
HXDLIN( 118)							if ((cx > nextX1)) {
HXLINE( 118)								min5 = ::Math_obj::floor(nextX1);
            							}
            							else {
HXLINE( 118)								min5 = ::Math_obj::ceil(cx);
            							}
HXDLIN( 118)							int ii_min10 = min5;
HXDLIN( 118)							int ii_max10 = ::Math_obj::ceil(lastX);
HXDLIN( 118)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXLINE( 118)							int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 118)							int ii_max11 = ::Math_obj::ceil(nextX1);
HXDLIN( 118)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 118)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 118)					if ((cy > lastY)) {
HXLINE( 118)						if ((cy > nextY1)) {
HXLINE( 118)							int min6;
HXDLIN( 118)							if ((lastY > nextY1)) {
HXLINE( 118)								min6 = ::Math_obj::floor(nextY1);
            							}
            							else {
HXLINE( 118)								min6 = ::Math_obj::floor(lastY);
            							}
HXDLIN( 118)							int ii_min12 = min6;
HXDLIN( 118)							int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 118)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXLINE( 118)							int ii_min13 = ::Math_obj::floor(lastY);
HXDLIN( 118)							int ii_max13 = ::Math_obj::ceil(nextY1);
HXDLIN( 118)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXLINE( 118)						if ((lastY > nextY1)) {
HXLINE( 118)							int min7;
HXDLIN( 118)							if ((cy > nextY1)) {
HXLINE( 118)								min7 = ::Math_obj::floor(nextY1);
            							}
            							else {
HXLINE( 118)								min7 = ::Math_obj::ceil(cy);
            							}
HXDLIN( 118)							int ii_min14 = min7;
HXDLIN( 118)							int ii_max14 = ::Math_obj::ceil(lastY);
HXDLIN( 118)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXLINE( 118)							int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 118)							int ii_max15 = ::Math_obj::ceil(nextY1);
HXDLIN( 118)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
HXDLIN( 118)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 118)					if (hasUndo1) {
HXLINE( 118)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 118)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 118)						 ::Dynamic imageType1 = null();
HXDLIN( 118)						 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 118)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 118)						::Dynamic undoImage4;
HXDLIN( 118)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXLINE( 118)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 118)								 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 118)								{
HXLINE( 118)									b6->width = width1;
HXDLIN( 118)									b6->height = height1;
HXDLIN( 118)									b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 118)									b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 118)									{
HXLINE( 118)										int len2 = b6->length;
HXDLIN( 118)										int w1 = 0;
HXDLIN( 118)										{
HXLINE( 118)											int _g24 = 0;
HXDLIN( 118)											int _g25 = b6->height;
HXDLIN( 118)											while((_g24 < _g25)){
HXLINE( 118)												_g24 = (_g24 + 1);
HXDLIN( 118)												int y3 = (_g24 - 1);
HXDLIN( 118)												{
HXLINE( 118)													int _g26 = 0;
HXDLIN( 118)													int _g27 = b6->width;
HXDLIN( 118)													while((_g26 < _g27)){
HXLINE( 118)														_g26 = (_g26 + 1);
HXDLIN( 118)														int x3 = (_g26 - 1);
HXDLIN( 118)														{
HXLINE( 118)															w1 = (w1 + 1);
HXDLIN( 118)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 118)														{
HXLINE( 118)															w1 = (w1 + 1);
HXDLIN( 118)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 118)														{
HXLINE( 118)															w1 = (w1 + 1);
HXDLIN( 118)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 118)														{
HXLINE( 118)															w1 = (w1 + 1);
HXDLIN( 118)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 118)								undoImage4 = b6;
            							}
            							break;
            							case (int)1: {
HXLINE( 118)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 118)								 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 118)								{
HXLINE( 118)									a7->width = width1;
HXDLIN( 118)									a7->height = height1;
HXDLIN( 118)									a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 118)									a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 118)									{
HXLINE( 118)										int _g28 = 0;
HXDLIN( 118)										int _g29 = a7->length;
HXDLIN( 118)										while((_g28 < _g29)){
HXLINE( 118)											_g28 = (_g28 + 1);
HXDLIN( 118)											int i12 = (_g28 - 1);
HXDLIN( 118)											a7->data[i12] = 0;
            										}
            									}
            								}
HXDLIN( 118)								undoImage4 = a7;
            							}
            							break;
            							case (int)2: {
HXLINE( 118)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 118)								 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 118)								{
HXLINE( 118)									b7->width = width1;
HXDLIN( 118)									b7->height = height1;
HXDLIN( 118)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 118)									int size1 = (b7->length * 4);
HXDLIN( 118)									b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 118)									{
HXLINE( 118)										int _g30 = 0;
HXDLIN( 118)										int _g31 = b7->length;
HXDLIN( 118)										while((_g30 < _g31)){
HXLINE( 118)											_g30 = (_g30 + 1);
HXDLIN( 118)											int i13 = (_g30 - 1);
HXDLIN( 118)											{
HXLINE( 118)												 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN( 118)												bool undoImage5;
HXDLIN( 118)												if ((i13 >= 0)) {
HXLINE( 118)													undoImage5 = (i13 < (this33->byteLength >> 2));
            												}
            												else {
HXLINE( 118)													undoImage5 = false;
            												}
HXDLIN( 118)												if (undoImage5) {
HXLINE( 118)													 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 118)													int pos1 = ((i13 << 2) + this33->byteOffset);
HXDLIN( 118)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 118)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 118)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 118)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 118)								undoImage4 = b7;
            							}
            							break;
            							case (int)3: {
HXLINE( 118)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 118)								 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 118)								{
HXLINE( 118)									v4->width = width1;
HXDLIN( 118)									v4->height = height1;
HXDLIN( 118)									v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 118)									v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 118)									{
HXLINE( 118)										int _g32 = 0;
HXDLIN( 118)										int _g33 = v4->length;
HXDLIN( 118)										while((_g32 < _g33)){
HXLINE( 118)											_g32 = (_g32 + 1);
HXDLIN( 118)											int i14 = (_g32 - 1);
HXDLIN( 118)											v4->data->__unsafe_set(i14,0);
            										}
            									}
            								}
HXDLIN( 118)								undoImage4 = v4;
            							}
            							break;
            							case (int)4: {
HXLINE( 118)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 118)								 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 118)								{
HXLINE( 118)									b8->width = width1;
HXDLIN( 118)									b8->height = height1;
HXDLIN( 118)									b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 118)									b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 118)									{
HXLINE( 118)										int len3 = b8->length;
HXDLIN( 118)										 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 118)										if (::hx::IsNull( d1->head )) {
HXLINE( 118)											int _g34 = 0;
HXDLIN( 118)											int _g35 = len3;
HXDLIN( 118)											while((_g34 < _g35)){
HXLINE( 118)												_g34 = (_g34 + 1);
HXDLIN( 118)												int i15 = (_g34 - 1);
HXDLIN( 118)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXLINE( 118)											int _g36 = 0;
HXDLIN( 118)											int _g37 = len3;
HXDLIN( 118)											while((_g36 < _g37)){
HXLINE( 118)												_g36 = (_g36 + 1);
HXDLIN( 118)												int i16 = (_g36 - 1);
HXDLIN( 118)												{
HXLINE( 118)													 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 118)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 118)													{
HXLINE( 118)														int _g38 = 0;
HXDLIN( 118)														int _g39 = i16;
HXDLIN( 118)														while((_g38 < _g39)){
HXLINE( 118)															_g38 = (_g38 + 1);
HXDLIN( 118)															int i17 = (_g38 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE( 118)													if (::hx::IsNull( prev1 )) {
HXLINE( 118)														b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 118)														l1 = null();
            													}
            													else {
HXLINE( 118)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 118)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 118)								undoImage4 = b8;
            							}
            							break;
            						}
HXDLIN( 118)						this32->image = undoImage4;
HXDLIN( 118)						this32->width = width1;
HXDLIN( 118)						this32->height = height1;
HXDLIN( 118)						this32->imageType = ( (int)(imageType1) );
HXDLIN( 118)						undoImage3 = this32;
HXDLIN( 118)						{
HXLINE( 118)							int rectLeft1 = xIter31->start;
HXDLIN( 118)							int rectTop1 = yIter31->start;
HXDLIN( 118)							int rectRight1 = xIter31->max;
HXDLIN( 118)							bool forceClear1 = false;
HXDLIN( 118)							{
HXLINE( 118)								int _g40 = rectTop1;
HXDLIN( 118)								int _g41 = yIter31->max;
HXDLIN( 118)								while((_g40 < _g41)){
HXLINE( 118)									_g40 = (_g40 + 1);
HXDLIN( 118)									int dy1 = (_g40 - 1);
HXDLIN( 118)									{
HXLINE( 118)										int _g42 = rectLeft1;
HXDLIN( 118)										int _g43 = rectRight1;
HXDLIN( 118)										while((_g42 < _g43)){
HXLINE( 118)											_g42 = (_g42 + 1);
HXDLIN( 118)											int dx1 = (_g42 - 1);
HXDLIN( 118)											::Dynamic this34 = pixelimage->image;
HXDLIN( 118)											int index4;
HXDLIN( 118)											if (pixelimage->useVirtualPos) {
HXLINE( 118)												index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelimage->virtualY) * ( (Float)(pixelimage->width) )) + dx1) - pixelimage->virtualX));
            											}
            											else {
HXLINE( 118)												index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelimage->width) + dx1)) ));
            											}
HXDLIN( 118)											int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 118)											int col1;
HXDLIN( 118)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)												col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXLINE( 118)												col1 = c3;
            											}
HXDLIN( 118)											bool _hx_tmp8;
HXDLIN( 118)											if (pixelimage->useMask) {
HXLINE( 118)												_hx_tmp8 = ::hx::IsNotNull( pixelimage->mask );
            											}
            											else {
HXLINE( 118)												_hx_tmp8 = false;
            											}
HXDLIN( 118)											if (_hx_tmp8) {
HXLINE( 118)												 ::pi_xy::ImageStruct this35 = pixelimage->mask;
HXDLIN( 118)												::Dynamic this36 = this35->image;
HXDLIN( 118)												int index5;
HXDLIN( 118)												if (this35->useVirtualPos) {
HXLINE( 118)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx1) - this35->virtualX));
            												}
            												else {
HXLINE( 118)													index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this35->width) + dx1)) ));
            												}
HXDLIN( 118)												int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 118)												int v5;
HXDLIN( 118)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)													v5 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE( 118)													v5 = c4;
            												}
HXDLIN( 118)												int maskPixel1 = v5;
HXDLIN( 118)												int this37 = col1;
HXDLIN( 118)												if ((maskPixel1 == 0)) {
HXLINE( 118)													col1 = this37;
            												}
            												else {
HXLINE( 118)													Float m01;
HXDLIN( 118)													int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 118)													if ((this38 == 0)) {
HXLINE( 118)														m01 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float m11;
HXDLIN( 118)													int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 118)													if ((this39 == 0)) {
HXLINE( 118)														m11 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float m21;
HXDLIN( 118)													int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 118)													if ((this40 == 0)) {
HXLINE( 118)														m21 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float m31;
HXDLIN( 118)													int this41 = (maskPixel1 & 255);
HXDLIN( 118)													if ((this41 == 0)) {
HXLINE( 118)														m31 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 118)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 118)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 118)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 118)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 118)											if ((col1 != 0)) {
HXLINE( 118)												int x4 = (dx1 - rectLeft1);
HXDLIN( 118)												int y4 = (dy1 - rectTop1);
HXDLIN( 118)												int c5 = col1;
HXDLIN( 118)												bool _hx_tmp9;
HXDLIN( 118)												if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 118)													_hx_tmp9 = undoImage3->transparent;
            												}
            												else {
HXLINE( 118)													_hx_tmp9 = false;
            												}
HXDLIN( 118)												if (_hx_tmp9) {
HXLINE( 118)													int location2;
HXDLIN( 118)													if (undoImage3->useVirtualPos) {
HXLINE( 118)														location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 118)														location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 118)													int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 118)													int this43;
HXDLIN( 118)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)														this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            													}
            													else {
HXLINE( 118)														this43 = this42;
            													}
HXDLIN( 118)													Float a12;
HXDLIN( 118)													int this44 = ((this43 >> 24) & 255);
HXDLIN( 118)													if ((this44 == 0)) {
HXLINE( 118)														a12 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float r12;
HXDLIN( 118)													int this45 = ((this43 >> 16) & 255);
HXDLIN( 118)													if ((this45 == 0)) {
HXLINE( 118)														r12 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float g12;
HXDLIN( 118)													int this46 = ((this43 >> 8) & 255);
HXDLIN( 118)													if ((this46 == 0)) {
HXLINE( 118)														g12 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float b13;
HXDLIN( 118)													int this47 = (this43 & 255);
HXDLIN( 118)													if ((this47 == 0)) {
HXLINE( 118)														b13 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float a22;
HXDLIN( 118)													int this48 = ((col1 >> 24) & 255);
HXDLIN( 118)													if ((this48 == 0)) {
HXLINE( 118)														a22 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float r22;
HXDLIN( 118)													int this49 = ((col1 >> 16) & 255);
HXDLIN( 118)													if ((this49 == 0)) {
HXLINE( 118)														r22 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float g22;
HXDLIN( 118)													int this50 = ((col1 >> 8) & 255);
HXDLIN( 118)													if ((this50 == 0)) {
HXLINE( 118)														g22 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float b23;
HXDLIN( 118)													int this51 = (col1 & 255);
HXDLIN( 118)													if ((this51 == 0)) {
HXLINE( 118)														b23 = ((Float)0.);
            													}
            													else {
HXLINE( 118)														b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN( 118)													Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 118)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 118)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 118)													int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 118)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 118)													int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 118)													{
HXLINE( 118)														int _hx_tmp10;
HXDLIN( 118)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)															_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE( 118)															_hx_tmp10 = blended2;
            														}
HXDLIN( 118)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            													}
            												}
            												else {
HXLINE( 118)													::Dynamic this52 = undoImage3->image;
HXDLIN( 118)													int index6;
HXDLIN( 118)													if (undoImage3->useVirtualPos) {
HXLINE( 118)														index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 118)														index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 118)													int _hx_tmp11;
HXDLIN( 118)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)														_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE( 118)														_hx_tmp11 = c5;
            													}
HXDLIN( 118)													::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            												}
            											}
            											else {
HXLINE( 118)												if (forceClear1) {
HXLINE( 118)													::Dynamic this53 = undoImage3->image;
HXDLIN( 118)													int x5 = (dx1 - rectLeft1);
HXDLIN( 118)													int y5 = (dy1 - rectTop1);
HXDLIN( 118)													int index7;
HXDLIN( 118)													if (undoImage3->useVirtualPos) {
HXLINE( 118)														index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 118)														index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN( 118)													::iterMagic::Iimg_obj::set(this53,index7,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 118)					bool found1 = false;
HXDLIN( 118)					{
HXLINE( 118)						int _g_min2 = xIter31->start;
HXDLIN( 118)						int _g_max2 = xIter31->max;
HXDLIN( 118)						while((_g_min2 < _g_max2)){
HXLINE( 118)							_g_min2 = (_g_min2 + 1);
HXDLIN( 118)							int px1 = (_g_min2 - 1);
HXDLIN( 118)							Float pcx1 = (( (Float)(px1) ) - nextX1);
HXLINE( 619)							found1 = false;
HXLINE( 118)							{
HXLINE( 118)								int _g_min3 = yIter31->start;
HXDLIN( 118)								int _g_max3 = yIter31->max;
HXDLIN( 118)								while((_g_min3 < _g_max3)){
HXLINE( 118)									_g_min3 = (_g_min3 + 1);
HXDLIN( 118)									int py1 = (_g_min3 - 1);
HXDLIN( 118)									Float pcy1 = (( (Float)(py1) ) - nextY1);
HXDLIN( 118)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 118)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 118)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 118)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 118)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 118)									bool _hx_tmp12;
HXDLIN( 118)									bool _hx_tmp13;
HXDLIN( 118)									if ((ratioA1 >= 0)) {
HXLINE( 118)										_hx_tmp13 = (ratioB1 >= 0);
            									}
            									else {
HXLINE( 118)										_hx_tmp13 = false;
            									}
HXDLIN( 118)									if (_hx_tmp13) {
HXLINE( 118)										_hx_tmp12 = (ratioC1 >= 0);
            									}
            									else {
HXLINE( 118)										_hx_tmp12 = false;
            									}
HXDLIN( 118)									if (_hx_tmp12) {
HXLINE( 118)										int i18 = ::Std_obj::_hx_int((( (Float)(aA1) ) * (softC * ratioB1)));
HXDLIN( 118)										if ((i18 > 255)) {
HXLINE(  24)											i18 = 255;
            										}
HXLINE( 118)										if ((i18 < 0)) {
HXLINE(  25)											i18 = 0;
            										}
HXLINE( 118)										int a9 = i18;
HXDLIN( 118)										int i19 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 118)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE( 118)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE( 118)										int r6 = i19;
HXDLIN( 118)										int i20 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 118)										if ((i20 > 255)) {
HXLINE(  24)											i20 = 255;
            										}
HXLINE( 118)										if ((i20 < 0)) {
HXLINE(  25)											i20 = 0;
            										}
HXLINE( 118)										int g6 = i20;
HXDLIN( 118)										int i21 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 118)										if ((i21 > 255)) {
HXLINE(  24)											i21 = 255;
            										}
HXLINE( 118)										if ((i21 < 0)) {
HXLINE(  25)											i21 = 0;
            										}
HXLINE( 118)										int b10 = i21;
HXDLIN( 118)										{
HXLINE( 118)											int location3;
HXDLIN( 118)											if (pixelimage->useVirtualPos) {
HXLINE( 118)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelimage->virtualY) * ( (Float)(pixelimage->width) )) + px1) - pixelimage->virtualX));
            											}
            											else {
HXLINE( 118)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelimage->width) + px1)) ));
            											}
HXDLIN( 118)											bool _hx_tmp14;
HXDLIN( 118)											if (pixelimage->transparent) {
HXLINE( 118)												_hx_tmp14 = (a9 < 254);
            											}
            											else {
HXLINE( 118)												_hx_tmp14 = false;
            											}
HXDLIN( 118)											if (_hx_tmp14) {
HXLINE( 118)												int this54 = ::iterMagic::Iimg_obj::get(pixelimage->image,location3);
HXDLIN( 118)												int old1;
HXDLIN( 118)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)													old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            												}
            												else {
HXLINE( 118)													old1 = this54;
            												}
HXDLIN( 118)												int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 118)												Float a13;
HXDLIN( 118)												int this55 = ((old1 >> 24) & 255);
HXDLIN( 118)												if ((this55 == 0)) {
HXLINE( 118)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													a13 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float r13;
HXDLIN( 118)												int this56 = ((old1 >> 16) & 255);
HXDLIN( 118)												if ((this56 == 0)) {
HXLINE( 118)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float g13;
HXDLIN( 118)												int this57 = ((old1 >> 8) & 255);
HXDLIN( 118)												if ((this57 == 0)) {
HXLINE( 118)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float b14;
HXDLIN( 118)												int this58 = (old1 & 255);
HXDLIN( 118)												if ((this58 == 0)) {
HXLINE( 118)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													b14 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float a23;
HXDLIN( 118)												int this59 = ((rhs1 >> 24) & 255);
HXDLIN( 118)												if ((this59 == 0)) {
HXLINE( 118)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float r23;
HXDLIN( 118)												int this60 = ((rhs1 >> 16) & 255);
HXDLIN( 118)												if ((this60 == 0)) {
HXLINE( 118)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float g23;
HXDLIN( 118)												int this61 = ((rhs1 >> 8) & 255);
HXDLIN( 118)												if ((this61 == 0)) {
HXLINE( 118)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float b24;
HXDLIN( 118)												int this62 = (rhs1 & 255);
HXDLIN( 118)												if ((this62 == 0)) {
HXLINE( 118)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 118)													b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 118)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 118)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 118)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 118)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 118)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 118)												int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 118)												{
HXLINE( 118)													int _hx_tmp15;
HXDLIN( 118)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 118)														_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 118)														_hx_tmp15 = blended3;
            													}
HXDLIN( 118)													::iterMagic::Iimg_obj::set(pixelimage->image,location3,_hx_tmp15);
            												}
            											}
            											else {
HXLINE( 118)												int value1;
HXDLIN( 118)												if (pixelimage->isLittle) {
HXLINE( 118)													value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            												}
            												else {
HXLINE( 118)													value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            												}
HXDLIN( 118)												::iterMagic::Iimg_obj::set(pixelimage->image,location3,value1);
            											}
            										}
HXLINE( 633)										found1 = true;
            									}
            									else {
HXLINE( 118)										if (found1) {
HXLINE( 118)											goto _hx_goto_52;
            										}
            									}
            								}
            								_hx_goto_52:;
            							}
            						}
            					}
HXDLIN( 118)					if ((hasHit1 == false)) {
HXLINE( 118)						 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,lastX,lastY,nextX1,nextY1,true);
HXDLIN( 118)						if (hasUndo1) {
HXLINE( 118)							v6->undoImage = undoImage3;
HXDLIN( 118)							v6->undoX = xIter31->start;
HXDLIN( 118)							v6->undoY = yIter31->start;
            						}
            					}
            				}
HXLINE( 119)				lastX = nextX1;
HXLINE( 120)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(PolyPixel_Fields__obj,softFillPolygonBuild,(void))

void PolyPixel_Fields__obj::tilePolygonBuild( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_87ef2d4220a4cd37_132_tilePolygonBuild)
HXLINE( 133)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE( 134)		Float omega;
HXDLIN( 134)		if (cornerUp) {
HXLINE( 134)			omega = ((Float)0.);
            		}
            		else {
HXLINE( 138)			if ((::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(2) ))) == (( (Float)(sides) ) / ( (Float)(2) )))) {
HXLINE( 134)				omega = (::Math_obj::PI / ( (Float)(sides) ));
            			}
            			else {
HXLINE( 141)				Float v = ((( (Float)(sides) ) / ( (Float)(2) )) - ((Float)0.5));
HXLINE( 142)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXLINE( 134)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) )) - ::Math_obj::PI);
            				}
            				else {
HXLINE( 134)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) ));
            				}
            			}
            		}
HXLINE( 151)		Float lastX = ((Float)0.);
HXLINE( 152)		Float lastY = ((Float)0.);
HXLINE( 153)		if (::hx::IsNotEq( phi,0 )) {
HXLINE( 154)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE( 155)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE( 157)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE( 158)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 160)		if (::hx::IsNotEq( phi,0 )) {
HXLINE( 161)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE( 162)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE( 163)			{
HXLINE( 163)				int _g = 0;
HXDLIN( 163)				int _g1 = (sides + 1);
HXDLIN( 163)				while((_g < _g1)){
HXLINE( 163)					_g = (_g + 1);
HXDLIN( 163)					int i = (_g - 1);
HXLINE( 164)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE( 165)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXLINE( 166)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE( 167)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE( 168)					{
HXLINE( 168)						 ::pi_xy::ImageStruct this1 = pixelimage;
HXDLIN( 168)						bool hasHit = false;
HXDLIN( 168)						{
HXLINE( 168)							Float bx = lastX;
HXDLIN( 168)							Float by = lastY;
HXDLIN( 168)							Float cx1 = nextX;
HXDLIN( 168)							Float cy1 = nextY;
HXDLIN( 168)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 168)							if (!(adjustWinding)) {
HXLINE( 168)								Float bx_ = bx;
HXDLIN( 168)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE( 168)							{
HXLINE( 168)								bool hasUndo = false;
HXDLIN( 168)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 168)								Float sx = (cy1 - cy);
HXDLIN( 168)								Float sy = (cx - cx1);
HXDLIN( 168)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 168)								Float tx = (cy - by);
HXDLIN( 168)								Float ty = (bx - cx);
HXDLIN( 168)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 168)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 168)								if ((cx > bx)) {
HXLINE( 168)									if ((cx > cx1)) {
HXLINE( 168)										int min;
HXDLIN( 168)										if ((bx > cx1)) {
HXLINE( 168)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE( 168)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 168)										int ii_min = min;
HXDLIN( 168)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 168)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE( 168)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 168)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 168)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE( 168)									if ((bx > cx1)) {
HXLINE( 168)										int min1;
HXDLIN( 168)										if ((cx > cx1)) {
HXLINE( 168)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE( 168)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 168)										int ii_min2 = min1;
HXDLIN( 168)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 168)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE( 168)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 168)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 168)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 168)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 168)								if ((cy > by)) {
HXLINE( 168)									if ((cy > cy1)) {
HXLINE( 168)										int min2;
HXDLIN( 168)										if ((by > cy1)) {
HXLINE( 168)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE( 168)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 168)										int ii_min4 = min2;
HXDLIN( 168)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 168)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE( 168)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 168)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 168)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE( 168)									if ((by > cy1)) {
HXLINE( 168)										int min3;
HXDLIN( 168)										if ((cy > cy1)) {
HXLINE( 168)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE( 168)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 168)										int ii_min6 = min3;
HXDLIN( 168)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 168)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE( 168)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 168)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 168)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 168)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 168)								if (hasUndo) {
HXLINE( 168)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 168)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 168)									 ::Dynamic imageType = null();
HXDLIN( 168)									 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 168)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 168)									::Dynamic undoImage1;
HXDLIN( 168)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE( 168)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 168)											{
HXLINE( 168)												b->width = width;
HXDLIN( 168)												b->height = height;
HXDLIN( 168)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 168)												{
HXLINE( 168)													int len = b->length;
HXDLIN( 168)													int w = 0;
HXDLIN( 168)													{
HXLINE( 168)														int _g2 = 0;
HXDLIN( 168)														int _g3 = b->height;
HXDLIN( 168)														while((_g2 < _g3)){
HXLINE( 168)															_g2 = (_g2 + 1);
HXDLIN( 168)															int y = (_g2 - 1);
HXDLIN( 168)															{
HXLINE( 168)																int _g4 = 0;
HXDLIN( 168)																int _g5 = b->width;
HXDLIN( 168)																while((_g4 < _g5)){
HXLINE( 168)																	_g4 = (_g4 + 1);
HXDLIN( 168)																	int x = (_g4 - 1);
HXDLIN( 168)																	{
HXLINE( 168)																		w = (w + 1);
HXDLIN( 168)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w = (w + 1);
HXDLIN( 168)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w = (w + 1);
HXDLIN( 168)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w = (w + 1);
HXDLIN( 168)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE( 168)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 168)											{
HXLINE( 168)												a->width = width;
HXDLIN( 168)												a->height = height;
HXDLIN( 168)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 168)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)												{
HXLINE( 168)													int _g6 = 0;
HXDLIN( 168)													int _g7 = a->length;
HXDLIN( 168)													while((_g6 < _g7)){
HXLINE( 168)														_g6 = (_g6 + 1);
HXDLIN( 168)														int i1 = (_g6 - 1);
HXDLIN( 168)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 168)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE( 168)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 168)											{
HXLINE( 168)												b1->width = width;
HXDLIN( 168)												b1->height = height;
HXDLIN( 168)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)												int size = (b1->length * 4);
HXDLIN( 168)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 168)												{
HXLINE( 168)													int _g8 = 0;
HXDLIN( 168)													int _g9 = b1->length;
HXDLIN( 168)													while((_g8 < _g9)){
HXLINE( 168)														_g8 = (_g8 + 1);
HXDLIN( 168)														int i2 = (_g8 - 1);
HXDLIN( 168)														{
HXLINE( 168)															 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 168)															bool undoImage2;
HXDLIN( 168)															if ((i2 >= 0)) {
HXLINE( 168)																undoImage2 = (i2 < (this3->byteLength >> 2));
            															}
            															else {
HXLINE( 168)																undoImage2 = false;
            															}
HXDLIN( 168)															if (undoImage2) {
HXLINE( 168)																 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 168)																int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN( 168)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 168)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 168)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 168)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE( 168)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 168)											{
HXLINE( 168)												v1->width = width;
HXDLIN( 168)												v1->height = height;
HXDLIN( 168)												v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)												v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 168)												{
HXLINE( 168)													int _g10 = 0;
HXDLIN( 168)													int _g11 = v1->length;
HXDLIN( 168)													while((_g10 < _g11)){
HXLINE( 168)														_g10 = (_g10 + 1);
HXDLIN( 168)														int i3 = (_g10 - 1);
HXDLIN( 168)														v1->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 168)											undoImage1 = v1;
            										}
            										break;
            										case (int)4: {
HXLINE( 168)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 168)											{
HXLINE( 168)												b2->width = width;
HXDLIN( 168)												b2->height = height;
HXDLIN( 168)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 168)												{
HXLINE( 168)													int len1 = b2->length;
HXDLIN( 168)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 168)													if (::hx::IsNull( d->head )) {
HXLINE( 168)														int _g12 = 0;
HXDLIN( 168)														int _g13 = len1;
HXDLIN( 168)														while((_g12 < _g13)){
HXLINE( 168)															_g12 = (_g12 + 1);
HXDLIN( 168)															int i4 = (_g12 - 1);
HXDLIN( 168)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE( 168)														int _g14 = 0;
HXDLIN( 168)														int _g15 = len1;
HXDLIN( 168)														while((_g14 < _g15)){
HXLINE( 168)															_g14 = (_g14 + 1);
HXDLIN( 168)															int i5 = (_g14 - 1);
HXDLIN( 168)															{
HXLINE( 168)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 168)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 168)																{
HXLINE( 168)																	int _g16 = 0;
HXDLIN( 168)																	int _g17 = i5;
HXDLIN( 168)																	while((_g16 < _g17)){
HXLINE( 168)																		_g16 = (_g16 + 1);
HXDLIN( 168)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 168)																if (::hx::IsNull( prev )) {
HXLINE( 168)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 168)																	l = null();
            																}
            																else {
HXLINE( 168)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 168)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 168)									this2->image = undoImage1;
HXDLIN( 168)									this2->width = width;
HXDLIN( 168)									this2->height = height;
HXDLIN( 168)									this2->imageType = ( (int)(imageType) );
HXDLIN( 168)									undoImage = this2;
HXDLIN( 168)									{
HXLINE( 168)										int rectLeft = xIter3->start;
HXDLIN( 168)										int rectTop = yIter3->start;
HXDLIN( 168)										int rectRight = xIter3->max;
HXDLIN( 168)										bool forceClear = false;
HXDLIN( 168)										{
HXLINE( 168)											int _g18 = rectTop;
HXDLIN( 168)											int _g19 = yIter3->max;
HXDLIN( 168)											while((_g18 < _g19)){
HXLINE( 168)												_g18 = (_g18 + 1);
HXDLIN( 168)												int dy = (_g18 - 1);
HXDLIN( 168)												{
HXLINE( 168)													int _g20 = rectLeft;
HXDLIN( 168)													int _g21 = rectRight;
HXDLIN( 168)													while((_g20 < _g21)){
HXLINE( 168)														_g20 = (_g20 + 1);
HXDLIN( 168)														int dx = (_g20 - 1);
HXDLIN( 168)														::Dynamic this4 = this1->image;
HXDLIN( 168)														int index;
HXDLIN( 168)														if (this1->useVirtualPos) {
HXLINE( 168)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE( 168)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN( 168)														int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 168)														int col;
HXDLIN( 168)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 168)															col = c;
            														}
HXDLIN( 168)														bool _hx_tmp;
HXDLIN( 168)														if (this1->useMask) {
HXLINE( 168)															_hx_tmp = ::hx::IsNotNull( this1->mask );
            														}
            														else {
HXLINE( 168)															_hx_tmp = false;
            														}
HXDLIN( 168)														if (_hx_tmp) {
HXLINE( 168)															 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 168)															::Dynamic this6 = this5->image;
HXDLIN( 168)															int index1;
HXDLIN( 168)															if (this5->useVirtualPos) {
HXLINE( 168)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            															}
            															else {
HXLINE( 168)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            															}
HXDLIN( 168)															int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 168)															int v2;
HXDLIN( 168)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 168)																v2 = c1;
            															}
HXDLIN( 168)															int maskPixel = v2;
HXDLIN( 168)															int this7 = col;
HXDLIN( 168)															if ((maskPixel == 0)) {
HXLINE( 168)																col = this7;
            															}
            															else {
HXLINE( 168)																Float m0;
HXDLIN( 168)																int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 168)																if ((this8 == 0)) {
HXLINE( 168)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m1;
HXDLIN( 168)																int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 168)																if ((this9 == 0)) {
HXLINE( 168)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m2;
HXDLIN( 168)																int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 168)																if ((this10 == 0)) {
HXLINE( 168)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m3;
HXDLIN( 168)																int this11 = (maskPixel & 255);
HXDLIN( 168)																if ((this11 == 0)) {
HXLINE( 168)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 168)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 168)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 168)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 168)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 168)														if ((col != 0)) {
HXLINE( 168)															int x1 = (dx - rectLeft);
HXDLIN( 168)															int y1 = (dy - rectTop);
HXDLIN( 168)															int c2 = col;
HXDLIN( 168)															bool _hx_tmp1;
HXDLIN( 168)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 168)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE( 168)																_hx_tmp1 = false;
            															}
HXDLIN( 168)															if (_hx_tmp1) {
HXLINE( 168)																int location;
HXDLIN( 168)																if (undoImage->useVirtualPos) {
HXLINE( 168)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 168)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 168)																int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 168)																int this13;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	this13 = this12;
            																}
HXDLIN( 168)																Float a1;
HXDLIN( 168)																int this14 = ((this13 >> 24) & 255);
HXDLIN( 168)																if ((this14 == 0)) {
HXLINE( 168)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r1;
HXDLIN( 168)																int this15 = ((this13 >> 16) & 255);
HXDLIN( 168)																if ((this15 == 0)) {
HXLINE( 168)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g1;
HXDLIN( 168)																int this16 = ((this13 >> 8) & 255);
HXDLIN( 168)																if ((this16 == 0)) {
HXLINE( 168)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b11;
HXDLIN( 168)																int this17 = (this13 & 255);
HXDLIN( 168)																if ((this17 == 0)) {
HXLINE( 168)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a2;
HXDLIN( 168)																int this18 = ((col >> 24) & 255);
HXDLIN( 168)																if ((this18 == 0)) {
HXLINE( 168)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r2;
HXDLIN( 168)																int this19 = ((col >> 16) & 255);
HXDLIN( 168)																if ((this19 == 0)) {
HXLINE( 168)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g2;
HXDLIN( 168)																int this20 = ((col >> 8) & 255);
HXDLIN( 168)																if ((this20 == 0)) {
HXLINE( 168)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b21;
HXDLIN( 168)																int this21 = (col & 255);
HXDLIN( 168)																if ((this21 == 0)) {
HXLINE( 168)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 168)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 168)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 168)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 168)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 168)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 168)																{
HXLINE( 168)																	int _hx_tmp2;
HXDLIN( 168)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 168)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 168)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE( 168)																::Dynamic this22 = undoImage->image;
HXDLIN( 168)																int index2;
HXDLIN( 168)																if (undoImage->useVirtualPos) {
HXLINE( 168)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 168)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 168)																int _hx_tmp3;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	_hx_tmp3 = c2;
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE( 168)															if (forceClear) {
HXLINE( 168)																::Dynamic this23 = undoImage->image;
HXDLIN( 168)																int x2 = (dx - rectLeft);
HXDLIN( 168)																int y2 = (dy - rectTop);
HXDLIN( 168)																int index3;
HXDLIN( 168)																if (undoImage->useVirtualPos) {
HXLINE( 168)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE( 168)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this23,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 168)								bool foundY = false;
HXDLIN( 168)								Float s = ((Float)0.);
HXDLIN( 168)								Float t = ((Float)0.);
HXDLIN( 168)								Float sxx = ((Float)0.);
HXDLIN( 168)								Float txx = ((Float)0.);
HXDLIN( 168)								{
HXLINE( 168)									int _g_min = xIter3->start;
HXDLIN( 168)									int _g_max = xIter3->max;
HXDLIN( 168)									while((_g_min < _g_max)){
HXLINE( 168)										_g_min = (_g_min + 1);
HXDLIN( 168)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE( 168)										{
HXLINE( 168)											int _g_min1 = yIter3->start;
HXDLIN( 168)											int _g_max1 = yIter3->max;
HXDLIN( 168)											while((_g_min1 < _g_max1)){
HXLINE( 168)												_g_min1 = (_g_min1 + 1);
HXDLIN( 168)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 168)												bool _hx_tmp4;
HXDLIN( 168)												if (!((s <= 0))) {
HXLINE( 168)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXLINE( 168)													_hx_tmp4 = true;
            												}
HXDLIN( 168)												if (_hx_tmp4) {
HXLINE( 168)													if (foundY) {
HXLINE( 168)														goto _hx_goto_66;
            													}
            												}
            												else {
HXLINE( 168)													if (((s + t) < A)) {
HXLINE( 168)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 168)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 168)														::Dynamic this24 = tileImage->image;
HXDLIN( 168)														int index4;
HXDLIN( 168)														if (tileImage->useVirtualPos) {
HXLINE( 168)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXLINE( 168)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN( 168)														int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 168)														int color;
HXDLIN( 168)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXLINE( 168)															color = c3;
            														}
HXDLIN( 168)														{
HXLINE( 168)															int c4 = color;
HXDLIN( 168)															bool _hx_tmp5;
HXDLIN( 168)															if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 168)																_hx_tmp5 = this1->transparent;
            															}
            															else {
HXLINE( 168)																_hx_tmp5 = false;
            															}
HXDLIN( 168)															if (_hx_tmp5) {
HXLINE( 168)																int location1;
HXDLIN( 168)																if (this1->useVirtualPos) {
HXLINE( 168)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE( 168)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN( 168)																int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 168)																int this26;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	this26 = this25;
            																}
HXDLIN( 168)																Float a11;
HXDLIN( 168)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 168)																if ((this27 == 0)) {
HXLINE( 168)																	a11 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r11;
HXDLIN( 168)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 168)																if ((this28 == 0)) {
HXLINE( 168)																	r11 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g11;
HXDLIN( 168)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 168)																if ((this29 == 0)) {
HXLINE( 168)																	g11 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b12;
HXDLIN( 168)																int this30 = (this26 & 255);
HXDLIN( 168)																if ((this30 == 0)) {
HXLINE( 168)																	b12 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a21;
HXDLIN( 168)																int this31 = ((color >> 24) & 255);
HXDLIN( 168)																if ((this31 == 0)) {
HXLINE( 168)																	a21 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r21;
HXDLIN( 168)																int this32 = ((color >> 16) & 255);
HXDLIN( 168)																if ((this32 == 0)) {
HXLINE( 168)																	r21 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g21;
HXDLIN( 168)																int this33 = ((color >> 8) & 255);
HXDLIN( 168)																if ((this33 == 0)) {
HXLINE( 168)																	g21 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b22;
HXDLIN( 168)																int this34 = (color & 255);
HXDLIN( 168)																if ((this34 == 0)) {
HXLINE( 168)																	b22 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 168)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 168)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 168)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 168)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 168)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 168)																{
HXLINE( 168)																	int _hx_tmp6;
HXDLIN( 168)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXLINE( 168)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 168)																	::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXLINE( 168)																::Dynamic this35 = this1->image;
HXDLIN( 168)																int index5;
HXDLIN( 168)																if (this1->useVirtualPos) {
HXLINE( 168)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE( 168)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN( 168)																int _hx_tmp7;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	_hx_tmp7 = c4;
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXLINE( 168)														if (foundY) {
HXLINE( 168)															goto _hx_goto_66;
            														}
            													}
            												}
            											}
            											_hx_goto_66:;
            										}
            									}
            								}
HXDLIN( 168)								if ((hasHit == false)) {
HXLINE( 168)									 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 168)									if (hasUndo) {
HXLINE( 168)										v3->undoImage = undoImage;
HXDLIN( 168)										v3->undoX = xIter3->start;
HXDLIN( 168)										v3->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE( 169)					lastX = nextX;
HXLINE( 170)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE( 173)			int _g22 = 0;
HXDLIN( 173)			int _g23 = (sides + 1);
HXDLIN( 173)			while((_g22 < _g23)){
HXLINE( 173)				_g22 = (_g22 + 1);
HXDLIN( 173)				int i7 = (_g22 - 1);
HXLINE( 174)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXLINE( 175)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXLINE( 176)				{
HXLINE( 176)					 ::pi_xy::ImageStruct this36 = pixelimage;
HXDLIN( 176)					bool hasHit1 = false;
HXDLIN( 176)					{
HXLINE( 176)						Float bx1 = lastX;
HXDLIN( 176)						Float by1 = lastY;
HXDLIN( 176)						Float cx2 = nextX1;
HXDLIN( 176)						Float cy2 = nextY1;
HXDLIN( 176)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 176)						if (!(adjustWinding1)) {
HXLINE( 176)							Float bx_1 = bx1;
HXDLIN( 176)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE( 176)						{
HXLINE( 176)							bool hasUndo1 = false;
HXDLIN( 176)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 176)							Float sx1 = (cy2 - cy);
HXDLIN( 176)							Float sy1 = (cx - cx2);
HXDLIN( 176)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 176)							Float tx1 = (cy - by1);
HXDLIN( 176)							Float ty1 = (bx1 - cx);
HXDLIN( 176)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 176)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 176)							if ((cx > bx1)) {
HXLINE( 176)								if ((cx > cx2)) {
HXLINE( 176)									int min4;
HXDLIN( 176)									if ((bx1 > cx2)) {
HXLINE( 176)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE( 176)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 176)									int ii_min8 = min4;
HXDLIN( 176)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 176)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE( 176)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 176)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 176)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE( 176)								if ((bx1 > cx2)) {
HXLINE( 176)									int min5;
HXDLIN( 176)									if ((cx > cx2)) {
HXLINE( 176)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE( 176)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 176)									int ii_min10 = min5;
HXDLIN( 176)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 176)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE( 176)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 176)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 176)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 176)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 176)							if ((cy > by1)) {
HXLINE( 176)								if ((cy > cy2)) {
HXLINE( 176)									int min6;
HXDLIN( 176)									if ((by1 > cy2)) {
HXLINE( 176)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE( 176)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 176)									int ii_min12 = min6;
HXDLIN( 176)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 176)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE( 176)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 176)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 176)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE( 176)								if ((by1 > cy2)) {
HXLINE( 176)									int min7;
HXDLIN( 176)									if ((cy > cy2)) {
HXLINE( 176)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE( 176)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 176)									int ii_min14 = min7;
HXDLIN( 176)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 176)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE( 176)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 176)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 176)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 176)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 176)							if (hasUndo1) {
HXLINE( 176)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 176)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 176)								 ::Dynamic imageType1 = null();
HXDLIN( 176)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 176)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 176)								::Dynamic undoImage4;
HXDLIN( 176)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE( 176)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 176)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 176)										{
HXLINE( 176)											b5->width = width1;
HXDLIN( 176)											b5->height = height1;
HXDLIN( 176)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 176)											{
HXLINE( 176)												int len2 = b5->length;
HXDLIN( 176)												int w1 = 0;
HXDLIN( 176)												{
HXLINE( 176)													int _g24 = 0;
HXDLIN( 176)													int _g25 = b5->height;
HXDLIN( 176)													while((_g24 < _g25)){
HXLINE( 176)														_g24 = (_g24 + 1);
HXDLIN( 176)														int y5 = (_g24 - 1);
HXDLIN( 176)														{
HXLINE( 176)															int _g26 = 0;
HXDLIN( 176)															int _g27 = b5->width;
HXDLIN( 176)															while((_g26 < _g27)){
HXLINE( 176)																_g26 = (_g26 + 1);
HXDLIN( 176)																int x5 = (_g26 - 1);
HXDLIN( 176)																{
HXLINE( 176)																	w1 = (w1 + 1);
HXDLIN( 176)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 176)																{
HXLINE( 176)																	w1 = (w1 + 1);
HXDLIN( 176)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 176)																{
HXLINE( 176)																	w1 = (w1 + 1);
HXDLIN( 176)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 176)																{
HXLINE( 176)																	w1 = (w1 + 1);
HXDLIN( 176)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 176)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXLINE( 176)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 176)										{
HXLINE( 176)											a6->width = width1;
HXDLIN( 176)											a6->height = height1;
HXDLIN( 176)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 176)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)											{
HXLINE( 176)												int _g28 = 0;
HXDLIN( 176)												int _g29 = a6->length;
HXDLIN( 176)												while((_g28 < _g29)){
HXLINE( 176)													_g28 = (_g28 + 1);
HXDLIN( 176)													int i8 = (_g28 - 1);
HXDLIN( 176)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 176)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXLINE( 176)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 176)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 176)										{
HXLINE( 176)											b6->width = width1;
HXDLIN( 176)											b6->height = height1;
HXDLIN( 176)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)											int size1 = (b6->length * 4);
HXDLIN( 176)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 176)											{
HXLINE( 176)												int _g30 = 0;
HXDLIN( 176)												int _g31 = b6->length;
HXDLIN( 176)												while((_g30 < _g31)){
HXLINE( 176)													_g30 = (_g30 + 1);
HXDLIN( 176)													int i9 = (_g30 - 1);
HXDLIN( 176)													{
HXLINE( 176)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 176)														bool undoImage5;
HXDLIN( 176)														if ((i9 >= 0)) {
HXLINE( 176)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXLINE( 176)															undoImage5 = false;
            														}
HXDLIN( 176)														if (undoImage5) {
HXLINE( 176)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 176)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 176)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 176)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 176)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 176)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 176)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXLINE( 176)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)										 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 176)										{
HXLINE( 176)											v4->width = width1;
HXDLIN( 176)											v4->height = height1;
HXDLIN( 176)											v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)											v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 176)											{
HXLINE( 176)												int _g32 = 0;
HXDLIN( 176)												int _g33 = v4->length;
HXDLIN( 176)												while((_g32 < _g33)){
HXLINE( 176)													_g32 = (_g32 + 1);
HXDLIN( 176)													int i10 = (_g32 - 1);
HXDLIN( 176)													v4->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 176)										undoImage4 = v4;
            									}
            									break;
            									case (int)4: {
HXLINE( 176)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 176)										{
HXLINE( 176)											b7->width = width1;
HXDLIN( 176)											b7->height = height1;
HXDLIN( 176)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 176)											{
HXLINE( 176)												int len3 = b7->length;
HXDLIN( 176)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 176)												if (::hx::IsNull( d1->head )) {
HXLINE( 176)													int _g34 = 0;
HXDLIN( 176)													int _g35 = len3;
HXDLIN( 176)													while((_g34 < _g35)){
HXLINE( 176)														_g34 = (_g34 + 1);
HXDLIN( 176)														int i11 = (_g34 - 1);
HXDLIN( 176)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE( 176)													int _g36 = 0;
HXDLIN( 176)													int _g37 = len3;
HXDLIN( 176)													while((_g36 < _g37)){
HXLINE( 176)														_g36 = (_g36 + 1);
HXDLIN( 176)														int i12 = (_g36 - 1);
HXDLIN( 176)														{
HXLINE( 176)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 176)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 176)															{
HXLINE( 176)																int _g38 = 0;
HXDLIN( 176)																int _g39 = i12;
HXDLIN( 176)																while((_g38 < _g39)){
HXLINE( 176)																	_g38 = (_g38 + 1);
HXDLIN( 176)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 176)															if (::hx::IsNull( prev1 )) {
HXLINE( 176)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 176)																l1 = null();
            															}
            															else {
HXLINE( 176)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 176)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 176)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 176)								this37->image = undoImage4;
HXDLIN( 176)								this37->width = width1;
HXDLIN( 176)								this37->height = height1;
HXDLIN( 176)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 176)								undoImage3 = this37;
HXDLIN( 176)								{
HXLINE( 176)									int rectLeft1 = xIter31->start;
HXDLIN( 176)									int rectTop1 = yIter31->start;
HXDLIN( 176)									int rectRight1 = xIter31->max;
HXDLIN( 176)									bool forceClear1 = false;
HXDLIN( 176)									{
HXLINE( 176)										int _g40 = rectTop1;
HXDLIN( 176)										int _g41 = yIter31->max;
HXDLIN( 176)										while((_g40 < _g41)){
HXLINE( 176)											_g40 = (_g40 + 1);
HXDLIN( 176)											int dy1 = (_g40 - 1);
HXDLIN( 176)											{
HXLINE( 176)												int _g42 = rectLeft1;
HXDLIN( 176)												int _g43 = rectRight1;
HXDLIN( 176)												while((_g42 < _g43)){
HXLINE( 176)													_g42 = (_g42 + 1);
HXDLIN( 176)													int dx1 = (_g42 - 1);
HXDLIN( 176)													::Dynamic this39 = this36->image;
HXDLIN( 176)													int index6;
HXDLIN( 176)													if (this36->useVirtualPos) {
HXLINE( 176)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXLINE( 176)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 176)													int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 176)													int col1;
HXDLIN( 176)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE( 176)														col1 = c5;
            													}
HXDLIN( 176)													bool _hx_tmp8;
HXDLIN( 176)													if (this36->useMask) {
HXLINE( 176)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXLINE( 176)														_hx_tmp8 = false;
            													}
HXDLIN( 176)													if (_hx_tmp8) {
HXLINE( 176)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 176)														::Dynamic this41 = this40->image;
HXDLIN( 176)														int index7;
HXDLIN( 176)														if (this40->useVirtualPos) {
HXLINE( 176)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXLINE( 176)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 176)														int c6 = ::iterMagic::Iimg_obj::get(this41,index7);
HXDLIN( 176)														int v5;
HXDLIN( 176)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)															v5 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXLINE( 176)															v5 = c6;
            														}
HXDLIN( 176)														int maskPixel1 = v5;
HXDLIN( 176)														int this42 = col1;
HXDLIN( 176)														if ((maskPixel1 == 0)) {
HXLINE( 176)															col1 = this42;
            														}
            														else {
HXLINE( 176)															Float m01;
HXDLIN( 176)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 176)															if ((this43 == 0)) {
HXLINE( 176)																m01 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float m11;
HXDLIN( 176)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 176)															if ((this44 == 0)) {
HXLINE( 176)																m11 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float m21;
HXDLIN( 176)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 176)															if ((this45 == 0)) {
HXLINE( 176)																m21 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float m31;
HXDLIN( 176)															int this46 = (maskPixel1 & 255);
HXDLIN( 176)															if ((this46 == 0)) {
HXLINE( 176)																m31 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 176)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 176)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 176)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 176)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 176)													if ((col1 != 0)) {
HXLINE( 176)														int x6 = (dx1 - rectLeft1);
HXDLIN( 176)														int y6 = (dy1 - rectTop1);
HXDLIN( 176)														int c7 = col1;
HXDLIN( 176)														bool _hx_tmp9;
HXDLIN( 176)														if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 176)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXLINE( 176)															_hx_tmp9 = false;
            														}
HXDLIN( 176)														if (_hx_tmp9) {
HXLINE( 176)															int location2;
HXDLIN( 176)															if (undoImage3->useVirtualPos) {
HXLINE( 176)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 176)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 176)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 176)															int this48;
HXDLIN( 176)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXLINE( 176)																this48 = this47;
            															}
HXDLIN( 176)															Float a12;
HXDLIN( 176)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 176)															if ((this49 == 0)) {
HXLINE( 176)																a12 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float r12;
HXDLIN( 176)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 176)															if ((this50 == 0)) {
HXLINE( 176)																r12 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float g12;
HXDLIN( 176)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 176)															if ((this51 == 0)) {
HXLINE( 176)																g12 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float b13;
HXDLIN( 176)															int this52 = (this48 & 255);
HXDLIN( 176)															if ((this52 == 0)) {
HXLINE( 176)																b13 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float a22;
HXDLIN( 176)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 176)															if ((this53 == 0)) {
HXLINE( 176)																a22 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float r22;
HXDLIN( 176)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 176)															if ((this54 == 0)) {
HXLINE( 176)																r22 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float g22;
HXDLIN( 176)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 176)															if ((this55 == 0)) {
HXLINE( 176)																g22 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float b23;
HXDLIN( 176)															int this56 = (col1 & 255);
HXDLIN( 176)															if ((this56 == 0)) {
HXLINE( 176)																b23 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 176)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 176)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 176)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 176)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 176)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 176)															{
HXLINE( 176)																int _hx_tmp10;
HXDLIN( 176)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXLINE( 176)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 176)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXLINE( 176)															::Dynamic this57 = undoImage3->image;
HXDLIN( 176)															int index8;
HXDLIN( 176)															if (undoImage3->useVirtualPos) {
HXLINE( 176)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 176)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 176)															int _hx_tmp11;
HXDLIN( 176)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXLINE( 176)																_hx_tmp11 = c7;
            															}
HXDLIN( 176)															::iterMagic::Iimg_obj::set(this57,index8,_hx_tmp11);
            														}
            													}
            													else {
HXLINE( 176)														if (forceClear1) {
HXLINE( 176)															::Dynamic this58 = undoImage3->image;
HXDLIN( 176)															int x7 = (dx1 - rectLeft1);
HXDLIN( 176)															int y7 = (dy1 - rectTop1);
HXDLIN( 176)															int index9;
HXDLIN( 176)															if (undoImage3->useVirtualPos) {
HXLINE( 176)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 176)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN( 176)															::iterMagic::Iimg_obj::set(this58,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 176)							bool foundY1 = false;
HXDLIN( 176)							Float s1 = ((Float)0.);
HXDLIN( 176)							Float t1 = ((Float)0.);
HXDLIN( 176)							Float sxx1 = ((Float)0.);
HXDLIN( 176)							Float txx1 = ((Float)0.);
HXDLIN( 176)							{
HXLINE( 176)								int _g_min2 = xIter31->start;
HXDLIN( 176)								int _g_max2 = xIter31->max;
HXDLIN( 176)								while((_g_min2 < _g_max2)){
HXLINE( 176)									_g_min2 = (_g_min2 + 1);
HXDLIN( 176)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE( 176)									{
HXLINE( 176)										int _g_min3 = yIter31->start;
HXDLIN( 176)										int _g_max3 = yIter31->max;
HXDLIN( 176)										while((_g_min3 < _g_max3)){
HXLINE( 176)											_g_min3 = (_g_min3 + 1);
HXDLIN( 176)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 176)											bool _hx_tmp12;
HXDLIN( 176)											if (!((s1 <= 0))) {
HXLINE( 176)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXLINE( 176)												_hx_tmp12 = true;
            											}
HXDLIN( 176)											if (_hx_tmp12) {
HXLINE( 176)												if (foundY1) {
HXLINE( 176)													goto _hx_goto_79;
            												}
            											}
            											else {
HXLINE( 176)												if (((s1 + t1) < A1)) {
HXLINE( 176)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 176)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 176)													::Dynamic this59 = tileImage->image;
HXDLIN( 176)													int index10;
HXDLIN( 176)													if (tileImage->useVirtualPos) {
HXLINE( 176)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXLINE( 176)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN( 176)													int c8 = ::iterMagic::Iimg_obj::get(this59,index10);
HXDLIN( 176)													int color1;
HXDLIN( 176)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE( 176)														color1 = c8;
            													}
HXDLIN( 176)													{
HXLINE( 176)														int c9 = color1;
HXDLIN( 176)														bool _hx_tmp13;
HXDLIN( 176)														if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 176)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXLINE( 176)															_hx_tmp13 = false;
            														}
HXDLIN( 176)														if (_hx_tmp13) {
HXLINE( 176)															int location3;
HXDLIN( 176)															if (this36->useVirtualPos) {
HXLINE( 176)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this36->virtualY) * ( (Float)(this36->width) )) + x8) - this36->virtualX));
            															}
            															else {
HXLINE( 176)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this36->width) + x8)) ));
            															}
HXDLIN( 176)															int this60 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 176)															int this61;
HXDLIN( 176)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            															}
            															else {
HXLINE( 176)																this61 = this60;
            															}
HXDLIN( 176)															Float a13;
HXDLIN( 176)															int this62 = ((this61 >> 24) & 255);
HXDLIN( 176)															if ((this62 == 0)) {
HXLINE( 176)																a13 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																a13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float r13;
HXDLIN( 176)															int this63 = ((this61 >> 16) & 255);
HXDLIN( 176)															if ((this63 == 0)) {
HXLINE( 176)																r13 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																r13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float g13;
HXDLIN( 176)															int this64 = ((this61 >> 8) & 255);
HXDLIN( 176)															if ((this64 == 0)) {
HXLINE( 176)																g13 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																g13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float b14;
HXDLIN( 176)															int this65 = (this61 & 255);
HXDLIN( 176)															if ((this65 == 0)) {
HXLINE( 176)																b14 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float a23;
HXDLIN( 176)															int this66 = ((color1 >> 24) & 255);
HXDLIN( 176)															if ((this66 == 0)) {
HXLINE( 176)																a23 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																a23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float r23;
HXDLIN( 176)															int this67 = ((color1 >> 16) & 255);
HXDLIN( 176)															if ((this67 == 0)) {
HXLINE( 176)																r23 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																r23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float g23;
HXDLIN( 176)															int this68 = ((color1 >> 8) & 255);
HXDLIN( 176)															if ((this68 == 0)) {
HXLINE( 176)																g23 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																g23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float b24;
HXDLIN( 176)															int this69 = (color1 & 255);
HXDLIN( 176)															if ((this69 == 0)) {
HXLINE( 176)																b24 = ((Float)0.);
            															}
            															else {
HXLINE( 176)																b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN( 176)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 176)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 176)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 176)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 176)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 176)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 176)															{
HXLINE( 176)																int _hx_tmp14;
HXDLIN( 176)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE( 176)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 176)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXLINE( 176)															::Dynamic this70 = this36->image;
HXDLIN( 176)															int index11;
HXDLIN( 176)															if (this36->useVirtualPos) {
HXLINE( 176)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this36->virtualY) * ( (Float)(this36->width) )) + x8) - this36->virtualX));
            															}
            															else {
HXLINE( 176)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this36->width) + x8)) ));
            															}
HXDLIN( 176)															int _hx_tmp15;
HXDLIN( 176)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXLINE( 176)																_hx_tmp15 = c9;
            															}
HXDLIN( 176)															::iterMagic::Iimg_obj::set(this70,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXLINE( 176)													if (foundY1) {
HXLINE( 176)														goto _hx_goto_79;
            													}
            												}
            											}
            										}
            										_hx_goto_79:;
            									}
            								}
            							}
HXDLIN( 176)							if ((hasHit1 == false)) {
HXLINE( 176)								 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 176)								if (hasUndo1) {
HXLINE( 176)									v6->undoImage = undoImage3;
HXDLIN( 176)									v6->undoX = xIter31->start;
HXDLIN( 176)									v6->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE( 177)				lastX = nextX1;
HXLINE( 178)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(PolyPixel_Fields__obj,tilePolygonBuild,(void))

void PolyPixel_Fields__obj::fillRadialPolyBuild( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry,int colorIn,int colorOut, ::Dynamic __o_gx, ::Dynamic __o_gy, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic gx = __o_gx;
            		if (::hx::IsNull(__o_gx)) gx = 0;
            		 ::Dynamic gy = __o_gy;
            		if (::hx::IsNull(__o_gy)) gy = 0;
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_87ef2d4220a4cd37_192_fillRadialPolyBuild)
HXLINE( 193)		if (::hx::IsLess( gx,((Float)-1.) )) {
HXLINE( 193)			gx = -1;
            		}
HXLINE( 194)		if (::hx::IsGreater( gx,((Float)1.) )) {
HXLINE( 194)			gx = 1;
            		}
HXLINE( 195)		if (::hx::IsLess( gy,((Float)-1.) )) {
HXLINE( 195)			gy = ((Float)-1.);
            		}
HXLINE( 196)		if (::hx::IsGreater( gy,((Float)1.) )) {
HXLINE( 196)			gy = 1;
            		}
HXLINE( 198)		Float mx = (cx + (( (Float)(gx) ) * rx));
HXLINE( 199)		Float my = (cy + (( (Float)(gy) ) * ry));
HXLINE( 200)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE( 201)		Float omega;
HXDLIN( 201)		if (cornerUp) {
HXLINE( 201)			omega = ((Float)0.);
            		}
            		else {
HXLINE( 205)			if ((::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(2) ))) == (( (Float)(sides) ) / ( (Float)(2) )))) {
HXLINE( 201)				omega = (::Math_obj::PI / ( (Float)(sides) ));
            			}
            			else {
HXLINE( 208)				Float v = ((( (Float)(sides) ) / ( (Float)(2) )) - ((Float)0.5));
HXLINE( 209)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXLINE( 201)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) )) - ::Math_obj::PI);
            				}
            				else {
HXLINE( 201)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides) ));
            				}
            			}
            		}
HXLINE( 218)		Float lastX = ((Float)0.);
HXLINE( 219)		Float lastY = ((Float)0.);
HXLINE( 220)		if (::hx::IsNotEq( phi,0 )) {
HXLINE( 221)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE( 222)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE( 224)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE( 225)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 227)		if (::hx::IsNotEq( phi,0 )) {
HXLINE( 228)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE( 229)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE( 230)			{
HXLINE( 230)				int _g = 0;
HXDLIN( 230)				int _g1 = (sides + 1);
HXDLIN( 230)				while((_g < _g1)){
HXLINE( 230)					_g = (_g + 1);
HXDLIN( 230)					int i = (_g - 1);
HXLINE( 231)					Float stheta = ::Math_obj::sin(((( (Float)(i) ) * theta) + omega));
HXLINE( 232)					Float ctheta = ::Math_obj::cos(((( (Float)(i) ) * theta) + omega));
HXLINE( 233)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE( 234)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE( 235)					{
HXLINE( 235)						 ::pi_xy::ImageStruct this1 = pixelimage;
HXDLIN( 235)						{
HXLINE( 235)							bool hasHit = false;
HXDLIN( 235)							bool hasUndo = false;
HXDLIN( 235)							int aA = ((colorOut >> 24) & 255);
HXDLIN( 235)							int rA = ((colorOut >> 16) & 255);
HXDLIN( 235)							int gA = ((colorOut >> 8) & 255);
HXDLIN( 235)							int bA = (colorOut & 255);
HXDLIN( 235)							int aB = ((colorIn >> 24) & 255);
HXDLIN( 235)							int rB = ((colorIn >> 16) & 255);
HXDLIN( 235)							int gB = ((colorIn >> 8) & 255);
HXDLIN( 235)							int bB = (colorIn & 255);
HXDLIN( 235)							int aC = ((colorOut >> 24) & 255);
HXDLIN( 235)							int rC = ((colorOut >> 16) & 255);
HXDLIN( 235)							int gC = ((colorOut >> 8) & 255);
HXDLIN( 235)							int bC = (colorOut & 255);
HXDLIN( 235)							Float bcx = (lastX - nextX);
HXDLIN( 235)							Float bcy = (lastY - nextY);
HXDLIN( 235)							Float acx = (mx - nextX);
HXDLIN( 235)							Float acy = (my - nextY);
HXDLIN( 235)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 235)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 235)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 235)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 235)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 235)							if ((mx > lastX)) {
HXLINE( 235)								if ((mx > nextX)) {
HXLINE( 235)									int min;
HXDLIN( 235)									if ((lastX > nextX)) {
HXLINE( 235)										min = ::Math_obj::floor(nextX);
            									}
            									else {
HXLINE( 235)										min = ::Math_obj::floor(lastX);
            									}
HXDLIN( 235)									int ii_min = min;
HXDLIN( 235)									int ii_max = ::Math_obj::ceil(mx);
HXDLIN( 235)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            								}
            								else {
HXLINE( 235)									int ii_min1 = ::Math_obj::floor(lastX);
HXDLIN( 235)									int ii_max1 = ::Math_obj::ceil(nextX);
HXDLIN( 235)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            								}
            							}
            							else {
HXLINE( 235)								if ((lastX > nextX)) {
HXLINE( 235)									int min1;
HXDLIN( 235)									if ((mx > nextX)) {
HXLINE( 235)										min1 = ::Math_obj::floor(nextX);
            									}
            									else {
HXLINE( 235)										min1 = ::Math_obj::ceil(mx);
            									}
HXDLIN( 235)									int ii_min2 = min1;
HXDLIN( 235)									int ii_max2 = ::Math_obj::ceil(lastX);
HXDLIN( 235)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            								}
            								else {
HXLINE( 235)									int ii_min3 = ::Math_obj::floor(mx);
HXDLIN( 235)									int ii_max3 = ::Math_obj::ceil(nextX);
HXDLIN( 235)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            								}
            							}
HXDLIN( 235)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 235)							if ((my > lastY)) {
HXLINE( 235)								if ((my > nextY)) {
HXLINE( 235)									int min2;
HXDLIN( 235)									if ((lastY > nextY)) {
HXLINE( 235)										min2 = ::Math_obj::floor(nextY);
            									}
            									else {
HXLINE( 235)										min2 = ::Math_obj::floor(lastY);
            									}
HXDLIN( 235)									int ii_min4 = min2;
HXDLIN( 235)									int ii_max4 = ::Math_obj::ceil(my);
HXDLIN( 235)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            								}
            								else {
HXLINE( 235)									int ii_min5 = ::Math_obj::floor(lastY);
HXDLIN( 235)									int ii_max5 = ::Math_obj::ceil(nextY);
HXDLIN( 235)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            								}
            							}
            							else {
HXLINE( 235)								if ((lastY > nextY)) {
HXLINE( 235)									int min3;
HXDLIN( 235)									if ((my > nextY)) {
HXLINE( 235)										min3 = ::Math_obj::floor(nextY);
            									}
            									else {
HXLINE( 235)										min3 = ::Math_obj::ceil(my);
            									}
HXDLIN( 235)									int ii_min6 = min3;
HXDLIN( 235)									int ii_max6 = ::Math_obj::ceil(lastY);
HXDLIN( 235)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            								}
            								else {
HXLINE( 235)									int ii_min7 = ::Math_obj::floor(my);
HXDLIN( 235)									int ii_max7 = ::Math_obj::ceil(nextY);
HXDLIN( 235)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            								}
            							}
HXDLIN( 235)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 235)							if (hasUndo) {
HXLINE( 235)								int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 235)								int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 235)								 ::Dynamic imageType = null();
HXDLIN( 235)								 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)								if (::hx::IsNull( imageType )) {
HXLINE(  54)									imageType = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 235)								::Dynamic undoImage1;
HXDLIN( 235)								switch((int)(( (int)(imageType) ))){
            									case (int)0: {
HXLINE( 235)										 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)										 ::iterMagic::BytesImg b = byt;
HXDLIN( 235)										{
HXLINE( 235)											b->width = width;
HXDLIN( 235)											b->height = height;
HXDLIN( 235)											b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)											b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 235)											{
HXLINE( 235)												int len = b->length;
HXDLIN( 235)												int w = 0;
HXDLIN( 235)												{
HXLINE( 235)													int _g2 = 0;
HXDLIN( 235)													int _g3 = b->height;
HXDLIN( 235)													while((_g2 < _g3)){
HXLINE( 235)														_g2 = (_g2 + 1);
HXDLIN( 235)														int y = (_g2 - 1);
HXDLIN( 235)														{
HXLINE( 235)															int _g4 = 0;
HXDLIN( 235)															int _g5 = b->width;
HXDLIN( 235)															while((_g4 < _g5)){
HXLINE( 235)																_g4 = (_g4 + 1);
HXDLIN( 235)																int x = (_g4 - 1);
HXDLIN( 235)																{
HXLINE( 235)																	w = (w + 1);
HXDLIN( 235)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 235)																{
HXLINE( 235)																	w = (w + 1);
HXDLIN( 235)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 235)																{
HXLINE( 235)																	w = (w + 1);
HXDLIN( 235)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 235)																{
HXLINE( 235)																	w = (w + 1);
HXDLIN( 235)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 235)										undoImage1 = b;
            									}
            									break;
            									case (int)1: {
HXLINE( 235)										 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)										 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 235)										{
HXLINE( 235)											a->width = width;
HXDLIN( 235)											a->height = height;
HXDLIN( 235)											a->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)											a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)											{
HXLINE( 235)												int _g6 = 0;
HXDLIN( 235)												int _g7 = a->length;
HXDLIN( 235)												while((_g6 < _g7)){
HXLINE( 235)													_g6 = (_g6 + 1);
HXDLIN( 235)													int i1 = (_g6 - 1);
HXDLIN( 235)													a->data[i1] = 0;
            												}
            											}
            										}
HXDLIN( 235)										undoImage1 = a;
            									}
            									break;
            									case (int)2: {
HXLINE( 235)										 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)										 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 235)										{
HXLINE( 235)											b1->width = width;
HXDLIN( 235)											b1->height = height;
HXDLIN( 235)											b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)											int size = (b1->length * 4);
HXDLIN( 235)											b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 235)											{
HXLINE( 235)												int _g8 = 0;
HXDLIN( 235)												int _g9 = b1->length;
HXDLIN( 235)												while((_g8 < _g9)){
HXLINE( 235)													_g8 = (_g8 + 1);
HXDLIN( 235)													int i2 = (_g8 - 1);
HXDLIN( 235)													{
HXLINE( 235)														 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 235)														bool undoImage2;
HXDLIN( 235)														if ((i2 >= 0)) {
HXLINE( 235)															undoImage2 = (i2 < (this3->byteLength >> 2));
            														}
            														else {
HXLINE( 235)															undoImage2 = false;
            														}
HXDLIN( 235)														if (undoImage2) {
HXLINE( 235)															 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 235)															int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN( 235)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 235)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 235)										undoImage1 = b1;
            									}
            									break;
            									case (int)3: {
HXLINE( 235)										 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)										 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 235)										{
HXLINE( 235)											v1->width = width;
HXDLIN( 235)											v1->height = height;
HXDLIN( 235)											v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)											v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 235)											{
HXLINE( 235)												int _g10 = 0;
HXDLIN( 235)												int _g11 = v1->length;
HXDLIN( 235)												while((_g10 < _g11)){
HXLINE( 235)													_g10 = (_g10 + 1);
HXDLIN( 235)													int i3 = (_g10 - 1);
HXDLIN( 235)													v1->data->__unsafe_set(i3,0);
            												}
            											}
            										}
HXDLIN( 235)										undoImage1 = v1;
            									}
            									break;
            									case (int)4: {
HXLINE( 235)										 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)										 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 235)										{
HXLINE( 235)											b2->width = width;
HXDLIN( 235)											b2->height = height;
HXDLIN( 235)											b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)											b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)											{
HXLINE( 235)												int len1 = b2->length;
HXDLIN( 235)												 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 235)												if (::hx::IsNull( d->head )) {
HXLINE( 235)													int _g12 = 0;
HXDLIN( 235)													int _g13 = len1;
HXDLIN( 235)													while((_g12 < _g13)){
HXLINE( 235)														_g12 = (_g12 + 1);
HXDLIN( 235)														int i4 = (_g12 - 1);
HXDLIN( 235)														d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            													}
            												}
            												else {
HXLINE( 235)													int _g14 = 0;
HXDLIN( 235)													int _g15 = len1;
HXDLIN( 235)													while((_g14 < _g15)){
HXLINE( 235)														_g14 = (_g14 + 1);
HXDLIN( 235)														int i5 = (_g14 - 1);
HXDLIN( 235)														{
HXLINE( 235)															 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 235)															 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 235)															{
HXLINE( 235)																int _g16 = 0;
HXDLIN( 235)																int _g17 = i5;
HXDLIN( 235)																while((_g16 < _g17)){
HXLINE( 235)																	_g16 = (_g16 + 1);
HXDLIN( 235)																	int i6 = (_g16 - 1);
HXLINE( 345)																	prev = l;
HXLINE( 346)																	l = l->next;
            																}
            															}
HXLINE( 235)															if (::hx::IsNull( prev )) {
HXLINE( 235)																b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)																l = null();
            															}
            															else {
HXLINE( 235)																prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)																l = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 235)										undoImage1 = b2;
            									}
            									break;
            								}
HXDLIN( 235)								this2->image = undoImage1;
HXDLIN( 235)								this2->width = width;
HXDLIN( 235)								this2->height = height;
HXDLIN( 235)								this2->imageType = ( (int)(imageType) );
HXDLIN( 235)								undoImage = this2;
HXDLIN( 235)								{
HXLINE( 235)									int rectLeft = xIter3->start;
HXDLIN( 235)									int rectTop = yIter3->start;
HXDLIN( 235)									int rectRight = xIter3->max;
HXDLIN( 235)									bool forceClear = false;
HXDLIN( 235)									{
HXLINE( 235)										int _g18 = rectTop;
HXDLIN( 235)										int _g19 = yIter3->max;
HXDLIN( 235)										while((_g18 < _g19)){
HXLINE( 235)											_g18 = (_g18 + 1);
HXDLIN( 235)											int dy = (_g18 - 1);
HXDLIN( 235)											{
HXLINE( 235)												int _g20 = rectLeft;
HXDLIN( 235)												int _g21 = rectRight;
HXDLIN( 235)												while((_g20 < _g21)){
HXLINE( 235)													_g20 = (_g20 + 1);
HXDLIN( 235)													int dx = (_g20 - 1);
HXDLIN( 235)													::Dynamic this4 = this1->image;
HXDLIN( 235)													int index;
HXDLIN( 235)													if (this1->useVirtualPos) {
HXLINE( 235)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 235)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 235)													int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 235)													int col;
HXDLIN( 235)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 235)														col = c;
            													}
HXDLIN( 235)													bool _hx_tmp;
HXDLIN( 235)													if (this1->useMask) {
HXLINE( 235)														_hx_tmp = ::hx::IsNotNull( this1->mask );
            													}
            													else {
HXLINE( 235)														_hx_tmp = false;
            													}
HXDLIN( 235)													if (_hx_tmp) {
HXLINE( 235)														 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 235)														::Dynamic this6 = this5->image;
HXDLIN( 235)														int index1;
HXDLIN( 235)														if (this5->useVirtualPos) {
HXLINE( 235)															index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            														}
            														else {
HXLINE( 235)															index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            														}
HXDLIN( 235)														int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 235)														int v2;
HXDLIN( 235)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)															v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 235)															v2 = c1;
            														}
HXDLIN( 235)														int maskPixel = v2;
HXDLIN( 235)														int this7 = col;
HXDLIN( 235)														if ((maskPixel == 0)) {
HXLINE( 235)															col = this7;
            														}
            														else {
HXLINE( 235)															Float m0;
HXDLIN( 235)															int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 235)															if ((this8 == 0)) {
HXLINE( 235)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float m1;
HXDLIN( 235)															int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 235)															if ((this9 == 0)) {
HXLINE( 235)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float m2;
HXDLIN( 235)															int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 235)															if ((this10 == 0)) {
HXLINE( 235)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float m3;
HXDLIN( 235)															int this11 = (maskPixel & 255);
HXDLIN( 235)															if ((this11 == 0)) {
HXLINE( 235)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 235)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 235)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 235)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 235)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 235)													if ((col != 0)) {
HXLINE( 235)														int x1 = (dx - rectLeft);
HXDLIN( 235)														int y1 = (dy - rectTop);
HXDLIN( 235)														int c2 = col;
HXDLIN( 235)														bool _hx_tmp1;
HXDLIN( 235)														if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 235)															_hx_tmp1 = undoImage->transparent;
            														}
            														else {
HXLINE( 235)															_hx_tmp1 = false;
            														}
HXDLIN( 235)														if (_hx_tmp1) {
HXLINE( 235)															int location;
HXDLIN( 235)															if (undoImage->useVirtualPos) {
HXLINE( 235)																location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            															}
            															else {
HXLINE( 235)																location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            															}
HXDLIN( 235)															int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 235)															int this13;
HXDLIN( 235)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)																this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            															}
            															else {
HXLINE( 235)																this13 = this12;
            															}
HXDLIN( 235)															Float a1;
HXDLIN( 235)															int this14 = ((this13 >> 24) & 255);
HXDLIN( 235)															if ((this14 == 0)) {
HXLINE( 235)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float r1;
HXDLIN( 235)															int this15 = ((this13 >> 16) & 255);
HXDLIN( 235)															if ((this15 == 0)) {
HXLINE( 235)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float g1;
HXDLIN( 235)															int this16 = ((this13 >> 8) & 255);
HXDLIN( 235)															if ((this16 == 0)) {
HXLINE( 235)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float b11;
HXDLIN( 235)															int this17 = (this13 & 255);
HXDLIN( 235)															if ((this17 == 0)) {
HXLINE( 235)																b11 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float a2;
HXDLIN( 235)															int this18 = ((col >> 24) & 255);
HXDLIN( 235)															if ((this18 == 0)) {
HXLINE( 235)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float r2;
HXDLIN( 235)															int this19 = ((col >> 16) & 255);
HXDLIN( 235)															if ((this19 == 0)) {
HXLINE( 235)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float g2;
HXDLIN( 235)															int this20 = ((col >> 8) & 255);
HXDLIN( 235)															if ((this20 == 0)) {
HXLINE( 235)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float b21;
HXDLIN( 235)															int this21 = (col & 255);
HXDLIN( 235)															if ((this21 == 0)) {
HXLINE( 235)																b21 = ((Float)0.);
            															}
            															else {
HXLINE( 235)																b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            															}
HXDLIN( 235)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 235)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 235)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 235)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 235)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 235)															int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 235)															{
HXLINE( 235)																int _hx_tmp2;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)																	_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 235)																	_hx_tmp2 = blended;
            																}
HXDLIN( 235)																::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            															}
            														}
            														else {
HXLINE( 235)															::Dynamic this22 = undoImage->image;
HXDLIN( 235)															int index2;
HXDLIN( 235)															if (undoImage->useVirtualPos) {
HXLINE( 235)																index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            															}
            															else {
HXLINE( 235)																index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            															}
HXDLIN( 235)															int _hx_tmp3;
HXDLIN( 235)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)																_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            															}
            															else {
HXLINE( 235)																_hx_tmp3 = c2;
            															}
HXDLIN( 235)															::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            														}
            													}
            													else {
HXLINE( 235)														if (forceClear) {
HXLINE( 235)															::Dynamic this23 = undoImage->image;
HXDLIN( 235)															int x2 = (dx - rectLeft);
HXDLIN( 235)															int y2 = (dy - rectTop);
HXDLIN( 235)															int index3;
HXDLIN( 235)															if (undoImage->useVirtualPos) {
HXLINE( 235)																index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            															}
            															else {
HXLINE( 235)																index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            															}
HXDLIN( 235)															::iterMagic::Iimg_obj::set(this23,index3,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 235)							{
HXLINE( 235)								int _g_min = xIter3->start;
HXDLIN( 235)								int _g_max = xIter3->max;
HXDLIN( 235)								while((_g_min < _g_max)){
HXLINE( 235)									_g_min = (_g_min + 1);
HXDLIN( 235)									int px = (_g_min - 1);
HXDLIN( 235)									Float pcx = (( (Float)(px) ) - nextX);
HXDLIN( 235)									{
HXLINE( 235)										int _g_min1 = yIter3->start;
HXDLIN( 235)										int _g_max1 = yIter3->max;
HXDLIN( 235)										while((_g_min1 < _g_max1)){
HXLINE( 235)											_g_min1 = (_g_min1 + 1);
HXDLIN( 235)											int py = (_g_min1 - 1);
HXDLIN( 235)											Float pcy = (( (Float)(py) ) - nextY);
HXDLIN( 235)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 235)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 235)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 235)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 235)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 235)											bool _hx_tmp4;
HXDLIN( 235)											bool _hx_tmp5;
HXDLIN( 235)											if ((ratioA >= 0)) {
HXLINE( 235)												_hx_tmp5 = (ratioB >= 0);
            											}
            											else {
HXLINE( 235)												_hx_tmp5 = false;
            											}
HXDLIN( 235)											if (_hx_tmp5) {
HXLINE( 235)												_hx_tmp4 = (ratioC >= 0);
            											}
            											else {
HXLINE( 235)												_hx_tmp4 = false;
            											}
HXDLIN( 235)											if (_hx_tmp4) {
HXLINE( 235)												int i7 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 235)												if ((i7 > 255)) {
HXLINE(  24)													i7 = 255;
            												}
HXLINE( 235)												if ((i7 < 0)) {
HXLINE(  25)													i7 = 0;
            												}
HXLINE( 235)												int a5 = i7;
HXDLIN( 235)												int i8 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 235)												if ((i8 > 255)) {
HXLINE(  24)													i8 = 255;
            												}
HXLINE( 235)												if ((i8 < 0)) {
HXLINE(  25)													i8 = 0;
            												}
HXLINE( 235)												int r3 = i8;
HXDLIN( 235)												int i9 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 235)												if ((i9 > 255)) {
HXLINE(  24)													i9 = 255;
            												}
HXLINE( 235)												if ((i9 < 0)) {
HXLINE(  25)													i9 = 0;
            												}
HXLINE( 235)												int g3 = i9;
HXDLIN( 235)												int i10 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 235)												if ((i10 > 255)) {
HXLINE(  24)													i10 = 255;
            												}
HXLINE( 235)												if ((i10 < 0)) {
HXLINE(  25)													i10 = 0;
            												}
HXLINE( 235)												int b4 = i10;
HXDLIN( 235)												{
HXLINE( 235)													int location1;
HXDLIN( 235)													if (this1->useVirtualPos) {
HXLINE( 235)														location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            													}
            													else {
HXLINE( 235)														location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            													}
HXDLIN( 235)													bool _hx_tmp6;
HXDLIN( 235)													if (this1->transparent) {
HXLINE( 235)														_hx_tmp6 = (a5 < 254);
            													}
            													else {
HXLINE( 235)														_hx_tmp6 = false;
            													}
HXDLIN( 235)													if (_hx_tmp6) {
HXLINE( 235)														int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 235)														int old;
HXDLIN( 235)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)															old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            														}
            														else {
HXLINE( 235)															old = this24;
            														}
HXDLIN( 235)														int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 235)														Float a11;
HXDLIN( 235)														int this25 = ((old >> 24) & 255);
HXDLIN( 235)														if ((this25 == 0)) {
HXLINE( 235)															a11 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float r11;
HXDLIN( 235)														int this26 = ((old >> 16) & 255);
HXDLIN( 235)														if ((this26 == 0)) {
HXLINE( 235)															r11 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float g11;
HXDLIN( 235)														int this27 = ((old >> 8) & 255);
HXDLIN( 235)														if ((this27 == 0)) {
HXLINE( 235)															g11 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float b12;
HXDLIN( 235)														int this28 = (old & 255);
HXDLIN( 235)														if ((this28 == 0)) {
HXLINE( 235)															b12 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float a21;
HXDLIN( 235)														int this29 = ((rhs >> 24) & 255);
HXDLIN( 235)														if ((this29 == 0)) {
HXLINE( 235)															a21 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float r21;
HXDLIN( 235)														int this30 = ((rhs >> 16) & 255);
HXDLIN( 235)														if ((this30 == 0)) {
HXLINE( 235)															r21 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float g21;
HXDLIN( 235)														int this31 = ((rhs >> 8) & 255);
HXDLIN( 235)														if ((this31 == 0)) {
HXLINE( 235)															g21 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float b22;
HXDLIN( 235)														int this32 = (rhs & 255);
HXDLIN( 235)														if ((this32 == 0)) {
HXLINE( 235)															b22 = ((Float)0.);
            														}
            														else {
HXLINE( 235)															b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN( 235)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 235)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 235)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 235)														int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 235)														int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 235)														int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 235)														{
HXLINE( 235)															int _hx_tmp7;
HXDLIN( 235)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)																_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE( 235)																_hx_tmp7 = blended1;
            															}
HXDLIN( 235)															::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            														}
            													}
            													else {
HXLINE( 235)														int value;
HXDLIN( 235)														if (this1->isLittle) {
HXLINE( 235)															value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            														}
            														else {
HXLINE( 235)															value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            														}
HXDLIN( 235)														::iterMagic::Iimg_obj::set(this1->image,location1,value);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 235)							if ((hasHit == false)) {
HXLINE( 235)								 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN( 235)								if (hasUndo) {
HXLINE( 235)									v3->undoImage = undoImage;
HXDLIN( 235)									v3->undoX = xIter3->start;
HXDLIN( 235)									v3->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXLINE( 236)					lastX = nextX;
HXLINE( 237)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE( 240)			int _g22 = 0;
HXDLIN( 240)			int _g23 = (sides + 1);
HXDLIN( 240)			while((_g22 < _g23)){
HXLINE( 240)				_g22 = (_g22 + 1);
HXDLIN( 240)				int i11 = (_g22 - 1);
HXLINE( 241)				Float nextX1 = (cx + (rx * ::Math_obj::cos(((( (Float)(i11) ) * theta) + omega))));
HXLINE( 242)				Float nextY1 = (cy + (ry * ::Math_obj::sin(((( (Float)(i11) ) * theta) + omega))));
HXLINE( 243)				{
HXLINE( 243)					 ::pi_xy::ImageStruct this33 = pixelimage;
HXDLIN( 243)					{
HXLINE( 243)						bool hasHit1 = false;
HXDLIN( 243)						bool hasUndo1 = false;
HXDLIN( 243)						int aA1 = ((colorOut >> 24) & 255);
HXDLIN( 243)						int rA1 = ((colorOut >> 16) & 255);
HXDLIN( 243)						int gA1 = ((colorOut >> 8) & 255);
HXDLIN( 243)						int bA1 = (colorOut & 255);
HXDLIN( 243)						int aB1 = ((colorIn >> 24) & 255);
HXDLIN( 243)						int rB1 = ((colorIn >> 16) & 255);
HXDLIN( 243)						int gB1 = ((colorIn >> 8) & 255);
HXDLIN( 243)						int bB1 = (colorIn & 255);
HXDLIN( 243)						int aC1 = ((colorOut >> 24) & 255);
HXDLIN( 243)						int rC1 = ((colorOut >> 16) & 255);
HXDLIN( 243)						int gC1 = ((colorOut >> 8) & 255);
HXDLIN( 243)						int bC1 = (colorOut & 255);
HXDLIN( 243)						Float bcx1 = (lastX - nextX1);
HXDLIN( 243)						Float bcy1 = (lastY - nextY1);
HXDLIN( 243)						Float acx1 = (mx - nextX1);
HXDLIN( 243)						Float acy1 = (my - nextY1);
HXDLIN( 243)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 243)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 243)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 243)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 243)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 243)						if ((mx > lastX)) {
HXLINE( 243)							if ((mx > nextX1)) {
HXLINE( 243)								int min4;
HXDLIN( 243)								if ((lastX > nextX1)) {
HXLINE( 243)									min4 = ::Math_obj::floor(nextX1);
            								}
            								else {
HXLINE( 243)									min4 = ::Math_obj::floor(lastX);
            								}
HXDLIN( 243)								int ii_min8 = min4;
HXDLIN( 243)								int ii_max8 = ::Math_obj::ceil(mx);
HXDLIN( 243)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE( 243)								int ii_min9 = ::Math_obj::floor(lastX);
HXDLIN( 243)								int ii_max9 = ::Math_obj::ceil(nextX1);
HXDLIN( 243)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXLINE( 243)							if ((lastX > nextX1)) {
HXLINE( 243)								int min5;
HXDLIN( 243)								if ((mx > nextX1)) {
HXLINE( 243)									min5 = ::Math_obj::floor(nextX1);
            								}
            								else {
HXLINE( 243)									min5 = ::Math_obj::ceil(mx);
            								}
HXDLIN( 243)								int ii_min10 = min5;
HXDLIN( 243)								int ii_max10 = ::Math_obj::ceil(lastX);
HXDLIN( 243)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE( 243)								int ii_min11 = ::Math_obj::floor(mx);
HXDLIN( 243)								int ii_max11 = ::Math_obj::ceil(nextX1);
HXDLIN( 243)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN( 243)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 243)						if ((my > lastY)) {
HXLINE( 243)							if ((my > nextY1)) {
HXLINE( 243)								int min6;
HXDLIN( 243)								if ((lastY > nextY1)) {
HXLINE( 243)									min6 = ::Math_obj::floor(nextY1);
            								}
            								else {
HXLINE( 243)									min6 = ::Math_obj::floor(lastY);
            								}
HXDLIN( 243)								int ii_min12 = min6;
HXDLIN( 243)								int ii_max12 = ::Math_obj::ceil(my);
HXDLIN( 243)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE( 243)								int ii_min13 = ::Math_obj::floor(lastY);
HXDLIN( 243)								int ii_max13 = ::Math_obj::ceil(nextY1);
HXDLIN( 243)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXLINE( 243)							if ((lastY > nextY1)) {
HXLINE( 243)								int min7;
HXDLIN( 243)								if ((my > nextY1)) {
HXLINE( 243)									min7 = ::Math_obj::floor(nextY1);
            								}
            								else {
HXLINE( 243)									min7 = ::Math_obj::ceil(my);
            								}
HXDLIN( 243)								int ii_min14 = min7;
HXDLIN( 243)								int ii_max14 = ::Math_obj::ceil(lastY);
HXDLIN( 243)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE( 243)								int ii_min15 = ::Math_obj::floor(my);
HXDLIN( 243)								int ii_max15 = ::Math_obj::ceil(nextY1);
HXDLIN( 243)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
HXDLIN( 243)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 243)						if (hasUndo1) {
HXLINE( 243)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 243)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 243)							 ::Dynamic imageType1 = null();
HXDLIN( 243)							 ::pi_xy::ImageStruct this34 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 243)							if (::hx::IsNull( imageType1 )) {
HXLINE(  54)								imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 243)							::Dynamic undoImage4;
HXDLIN( 243)							switch((int)(( (int)(imageType1) ))){
            								case (int)0: {
HXLINE( 243)									 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 243)									 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 243)									{
HXLINE( 243)										b6->width = width1;
HXDLIN( 243)										b6->height = height1;
HXDLIN( 243)										b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 243)										b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 243)										{
HXLINE( 243)											int len2 = b6->length;
HXDLIN( 243)											int w1 = 0;
HXDLIN( 243)											{
HXLINE( 243)												int _g24 = 0;
HXDLIN( 243)												int _g25 = b6->height;
HXDLIN( 243)												while((_g24 < _g25)){
HXLINE( 243)													_g24 = (_g24 + 1);
HXDLIN( 243)													int y3 = (_g24 - 1);
HXDLIN( 243)													{
HXLINE( 243)														int _g26 = 0;
HXDLIN( 243)														int _g27 = b6->width;
HXDLIN( 243)														while((_g26 < _g27)){
HXLINE( 243)															_g26 = (_g26 + 1);
HXDLIN( 243)															int x3 = (_g26 - 1);
HXDLIN( 243)															{
HXLINE( 243)																w1 = (w1 + 1);
HXDLIN( 243)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 243)															{
HXLINE( 243)																w1 = (w1 + 1);
HXDLIN( 243)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 243)															{
HXLINE( 243)																w1 = (w1 + 1);
HXDLIN( 243)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 243)															{
HXLINE( 243)																w1 = (w1 + 1);
HXDLIN( 243)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 243)									undoImage4 = b6;
            								}
            								break;
            								case (int)1: {
HXLINE( 243)									 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 243)									 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 243)									{
HXLINE( 243)										a7->width = width1;
HXDLIN( 243)										a7->height = height1;
HXDLIN( 243)										a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 243)										a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 243)										{
HXLINE( 243)											int _g28 = 0;
HXDLIN( 243)											int _g29 = a7->length;
HXDLIN( 243)											while((_g28 < _g29)){
HXLINE( 243)												_g28 = (_g28 + 1);
HXDLIN( 243)												int i12 = (_g28 - 1);
HXDLIN( 243)												a7->data[i12] = 0;
            											}
            										}
            									}
HXDLIN( 243)									undoImage4 = a7;
            								}
            								break;
            								case (int)2: {
HXLINE( 243)									 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 243)									 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 243)									{
HXLINE( 243)										b7->width = width1;
HXDLIN( 243)										b7->height = height1;
HXDLIN( 243)										b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 243)										int size1 = (b7->length * 4);
HXDLIN( 243)										b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 243)										{
HXLINE( 243)											int _g30 = 0;
HXDLIN( 243)											int _g31 = b7->length;
HXDLIN( 243)											while((_g30 < _g31)){
HXLINE( 243)												_g30 = (_g30 + 1);
HXDLIN( 243)												int i13 = (_g30 - 1);
HXDLIN( 243)												{
HXLINE( 243)													 ::haxe::io::ArrayBufferViewImpl this35 = b7->data;
HXDLIN( 243)													bool undoImage5;
HXDLIN( 243)													if ((i13 >= 0)) {
HXLINE( 243)														undoImage5 = (i13 < (this35->byteLength >> 2));
            													}
            													else {
HXLINE( 243)														undoImage5 = false;
            													}
HXDLIN( 243)													if (undoImage5) {
HXLINE( 243)														 ::haxe::io::Bytes _this1 = this35->bytes;
HXDLIN( 243)														int pos1 = ((i13 << 2) + this35->byteOffset);
HXDLIN( 243)														_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 243)														_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 243)														_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 243)														_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 243)									undoImage4 = b7;
            								}
            								break;
            								case (int)3: {
HXLINE( 243)									 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 243)									 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 243)									{
HXLINE( 243)										v4->width = width1;
HXDLIN( 243)										v4->height = height1;
HXDLIN( 243)										v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 243)										v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 243)										{
HXLINE( 243)											int _g32 = 0;
HXDLIN( 243)											int _g33 = v4->length;
HXDLIN( 243)											while((_g32 < _g33)){
HXLINE( 243)												_g32 = (_g32 + 1);
HXDLIN( 243)												int i14 = (_g32 - 1);
HXDLIN( 243)												v4->data->__unsafe_set(i14,0);
            											}
            										}
            									}
HXDLIN( 243)									undoImage4 = v4;
            								}
            								break;
            								case (int)4: {
HXLINE( 243)									 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 243)									 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 243)									{
HXLINE( 243)										b8->width = width1;
HXDLIN( 243)										b8->height = height1;
HXDLIN( 243)										b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 243)										b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 243)										{
HXLINE( 243)											int len3 = b8->length;
HXDLIN( 243)											 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 243)											if (::hx::IsNull( d1->head )) {
HXLINE( 243)												int _g34 = 0;
HXDLIN( 243)												int _g35 = len3;
HXDLIN( 243)												while((_g34 < _g35)){
HXLINE( 243)													_g34 = (_g34 + 1);
HXDLIN( 243)													int i15 = (_g34 - 1);
HXDLIN( 243)													d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            												}
            											}
            											else {
HXLINE( 243)												int _g36 = 0;
HXDLIN( 243)												int _g37 = len3;
HXDLIN( 243)												while((_g36 < _g37)){
HXLINE( 243)													_g36 = (_g36 + 1);
HXDLIN( 243)													int i16 = (_g36 - 1);
HXDLIN( 243)													{
HXLINE( 243)														 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 243)														 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 243)														{
HXLINE( 243)															int _g38 = 0;
HXDLIN( 243)															int _g39 = i16;
HXDLIN( 243)															while((_g38 < _g39)){
HXLINE( 243)																_g38 = (_g38 + 1);
HXDLIN( 243)																int i17 = (_g38 - 1);
HXLINE( 345)																prev1 = l1;
HXLINE( 346)																l1 = l1->next;
            															}
            														}
HXLINE( 243)														if (::hx::IsNull( prev1 )) {
HXLINE( 243)															b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 243)															l1 = null();
            														}
            														else {
HXLINE( 243)															prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 243)															l1 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 243)									undoImage4 = b8;
            								}
            								break;
            							}
HXDLIN( 243)							this34->image = undoImage4;
HXDLIN( 243)							this34->width = width1;
HXDLIN( 243)							this34->height = height1;
HXDLIN( 243)							this34->imageType = ( (int)(imageType1) );
HXDLIN( 243)							undoImage3 = this34;
HXDLIN( 243)							{
HXLINE( 243)								int rectLeft1 = xIter31->start;
HXDLIN( 243)								int rectTop1 = yIter31->start;
HXDLIN( 243)								int rectRight1 = xIter31->max;
HXDLIN( 243)								bool forceClear1 = false;
HXDLIN( 243)								{
HXLINE( 243)									int _g40 = rectTop1;
HXDLIN( 243)									int _g41 = yIter31->max;
HXDLIN( 243)									while((_g40 < _g41)){
HXLINE( 243)										_g40 = (_g40 + 1);
HXDLIN( 243)										int dy1 = (_g40 - 1);
HXDLIN( 243)										{
HXLINE( 243)											int _g42 = rectLeft1;
HXDLIN( 243)											int _g43 = rectRight1;
HXDLIN( 243)											while((_g42 < _g43)){
HXLINE( 243)												_g42 = (_g42 + 1);
HXDLIN( 243)												int dx1 = (_g42 - 1);
HXDLIN( 243)												::Dynamic this36 = this33->image;
HXDLIN( 243)												int index4;
HXDLIN( 243)												if (this33->useVirtualPos) {
HXLINE( 243)													index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this33->virtualY) * ( (Float)(this33->width) )) + dx1) - this33->virtualX));
            												}
            												else {
HXLINE( 243)													index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this33->width) + dx1)) ));
            												}
HXDLIN( 243)												int c3 = ::iterMagic::Iimg_obj::get(this36,index4);
HXDLIN( 243)												int col1;
HXDLIN( 243)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)													col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE( 243)													col1 = c3;
            												}
HXDLIN( 243)												bool _hx_tmp8;
HXDLIN( 243)												if (this33->useMask) {
HXLINE( 243)													_hx_tmp8 = ::hx::IsNotNull( this33->mask );
            												}
            												else {
HXLINE( 243)													_hx_tmp8 = false;
            												}
HXDLIN( 243)												if (_hx_tmp8) {
HXLINE( 243)													 ::pi_xy::ImageStruct this37 = this33->mask;
HXDLIN( 243)													::Dynamic this38 = this37->image;
HXDLIN( 243)													int index5;
HXDLIN( 243)													if (this37->useVirtualPos) {
HXLINE( 243)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXLINE( 243)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN( 243)													int c4 = ::iterMagic::Iimg_obj::get(this38,index5);
HXDLIN( 243)													int v5;
HXDLIN( 243)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)														v5 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE( 243)														v5 = c4;
            													}
HXDLIN( 243)													int maskPixel1 = v5;
HXDLIN( 243)													int this39 = col1;
HXDLIN( 243)													if ((maskPixel1 == 0)) {
HXLINE( 243)														col1 = this39;
            													}
            													else {
HXLINE( 243)														Float m01;
HXDLIN( 243)														int this40 = ((maskPixel1 >> 24) & 255);
HXDLIN( 243)														if ((this40 == 0)) {
HXLINE( 243)															m01 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															m01 = (( (Float)(this40) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float m11;
HXDLIN( 243)														int this41 = ((maskPixel1 >> 16) & 255);
HXDLIN( 243)														if ((this41 == 0)) {
HXLINE( 243)															m11 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															m11 = (( (Float)(this41) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float m21;
HXDLIN( 243)														int this42 = ((maskPixel1 >> 8) & 255);
HXDLIN( 243)														if ((this42 == 0)) {
HXLINE( 243)															m21 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															m21 = (( (Float)(this42) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float m31;
HXDLIN( 243)														int this43 = (maskPixel1 & 255);
HXDLIN( 243)														if ((this43 == 0)) {
HXLINE( 243)															m31 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															m31 = (( (Float)(this43) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this39 >> 24) & 255)) )));
HXDLIN( 243)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this39 >> 16) & 255)) )));
HXDLIN( 243)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this39 >> 8) & 255)) )));
HXDLIN( 243)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this39 & 255)) )));
HXDLIN( 243)														col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 243)												if ((col1 != 0)) {
HXLINE( 243)													int x4 = (dx1 - rectLeft1);
HXDLIN( 243)													int y4 = (dy1 - rectTop1);
HXDLIN( 243)													int c5 = col1;
HXDLIN( 243)													bool _hx_tmp9;
HXDLIN( 243)													if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 243)														_hx_tmp9 = undoImage3->transparent;
            													}
            													else {
HXLINE( 243)														_hx_tmp9 = false;
            													}
HXDLIN( 243)													if (_hx_tmp9) {
HXLINE( 243)														int location2;
HXDLIN( 243)														if (undoImage3->useVirtualPos) {
HXLINE( 243)															location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 243)															location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            														}
HXDLIN( 243)														int this44 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 243)														int this45;
HXDLIN( 243)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)															this45 = ((((((this44 >> 24) & 255) << 24) | ((this44 & 255) << 16)) | (((this44 >> 8) & 255) << 8)) | ((this44 >> 16) & 255));
            														}
            														else {
HXLINE( 243)															this45 = this44;
            														}
HXDLIN( 243)														Float a12;
HXDLIN( 243)														int this46 = ((this45 >> 24) & 255);
HXDLIN( 243)														if ((this46 == 0)) {
HXLINE( 243)															a12 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															a12 = (( (Float)(this46) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float r12;
HXDLIN( 243)														int this47 = ((this45 >> 16) & 255);
HXDLIN( 243)														if ((this47 == 0)) {
HXLINE( 243)															r12 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															r12 = (( (Float)(this47) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float g12;
HXDLIN( 243)														int this48 = ((this45 >> 8) & 255);
HXDLIN( 243)														if ((this48 == 0)) {
HXLINE( 243)															g12 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															g12 = (( (Float)(this48) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float b13;
HXDLIN( 243)														int this49 = (this45 & 255);
HXDLIN( 243)														if ((this49 == 0)) {
HXLINE( 243)															b13 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															b13 = (( (Float)(this49) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float a22;
HXDLIN( 243)														int this50 = ((col1 >> 24) & 255);
HXDLIN( 243)														if ((this50 == 0)) {
HXLINE( 243)															a22 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															a22 = (( (Float)(this50) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float r22;
HXDLIN( 243)														int this51 = ((col1 >> 16) & 255);
HXDLIN( 243)														if ((this51 == 0)) {
HXLINE( 243)															r22 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															r22 = (( (Float)(this51) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float g22;
HXDLIN( 243)														int this52 = ((col1 >> 8) & 255);
HXDLIN( 243)														if ((this52 == 0)) {
HXLINE( 243)															g22 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															g22 = (( (Float)(this52) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float b23;
HXDLIN( 243)														int this53 = (col1 & 255);
HXDLIN( 243)														if ((this53 == 0)) {
HXLINE( 243)															b23 = ((Float)0.);
            														}
            														else {
HXLINE( 243)															b23 = (( (Float)(this53) ) / ( (Float)(255) ));
            														}
HXDLIN( 243)														Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 243)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 243)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 243)														int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 243)														int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 243)														int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 243)														{
HXLINE( 243)															int _hx_tmp10;
HXDLIN( 243)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)																_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXLINE( 243)																_hx_tmp10 = blended2;
            															}
HXDLIN( 243)															::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            														}
            													}
            													else {
HXLINE( 243)														::Dynamic this54 = undoImage3->image;
HXDLIN( 243)														int index6;
HXDLIN( 243)														if (undoImage3->useVirtualPos) {
HXLINE( 243)															index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 243)															index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            														}
HXDLIN( 243)														int _hx_tmp11;
HXDLIN( 243)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)															_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXLINE( 243)															_hx_tmp11 = c5;
            														}
HXDLIN( 243)														::iterMagic::Iimg_obj::set(this54,index6,_hx_tmp11);
            													}
            												}
            												else {
HXLINE( 243)													if (forceClear1) {
HXLINE( 243)														::Dynamic this55 = undoImage3->image;
HXDLIN( 243)														int x5 = (dx1 - rectLeft1);
HXDLIN( 243)														int y5 = (dy1 - rectTop1);
HXDLIN( 243)														int index7;
HXDLIN( 243)														if (undoImage3->useVirtualPos) {
HXLINE( 243)															index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 243)															index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            														}
HXDLIN( 243)														::iterMagic::Iimg_obj::set(this55,index7,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 243)						{
HXLINE( 243)							int _g_min2 = xIter31->start;
HXDLIN( 243)							int _g_max2 = xIter31->max;
HXDLIN( 243)							while((_g_min2 < _g_max2)){
HXLINE( 243)								_g_min2 = (_g_min2 + 1);
HXDLIN( 243)								int px1 = (_g_min2 - 1);
HXDLIN( 243)								Float pcx1 = (( (Float)(px1) ) - nextX1);
HXDLIN( 243)								{
HXLINE( 243)									int _g_min3 = yIter31->start;
HXDLIN( 243)									int _g_max3 = yIter31->max;
HXDLIN( 243)									while((_g_min3 < _g_max3)){
HXLINE( 243)										_g_min3 = (_g_min3 + 1);
HXDLIN( 243)										int py1 = (_g_min3 - 1);
HXDLIN( 243)										Float pcy1 = (( (Float)(py1) ) - nextY1);
HXDLIN( 243)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 243)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 243)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 243)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 243)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 243)										bool _hx_tmp12;
HXDLIN( 243)										bool _hx_tmp13;
HXDLIN( 243)										if ((ratioA1 >= 0)) {
HXLINE( 243)											_hx_tmp13 = (ratioB1 >= 0);
            										}
            										else {
HXLINE( 243)											_hx_tmp13 = false;
            										}
HXDLIN( 243)										if (_hx_tmp13) {
HXLINE( 243)											_hx_tmp12 = (ratioC1 >= 0);
            										}
            										else {
HXLINE( 243)											_hx_tmp12 = false;
            										}
HXDLIN( 243)										if (_hx_tmp12) {
HXLINE( 243)											int i18 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 243)											if ((i18 > 255)) {
HXLINE(  24)												i18 = 255;
            											}
HXLINE( 243)											if ((i18 < 0)) {
HXLINE(  25)												i18 = 0;
            											}
HXLINE( 243)											int a9 = i18;
HXDLIN( 243)											int i19 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 243)											if ((i19 > 255)) {
HXLINE(  24)												i19 = 255;
            											}
HXLINE( 243)											if ((i19 < 0)) {
HXLINE(  25)												i19 = 0;
            											}
HXLINE( 243)											int r6 = i19;
HXDLIN( 243)											int i20 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 243)											if ((i20 > 255)) {
HXLINE(  24)												i20 = 255;
            											}
HXLINE( 243)											if ((i20 < 0)) {
HXLINE(  25)												i20 = 0;
            											}
HXLINE( 243)											int g6 = i20;
HXDLIN( 243)											int i21 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 243)											if ((i21 > 255)) {
HXLINE(  24)												i21 = 255;
            											}
HXLINE( 243)											if ((i21 < 0)) {
HXLINE(  25)												i21 = 0;
            											}
HXLINE( 243)											int b10 = i21;
HXDLIN( 243)											{
HXLINE( 243)												int location3;
HXDLIN( 243)												if (this33->useVirtualPos) {
HXLINE( 243)													location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this33->virtualY) * ( (Float)(this33->width) )) + px1) - this33->virtualX));
            												}
            												else {
HXLINE( 243)													location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this33->width) + px1)) ));
            												}
HXDLIN( 243)												bool _hx_tmp14;
HXDLIN( 243)												if (this33->transparent) {
HXLINE( 243)													_hx_tmp14 = (a9 < 254);
            												}
            												else {
HXLINE( 243)													_hx_tmp14 = false;
            												}
HXDLIN( 243)												if (_hx_tmp14) {
HXLINE( 243)													int this56 = ::iterMagic::Iimg_obj::get(this33->image,location3);
HXDLIN( 243)													int old1;
HXDLIN( 243)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)														old1 = ((((((this56 >> 24) & 255) << 24) | ((this56 & 255) << 16)) | (((this56 >> 8) & 255) << 8)) | ((this56 >> 16) & 255));
            													}
            													else {
HXLINE( 243)														old1 = this56;
            													}
HXDLIN( 243)													int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 243)													Float a13;
HXDLIN( 243)													int this57 = ((old1 >> 24) & 255);
HXDLIN( 243)													if ((this57 == 0)) {
HXLINE( 243)														a13 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														a13 = (( (Float)(this57) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float r13;
HXDLIN( 243)													int this58 = ((old1 >> 16) & 255);
HXDLIN( 243)													if ((this58 == 0)) {
HXLINE( 243)														r13 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														r13 = (( (Float)(this58) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float g13;
HXDLIN( 243)													int this59 = ((old1 >> 8) & 255);
HXDLIN( 243)													if ((this59 == 0)) {
HXLINE( 243)														g13 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														g13 = (( (Float)(this59) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float b14;
HXDLIN( 243)													int this60 = (old1 & 255);
HXDLIN( 243)													if ((this60 == 0)) {
HXLINE( 243)														b14 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														b14 = (( (Float)(this60) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float a23;
HXDLIN( 243)													int this61 = ((rhs1 >> 24) & 255);
HXDLIN( 243)													if ((this61 == 0)) {
HXLINE( 243)														a23 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														a23 = (( (Float)(this61) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float r23;
HXDLIN( 243)													int this62 = ((rhs1 >> 16) & 255);
HXDLIN( 243)													if ((this62 == 0)) {
HXLINE( 243)														r23 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														r23 = (( (Float)(this62) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float g23;
HXDLIN( 243)													int this63 = ((rhs1 >> 8) & 255);
HXDLIN( 243)													if ((this63 == 0)) {
HXLINE( 243)														g23 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														g23 = (( (Float)(this63) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float b24;
HXDLIN( 243)													int this64 = (rhs1 & 255);
HXDLIN( 243)													if ((this64 == 0)) {
HXLINE( 243)														b24 = ((Float)0.);
            													}
            													else {
HXLINE( 243)														b24 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN( 243)													Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 243)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 243)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 243)													int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 243)													int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 243)													int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 243)													{
HXLINE( 243)														int _hx_tmp15;
HXDLIN( 243)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 243)															_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXLINE( 243)															_hx_tmp15 = blended3;
            														}
HXDLIN( 243)														::iterMagic::Iimg_obj::set(this33->image,location3,_hx_tmp15);
            													}
            												}
            												else {
HXLINE( 243)													int value1;
HXDLIN( 243)													if (this33->isLittle) {
HXLINE( 243)														value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            													}
            													else {
HXLINE( 243)														value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            													}
HXDLIN( 243)													::iterMagic::Iimg_obj::set(this33->image,location3,value1);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 243)						if ((hasHit1 == false)) {
HXLINE( 243)							 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX1,nextY1,true);
HXDLIN( 243)							if (hasUndo1) {
HXLINE( 243)								v6->undoImage = undoImage3;
HXDLIN( 243)								v6->undoX = xIter31->start;
HXDLIN( 243)								v6->undoY = yIter31->start;
            							}
            						}
            					}
            				}
HXLINE( 244)				lastX = nextX1;
HXLINE( 245)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(PolyPixel_Fields__obj,fillRadialPolyBuild,(void))


PolyPixel_Fields__obj::PolyPixel_Fields__obj()
{
}

bool PolyPixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 16:
		if (HX_FIELD_EQ(inName,"fillPolygonBuild") ) { outValue = fillPolygonBuild_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tilePolygonBuild") ) { outValue = tilePolygonBuild_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"fillRadialPolyBuild") ) { outValue = fillRadialPolyBuild_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"softFillPolygonBuild") ) { outValue = softFillPolygonBuild_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PolyPixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PolyPixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class PolyPixel_Fields__obj::__mClass;

static ::String PolyPixel_Fields__obj_sStaticFields[] = {
	HX_("fillPolygonBuild",77,61,f5,9a),
	HX_("softFillPolygonBuild",81,4e,1e,8f),
	HX_("tilePolygonBuild",a2,32,54,97),
	HX_("fillRadialPolyBuild",20,4b,b2,6e),
	::String(null())
};

void PolyPixel_Fields__obj::__register()
{
	PolyPixel_Fields__obj _hx_dummy;
	PolyPixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._PolyPixel.PolyPixel_Fields_",c2,98,e6,36);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PolyPixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PolyPixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< PolyPixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PolyPixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PolyPixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _PolyPixel
