// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__BinaryPatternFill_BinaryPatternFill_Fields_
#include <pi_xy/transformation/_BinaryPatternFill/BinaryPatternFill_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_624da9d4d0c0156d_10_patternRectangle,"pi_xy.transformation._BinaryPatternFill.BinaryPatternFill_Fields_","patternRectangle",0xe02ac271,"pi_xy.transformation._BinaryPatternFill.BinaryPatternFill_Fields_.patternRectangle","pi_xy/transformation/BinaryPatternFill.hx",10,0x98af9e6a)
HX_LOCAL_STACK_FRAME(_hx_pos_624da9d4d0c0156d_42_patternRectangleDown,"pi_xy.transformation._BinaryPatternFill.BinaryPatternFill_Fields_","patternRectangleDown",0x37427373,"pi_xy.transformation._BinaryPatternFill.BinaryPatternFill_Fields_.patternRectangleDown","pi_xy/transformation/BinaryPatternFill.hx",42,0x98af9e6a)
namespace pi_xy{
namespace transformation{
namespace _BinaryPatternFill{

void BinaryPatternFill_Fields__obj::__construct() { }

Dynamic BinaryPatternFill_Fields__obj::__CreateEmpty() { return new BinaryPatternFill_Fields__obj; }

void *BinaryPatternFill_Fields__obj::_hx_vtable = 0;

Dynamic BinaryPatternFill_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BinaryPatternFill_Fields__obj > _hx_result = new BinaryPatternFill_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool BinaryPatternFill_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7c85c136;
}

void BinaryPatternFill_Fields__obj::patternRectangle( ::pi_xy::ImageStruct thisImage,Float x,Float y,Float w,Float h,int foreColor,int backColor,::Array< bool > patternFill){
            	HX_STACKFRAME(&_hx_pos_624da9d4d0c0156d_10_patternRectangle)
HXLINE(  11)		int p = ::Std_obj::_hx_int(x);
HXLINE(  12)		int xx = p;
HXLINE(  13)		int q = ::Std_obj::_hx_int(y);
HXLINE(  14)		int maxX = ::Std_obj::_hx_int((x + w));
HXLINE(  15)		int maxY = ::Std_obj::_hx_int((y + h));
HXLINE(  16)		int count = 0;
HXLINE(  17)		bool useFore = true;
HXLINE(  18)		do {
HXLINE(  20)			if ((count < patternFill->length)) {
HXLINE(  21)				useFore = patternFill->__get(count);
HXLINE(  22)				count = (count + 1);
            			}
            			else {
HXLINE(  24)				count = 0;
HXLINE(  25)				useFore = patternFill->__get(count);
HXLINE(  26)				count = (count + 1);
            			}
HXLINE(  28)			int color;
HXDLIN(  28)			if (useFore) {
HXLINE(  28)				color = foreColor;
            			}
            			else {
HXLINE(  28)				color = backColor;
            			}
HXLINE(  29)			{
HXLINE(  29)				p = (p + 1);
HXDLIN(  29)				int x1 = (p - 1);
HXDLIN(  29)				int c = color;
HXDLIN(  29)				bool _hx_tmp;
HXDLIN(  29)				if ((((c >> 24) & 255) < 254)) {
HXLINE(  29)					_hx_tmp = thisImage->transparent;
            				}
            				else {
HXLINE(  29)					_hx_tmp = false;
            				}
HXDLIN(  29)				if (_hx_tmp) {
HXLINE(  29)					int location;
HXDLIN(  29)					if (thisImage->useVirtualPos) {
HXLINE(  29)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x1) - thisImage->virtualX));
            					}
            					else {
HXLINE(  29)						location = ::Std_obj::_hx_int(( (Float)(((q * thisImage->width) + x1)) ));
            					}
HXDLIN(  29)					int this1 = ::iterMagic::Iimg_obj::get(thisImage->image,location);
HXDLIN(  29)					int this2;
HXDLIN(  29)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)						this2 = ((((((this1 >> 24) & 255) << 24) | ((this1 & 255) << 16)) | (((this1 >> 8) & 255) << 8)) | ((this1 >> 16) & 255));
            					}
            					else {
HXLINE(  29)						this2 = this1;
            					}
HXDLIN(  29)					Float a1;
HXDLIN(  29)					int this3 = ((this2 >> 24) & 255);
HXDLIN(  29)					if ((this3 == 0)) {
HXLINE(  29)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						a1 = (( (Float)(this3) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float r1;
HXDLIN(  29)					int this4 = ((this2 >> 16) & 255);
HXDLIN(  29)					if ((this4 == 0)) {
HXLINE(  29)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						r1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float g1;
HXDLIN(  29)					int this5 = ((this2 >> 8) & 255);
HXDLIN(  29)					if ((this5 == 0)) {
HXLINE(  29)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						g1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float b1;
HXDLIN(  29)					int this6 = (this2 & 255);
HXDLIN(  29)					if ((this6 == 0)) {
HXLINE(  29)						b1 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						b1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float a2;
HXDLIN(  29)					int this7 = ((color >> 24) & 255);
HXDLIN(  29)					if ((this7 == 0)) {
HXLINE(  29)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						a2 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float r2;
HXDLIN(  29)					int this8 = ((color >> 16) & 255);
HXDLIN(  29)					if ((this8 == 0)) {
HXLINE(  29)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						r2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float g2;
HXDLIN(  29)					int this9 = ((color >> 8) & 255);
HXDLIN(  29)					if ((this9 == 0)) {
HXLINE(  29)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						g2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float b2;
HXDLIN(  29)					int this10 = (color & 255);
HXDLIN(  29)					if ((this10 == 0)) {
HXLINE(  29)						b2 = ((Float)0.);
            					}
            					else {
HXLINE(  29)						b2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  29)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  29)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  29)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  29)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  29)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  29)					{
HXLINE(  29)						int _hx_tmp1;
HXDLIN(  29)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  29)							_hx_tmp1 = blended;
            						}
HXDLIN(  29)						::iterMagic::Iimg_obj::set(thisImage->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXLINE(  29)					::Dynamic this11 = thisImage->image;
HXDLIN(  29)					int index;
HXDLIN(  29)					if (thisImage->useVirtualPos) {
HXLINE(  29)						index = ::Std_obj::_hx_int(((((( (Float)(q) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x1) - thisImage->virtualX));
            					}
            					else {
HXLINE(  29)						index = ::Std_obj::_hx_int(( (Float)(((q * thisImage->width) + x1)) ));
            					}
HXDLIN(  29)					int _hx_tmp2;
HXDLIN(  29)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE(  29)						_hx_tmp2 = c;
            					}
HXDLIN(  29)					::iterMagic::Iimg_obj::set(this11,index,_hx_tmp2);
            				}
            			}
HXLINE(  30)			if ((p > maxX)) {
HXLINE(  31)				p = xx;
HXLINE(  32)				q = (q + 1);
            			}
            		} while((q <= maxY));
;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(BinaryPatternFill_Fields__obj,patternRectangle,(void))

void BinaryPatternFill_Fields__obj::patternRectangleDown( ::pi_xy::ImageStruct thisImage,Float x,Float y,Float w,Float h,int foreColor,int backColor,::Array< bool > patternFill){
            	HX_STACKFRAME(&_hx_pos_624da9d4d0c0156d_42_patternRectangleDown)
HXLINE(  43)		int p = ::Std_obj::_hx_int(x);
HXLINE(  44)		int q = ::Std_obj::_hx_int(y);
HXLINE(  45)		int yy = q;
HXLINE(  46)		int maxX = ::Std_obj::_hx_int((x + w));
HXLINE(  47)		int maxY = ::Std_obj::_hx_int((y + h));
HXLINE(  48)		int count = 0;
HXLINE(  49)		bool useFore = true;
HXLINE(  50)		do {
HXLINE(  52)			if ((count < patternFill->length)) {
HXLINE(  53)				useFore = patternFill->__get(count);
HXLINE(  54)				count = (count + 1);
            			}
            			else {
HXLINE(  56)				count = 0;
HXLINE(  57)				useFore = patternFill->__get(count);
HXLINE(  58)				count = (count + 1);
            			}
HXLINE(  60)			int color;
HXDLIN(  60)			if (useFore) {
HXLINE(  60)				color = foreColor;
            			}
            			else {
HXLINE(  60)				color = backColor;
            			}
HXLINE(  61)			{
HXLINE(  61)				q = (q + 1);
HXDLIN(  61)				int y1 = (q - 1);
HXDLIN(  61)				int c = color;
HXDLIN(  61)				bool _hx_tmp;
HXDLIN(  61)				if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)					_hx_tmp = thisImage->transparent;
            				}
            				else {
HXLINE(  61)					_hx_tmp = false;
            				}
HXDLIN(  61)				if (_hx_tmp) {
HXLINE(  61)					int location;
HXDLIN(  61)					if (thisImage->useVirtualPos) {
HXLINE(  61)						location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + p) - thisImage->virtualX));
            					}
            					else {
HXLINE(  61)						location = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage->width) + p)) ));
            					}
HXDLIN(  61)					int this1 = ::iterMagic::Iimg_obj::get(thisImage->image,location);
HXDLIN(  61)					int this2;
HXDLIN(  61)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)						this2 = ((((((this1 >> 24) & 255) << 24) | ((this1 & 255) << 16)) | (((this1 >> 8) & 255) << 8)) | ((this1 >> 16) & 255));
            					}
            					else {
HXLINE(  61)						this2 = this1;
            					}
HXDLIN(  61)					Float a1;
HXDLIN(  61)					int this3 = ((this2 >> 24) & 255);
HXDLIN(  61)					if ((this3 == 0)) {
HXLINE(  61)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						a1 = (( (Float)(this3) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float r1;
HXDLIN(  61)					int this4 = ((this2 >> 16) & 255);
HXDLIN(  61)					if ((this4 == 0)) {
HXLINE(  61)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						r1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float g1;
HXDLIN(  61)					int this5 = ((this2 >> 8) & 255);
HXDLIN(  61)					if ((this5 == 0)) {
HXLINE(  61)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						g1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float b1;
HXDLIN(  61)					int this6 = (this2 & 255);
HXDLIN(  61)					if ((this6 == 0)) {
HXLINE(  61)						b1 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						b1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float a2;
HXDLIN(  61)					int this7 = ((color >> 24) & 255);
HXDLIN(  61)					if ((this7 == 0)) {
HXLINE(  61)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						a2 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float r2;
HXDLIN(  61)					int this8 = ((color >> 16) & 255);
HXDLIN(  61)					if ((this8 == 0)) {
HXLINE(  61)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						r2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float g2;
HXDLIN(  61)					int this9 = ((color >> 8) & 255);
HXDLIN(  61)					if ((this9 == 0)) {
HXLINE(  61)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						g2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float b2;
HXDLIN(  61)					int this10 = (color & 255);
HXDLIN(  61)					if ((this10 == 0)) {
HXLINE(  61)						b2 = ((Float)0.);
            					}
            					else {
HXLINE(  61)						b2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  61)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)					{
HXLINE(  61)						int _hx_tmp1;
HXDLIN(  61)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  61)							_hx_tmp1 = blended;
            						}
HXDLIN(  61)						::iterMagic::Iimg_obj::set(thisImage->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXLINE(  61)					::Dynamic this11 = thisImage->image;
HXDLIN(  61)					int index;
HXDLIN(  61)					if (thisImage->useVirtualPos) {
HXLINE(  61)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + p) - thisImage->virtualX));
            					}
            					else {
HXLINE(  61)						index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage->width) + p)) ));
            					}
HXDLIN(  61)					int _hx_tmp2;
HXDLIN(  61)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE(  61)						_hx_tmp2 = c;
            					}
HXDLIN(  61)					::iterMagic::Iimg_obj::set(this11,index,_hx_tmp2);
            				}
            			}
HXLINE(  62)			if ((q > maxY)) {
HXLINE(  63)				q = yy;
HXLINE(  64)				q = (q + 1);
            			}
            		} while((p <= maxX));
;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(BinaryPatternFill_Fields__obj,patternRectangleDown,(void))


BinaryPatternFill_Fields__obj::BinaryPatternFill_Fields__obj()
{
}

bool BinaryPatternFill_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 16:
		if (HX_FIELD_EQ(inName,"patternRectangle") ) { outValue = patternRectangle_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"patternRectangleDown") ) { outValue = patternRectangleDown_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *BinaryPatternFill_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *BinaryPatternFill_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class BinaryPatternFill_Fields__obj::__mClass;

static ::String BinaryPatternFill_Fields__obj_sStaticFields[] = {
	HX_("patternRectangle",bf,63,0d,19),
	HX_("patternRectangleDown",c1,d3,ca,f5),
	::String(null())
};

void BinaryPatternFill_Fields__obj::__register()
{
	BinaryPatternFill_Fields__obj _hx_dummy;
	BinaryPatternFill_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.transformation._BinaryPatternFill.BinaryPatternFill_Fields_",fc,61,14,22);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &BinaryPatternFill_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(BinaryPatternFill_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< BinaryPatternFill_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BinaryPatternFill_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BinaryPatternFill_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace transformation
} // end namespace _BinaryPatternFill
