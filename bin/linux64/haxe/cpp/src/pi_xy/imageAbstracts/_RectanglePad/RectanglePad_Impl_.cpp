// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts_NineColorBorder
#include <pi_xy/imageAbstracts/NineColorBorder.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__RectanglePad_RectanglePad_Impl_
#include <pi_xy/imageAbstracts/_RectanglePad/RectanglePad_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_43__new,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","_new",0xb59084ef,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_._new","pi_xy/imageAbstracts/RectanglePad.hx",43,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_49_colorPadImage,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","colorPadImage",0xbd74883d,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.colorPadImage","pi_xy/imageAbstracts/RectanglePad.hx",49,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_52_colorPadImageXY,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","colorPadImageXY",0x69d51e7e,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.colorPadImageXY","pi_xy/imageAbstracts/RectanglePad.hx",52,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_80_borderPad,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","borderPad",0x74420579,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.borderPad","pi_xy/imageAbstracts/RectanglePad.hx",80,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_108_padImage,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","padImage",0x5435df96,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.padImage","pi_xy/imageAbstracts/RectanglePad.hx",108,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_111_padImageXY,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","padImageXY",0x351dbe17,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.padImageXY","pi_xy/imageAbstracts/RectanglePad.hx",111,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_139_padWrapImage,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","padWrapImage",0x35b092ec,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.padWrapImage","pi_xy/imageAbstracts/RectanglePad.hx",139,0x5b33fd69)
HX_LOCAL_STACK_FRAME(_hx_pos_684e147a04b272d1_144_padWrapImageXY,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_","padWrapImageXY",0x712c72ed,"pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_.padWrapImageXY","pi_xy/imageAbstracts/RectanglePad.hx",144,0x5b33fd69)
namespace pi_xy{
namespace imageAbstracts{
namespace _RectanglePad{

void RectanglePad_Impl__obj::__construct() { }

Dynamic RectanglePad_Impl__obj::__CreateEmpty() { return new RectanglePad_Impl__obj; }

void *RectanglePad_Impl__obj::_hx_vtable = 0;

Dynamic RectanglePad_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RectanglePad_Impl__obj > _hx_result = new RectanglePad_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RectanglePad_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7e0dafea;
}

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_43__new)
HXLINE(  45)		 ::Dynamic imageType = null();
HXDLIN(  45)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  45)		if (::hx::IsNull( imageType )) {
HXLINE(  45)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  45)		::Dynamic this2;
HXDLIN(  45)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  45)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  45)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  45)				{
HXLINE(  45)					b->width = w;
HXDLIN(  45)					b->height = h;
HXDLIN(  45)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  45)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  45)					{
HXLINE(  45)						int len = b->length;
HXDLIN(  45)						int w1 = 0;
HXDLIN(  45)						{
HXLINE(  45)							int _g = 0;
HXDLIN(  45)							int _g1 = b->height;
HXDLIN(  45)							while((_g < _g1)){
HXLINE(  45)								_g = (_g + 1);
HXDLIN(  45)								int y = (_g - 1);
HXDLIN(  45)								{
HXLINE(  45)									int _g2 = 0;
HXDLIN(  45)									int _g3 = b->width;
HXDLIN(  45)									while((_g2 < _g3)){
HXLINE(  45)										_g2 = (_g2 + 1);
HXDLIN(  45)										int x = (_g2 - 1);
HXDLIN(  45)										{
HXLINE(  45)											w1 = (w1 + 1);
HXDLIN(  45)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  45)										{
HXLINE(  45)											w1 = (w1 + 1);
HXDLIN(  45)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  45)										{
HXLINE(  45)											w1 = (w1 + 1);
HXDLIN(  45)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  45)										{
HXLINE(  45)											w1 = (w1 + 1);
HXDLIN(  45)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  45)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  45)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  45)				{
HXLINE(  45)					a->width = w;
HXDLIN(  45)					a->height = h;
HXDLIN(  45)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  45)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  45)					{
HXLINE(  45)						int _g4 = 0;
HXDLIN(  45)						int _g5 = a->length;
HXDLIN(  45)						while((_g4 < _g5)){
HXLINE(  45)							_g4 = (_g4 + 1);
HXDLIN(  45)							int i = (_g4 - 1);
HXDLIN(  45)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  45)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  45)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  45)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  45)				{
HXLINE(  45)					b1->width = w;
HXDLIN(  45)					b1->height = h;
HXDLIN(  45)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  45)					int size = (b1->length * 4);
HXDLIN(  45)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  45)					{
HXLINE(  45)						int _g6 = 0;
HXDLIN(  45)						int _g7 = b1->length;
HXDLIN(  45)						while((_g6 < _g7)){
HXLINE(  45)							_g6 = (_g6 + 1);
HXDLIN(  45)							int i1 = (_g6 - 1);
HXDLIN(  45)							{
HXLINE(  45)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  45)								bool this4;
HXDLIN(  45)								if ((i1 >= 0)) {
HXLINE(  45)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  45)									this4 = false;
            								}
HXDLIN(  45)								if (this4) {
HXLINE(  45)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  45)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  45)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  45)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  45)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  45)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  45)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  45)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  45)				{
HXLINE(  45)					v->width = w;
HXDLIN(  45)					v->height = h;
HXDLIN(  45)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  45)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  45)					{
HXLINE(  45)						int _g8 = 0;
HXDLIN(  45)						int _g9 = v->length;
HXDLIN(  45)						while((_g8 < _g9)){
HXLINE(  45)							_g8 = (_g8 + 1);
HXDLIN(  45)							int i2 = (_g8 - 1);
HXDLIN(  45)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  45)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  45)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  45)				{
HXLINE(  45)					b2->width = w;
HXDLIN(  45)					b2->height = h;
HXDLIN(  45)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  45)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  45)					{
HXLINE(  45)						int len1 = b2->length;
HXDLIN(  45)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  45)						if (::hx::IsNull( d->head )) {
HXLINE(  45)							int _g10 = 0;
HXDLIN(  45)							int _g11 = len1;
HXDLIN(  45)							while((_g10 < _g11)){
HXLINE(  45)								_g10 = (_g10 + 1);
HXDLIN(  45)								int i3 = (_g10 - 1);
HXDLIN(  45)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  45)							int _g12 = 0;
HXDLIN(  45)							int _g13 = len1;
HXDLIN(  45)							while((_g12 < _g13)){
HXLINE(  45)								_g12 = (_g12 + 1);
HXDLIN(  45)								int i4 = (_g12 - 1);
HXDLIN(  45)								{
HXLINE(  45)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  45)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  45)									{
HXLINE(  45)										int _g14 = 0;
HXDLIN(  45)										int _g15 = i4;
HXDLIN(  45)										while((_g14 < _g15)){
HXLINE(  45)											_g14 = (_g14 + 1);
HXDLIN(  45)											int i5 = (_g14 - 1);
HXDLIN(  45)											prev = l;
HXDLIN(  45)											l = l->next;
            										}
            									}
HXDLIN(  45)									if (::hx::IsNull( prev )) {
HXLINE(  45)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  45)										l = null();
            									}
            									else {
HXLINE(  45)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  45)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  45)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  45)		this1->image = this2;
HXDLIN(  45)		this1->width = w;
HXDLIN(  45)		this1->height = h;
HXDLIN(  45)		this1->imageType = ( (int)(imageType) );
HXLINE(  43)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectanglePad_Impl__obj,_new,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::colorPadImage( ::pi_xy::ImageStruct this1,int places, ::pi_xy::imageAbstracts::NineColorBorder color){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_49_colorPadImage)
HXDLIN(  49)		 ::pi_xy::imageAbstracts::NineColorBorder color1 = color;
HXDLIN(  49)		int width = (this1->width + (2 * places));
HXDLIN(  49)		int height = (this1->height + (2 * places));
HXDLIN(  49)		 ::Dynamic imageType = null();
HXDLIN(  49)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  49)		if (::hx::IsNull( imageType )) {
HXDLIN(  49)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  49)		::Dynamic _hx_tmp;
HXDLIN(  49)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  49)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  49)				{
HXDLIN(  49)					b->width = width;
HXDLIN(  49)					b->height = height;
HXDLIN(  49)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  49)					{
HXDLIN(  49)						int len = b->length;
HXDLIN(  49)						int w = 0;
HXDLIN(  49)						{
HXDLIN(  49)							int _g = 0;
HXDLIN(  49)							int _g1 = b->height;
HXDLIN(  49)							while((_g < _g1)){
HXDLIN(  49)								_g = (_g + 1);
HXDLIN(  49)								int y = (_g - 1);
HXDLIN(  49)								{
HXDLIN(  49)									int _g2 = 0;
HXDLIN(  49)									int _g3 = b->width;
HXDLIN(  49)									while((_g2 < _g3)){
HXDLIN(  49)										_g2 = (_g2 + 1);
HXDLIN(  49)										int x = (_g2 - 1);
HXDLIN(  49)										{
HXDLIN(  49)											w = (w + 1);
HXDLIN(  49)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w = (w + 1);
HXDLIN(  49)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w = (w + 1);
HXDLIN(  49)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w = (w + 1);
HXDLIN(  49)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  49)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  49)				{
HXDLIN(  49)					a->width = width;
HXDLIN(  49)					a->height = height;
HXDLIN(  49)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  49)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					{
HXDLIN(  49)						int _g4 = 0;
HXDLIN(  49)						int _g5 = a->length;
HXDLIN(  49)						while((_g4 < _g5)){
HXDLIN(  49)							_g4 = (_g4 + 1);
HXDLIN(  49)							int i = (_g4 - 1);
HXDLIN(  49)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  49)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  49)				{
HXDLIN(  49)					b1->width = width;
HXDLIN(  49)					b1->height = height;
HXDLIN(  49)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					int size = (b1->length * 4);
HXDLIN(  49)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  49)					{
HXDLIN(  49)						int _g6 = 0;
HXDLIN(  49)						int _g7 = b1->length;
HXDLIN(  49)						while((_g6 < _g7)){
HXDLIN(  49)							_g6 = (_g6 + 1);
HXDLIN(  49)							int i1 = (_g6 - 1);
HXDLIN(  49)							{
HXDLIN(  49)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  49)								bool _hx_tmp1;
HXDLIN(  49)								if ((i1 >= 0)) {
HXDLIN(  49)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  49)									_hx_tmp1 = false;
            								}
HXDLIN(  49)								if (_hx_tmp1) {
HXDLIN(  49)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  49)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  49)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  49)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  49)				{
HXDLIN(  49)					v->width = width;
HXDLIN(  49)					v->height = height;
HXDLIN(  49)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  49)					{
HXDLIN(  49)						int _g8 = 0;
HXDLIN(  49)						int _g9 = v->length;
HXDLIN(  49)						while((_g8 < _g9)){
HXDLIN(  49)							_g8 = (_g8 + 1);
HXDLIN(  49)							int i2 = (_g8 - 1);
HXDLIN(  49)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  49)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  49)				{
HXDLIN(  49)					b2->width = width;
HXDLIN(  49)					b2->height = height;
HXDLIN(  49)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  49)					{
HXDLIN(  49)						int len1 = b2->length;
HXDLIN(  49)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  49)						if (::hx::IsNull( d->head )) {
HXDLIN(  49)							int _g10 = 0;
HXDLIN(  49)							int _g11 = len1;
HXDLIN(  49)							while((_g10 < _g11)){
HXDLIN(  49)								_g10 = (_g10 + 1);
HXDLIN(  49)								int i3 = (_g10 - 1);
HXDLIN(  49)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  49)							int _g12 = 0;
HXDLIN(  49)							int _g13 = len1;
HXDLIN(  49)							while((_g12 < _g13)){
HXDLIN(  49)								_g12 = (_g12 + 1);
HXDLIN(  49)								int i4 = (_g12 - 1);
HXDLIN(  49)								{
HXDLIN(  49)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  49)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  49)									{
HXDLIN(  49)										int _g14 = 0;
HXDLIN(  49)										int _g15 = i4;
HXDLIN(  49)										while((_g14 < _g15)){
HXDLIN(  49)											_g14 = (_g14 + 1);
HXDLIN(  49)											int i5 = (_g14 - 1);
HXDLIN(  49)											prev = l;
HXDLIN(  49)											l = l->next;
            										}
            									}
HXDLIN(  49)									if (::hx::IsNull( prev )) {
HXDLIN(  49)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)										l = null();
            									}
            									else {
HXDLIN(  49)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  49)		this2->image = _hx_tmp;
HXDLIN(  49)		this2->width = width;
HXDLIN(  49)		this2->height = height;
HXDLIN(  49)		this2->imageType = ( (int)(imageType) );
HXDLIN(  49)		 ::pi_xy::ImageStruct img = this2;
HXDLIN(  49)		{
HXDLIN(  49)			bool forceClear = false;
HXDLIN(  49)			{
HXDLIN(  49)				int _g16 = 0;
HXDLIN(  49)				int _g17 = this1->height;
HXDLIN(  49)				while((_g16 < _g17)){
HXDLIN(  49)					_g16 = (_g16 + 1);
HXDLIN(  49)					int dy = (_g16 - 1);
HXDLIN(  49)					{
HXDLIN(  49)						int _g18 = 0;
HXDLIN(  49)						int _g19 = this1->width;
HXDLIN(  49)						while((_g18 < _g19)){
HXDLIN(  49)							_g18 = (_g18 + 1);
HXDLIN(  49)							int dx = (_g18 - 1);
HXDLIN(  49)							::Dynamic this4 = this1->image;
HXDLIN(  49)							int index;
HXDLIN(  49)							if (this1->useVirtualPos) {
HXDLIN(  49)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXDLIN(  49)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN(  49)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  49)							int col;
HXDLIN(  49)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN(  49)								col = c;
            							}
HXDLIN(  49)							bool _hx_tmp2;
HXDLIN(  49)							if (this1->useMask) {
HXDLIN(  49)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXDLIN(  49)								_hx_tmp2 = false;
            							}
HXDLIN(  49)							if (_hx_tmp2) {
HXDLIN(  49)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  49)								::Dynamic this6 = this5->image;
HXDLIN(  49)								int index1;
HXDLIN(  49)								if (this5->useVirtualPos) {
HXDLIN(  49)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXDLIN(  49)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN(  49)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  49)								int v1;
HXDLIN(  49)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN(  49)									v1 = c1;
            								}
HXDLIN(  49)								int maskPixel = v1;
HXDLIN(  49)								int this7 = col;
HXDLIN(  49)								if ((maskPixel == 0)) {
HXDLIN(  49)									col = this7;
            								}
            								else {
HXDLIN(  49)									Float m0;
HXDLIN(  49)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  49)									if ((this8 == 0)) {
HXDLIN(  49)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m1;
HXDLIN(  49)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  49)									if ((this9 == 0)) {
HXDLIN(  49)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m2;
HXDLIN(  49)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  49)									if ((this10 == 0)) {
HXDLIN(  49)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m3;
HXDLIN(  49)									int this11 = (maskPixel & 255);
HXDLIN(  49)									if ((this11 == 0)) {
HXDLIN(  49)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  49)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  49)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  49)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  49)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  49)							if ((col != 0)) {
HXDLIN(  49)								int x1 = (places + dx);
HXDLIN(  49)								int y1 = (places + dy);
HXDLIN(  49)								int c2 = col;
HXDLIN(  49)								bool _hx_tmp3;
HXDLIN(  49)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp3 = false;
            								}
HXDLIN(  49)								if (_hx_tmp3) {
HXDLIN(  49)									int location;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  49)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN(  49)									int this13;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this13 = this12;
            									}
HXDLIN(  49)									Float a1;
HXDLIN(  49)									int this14 = ((this13 >> 24) & 255);
HXDLIN(  49)									if ((this14 == 0)) {
HXDLIN(  49)										a1 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r1;
HXDLIN(  49)									int this15 = ((this13 >> 16) & 255);
HXDLIN(  49)									if ((this15 == 0)) {
HXDLIN(  49)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g1;
HXDLIN(  49)									int this16 = ((this13 >> 8) & 255);
HXDLIN(  49)									if ((this16 == 0)) {
HXDLIN(  49)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b11;
HXDLIN(  49)									int this17 = (this13 & 255);
HXDLIN(  49)									if ((this17 == 0)) {
HXDLIN(  49)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a2;
HXDLIN(  49)									int this18 = ((col >> 24) & 255);
HXDLIN(  49)									if ((this18 == 0)) {
HXDLIN(  49)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r2;
HXDLIN(  49)									int this19 = ((col >> 16) & 255);
HXDLIN(  49)									if ((this19 == 0)) {
HXDLIN(  49)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g2;
HXDLIN(  49)									int this20 = ((col >> 8) & 255);
HXDLIN(  49)									if ((this20 == 0)) {
HXDLIN(  49)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b21;
HXDLIN(  49)									int this21 = (col & 255);
HXDLIN(  49)									if ((this21 == 0)) {
HXDLIN(  49)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  49)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  49)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  49)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  49)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  49)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp4;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp4 = blended;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this22 = img->image;
HXDLIN(  49)									int index2;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  49)									int _hx_tmp5;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp5 = c2;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXDLIN(  49)								if (forceClear) {
HXDLIN(  49)									::Dynamic this23 = img->image;
HXDLIN(  49)									int x2 = (places + dx);
HXDLIN(  49)									int y2 = (places + dy);
HXDLIN(  49)									int index3;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  49)		if (::hx::IsNull( color1 )) {
HXDLIN(  49)			color1 =  ::pi_xy::imageAbstracts::NineColorBorder_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null(),null());
            		}
HXDLIN(  49)		{
HXDLIN(  49)			int _g20 = 0;
HXDLIN(  49)			int _g21 = this1->width;
HXDLIN(  49)			while((_g20 < _g21)){
HXDLIN(  49)				_g20 = (_g20 + 1);
HXDLIN(  49)				int x3 = (_g20 - 1);
HXDLIN(  49)				{
HXDLIN(  49)					int _g22 = 0;
HXDLIN(  49)					int _g23 = places;
HXDLIN(  49)					while((_g22 < _g23)){
HXDLIN(  49)						_g22 = (_g22 + 1);
HXDLIN(  49)						int y3 = (_g22 - 1);
HXDLIN(  49)						{
HXDLIN(  49)							int x4 = (x3 + places);
HXDLIN(  49)							int color2 = color1->top;
HXDLIN(  49)							{
HXDLIN(  49)								int c3 = color2;
HXDLIN(  49)								bool _hx_tmp6;
HXDLIN(  49)								if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp6 = false;
            								}
HXDLIN(  49)								if (_hx_tmp6) {
HXDLIN(  49)									int location1;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  49)									int this24 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN(  49)									int this25;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this25 = this24;
            									}
HXDLIN(  49)									Float a11;
HXDLIN(  49)									int this26 = ((this25 >> 24) & 255);
HXDLIN(  49)									if ((this26 == 0)) {
HXDLIN(  49)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r11;
HXDLIN(  49)									int this27 = ((this25 >> 16) & 255);
HXDLIN(  49)									if ((this27 == 0)) {
HXDLIN(  49)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g11;
HXDLIN(  49)									int this28 = ((this25 >> 8) & 255);
HXDLIN(  49)									if ((this28 == 0)) {
HXDLIN(  49)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b12;
HXDLIN(  49)									int this29 = (this25 & 255);
HXDLIN(  49)									if ((this29 == 0)) {
HXDLIN(  49)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a21;
HXDLIN(  49)									int this30 = ((color2 >> 24) & 255);
HXDLIN(  49)									if ((this30 == 0)) {
HXDLIN(  49)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r21;
HXDLIN(  49)									int this31 = ((color2 >> 16) & 255);
HXDLIN(  49)									if ((this31 == 0)) {
HXDLIN(  49)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g21;
HXDLIN(  49)									int this32 = ((color2 >> 8) & 255);
HXDLIN(  49)									if ((this32 == 0)) {
HXDLIN(  49)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b22;
HXDLIN(  49)									int this33 = (color2 & 255);
HXDLIN(  49)									if ((this33 == 0)) {
HXDLIN(  49)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  49)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  49)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  49)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  49)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  49)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp7;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp7 = blended1;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this34 = img->image;
HXDLIN(  49)									int index4;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index4 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  49)									int _hx_tmp8;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp8 = c3;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            								}
            							}
            						}
HXDLIN(  49)						{
HXDLIN(  49)							int x5 = (x3 + places);
HXDLIN(  49)							int y4 = ((img->height - y3) - 1);
HXDLIN(  49)							int color3 = color1->bottom;
HXDLIN(  49)							{
HXDLIN(  49)								int c4 = color3;
HXDLIN(  49)								bool _hx_tmp9;
HXDLIN(  49)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp9 = false;
            								}
HXDLIN(  49)								if (_hx_tmp9) {
HXDLIN(  49)									int location2;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location2 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  49)									int this35 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN(  49)									int this36;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this36 = ((((((this35 >> 24) & 255) << 24) | ((this35 & 255) << 16)) | (((this35 >> 8) & 255) << 8)) | ((this35 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this36 = this35;
            									}
HXDLIN(  49)									Float a12;
HXDLIN(  49)									int this37 = ((this36 >> 24) & 255);
HXDLIN(  49)									if ((this37 == 0)) {
HXDLIN(  49)										a12 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a12 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r12;
HXDLIN(  49)									int this38 = ((this36 >> 16) & 255);
HXDLIN(  49)									if ((this38 == 0)) {
HXDLIN(  49)										r12 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r12 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g12;
HXDLIN(  49)									int this39 = ((this36 >> 8) & 255);
HXDLIN(  49)									if ((this39 == 0)) {
HXDLIN(  49)										g12 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b13;
HXDLIN(  49)									int this40 = (this36 & 255);
HXDLIN(  49)									if ((this40 == 0)) {
HXDLIN(  49)										b13 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b13 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a22;
HXDLIN(  49)									int this41 = ((color3 >> 24) & 255);
HXDLIN(  49)									if ((this41 == 0)) {
HXDLIN(  49)										a22 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a22 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r22;
HXDLIN(  49)									int this42 = ((color3 >> 16) & 255);
HXDLIN(  49)									if ((this42 == 0)) {
HXDLIN(  49)										r22 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r22 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g22;
HXDLIN(  49)									int this43 = ((color3 >> 8) & 255);
HXDLIN(  49)									if ((this43 == 0)) {
HXDLIN(  49)										g22 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b23;
HXDLIN(  49)									int this44 = (color3 & 255);
HXDLIN(  49)									if ((this44 == 0)) {
HXDLIN(  49)										b23 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b23 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  49)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  49)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  49)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  49)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  49)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp10;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp10 = blended2;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this45 = img->image;
HXDLIN(  49)									int index5;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  49)									int _hx_tmp11;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp11 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp11 = c4;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this45,index5,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  49)		{
HXDLIN(  49)			int _g24 = 0;
HXDLIN(  49)			int _g25 = this1->height;
HXDLIN(  49)			while((_g24 < _g25)){
HXDLIN(  49)				_g24 = (_g24 + 1);
HXDLIN(  49)				int y5 = (_g24 - 1);
HXDLIN(  49)				{
HXDLIN(  49)					int _g26 = 0;
HXDLIN(  49)					int _g27 = places;
HXDLIN(  49)					while((_g26 < _g27)){
HXDLIN(  49)						_g26 = (_g26 + 1);
HXDLIN(  49)						int x6 = (_g26 - 1);
HXDLIN(  49)						{
HXDLIN(  49)							int y6 = (y5 + places);
HXDLIN(  49)							int color4 = color1->left;
HXDLIN(  49)							{
HXDLIN(  49)								int c5 = color4;
HXDLIN(  49)								bool _hx_tmp12;
HXDLIN(  49)								if ((((c5 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp12 = false;
            								}
HXDLIN(  49)								if (_hx_tmp12) {
HXDLIN(  49)									int location3;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location3 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  49)									int this46 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN(  49)									int this47;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this47 = this46;
            									}
HXDLIN(  49)									Float a13;
HXDLIN(  49)									int this48 = ((this47 >> 24) & 255);
HXDLIN(  49)									if ((this48 == 0)) {
HXDLIN(  49)										a13 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a13 = (( (Float)(this48) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r13;
HXDLIN(  49)									int this49 = ((this47 >> 16) & 255);
HXDLIN(  49)									if ((this49 == 0)) {
HXDLIN(  49)										r13 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r13 = (( (Float)(this49) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g13;
HXDLIN(  49)									int this50 = ((this47 >> 8) & 255);
HXDLIN(  49)									if ((this50 == 0)) {
HXDLIN(  49)										g13 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g13 = (( (Float)(this50) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b14;
HXDLIN(  49)									int this51 = (this47 & 255);
HXDLIN(  49)									if ((this51 == 0)) {
HXDLIN(  49)										b14 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b14 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a23;
HXDLIN(  49)									int this52 = ((color4 >> 24) & 255);
HXDLIN(  49)									if ((this52 == 0)) {
HXDLIN(  49)										a23 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a23 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r23;
HXDLIN(  49)									int this53 = ((color4 >> 16) & 255);
HXDLIN(  49)									if ((this53 == 0)) {
HXDLIN(  49)										r23 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r23 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g23;
HXDLIN(  49)									int this54 = ((color4 >> 8) & 255);
HXDLIN(  49)									if ((this54 == 0)) {
HXDLIN(  49)										g23 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g23 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b24;
HXDLIN(  49)									int this55 = (color4 & 255);
HXDLIN(  49)									if ((this55 == 0)) {
HXDLIN(  49)										b24 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b24 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  49)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  49)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  49)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  49)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  49)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp13;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp13 = blended3;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this56 = img->image;
HXDLIN(  49)									int index6;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index6 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  49)									int _hx_tmp14;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp14 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp14 = c5;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this56,index6,_hx_tmp14);
            								}
            							}
            						}
HXDLIN(  49)						{
HXDLIN(  49)							int x7 = ((img->width - x6) - 1);
HXDLIN(  49)							int y7 = (y5 + places);
HXDLIN(  49)							int color5 = color1->right;
HXDLIN(  49)							{
HXDLIN(  49)								int c6 = color5;
HXDLIN(  49)								bool _hx_tmp15;
HXDLIN(  49)								if ((((c6 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp15 = false;
            								}
HXDLIN(  49)								if (_hx_tmp15) {
HXDLIN(  49)									int location4;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location4 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  49)									int this57 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN(  49)									int this58;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this58 = this57;
            									}
HXDLIN(  49)									Float a14;
HXDLIN(  49)									int this59 = ((this58 >> 24) & 255);
HXDLIN(  49)									if ((this59 == 0)) {
HXDLIN(  49)										a14 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r14;
HXDLIN(  49)									int this60 = ((this58 >> 16) & 255);
HXDLIN(  49)									if ((this60 == 0)) {
HXDLIN(  49)										r14 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r14 = (( (Float)(this60) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g14;
HXDLIN(  49)									int this61 = ((this58 >> 8) & 255);
HXDLIN(  49)									if ((this61 == 0)) {
HXDLIN(  49)										g14 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g14 = (( (Float)(this61) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b15;
HXDLIN(  49)									int this62 = (this58 & 255);
HXDLIN(  49)									if ((this62 == 0)) {
HXDLIN(  49)										b15 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b15 = (( (Float)(this62) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a24;
HXDLIN(  49)									int this63 = ((color5 >> 24) & 255);
HXDLIN(  49)									if ((this63 == 0)) {
HXDLIN(  49)										a24 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a24 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r24;
HXDLIN(  49)									int this64 = ((color5 >> 16) & 255);
HXDLIN(  49)									if ((this64 == 0)) {
HXDLIN(  49)										r24 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r24 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g24;
HXDLIN(  49)									int this65 = ((color5 >> 8) & 255);
HXDLIN(  49)									if ((this65 == 0)) {
HXDLIN(  49)										g24 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g24 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b25;
HXDLIN(  49)									int this66 = (color5 & 255);
HXDLIN(  49)									if ((this66 == 0)) {
HXDLIN(  49)										b25 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b25 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  49)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  49)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  49)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN(  49)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  49)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp16;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp16 = blended4;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this67 = img->image;
HXDLIN(  49)									int index7;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index7 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  49)									int _hx_tmp17;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp17 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp17 = c6;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this67,index7,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  49)		{
HXDLIN(  49)			int _g28 = 0;
HXDLIN(  49)			int _g29 = places;
HXDLIN(  49)			while((_g28 < _g29)){
HXDLIN(  49)				_g28 = (_g28 + 1);
HXDLIN(  49)				int x8 = (_g28 - 1);
HXDLIN(  49)				{
HXDLIN(  49)					int _g30 = 0;
HXDLIN(  49)					int _g31 = places;
HXDLIN(  49)					while((_g30 < _g31)){
HXDLIN(  49)						_g30 = (_g30 + 1);
HXDLIN(  49)						int y8 = (_g30 - 1);
HXDLIN(  49)						{
HXDLIN(  49)							int color6 = color1->leftTop;
HXDLIN(  49)							{
HXDLIN(  49)								int c7 = color6;
HXDLIN(  49)								bool _hx_tmp18;
HXDLIN(  49)								if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp18 = false;
            								}
HXDLIN(  49)								if (_hx_tmp18) {
HXDLIN(  49)									int location5;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location5 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location5 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            									}
HXDLIN(  49)									int this68 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN(  49)									int this69;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this69 = ((((((this68 >> 24) & 255) << 24) | ((this68 & 255) << 16)) | (((this68 >> 8) & 255) << 8)) | ((this68 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this69 = this68;
            									}
HXDLIN(  49)									Float a15;
HXDLIN(  49)									int this70 = ((this69 >> 24) & 255);
HXDLIN(  49)									if ((this70 == 0)) {
HXDLIN(  49)										a15 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a15 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r15;
HXDLIN(  49)									int this71 = ((this69 >> 16) & 255);
HXDLIN(  49)									if ((this71 == 0)) {
HXDLIN(  49)										r15 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r15 = (( (Float)(this71) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g15;
HXDLIN(  49)									int this72 = ((this69 >> 8) & 255);
HXDLIN(  49)									if ((this72 == 0)) {
HXDLIN(  49)										g15 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g15 = (( (Float)(this72) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b16;
HXDLIN(  49)									int this73 = (this69 & 255);
HXDLIN(  49)									if ((this73 == 0)) {
HXDLIN(  49)										b16 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b16 = (( (Float)(this73) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a25;
HXDLIN(  49)									int this74 = ((color6 >> 24) & 255);
HXDLIN(  49)									if ((this74 == 0)) {
HXDLIN(  49)										a25 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a25 = (( (Float)(this74) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r25;
HXDLIN(  49)									int this75 = ((color6 >> 16) & 255);
HXDLIN(  49)									if ((this75 == 0)) {
HXDLIN(  49)										r25 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r25 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g25;
HXDLIN(  49)									int this76 = ((color6 >> 8) & 255);
HXDLIN(  49)									if ((this76 == 0)) {
HXDLIN(  49)										g25 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g25 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b26;
HXDLIN(  49)									int this77 = (color6 & 255);
HXDLIN(  49)									if ((this77 == 0)) {
HXDLIN(  49)										b26 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b26 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  49)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  49)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  49)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN(  49)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  49)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp19;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp19 = blended5;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this78 = img->image;
HXDLIN(  49)									int index8;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index8 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            									}
HXDLIN(  49)									int _hx_tmp20;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp20 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp20 = c7;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this78,index8,_hx_tmp20);
            								}
            							}
            						}
HXDLIN(  49)						{
HXDLIN(  49)							int x9 = ((x8 + places) + this1->width);
HXDLIN(  49)							int color7 = color1->rightTop;
HXDLIN(  49)							{
HXDLIN(  49)								int c8 = color7;
HXDLIN(  49)								bool _hx_tmp21;
HXDLIN(  49)								if ((((c8 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp21 = false;
            								}
HXDLIN(  49)								if (_hx_tmp21) {
HXDLIN(  49)									int location6;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location6 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN(  49)									int this79 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN(  49)									int this80;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this80 = this79;
            									}
HXDLIN(  49)									Float a16;
HXDLIN(  49)									int this81 = ((this80 >> 24) & 255);
HXDLIN(  49)									if ((this81 == 0)) {
HXDLIN(  49)										a16 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a16 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r16;
HXDLIN(  49)									int this82 = ((this80 >> 16) & 255);
HXDLIN(  49)									if ((this82 == 0)) {
HXDLIN(  49)										r16 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r16 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g16;
HXDLIN(  49)									int this83 = ((this80 >> 8) & 255);
HXDLIN(  49)									if ((this83 == 0)) {
HXDLIN(  49)										g16 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g16 = (( (Float)(this83) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b17;
HXDLIN(  49)									int this84 = (this80 & 255);
HXDLIN(  49)									if ((this84 == 0)) {
HXDLIN(  49)										b17 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a26;
HXDLIN(  49)									int this85 = ((color7 >> 24) & 255);
HXDLIN(  49)									if ((this85 == 0)) {
HXDLIN(  49)										a26 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a26 = (( (Float)(this85) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r26;
HXDLIN(  49)									int this86 = ((color7 >> 16) & 255);
HXDLIN(  49)									if ((this86 == 0)) {
HXDLIN(  49)										r26 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r26 = (( (Float)(this86) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g26;
HXDLIN(  49)									int this87 = ((color7 >> 8) & 255);
HXDLIN(  49)									if ((this87 == 0)) {
HXDLIN(  49)										g26 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g26 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b27;
HXDLIN(  49)									int this88 = (color7 & 255);
HXDLIN(  49)									if ((this88 == 0)) {
HXDLIN(  49)										b27 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b27 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN(  49)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  49)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  49)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN(  49)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  49)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp22;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp22 = blended6;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this89 = img->image;
HXDLIN(  49)									int index9;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN(  49)									int _hx_tmp23;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp23 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp23 = c8;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this89,index9,_hx_tmp23);
            								}
            							}
            						}
HXDLIN(  49)						{
HXDLIN(  49)							int x10 = ((x8 + places) + this1->width);
HXDLIN(  49)							int y9 = ((y8 + places) + this1->height);
HXDLIN(  49)							int color8 = color1->rightBottom;
HXDLIN(  49)							{
HXDLIN(  49)								int c9 = color8;
HXDLIN(  49)								bool _hx_tmp24;
HXDLIN(  49)								if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp24 = false;
            								}
HXDLIN(  49)								if (_hx_tmp24) {
HXDLIN(  49)									int location7;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location7 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location7 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN(  49)									int this90 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN(  49)									int this91;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this91 = this90;
            									}
HXDLIN(  49)									Float a17;
HXDLIN(  49)									int this92 = ((this91 >> 24) & 255);
HXDLIN(  49)									if ((this92 == 0)) {
HXDLIN(  49)										a17 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r17;
HXDLIN(  49)									int this93 = ((this91 >> 16) & 255);
HXDLIN(  49)									if ((this93 == 0)) {
HXDLIN(  49)										r17 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r17 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g17;
HXDLIN(  49)									int this94 = ((this91 >> 8) & 255);
HXDLIN(  49)									if ((this94 == 0)) {
HXDLIN(  49)										g17 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g17 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b18;
HXDLIN(  49)									int this95 = (this91 & 255);
HXDLIN(  49)									if ((this95 == 0)) {
HXDLIN(  49)										b18 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b18 = (( (Float)(this95) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a27;
HXDLIN(  49)									int this96 = ((color8 >> 24) & 255);
HXDLIN(  49)									if ((this96 == 0)) {
HXDLIN(  49)										a27 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a27 = (( (Float)(this96) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r27;
HXDLIN(  49)									int this97 = ((color8 >> 16) & 255);
HXDLIN(  49)									if ((this97 == 0)) {
HXDLIN(  49)										r27 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r27 = (( (Float)(this97) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g27;
HXDLIN(  49)									int this98 = ((color8 >> 8) & 255);
HXDLIN(  49)									if ((this98 == 0)) {
HXDLIN(  49)										g27 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g27 = (( (Float)(this98) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b28;
HXDLIN(  49)									int this99 = (color8 & 255);
HXDLIN(  49)									if ((this99 == 0)) {
HXDLIN(  49)										b28 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b28 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN(  49)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  49)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  49)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN(  49)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  49)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp25;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp25 = blended7;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this100 = img->image;
HXDLIN(  49)									int index10;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index10 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN(  49)									int _hx_tmp26;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp26 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp26 = c9;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp26);
            								}
            							}
            						}
HXDLIN(  49)						{
HXDLIN(  49)							int y10 = ((y8 + places) + this1->width);
HXDLIN(  49)							int color9 = color1->leftBottom;
HXDLIN(  49)							{
HXDLIN(  49)								int c10 = color9;
HXDLIN(  49)								bool _hx_tmp27;
HXDLIN(  49)								if ((((c10 >> 24) & 255) < 254)) {
HXDLIN(  49)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXDLIN(  49)									_hx_tmp27 = false;
            								}
HXDLIN(  49)								if (_hx_tmp27) {
HXDLIN(  49)									int location8;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										location8 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										location8 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN(  49)									int this101 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN(  49)									int this102;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										this102 = ((((((this101 >> 24) & 255) << 24) | ((this101 & 255) << 16)) | (((this101 >> 8) & 255) << 8)) | ((this101 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										this102 = this101;
            									}
HXDLIN(  49)									Float a19;
HXDLIN(  49)									int this103 = ((this102 >> 24) & 255);
HXDLIN(  49)									if ((this103 == 0)) {
HXDLIN(  49)										a19 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a19 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r18;
HXDLIN(  49)									int this104 = ((this102 >> 16) & 255);
HXDLIN(  49)									if ((this104 == 0)) {
HXDLIN(  49)										r18 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r18 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g18;
HXDLIN(  49)									int this105 = ((this102 >> 8) & 255);
HXDLIN(  49)									if ((this105 == 0)) {
HXDLIN(  49)										g18 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g18 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b19;
HXDLIN(  49)									int this106 = (this102 & 255);
HXDLIN(  49)									if ((this106 == 0)) {
HXDLIN(  49)										b19 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b19 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a28;
HXDLIN(  49)									int this107 = ((color9 >> 24) & 255);
HXDLIN(  49)									if ((this107 == 0)) {
HXDLIN(  49)										a28 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										a28 = (( (Float)(this107) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r28;
HXDLIN(  49)									int this108 = ((color9 >> 16) & 255);
HXDLIN(  49)									if ((this108 == 0)) {
HXDLIN(  49)										r28 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										r28 = (( (Float)(this108) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g28;
HXDLIN(  49)									int this109 = ((color9 >> 8) & 255);
HXDLIN(  49)									if ((this109 == 0)) {
HXDLIN(  49)										g28 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										g28 = (( (Float)(this109) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b29;
HXDLIN(  49)									int this110 = (color9 & 255);
HXDLIN(  49)									if ((this110 == 0)) {
HXDLIN(  49)										b29 = ((Float)0.);
            									}
            									else {
HXDLIN(  49)										b29 = (( (Float)(this110) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN(  49)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN(  49)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN(  49)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN(  49)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN(  49)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN(  49)									{
HXDLIN(  49)										int _hx_tmp28;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXDLIN(  49)											_hx_tmp28 = blended8;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXDLIN(  49)									::Dynamic this111 = img->image;
HXDLIN(  49)									int index11;
HXDLIN(  49)									if (img->useVirtualPos) {
HXDLIN(  49)										index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN(  49)										index11 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN(  49)									int _hx_tmp29;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)										_hx_tmp29 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN(  49)										_hx_tmp29 = c10;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this111,index11,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  49)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectanglePad_Impl__obj,colorPadImage,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::colorPadImageXY( ::pi_xy::ImageStruct this1,int placesX,int placesY, ::pi_xy::imageAbstracts::NineColorBorder color){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_52_colorPadImageXY)
HXLINE(  53)		int width = (this1->width + (2 * placesX));
HXDLIN(  53)		int height = (this1->height + (2 * placesY));
HXDLIN(  53)		 ::Dynamic imageType = null();
HXDLIN(  53)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  53)		if (::hx::IsNull( imageType )) {
HXLINE(  53)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  53)		::Dynamic _hx_tmp;
HXDLIN(  53)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  53)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  53)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  53)				{
HXLINE(  53)					b->width = width;
HXDLIN(  53)					b->height = height;
HXDLIN(  53)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  53)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  53)					{
HXLINE(  53)						int len = b->length;
HXDLIN(  53)						int w = 0;
HXDLIN(  53)						{
HXLINE(  53)							int _g = 0;
HXDLIN(  53)							int _g1 = b->height;
HXDLIN(  53)							while((_g < _g1)){
HXLINE(  53)								_g = (_g + 1);
HXDLIN(  53)								int y = (_g - 1);
HXDLIN(  53)								{
HXLINE(  53)									int _g2 = 0;
HXDLIN(  53)									int _g3 = b->width;
HXDLIN(  53)									while((_g2 < _g3)){
HXLINE(  53)										_g2 = (_g2 + 1);
HXDLIN(  53)										int x = (_g2 - 1);
HXDLIN(  53)										{
HXLINE(  53)											w = (w + 1);
HXDLIN(  53)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  53)										{
HXLINE(  53)											w = (w + 1);
HXDLIN(  53)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  53)										{
HXLINE(  53)											w = (w + 1);
HXDLIN(  53)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  53)										{
HXLINE(  53)											w = (w + 1);
HXDLIN(  53)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  53)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  53)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  53)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  53)				{
HXLINE(  53)					a->width = width;
HXDLIN(  53)					a->height = height;
HXDLIN(  53)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  53)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  53)					{
HXLINE(  53)						int _g4 = 0;
HXDLIN(  53)						int _g5 = a->length;
HXDLIN(  53)						while((_g4 < _g5)){
HXLINE(  53)							_g4 = (_g4 + 1);
HXDLIN(  53)							int i = (_g4 - 1);
HXDLIN(  53)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  53)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  53)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  53)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  53)				{
HXLINE(  53)					b1->width = width;
HXDLIN(  53)					b1->height = height;
HXDLIN(  53)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  53)					int size = (b1->length * 4);
HXDLIN(  53)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  53)					{
HXLINE(  53)						int _g6 = 0;
HXDLIN(  53)						int _g7 = b1->length;
HXDLIN(  53)						while((_g6 < _g7)){
HXLINE(  53)							_g6 = (_g6 + 1);
HXDLIN(  53)							int i1 = (_g6 - 1);
HXDLIN(  53)							{
HXLINE(  53)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  53)								bool _hx_tmp1;
HXDLIN(  53)								if ((i1 >= 0)) {
HXLINE(  53)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  53)									_hx_tmp1 = false;
            								}
HXDLIN(  53)								if (_hx_tmp1) {
HXLINE(  53)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  53)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  53)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  53)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  53)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  53)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  53)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  53)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  53)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  53)				{
HXLINE(  53)					v->width = width;
HXDLIN(  53)					v->height = height;
HXDLIN(  53)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  53)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  53)					{
HXLINE(  53)						int _g8 = 0;
HXDLIN(  53)						int _g9 = v->length;
HXDLIN(  53)						while((_g8 < _g9)){
HXLINE(  53)							_g8 = (_g8 + 1);
HXDLIN(  53)							int i2 = (_g8 - 1);
HXDLIN(  53)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  53)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  53)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  53)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  53)				{
HXLINE(  53)					b2->width = width;
HXDLIN(  53)					b2->height = height;
HXDLIN(  53)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  53)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  53)					{
HXLINE(  53)						int len1 = b2->length;
HXDLIN(  53)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  53)						if (::hx::IsNull( d->head )) {
HXLINE(  53)							int _g10 = 0;
HXDLIN(  53)							int _g11 = len1;
HXDLIN(  53)							while((_g10 < _g11)){
HXLINE(  53)								_g10 = (_g10 + 1);
HXDLIN(  53)								int i3 = (_g10 - 1);
HXDLIN(  53)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  53)							int _g12 = 0;
HXDLIN(  53)							int _g13 = len1;
HXDLIN(  53)							while((_g12 < _g13)){
HXLINE(  53)								_g12 = (_g12 + 1);
HXDLIN(  53)								int i4 = (_g12 - 1);
HXDLIN(  53)								{
HXLINE(  53)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  53)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  53)									{
HXLINE(  53)										int _g14 = 0;
HXDLIN(  53)										int _g15 = i4;
HXDLIN(  53)										while((_g14 < _g15)){
HXLINE(  53)											_g14 = (_g14 + 1);
HXDLIN(  53)											int i5 = (_g14 - 1);
HXDLIN(  53)											prev = l;
HXDLIN(  53)											l = l->next;
            										}
            									}
HXDLIN(  53)									if (::hx::IsNull( prev )) {
HXLINE(  53)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  53)										l = null();
            									}
            									else {
HXLINE(  53)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  53)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  53)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  53)		this2->image = _hx_tmp;
HXDLIN(  53)		this2->width = width;
HXDLIN(  53)		this2->height = height;
HXDLIN(  53)		this2->imageType = ( (int)(imageType) );
HXDLIN(  53)		 ::pi_xy::ImageStruct img = this2;
HXLINE(  54)		{
HXLINE(  54)			bool forceClear = false;
HXDLIN(  54)			{
HXLINE(  54)				int _g16 = 0;
HXDLIN(  54)				int _g17 = this1->height;
HXDLIN(  54)				while((_g16 < _g17)){
HXLINE(  54)					_g16 = (_g16 + 1);
HXDLIN(  54)					int dy = (_g16 - 1);
HXDLIN(  54)					{
HXLINE(  54)						int _g18 = 0;
HXDLIN(  54)						int _g19 = this1->width;
HXDLIN(  54)						while((_g18 < _g19)){
HXLINE(  54)							_g18 = (_g18 + 1);
HXDLIN(  54)							int dx = (_g18 - 1);
HXDLIN(  54)							::Dynamic this4 = this1->image;
HXDLIN(  54)							int index;
HXDLIN(  54)							if (this1->useVirtualPos) {
HXLINE(  54)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXLINE(  54)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN(  54)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  54)							int col;
HXDLIN(  54)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  54)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  54)								col = c;
            							}
HXDLIN(  54)							bool _hx_tmp2;
HXDLIN(  54)							if (this1->useMask) {
HXLINE(  54)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXLINE(  54)								_hx_tmp2 = false;
            							}
HXDLIN(  54)							if (_hx_tmp2) {
HXLINE(  54)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  54)								::Dynamic this6 = this5->image;
HXDLIN(  54)								int index1;
HXDLIN(  54)								if (this5->useVirtualPos) {
HXLINE(  54)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXLINE(  54)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN(  54)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  54)								int v1;
HXDLIN(  54)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  54)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  54)									v1 = c1;
            								}
HXDLIN(  54)								int maskPixel = v1;
HXDLIN(  54)								int this7 = col;
HXDLIN(  54)								if ((maskPixel == 0)) {
HXLINE(  54)									col = this7;
            								}
            								else {
HXLINE(  54)									Float m0;
HXDLIN(  54)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  54)									if ((this8 == 0)) {
HXLINE(  54)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float m1;
HXDLIN(  54)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  54)									if ((this9 == 0)) {
HXLINE(  54)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float m2;
HXDLIN(  54)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  54)									if ((this10 == 0)) {
HXLINE(  54)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float m3;
HXDLIN(  54)									int this11 = (maskPixel & 255);
HXDLIN(  54)									if ((this11 == 0)) {
HXLINE(  54)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  54)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  54)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  54)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  54)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  54)							if ((col != 0)) {
HXLINE(  54)								int x1 = (placesX + dx);
HXDLIN(  54)								int y1 = (placesY + dy);
HXDLIN(  54)								int c2 = col;
HXDLIN(  54)								bool _hx_tmp3;
HXDLIN(  54)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  54)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXLINE(  54)									_hx_tmp3 = false;
            								}
HXDLIN(  54)								if (_hx_tmp3) {
HXLINE(  54)									int location;
HXDLIN(  54)									if (img->useVirtualPos) {
HXLINE(  54)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE(  54)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  54)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN(  54)									int this13;
HXDLIN(  54)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  54)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXLINE(  54)										this13 = this12;
            									}
HXDLIN(  54)									Float a1;
HXDLIN(  54)									int this14 = ((this13 >> 24) & 255);
HXDLIN(  54)									if ((this14 == 0)) {
HXLINE(  54)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float r1;
HXDLIN(  54)									int this15 = ((this13 >> 16) & 255);
HXDLIN(  54)									if ((this15 == 0)) {
HXLINE(  54)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float g1;
HXDLIN(  54)									int this16 = ((this13 >> 8) & 255);
HXDLIN(  54)									if ((this16 == 0)) {
HXLINE(  54)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float b11;
HXDLIN(  54)									int this17 = (this13 & 255);
HXDLIN(  54)									if ((this17 == 0)) {
HXLINE(  54)										b11 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float a2;
HXDLIN(  54)									int this18 = ((col >> 24) & 255);
HXDLIN(  54)									if ((this18 == 0)) {
HXLINE(  54)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float r2;
HXDLIN(  54)									int this19 = ((col >> 16) & 255);
HXDLIN(  54)									if ((this19 == 0)) {
HXLINE(  54)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float g2;
HXDLIN(  54)									int this20 = ((col >> 8) & 255);
HXDLIN(  54)									if ((this20 == 0)) {
HXLINE(  54)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float b21;
HXDLIN(  54)									int this21 = (col & 255);
HXDLIN(  54)									if ((this21 == 0)) {
HXLINE(  54)										b21 = ((Float)0.);
            									}
            									else {
HXLINE(  54)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN(  54)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  54)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  54)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  54)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  54)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  54)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  54)									{
HXLINE(  54)										int _hx_tmp4;
HXDLIN(  54)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  54)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  54)											_hx_tmp4 = blended;
            										}
HXDLIN(  54)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE(  54)									::Dynamic this22 = img->image;
HXDLIN(  54)									int index2;
HXDLIN(  54)									if (img->useVirtualPos) {
HXLINE(  54)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE(  54)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  54)									int _hx_tmp5;
HXDLIN(  54)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  54)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE(  54)										_hx_tmp5 = c2;
            									}
HXDLIN(  54)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE(  54)								if (forceClear) {
HXLINE(  54)									::Dynamic this23 = img->image;
HXDLIN(  54)									int x2 = (placesX + dx);
HXDLIN(  54)									int y2 = (placesY + dy);
HXDLIN(  54)									int index3;
HXDLIN(  54)									if (img->useVirtualPos) {
HXLINE(  54)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXLINE(  54)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN(  54)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  55)		if (::hx::IsNull( color )) {
HXLINE(  55)			color =  ::pi_xy::imageAbstracts::NineColorBorder_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null(),null());
            		}
HXLINE(  57)		{
HXLINE(  57)			int _g20 = 0;
HXDLIN(  57)			int _g21 = this1->width;
HXDLIN(  57)			while((_g20 < _g21)){
HXLINE(  57)				_g20 = (_g20 + 1);
HXDLIN(  57)				int x3 = (_g20 - 1);
HXDLIN(  57)				{
HXLINE(  57)					int _g22 = 0;
HXDLIN(  57)					int _g23 = placesY;
HXDLIN(  57)					while((_g22 < _g23)){
HXLINE(  57)						_g22 = (_g22 + 1);
HXDLIN(  57)						int y3 = (_g22 - 1);
HXLINE(  59)						{
HXLINE(  59)							int x4 = (x3 + placesX);
HXDLIN(  59)							int color1 = color->top;
HXDLIN(  59)							{
HXLINE(  59)								int c3 = color1;
HXDLIN(  59)								bool _hx_tmp6;
HXDLIN(  59)								if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  59)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXLINE(  59)									_hx_tmp6 = false;
            								}
HXDLIN(  59)								if (_hx_tmp6) {
HXLINE(  59)									int location1;
HXDLIN(  59)									if (img->useVirtualPos) {
HXLINE(  59)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE(  59)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  59)									int this24 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN(  59)									int this25;
HXDLIN(  59)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										this25 = this24;
            									}
HXDLIN(  59)									Float a11;
HXDLIN(  59)									int this26 = ((this25 >> 24) & 255);
HXDLIN(  59)									if ((this26 == 0)) {
HXLINE(  59)										a11 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r11;
HXDLIN(  59)									int this27 = ((this25 >> 16) & 255);
HXDLIN(  59)									if ((this27 == 0)) {
HXLINE(  59)										r11 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g11;
HXDLIN(  59)									int this28 = ((this25 >> 8) & 255);
HXDLIN(  59)									if ((this28 == 0)) {
HXLINE(  59)										g11 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b12;
HXDLIN(  59)									int this29 = (this25 & 255);
HXDLIN(  59)									if ((this29 == 0)) {
HXLINE(  59)										b12 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a21;
HXDLIN(  59)									int this30 = ((color1 >> 24) & 255);
HXDLIN(  59)									if ((this30 == 0)) {
HXLINE(  59)										a21 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r21;
HXDLIN(  59)									int this31 = ((color1 >> 16) & 255);
HXDLIN(  59)									if ((this31 == 0)) {
HXLINE(  59)										r21 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g21;
HXDLIN(  59)									int this32 = ((color1 >> 8) & 255);
HXDLIN(  59)									if ((this32 == 0)) {
HXLINE(  59)										g21 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b22;
HXDLIN(  59)									int this33 = (color1 & 255);
HXDLIN(  59)									if ((this33 == 0)) {
HXLINE(  59)										b22 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  59)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  59)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  59)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  59)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  59)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  59)									{
HXLINE(  59)										int _hx_tmp7;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											_hx_tmp7 = blended1;
            										}
HXDLIN(  59)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE(  59)									::Dynamic this34 = img->image;
HXDLIN(  59)									int index4;
HXDLIN(  59)									if (img->useVirtualPos) {
HXLINE(  59)										index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE(  59)										index4 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  59)									int _hx_tmp8;
HXDLIN(  59)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										_hx_tmp8 = c3;
            									}
HXDLIN(  59)									::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            								}
            							}
            						}
HXLINE(  61)						{
HXLINE(  61)							int x5 = (x3 + placesX);
HXDLIN(  61)							int y4 = ((img->height - y3) - 1);
HXDLIN(  61)							int color2 = color->bottom;
HXDLIN(  61)							{
HXLINE(  61)								int c4 = color2;
HXDLIN(  61)								bool _hx_tmp9;
HXDLIN(  61)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp9 = false;
            								}
HXDLIN(  61)								if (_hx_tmp9) {
HXLINE(  61)									int location2;
HXDLIN(  61)									if (img->useVirtualPos) {
HXLINE(  61)										location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE(  61)										location2 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  61)									int this35 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN(  61)									int this36;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this36 = ((((((this35 >> 24) & 255) << 24) | ((this35 & 255) << 16)) | (((this35 >> 8) & 255) << 8)) | ((this35 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this36 = this35;
            									}
HXDLIN(  61)									Float a12;
HXDLIN(  61)									int this37 = ((this36 >> 24) & 255);
HXDLIN(  61)									if ((this37 == 0)) {
HXLINE(  61)										a12 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a12 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r12;
HXDLIN(  61)									int this38 = ((this36 >> 16) & 255);
HXDLIN(  61)									if ((this38 == 0)) {
HXLINE(  61)										r12 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r12 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g12;
HXDLIN(  61)									int this39 = ((this36 >> 8) & 255);
HXDLIN(  61)									if ((this39 == 0)) {
HXLINE(  61)										g12 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b13;
HXDLIN(  61)									int this40 = (this36 & 255);
HXDLIN(  61)									if ((this40 == 0)) {
HXLINE(  61)										b13 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b13 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a22;
HXDLIN(  61)									int this41 = ((color2 >> 24) & 255);
HXDLIN(  61)									if ((this41 == 0)) {
HXLINE(  61)										a22 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a22 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r22;
HXDLIN(  61)									int this42 = ((color2 >> 16) & 255);
HXDLIN(  61)									if ((this42 == 0)) {
HXLINE(  61)										r22 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r22 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g22;
HXDLIN(  61)									int this43 = ((color2 >> 8) & 255);
HXDLIN(  61)									if ((this43 == 0)) {
HXLINE(  61)										g22 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b23;
HXDLIN(  61)									int this44 = (color2 & 255);
HXDLIN(  61)									if ((this44 == 0)) {
HXLINE(  61)										b23 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b23 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  61)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  61)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  61)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  61)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  61)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  61)									{
HXLINE(  61)										int _hx_tmp10;
HXDLIN(  61)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE(  61)											_hx_tmp10 = blended2;
            										}
HXDLIN(  61)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXLINE(  61)									::Dynamic this45 = img->image;
HXDLIN(  61)									int index5;
HXDLIN(  61)									if (img->useVirtualPos) {
HXLINE(  61)										index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE(  61)										index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  61)									int _hx_tmp11;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										_hx_tmp11 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										_hx_tmp11 = c4;
            									}
HXDLIN(  61)									::iterMagic::Iimg_obj::set(this45,index5,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  63)		{
HXLINE(  63)			int _g24 = 0;
HXDLIN(  63)			int _g25 = this1->height;
HXDLIN(  63)			while((_g24 < _g25)){
HXLINE(  63)				_g24 = (_g24 + 1);
HXDLIN(  63)				int y5 = (_g24 - 1);
HXDLIN(  63)				{
HXLINE(  63)					int _g26 = 0;
HXDLIN(  63)					int _g27 = placesX;
HXDLIN(  63)					while((_g26 < _g27)){
HXLINE(  63)						_g26 = (_g26 + 1);
HXDLIN(  63)						int x6 = (_g26 - 1);
HXLINE(  65)						{
HXLINE(  65)							int y6 = (y5 + placesY);
HXDLIN(  65)							int color3 = color->left;
HXDLIN(  65)							{
HXLINE(  65)								int c5 = color3;
HXDLIN(  65)								bool _hx_tmp12;
HXDLIN(  65)								if ((((c5 >> 24) & 255) < 254)) {
HXLINE(  65)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXLINE(  65)									_hx_tmp12 = false;
            								}
HXDLIN(  65)								if (_hx_tmp12) {
HXLINE(  65)									int location3;
HXDLIN(  65)									if (img->useVirtualPos) {
HXLINE(  65)										location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE(  65)										location3 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  65)									int this46 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN(  65)									int this47;
HXDLIN(  65)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)										this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            									}
            									else {
HXLINE(  65)										this47 = this46;
            									}
HXDLIN(  65)									Float a13;
HXDLIN(  65)									int this48 = ((this47 >> 24) & 255);
HXDLIN(  65)									if ((this48 == 0)) {
HXLINE(  65)										a13 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										a13 = (( (Float)(this48) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float r13;
HXDLIN(  65)									int this49 = ((this47 >> 16) & 255);
HXDLIN(  65)									if ((this49 == 0)) {
HXLINE(  65)										r13 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										r13 = (( (Float)(this49) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float g13;
HXDLIN(  65)									int this50 = ((this47 >> 8) & 255);
HXDLIN(  65)									if ((this50 == 0)) {
HXLINE(  65)										g13 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										g13 = (( (Float)(this50) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float b14;
HXDLIN(  65)									int this51 = (this47 & 255);
HXDLIN(  65)									if ((this51 == 0)) {
HXLINE(  65)										b14 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										b14 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float a23;
HXDLIN(  65)									int this52 = ((color3 >> 24) & 255);
HXDLIN(  65)									if ((this52 == 0)) {
HXLINE(  65)										a23 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										a23 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float r23;
HXDLIN(  65)									int this53 = ((color3 >> 16) & 255);
HXDLIN(  65)									if ((this53 == 0)) {
HXLINE(  65)										r23 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										r23 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float g23;
HXDLIN(  65)									int this54 = ((color3 >> 8) & 255);
HXDLIN(  65)									if ((this54 == 0)) {
HXLINE(  65)										g23 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										g23 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float b24;
HXDLIN(  65)									int this55 = (color3 & 255);
HXDLIN(  65)									if ((this55 == 0)) {
HXLINE(  65)										b24 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										b24 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  65)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  65)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  65)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  65)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  65)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  65)									{
HXLINE(  65)										int _hx_tmp13;
HXDLIN(  65)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											_hx_tmp13 = blended3;
            										}
HXDLIN(  65)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXLINE(  65)									::Dynamic this56 = img->image;
HXDLIN(  65)									int index6;
HXDLIN(  65)									if (img->useVirtualPos) {
HXLINE(  65)										index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE(  65)										index6 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  65)									int _hx_tmp14;
HXDLIN(  65)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)										_hx_tmp14 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE(  65)										_hx_tmp14 = c5;
            									}
HXDLIN(  65)									::iterMagic::Iimg_obj::set(this56,index6,_hx_tmp14);
            								}
            							}
            						}
HXLINE(  67)						{
HXLINE(  67)							int x7 = ((img->width - x6) - 1);
HXDLIN(  67)							int y7 = (y5 + placesY);
HXDLIN(  67)							int color4 = color->right;
HXDLIN(  67)							{
HXLINE(  67)								int c6 = color4;
HXDLIN(  67)								bool _hx_tmp15;
HXDLIN(  67)								if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  67)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXLINE(  67)									_hx_tmp15 = false;
            								}
HXDLIN(  67)								if (_hx_tmp15) {
HXLINE(  67)									int location4;
HXDLIN(  67)									if (img->useVirtualPos) {
HXLINE(  67)										location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE(  67)										location4 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  67)									int this57 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN(  67)									int this58;
HXDLIN(  67)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  67)										this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            									}
            									else {
HXLINE(  67)										this58 = this57;
            									}
HXDLIN(  67)									Float a14;
HXDLIN(  67)									int this59 = ((this58 >> 24) & 255);
HXDLIN(  67)									if ((this59 == 0)) {
HXLINE(  67)										a14 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float r14;
HXDLIN(  67)									int this60 = ((this58 >> 16) & 255);
HXDLIN(  67)									if ((this60 == 0)) {
HXLINE(  67)										r14 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										r14 = (( (Float)(this60) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float g14;
HXDLIN(  67)									int this61 = ((this58 >> 8) & 255);
HXDLIN(  67)									if ((this61 == 0)) {
HXLINE(  67)										g14 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										g14 = (( (Float)(this61) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float b15;
HXDLIN(  67)									int this62 = (this58 & 255);
HXDLIN(  67)									if ((this62 == 0)) {
HXLINE(  67)										b15 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										b15 = (( (Float)(this62) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float a24;
HXDLIN(  67)									int this63 = ((color4 >> 24) & 255);
HXDLIN(  67)									if ((this63 == 0)) {
HXLINE(  67)										a24 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										a24 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float r24;
HXDLIN(  67)									int this64 = ((color4 >> 16) & 255);
HXDLIN(  67)									if ((this64 == 0)) {
HXLINE(  67)										r24 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										r24 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float g24;
HXDLIN(  67)									int this65 = ((color4 >> 8) & 255);
HXDLIN(  67)									if ((this65 == 0)) {
HXLINE(  67)										g24 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										g24 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float b25;
HXDLIN(  67)									int this66 = (color4 & 255);
HXDLIN(  67)									if ((this66 == 0)) {
HXLINE(  67)										b25 = ((Float)0.);
            									}
            									else {
HXLINE(  67)										b25 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN(  67)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  67)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  67)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  67)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN(  67)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  67)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN(  67)									{
HXLINE(  67)										int _hx_tmp16;
HXDLIN(  67)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  67)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXLINE(  67)											_hx_tmp16 = blended4;
            										}
HXDLIN(  67)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXLINE(  67)									::Dynamic this67 = img->image;
HXDLIN(  67)									int index7;
HXDLIN(  67)									if (img->useVirtualPos) {
HXLINE(  67)										index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE(  67)										index7 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  67)									int _hx_tmp17;
HXDLIN(  67)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  67)										_hx_tmp17 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE(  67)										_hx_tmp17 = c6;
            									}
HXDLIN(  67)									::iterMagic::Iimg_obj::set(this67,index7,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  70)		{
HXLINE(  70)			int _g28 = 0;
HXDLIN(  70)			int _g29 = placesX;
HXDLIN(  70)			while((_g28 < _g29)){
HXLINE(  70)				_g28 = (_g28 + 1);
HXDLIN(  70)				int x8 = (_g28 - 1);
HXDLIN(  70)				{
HXLINE(  70)					int _g30 = 0;
HXDLIN(  70)					int _g31 = placesY;
HXDLIN(  70)					while((_g30 < _g31)){
HXLINE(  70)						_g30 = (_g30 + 1);
HXDLIN(  70)						int y8 = (_g30 - 1);
HXLINE(  72)						{
HXLINE(  72)							int color5 = color->leftTop;
HXDLIN(  72)							{
HXLINE(  72)								int c7 = color5;
HXDLIN(  72)								bool _hx_tmp18;
HXDLIN(  72)								if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  72)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXLINE(  72)									_hx_tmp18 = false;
            								}
HXDLIN(  72)								if (_hx_tmp18) {
HXLINE(  72)									int location5;
HXDLIN(  72)									if (img->useVirtualPos) {
HXLINE(  72)										location5 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE(  72)										location5 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            									}
HXDLIN(  72)									int this68 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN(  72)									int this69;
HXDLIN(  72)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)										this69 = ((((((this68 >> 24) & 255) << 24) | ((this68 & 255) << 16)) | (((this68 >> 8) & 255) << 8)) | ((this68 >> 16) & 255));
            									}
            									else {
HXLINE(  72)										this69 = this68;
            									}
HXDLIN(  72)									Float a15;
HXDLIN(  72)									int this70 = ((this69 >> 24) & 255);
HXDLIN(  72)									if ((this70 == 0)) {
HXLINE(  72)										a15 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										a15 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float r15;
HXDLIN(  72)									int this71 = ((this69 >> 16) & 255);
HXDLIN(  72)									if ((this71 == 0)) {
HXLINE(  72)										r15 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										r15 = (( (Float)(this71) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float g15;
HXDLIN(  72)									int this72 = ((this69 >> 8) & 255);
HXDLIN(  72)									if ((this72 == 0)) {
HXLINE(  72)										g15 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										g15 = (( (Float)(this72) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float b16;
HXDLIN(  72)									int this73 = (this69 & 255);
HXDLIN(  72)									if ((this73 == 0)) {
HXLINE(  72)										b16 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										b16 = (( (Float)(this73) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float a25;
HXDLIN(  72)									int this74 = ((color5 >> 24) & 255);
HXDLIN(  72)									if ((this74 == 0)) {
HXLINE(  72)										a25 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										a25 = (( (Float)(this74) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float r25;
HXDLIN(  72)									int this75 = ((color5 >> 16) & 255);
HXDLIN(  72)									if ((this75 == 0)) {
HXLINE(  72)										r25 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										r25 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float g25;
HXDLIN(  72)									int this76 = ((color5 >> 8) & 255);
HXDLIN(  72)									if ((this76 == 0)) {
HXLINE(  72)										g25 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										g25 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float b26;
HXDLIN(  72)									int this77 = (color5 & 255);
HXDLIN(  72)									if ((this77 == 0)) {
HXLINE(  72)										b26 = ((Float)0.);
            									}
            									else {
HXLINE(  72)										b26 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN(  72)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  72)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  72)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  72)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN(  72)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  72)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN(  72)									{
HXLINE(  72)										int _hx_tmp19;
HXDLIN(  72)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXLINE(  72)											_hx_tmp19 = blended5;
            										}
HXDLIN(  72)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXLINE(  72)									::Dynamic this78 = img->image;
HXDLIN(  72)									int index8;
HXDLIN(  72)									if (img->useVirtualPos) {
HXLINE(  72)										index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE(  72)										index8 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            									}
HXDLIN(  72)									int _hx_tmp20;
HXDLIN(  72)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)										_hx_tmp20 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE(  72)										_hx_tmp20 = c7;
            									}
HXDLIN(  72)									::iterMagic::Iimg_obj::set(this78,index8,_hx_tmp20);
            								}
            							}
            						}
HXLINE(  73)						{
HXLINE(  73)							int x9 = ((x8 + placesX) + this1->width);
HXDLIN(  73)							int color6 = color->rightTop;
HXDLIN(  73)							{
HXLINE(  73)								int c8 = color6;
HXDLIN(  73)								bool _hx_tmp21;
HXDLIN(  73)								if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  73)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXLINE(  73)									_hx_tmp21 = false;
            								}
HXDLIN(  73)								if (_hx_tmp21) {
HXLINE(  73)									int location6;
HXDLIN(  73)									if (img->useVirtualPos) {
HXLINE(  73)										location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE(  73)										location6 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN(  73)									int this79 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN(  73)									int this80;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            									}
            									else {
HXLINE(  73)										this80 = this79;
            									}
HXDLIN(  73)									Float a16;
HXDLIN(  73)									int this81 = ((this80 >> 24) & 255);
HXDLIN(  73)									if ((this81 == 0)) {
HXLINE(  73)										a16 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										a16 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float r16;
HXDLIN(  73)									int this82 = ((this80 >> 16) & 255);
HXDLIN(  73)									if ((this82 == 0)) {
HXLINE(  73)										r16 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										r16 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float g16;
HXDLIN(  73)									int this83 = ((this80 >> 8) & 255);
HXDLIN(  73)									if ((this83 == 0)) {
HXLINE(  73)										g16 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										g16 = (( (Float)(this83) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float b17;
HXDLIN(  73)									int this84 = (this80 & 255);
HXDLIN(  73)									if ((this84 == 0)) {
HXLINE(  73)										b17 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float a26;
HXDLIN(  73)									int this85 = ((color6 >> 24) & 255);
HXDLIN(  73)									if ((this85 == 0)) {
HXLINE(  73)										a26 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										a26 = (( (Float)(this85) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float r26;
HXDLIN(  73)									int this86 = ((color6 >> 16) & 255);
HXDLIN(  73)									if ((this86 == 0)) {
HXLINE(  73)										r26 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										r26 = (( (Float)(this86) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float g26;
HXDLIN(  73)									int this87 = ((color6 >> 8) & 255);
HXDLIN(  73)									if ((this87 == 0)) {
HXLINE(  73)										g26 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										g26 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float b27;
HXDLIN(  73)									int this88 = (color6 & 255);
HXDLIN(  73)									if ((this88 == 0)) {
HXLINE(  73)										b27 = ((Float)0.);
            									}
            									else {
HXLINE(  73)										b27 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN(  73)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN(  73)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  73)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  73)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN(  73)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  73)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN(  73)									{
HXLINE(  73)										int _hx_tmp22;
HXDLIN(  73)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXLINE(  73)											_hx_tmp22 = blended6;
            										}
HXDLIN(  73)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXLINE(  73)									::Dynamic this89 = img->image;
HXDLIN(  73)									int index9;
HXDLIN(  73)									if (img->useVirtualPos) {
HXLINE(  73)										index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE(  73)										index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN(  73)									int _hx_tmp23;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										_hx_tmp23 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE(  73)										_hx_tmp23 = c8;
            									}
HXDLIN(  73)									::iterMagic::Iimg_obj::set(this89,index9,_hx_tmp23);
            								}
            							}
            						}
HXLINE(  74)						{
HXLINE(  74)							int x10 = ((x8 + placesX) + this1->width);
HXDLIN(  74)							int y9 = ((y8 + placesY) + this1->height);
HXDLIN(  74)							int color7 = color->rightBottom;
HXDLIN(  74)							{
HXLINE(  74)								int c9 = color7;
HXDLIN(  74)								bool _hx_tmp24;
HXDLIN(  74)								if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  74)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXLINE(  74)									_hx_tmp24 = false;
            								}
HXDLIN(  74)								if (_hx_tmp24) {
HXLINE(  74)									int location7;
HXDLIN(  74)									if (img->useVirtualPos) {
HXLINE(  74)										location7 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE(  74)										location7 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN(  74)									int this90 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN(  74)									int this91;
HXDLIN(  74)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)										this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            									}
            									else {
HXLINE(  74)										this91 = this90;
            									}
HXDLIN(  74)									Float a17;
HXDLIN(  74)									int this92 = ((this91 >> 24) & 255);
HXDLIN(  74)									if ((this92 == 0)) {
HXLINE(  74)										a17 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float r17;
HXDLIN(  74)									int this93 = ((this91 >> 16) & 255);
HXDLIN(  74)									if ((this93 == 0)) {
HXLINE(  74)										r17 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										r17 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float g17;
HXDLIN(  74)									int this94 = ((this91 >> 8) & 255);
HXDLIN(  74)									if ((this94 == 0)) {
HXLINE(  74)										g17 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										g17 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float b18;
HXDLIN(  74)									int this95 = (this91 & 255);
HXDLIN(  74)									if ((this95 == 0)) {
HXLINE(  74)										b18 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										b18 = (( (Float)(this95) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float a27;
HXDLIN(  74)									int this96 = ((color7 >> 24) & 255);
HXDLIN(  74)									if ((this96 == 0)) {
HXLINE(  74)										a27 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										a27 = (( (Float)(this96) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float r27;
HXDLIN(  74)									int this97 = ((color7 >> 16) & 255);
HXDLIN(  74)									if ((this97 == 0)) {
HXLINE(  74)										r27 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										r27 = (( (Float)(this97) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float g27;
HXDLIN(  74)									int this98 = ((color7 >> 8) & 255);
HXDLIN(  74)									if ((this98 == 0)) {
HXLINE(  74)										g27 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										g27 = (( (Float)(this98) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float b28;
HXDLIN(  74)									int this99 = (color7 & 255);
HXDLIN(  74)									if ((this99 == 0)) {
HXLINE(  74)										b28 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										b28 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN(  74)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  74)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  74)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN(  74)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  74)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN(  74)									{
HXLINE(  74)										int _hx_tmp25;
HXDLIN(  74)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXLINE(  74)											_hx_tmp25 = blended7;
            										}
HXDLIN(  74)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXLINE(  74)									::Dynamic this100 = img->image;
HXDLIN(  74)									int index10;
HXDLIN(  74)									if (img->useVirtualPos) {
HXLINE(  74)										index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE(  74)										index10 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN(  74)									int _hx_tmp26;
HXDLIN(  74)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)										_hx_tmp26 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE(  74)										_hx_tmp26 = c9;
            									}
HXDLIN(  74)									::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp26);
            								}
            							}
            						}
HXLINE(  75)						{
HXLINE(  75)							int y10 = ((y8 + placesY) + this1->width);
HXDLIN(  75)							int color8 = color->leftBottom;
HXDLIN(  75)							{
HXLINE(  75)								int c10 = color8;
HXDLIN(  75)								bool _hx_tmp27;
HXDLIN(  75)								if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  75)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXLINE(  75)									_hx_tmp27 = false;
            								}
HXDLIN(  75)								if (_hx_tmp27) {
HXLINE(  75)									int location8;
HXDLIN(  75)									if (img->useVirtualPos) {
HXLINE(  75)										location8 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE(  75)										location8 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN(  75)									int this101 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN(  75)									int this102;
HXDLIN(  75)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)										this102 = ((((((this101 >> 24) & 255) << 24) | ((this101 & 255) << 16)) | (((this101 >> 8) & 255) << 8)) | ((this101 >> 16) & 255));
            									}
            									else {
HXLINE(  75)										this102 = this101;
            									}
HXDLIN(  75)									Float a19;
HXDLIN(  75)									int this103 = ((this102 >> 24) & 255);
HXDLIN(  75)									if ((this103 == 0)) {
HXLINE(  75)										a19 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										a19 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float r18;
HXDLIN(  75)									int this104 = ((this102 >> 16) & 255);
HXDLIN(  75)									if ((this104 == 0)) {
HXLINE(  75)										r18 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										r18 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float g18;
HXDLIN(  75)									int this105 = ((this102 >> 8) & 255);
HXDLIN(  75)									if ((this105 == 0)) {
HXLINE(  75)										g18 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										g18 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float b19;
HXDLIN(  75)									int this106 = (this102 & 255);
HXDLIN(  75)									if ((this106 == 0)) {
HXLINE(  75)										b19 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										b19 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float a28;
HXDLIN(  75)									int this107 = ((color8 >> 24) & 255);
HXDLIN(  75)									if ((this107 == 0)) {
HXLINE(  75)										a28 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										a28 = (( (Float)(this107) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float r28;
HXDLIN(  75)									int this108 = ((color8 >> 16) & 255);
HXDLIN(  75)									if ((this108 == 0)) {
HXLINE(  75)										r28 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										r28 = (( (Float)(this108) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float g28;
HXDLIN(  75)									int this109 = ((color8 >> 8) & 255);
HXDLIN(  75)									if ((this109 == 0)) {
HXLINE(  75)										g28 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										g28 = (( (Float)(this109) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float b29;
HXDLIN(  75)									int this110 = (color8 & 255);
HXDLIN(  75)									if ((this110 == 0)) {
HXLINE(  75)										b29 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										b29 = (( (Float)(this110) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN(  75)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN(  75)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN(  75)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN(  75)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN(  75)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN(  75)									{
HXLINE(  75)										int _hx_tmp28;
HXDLIN(  75)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXLINE(  75)											_hx_tmp28 = blended8;
            										}
HXDLIN(  75)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXLINE(  75)									::Dynamic this111 = img->image;
HXDLIN(  75)									int index11;
HXDLIN(  75)									if (img->useVirtualPos) {
HXLINE(  75)										index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE(  75)										index11 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN(  75)									int _hx_tmp29;
HXDLIN(  75)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)										_hx_tmp29 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE(  75)										_hx_tmp29 = c10;
            									}
HXDLIN(  75)									::iterMagic::Iimg_obj::set(this111,index11,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  77)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RectanglePad_Impl__obj,colorPadImageXY,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::borderPad( ::pi_xy::ImageStruct this1,int placesX,int placesY,int color){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_80_borderPad)
HXLINE(  81)		int width = (this1->width + (2 * placesX));
HXDLIN(  81)		int height = (this1->height + (2 * placesY));
HXDLIN(  81)		 ::Dynamic imageType = null();
HXDLIN(  81)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  81)		if (::hx::IsNull( imageType )) {
HXLINE(  81)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  81)		::Dynamic _hx_tmp;
HXDLIN(  81)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  81)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  81)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  81)				{
HXLINE(  81)					b->width = width;
HXDLIN(  81)					b->height = height;
HXDLIN(  81)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  81)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  81)					{
HXLINE(  81)						int len = b->length;
HXDLIN(  81)						int w = 0;
HXDLIN(  81)						{
HXLINE(  81)							int _g = 0;
HXDLIN(  81)							int _g1 = b->height;
HXDLIN(  81)							while((_g < _g1)){
HXLINE(  81)								_g = (_g + 1);
HXDLIN(  81)								int y = (_g - 1);
HXDLIN(  81)								{
HXLINE(  81)									int _g2 = 0;
HXDLIN(  81)									int _g3 = b->width;
HXDLIN(  81)									while((_g2 < _g3)){
HXLINE(  81)										_g2 = (_g2 + 1);
HXDLIN(  81)										int x = (_g2 - 1);
HXDLIN(  81)										{
HXLINE(  81)											w = (w + 1);
HXDLIN(  81)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  81)										{
HXLINE(  81)											w = (w + 1);
HXDLIN(  81)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  81)										{
HXLINE(  81)											w = (w + 1);
HXDLIN(  81)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  81)										{
HXLINE(  81)											w = (w + 1);
HXDLIN(  81)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  81)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  81)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  81)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  81)				{
HXLINE(  81)					a->width = width;
HXDLIN(  81)					a->height = height;
HXDLIN(  81)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  81)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  81)					{
HXLINE(  81)						int _g4 = 0;
HXDLIN(  81)						int _g5 = a->length;
HXDLIN(  81)						while((_g4 < _g5)){
HXLINE(  81)							_g4 = (_g4 + 1);
HXDLIN(  81)							int i = (_g4 - 1);
HXDLIN(  81)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  81)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  81)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  81)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  81)				{
HXLINE(  81)					b1->width = width;
HXDLIN(  81)					b1->height = height;
HXDLIN(  81)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  81)					int size = (b1->length * 4);
HXDLIN(  81)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)					{
HXLINE(  81)						int _g6 = 0;
HXDLIN(  81)						int _g7 = b1->length;
HXDLIN(  81)						while((_g6 < _g7)){
HXLINE(  81)							_g6 = (_g6 + 1);
HXDLIN(  81)							int i1 = (_g6 - 1);
HXDLIN(  81)							{
HXLINE(  81)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  81)								bool _hx_tmp1;
HXDLIN(  81)								if ((i1 >= 0)) {
HXLINE(  81)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  81)									_hx_tmp1 = false;
            								}
HXDLIN(  81)								if (_hx_tmp1) {
HXLINE(  81)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  81)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  81)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  81)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  81)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  81)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  81)				{
HXLINE(  81)					v->width = width;
HXDLIN(  81)					v->height = height;
HXDLIN(  81)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  81)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  81)					{
HXLINE(  81)						int _g8 = 0;
HXDLIN(  81)						int _g9 = v->length;
HXDLIN(  81)						while((_g8 < _g9)){
HXLINE(  81)							_g8 = (_g8 + 1);
HXDLIN(  81)							int i2 = (_g8 - 1);
HXDLIN(  81)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  81)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  81)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  81)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  81)				{
HXLINE(  81)					b2->width = width;
HXDLIN(  81)					b2->height = height;
HXDLIN(  81)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  81)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  81)					{
HXLINE(  81)						int len1 = b2->length;
HXDLIN(  81)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  81)						if (::hx::IsNull( d->head )) {
HXLINE(  81)							int _g10 = 0;
HXDLIN(  81)							int _g11 = len1;
HXDLIN(  81)							while((_g10 < _g11)){
HXLINE(  81)								_g10 = (_g10 + 1);
HXDLIN(  81)								int i3 = (_g10 - 1);
HXDLIN(  81)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  81)							int _g12 = 0;
HXDLIN(  81)							int _g13 = len1;
HXDLIN(  81)							while((_g12 < _g13)){
HXLINE(  81)								_g12 = (_g12 + 1);
HXDLIN(  81)								int i4 = (_g12 - 1);
HXDLIN(  81)								{
HXLINE(  81)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  81)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  81)									{
HXLINE(  81)										int _g14 = 0;
HXDLIN(  81)										int _g15 = i4;
HXDLIN(  81)										while((_g14 < _g15)){
HXLINE(  81)											_g14 = (_g14 + 1);
HXDLIN(  81)											int i5 = (_g14 - 1);
HXDLIN(  81)											prev = l;
HXDLIN(  81)											l = l->next;
            										}
            									}
HXDLIN(  81)									if (::hx::IsNull( prev )) {
HXLINE(  81)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  81)										l = null();
            									}
            									else {
HXLINE(  81)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  81)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  81)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  81)		this2->image = _hx_tmp;
HXDLIN(  81)		this2->width = width;
HXDLIN(  81)		this2->height = height;
HXDLIN(  81)		this2->imageType = ( (int)(imageType) );
HXDLIN(  81)		 ::pi_xy::ImageStruct img = this2;
HXLINE(  82)		{
HXLINE(  82)			bool forceClear = false;
HXDLIN(  82)			{
HXLINE(  82)				int _g16 = 0;
HXDLIN(  82)				int _g17 = this1->height;
HXDLIN(  82)				while((_g16 < _g17)){
HXLINE(  82)					_g16 = (_g16 + 1);
HXDLIN(  82)					int dy = (_g16 - 1);
HXDLIN(  82)					{
HXLINE(  82)						int _g18 = 0;
HXDLIN(  82)						int _g19 = this1->width;
HXDLIN(  82)						while((_g18 < _g19)){
HXLINE(  82)							_g18 = (_g18 + 1);
HXDLIN(  82)							int dx = (_g18 - 1);
HXDLIN(  82)							::Dynamic this4 = this1->image;
HXDLIN(  82)							int index;
HXDLIN(  82)							if (this1->useVirtualPos) {
HXLINE(  82)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXLINE(  82)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN(  82)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  82)							int col;
HXDLIN(  82)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  82)								col = c;
            							}
HXDLIN(  82)							bool _hx_tmp2;
HXDLIN(  82)							if (this1->useMask) {
HXLINE(  82)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXLINE(  82)								_hx_tmp2 = false;
            							}
HXDLIN(  82)							if (_hx_tmp2) {
HXLINE(  82)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  82)								::Dynamic this6 = this5->image;
HXDLIN(  82)								int index1;
HXDLIN(  82)								if (this5->useVirtualPos) {
HXLINE(  82)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXLINE(  82)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN(  82)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  82)								int v1;
HXDLIN(  82)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  82)									v1 = c1;
            								}
HXDLIN(  82)								int maskPixel = v1;
HXDLIN(  82)								int this7 = col;
HXDLIN(  82)								if ((maskPixel == 0)) {
HXLINE(  82)									col = this7;
            								}
            								else {
HXLINE(  82)									Float m0;
HXDLIN(  82)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  82)									if ((this8 == 0)) {
HXLINE(  82)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float m1;
HXDLIN(  82)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  82)									if ((this9 == 0)) {
HXLINE(  82)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float m2;
HXDLIN(  82)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  82)									if ((this10 == 0)) {
HXLINE(  82)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float m3;
HXDLIN(  82)									int this11 = (maskPixel & 255);
HXDLIN(  82)									if ((this11 == 0)) {
HXLINE(  82)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  82)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  82)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  82)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  82)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  82)							if ((col != 0)) {
HXLINE(  82)								int x1 = (placesX + dx);
HXDLIN(  82)								int y1 = (placesY + dy);
HXDLIN(  82)								int c2 = col;
HXDLIN(  82)								bool _hx_tmp3;
HXDLIN(  82)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  82)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXLINE(  82)									_hx_tmp3 = false;
            								}
HXDLIN(  82)								if (_hx_tmp3) {
HXLINE(  82)									int location;
HXDLIN(  82)									if (img->useVirtualPos) {
HXLINE(  82)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE(  82)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  82)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN(  82)									int this13;
HXDLIN(  82)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXLINE(  82)										this13 = this12;
            									}
HXDLIN(  82)									Float a1;
HXDLIN(  82)									int this14 = ((this13 >> 24) & 255);
HXDLIN(  82)									if ((this14 == 0)) {
HXLINE(  82)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float r1;
HXDLIN(  82)									int this15 = ((this13 >> 16) & 255);
HXDLIN(  82)									if ((this15 == 0)) {
HXLINE(  82)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float g1;
HXDLIN(  82)									int this16 = ((this13 >> 8) & 255);
HXDLIN(  82)									if ((this16 == 0)) {
HXLINE(  82)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float b11;
HXDLIN(  82)									int this17 = (this13 & 255);
HXDLIN(  82)									if ((this17 == 0)) {
HXLINE(  82)										b11 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float a2;
HXDLIN(  82)									int this18 = ((col >> 24) & 255);
HXDLIN(  82)									if ((this18 == 0)) {
HXLINE(  82)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float r2;
HXDLIN(  82)									int this19 = ((col >> 16) & 255);
HXDLIN(  82)									if ((this19 == 0)) {
HXLINE(  82)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float g2;
HXDLIN(  82)									int this20 = ((col >> 8) & 255);
HXDLIN(  82)									if ((this20 == 0)) {
HXLINE(  82)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float b21;
HXDLIN(  82)									int this21 = (col & 255);
HXDLIN(  82)									if ((this21 == 0)) {
HXLINE(  82)										b21 = ((Float)0.);
            									}
            									else {
HXLINE(  82)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN(  82)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  82)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  82)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  82)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  82)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  82)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  82)									{
HXLINE(  82)										int _hx_tmp4;
HXDLIN(  82)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  82)											_hx_tmp4 = blended;
            										}
HXDLIN(  82)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE(  82)									::Dynamic this22 = img->image;
HXDLIN(  82)									int index2;
HXDLIN(  82)									if (img->useVirtualPos) {
HXLINE(  82)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE(  82)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN(  82)									int _hx_tmp5;
HXDLIN(  82)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE(  82)										_hx_tmp5 = c2;
            									}
HXDLIN(  82)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE(  82)								if (forceClear) {
HXLINE(  82)									::Dynamic this23 = img->image;
HXDLIN(  82)									int x2 = (placesX + dx);
HXDLIN(  82)									int y2 = (placesY + dy);
HXDLIN(  82)									int index3;
HXDLIN(  82)									if (img->useVirtualPos) {
HXLINE(  82)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXLINE(  82)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN(  82)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  84)		{
HXLINE(  84)			int _g20 = 0;
HXDLIN(  84)			int _g21 = this1->width;
HXDLIN(  84)			while((_g20 < _g21)){
HXLINE(  84)				_g20 = (_g20 + 1);
HXDLIN(  84)				int x3 = (_g20 - 1);
HXDLIN(  84)				{
HXLINE(  84)					int _g22 = 0;
HXDLIN(  84)					int _g23 = placesY;
HXDLIN(  84)					while((_g22 < _g23)){
HXLINE(  84)						_g22 = (_g22 + 1);
HXDLIN(  84)						int y3 = (_g22 - 1);
HXLINE(  86)						{
HXLINE(  86)							int x4 = (x3 + placesX);
HXDLIN(  86)							{
HXLINE(  86)								int c3 = color;
HXDLIN(  86)								bool _hx_tmp6;
HXDLIN(  86)								if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  86)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXLINE(  86)									_hx_tmp6 = false;
            								}
HXDLIN(  86)								if (_hx_tmp6) {
HXLINE(  86)									int location1;
HXDLIN(  86)									if (img->useVirtualPos) {
HXLINE(  86)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE(  86)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  86)									int this24 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN(  86)									int this25;
HXDLIN(  86)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE(  86)										this25 = this24;
            									}
HXDLIN(  86)									Float a11;
HXDLIN(  86)									int this26 = ((this25 >> 24) & 255);
HXDLIN(  86)									if ((this26 == 0)) {
HXLINE(  86)										a11 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r11;
HXDLIN(  86)									int this27 = ((this25 >> 16) & 255);
HXDLIN(  86)									if ((this27 == 0)) {
HXLINE(  86)										r11 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g11;
HXDLIN(  86)									int this28 = ((this25 >> 8) & 255);
HXDLIN(  86)									if ((this28 == 0)) {
HXLINE(  86)										g11 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b12;
HXDLIN(  86)									int this29 = (this25 & 255);
HXDLIN(  86)									if ((this29 == 0)) {
HXLINE(  86)										b12 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a21;
HXDLIN(  86)									int this30 = ((color >> 24) & 255);
HXDLIN(  86)									if ((this30 == 0)) {
HXLINE(  86)										a21 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r21;
HXDLIN(  86)									int this31 = ((color >> 16) & 255);
HXDLIN(  86)									if ((this31 == 0)) {
HXLINE(  86)										r21 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g21;
HXDLIN(  86)									int this32 = ((color >> 8) & 255);
HXDLIN(  86)									if ((this32 == 0)) {
HXLINE(  86)										g21 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b22;
HXDLIN(  86)									int this33 = (color & 255);
HXDLIN(  86)									if ((this33 == 0)) {
HXLINE(  86)										b22 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  86)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  86)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  86)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  86)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  86)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  86)									{
HXLINE(  86)										int _hx_tmp7;
HXDLIN(  86)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE(  86)											_hx_tmp7 = blended1;
            										}
HXDLIN(  86)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE(  86)									::Dynamic this34 = img->image;
HXDLIN(  86)									int index4;
HXDLIN(  86)									if (img->useVirtualPos) {
HXLINE(  86)										index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE(  86)										index4 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN(  86)									int _hx_tmp8;
HXDLIN(  86)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE(  86)										_hx_tmp8 = c3;
            									}
HXDLIN(  86)									::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            								}
            							}
            						}
HXLINE(  88)						{
HXLINE(  88)							int x5 = (x3 + placesX);
HXDLIN(  88)							int y4 = ((img->height - y3) - 1);
HXDLIN(  88)							{
HXLINE(  88)								int c4 = color;
HXDLIN(  88)								bool _hx_tmp9;
HXDLIN(  88)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  88)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXLINE(  88)									_hx_tmp9 = false;
            								}
HXDLIN(  88)								if (_hx_tmp9) {
HXLINE(  88)									int location2;
HXDLIN(  88)									if (img->useVirtualPos) {
HXLINE(  88)										location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE(  88)										location2 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  88)									int this35 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN(  88)									int this36;
HXDLIN(  88)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)										this36 = ((((((this35 >> 24) & 255) << 24) | ((this35 & 255) << 16)) | (((this35 >> 8) & 255) << 8)) | ((this35 >> 16) & 255));
            									}
            									else {
HXLINE(  88)										this36 = this35;
            									}
HXDLIN(  88)									Float a12;
HXDLIN(  88)									int this37 = ((this36 >> 24) & 255);
HXDLIN(  88)									if ((this37 == 0)) {
HXLINE(  88)										a12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a12 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r12;
HXDLIN(  88)									int this38 = ((this36 >> 16) & 255);
HXDLIN(  88)									if ((this38 == 0)) {
HXLINE(  88)										r12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r12 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g12;
HXDLIN(  88)									int this39 = ((this36 >> 8) & 255);
HXDLIN(  88)									if ((this39 == 0)) {
HXLINE(  88)										g12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b13;
HXDLIN(  88)									int this40 = (this36 & 255);
HXDLIN(  88)									if ((this40 == 0)) {
HXLINE(  88)										b13 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b13 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a22;
HXDLIN(  88)									int this41 = ((color >> 24) & 255);
HXDLIN(  88)									if ((this41 == 0)) {
HXLINE(  88)										a22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a22 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r22;
HXDLIN(  88)									int this42 = ((color >> 16) & 255);
HXDLIN(  88)									if ((this42 == 0)) {
HXLINE(  88)										r22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r22 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g22;
HXDLIN(  88)									int this43 = ((color >> 8) & 255);
HXDLIN(  88)									if ((this43 == 0)) {
HXLINE(  88)										g22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b23;
HXDLIN(  88)									int this44 = (color & 255);
HXDLIN(  88)									if ((this44 == 0)) {
HXLINE(  88)										b23 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b23 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  88)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  88)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  88)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  88)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  88)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  88)									{
HXLINE(  88)										int _hx_tmp10;
HXDLIN(  88)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE(  88)											_hx_tmp10 = blended2;
            										}
HXDLIN(  88)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXLINE(  88)									::Dynamic this45 = img->image;
HXDLIN(  88)									int index5;
HXDLIN(  88)									if (img->useVirtualPos) {
HXLINE(  88)										index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE(  88)										index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN(  88)									int _hx_tmp11;
HXDLIN(  88)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)										_hx_tmp11 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE(  88)										_hx_tmp11 = c4;
            									}
HXDLIN(  88)									::iterMagic::Iimg_obj::set(this45,index5,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  90)		{
HXLINE(  90)			int _g24 = 0;
HXDLIN(  90)			int _g25 = this1->height;
HXDLIN(  90)			while((_g24 < _g25)){
HXLINE(  90)				_g24 = (_g24 + 1);
HXDLIN(  90)				int y5 = (_g24 - 1);
HXDLIN(  90)				{
HXLINE(  90)					int _g26 = 0;
HXDLIN(  90)					int _g27 = placesX;
HXDLIN(  90)					while((_g26 < _g27)){
HXLINE(  90)						_g26 = (_g26 + 1);
HXDLIN(  90)						int x6 = (_g26 - 1);
HXLINE(  92)						{
HXLINE(  92)							int y6 = (y5 + placesY);
HXDLIN(  92)							{
HXLINE(  92)								int c5 = color;
HXDLIN(  92)								bool _hx_tmp12;
HXDLIN(  92)								if ((((c5 >> 24) & 255) < 254)) {
HXLINE(  92)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXLINE(  92)									_hx_tmp12 = false;
            								}
HXDLIN(  92)								if (_hx_tmp12) {
HXLINE(  92)									int location3;
HXDLIN(  92)									if (img->useVirtualPos) {
HXLINE(  92)										location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE(  92)										location3 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  92)									int this46 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN(  92)									int this47;
HXDLIN(  92)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)										this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            									}
            									else {
HXLINE(  92)										this47 = this46;
            									}
HXDLIN(  92)									Float a13;
HXDLIN(  92)									int this48 = ((this47 >> 24) & 255);
HXDLIN(  92)									if ((this48 == 0)) {
HXLINE(  92)										a13 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										a13 = (( (Float)(this48) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float r13;
HXDLIN(  92)									int this49 = ((this47 >> 16) & 255);
HXDLIN(  92)									if ((this49 == 0)) {
HXLINE(  92)										r13 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										r13 = (( (Float)(this49) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float g13;
HXDLIN(  92)									int this50 = ((this47 >> 8) & 255);
HXDLIN(  92)									if ((this50 == 0)) {
HXLINE(  92)										g13 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										g13 = (( (Float)(this50) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float b14;
HXDLIN(  92)									int this51 = (this47 & 255);
HXDLIN(  92)									if ((this51 == 0)) {
HXLINE(  92)										b14 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										b14 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float a23;
HXDLIN(  92)									int this52 = ((color >> 24) & 255);
HXDLIN(  92)									if ((this52 == 0)) {
HXLINE(  92)										a23 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										a23 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float r23;
HXDLIN(  92)									int this53 = ((color >> 16) & 255);
HXDLIN(  92)									if ((this53 == 0)) {
HXLINE(  92)										r23 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										r23 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float g23;
HXDLIN(  92)									int this54 = ((color >> 8) & 255);
HXDLIN(  92)									if ((this54 == 0)) {
HXLINE(  92)										g23 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										g23 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float b24;
HXDLIN(  92)									int this55 = (color & 255);
HXDLIN(  92)									if ((this55 == 0)) {
HXLINE(  92)										b24 = ((Float)0.);
            									}
            									else {
HXLINE(  92)										b24 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN(  92)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  92)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  92)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  92)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  92)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  92)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  92)									{
HXLINE(  92)										int _hx_tmp13;
HXDLIN(  92)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE(  92)											_hx_tmp13 = blended3;
            										}
HXDLIN(  92)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXLINE(  92)									::Dynamic this56 = img->image;
HXDLIN(  92)									int index6;
HXDLIN(  92)									if (img->useVirtualPos) {
HXLINE(  92)										index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE(  92)										index6 = ::Std_obj::_hx_int(( (Float)(((y6 * img->width) + x6)) ));
            									}
HXDLIN(  92)									int _hx_tmp14;
HXDLIN(  92)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)										_hx_tmp14 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE(  92)										_hx_tmp14 = c5;
            									}
HXDLIN(  92)									::iterMagic::Iimg_obj::set(this56,index6,_hx_tmp14);
            								}
            							}
            						}
HXLINE(  94)						{
HXLINE(  94)							int x7 = ((img->width - x6) - 1);
HXDLIN(  94)							int y7 = (y5 + placesY);
HXDLIN(  94)							{
HXLINE(  94)								int c6 = color;
HXDLIN(  94)								bool _hx_tmp15;
HXDLIN(  94)								if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  94)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXLINE(  94)									_hx_tmp15 = false;
            								}
HXDLIN(  94)								if (_hx_tmp15) {
HXLINE(  94)									int location4;
HXDLIN(  94)									if (img->useVirtualPos) {
HXLINE(  94)										location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE(  94)										location4 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  94)									int this57 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN(  94)									int this58;
HXDLIN(  94)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)										this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            									}
            									else {
HXLINE(  94)										this58 = this57;
            									}
HXDLIN(  94)									Float a14;
HXDLIN(  94)									int this59 = ((this58 >> 24) & 255);
HXDLIN(  94)									if ((this59 == 0)) {
HXLINE(  94)										a14 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float r14;
HXDLIN(  94)									int this60 = ((this58 >> 16) & 255);
HXDLIN(  94)									if ((this60 == 0)) {
HXLINE(  94)										r14 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										r14 = (( (Float)(this60) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float g14;
HXDLIN(  94)									int this61 = ((this58 >> 8) & 255);
HXDLIN(  94)									if ((this61 == 0)) {
HXLINE(  94)										g14 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										g14 = (( (Float)(this61) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float b15;
HXDLIN(  94)									int this62 = (this58 & 255);
HXDLIN(  94)									if ((this62 == 0)) {
HXLINE(  94)										b15 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										b15 = (( (Float)(this62) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float a24;
HXDLIN(  94)									int this63 = ((color >> 24) & 255);
HXDLIN(  94)									if ((this63 == 0)) {
HXLINE(  94)										a24 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										a24 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float r24;
HXDLIN(  94)									int this64 = ((color >> 16) & 255);
HXDLIN(  94)									if ((this64 == 0)) {
HXLINE(  94)										r24 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										r24 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float g24;
HXDLIN(  94)									int this65 = ((color >> 8) & 255);
HXDLIN(  94)									if ((this65 == 0)) {
HXLINE(  94)										g24 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										g24 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float b25;
HXDLIN(  94)									int this66 = (color & 255);
HXDLIN(  94)									if ((this66 == 0)) {
HXLINE(  94)										b25 = ((Float)0.);
            									}
            									else {
HXLINE(  94)										b25 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN(  94)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  94)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  94)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  94)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN(  94)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  94)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN(  94)									{
HXLINE(  94)										int _hx_tmp16;
HXDLIN(  94)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXLINE(  94)											_hx_tmp16 = blended4;
            										}
HXDLIN(  94)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXLINE(  94)									::Dynamic this67 = img->image;
HXDLIN(  94)									int index7;
HXDLIN(  94)									if (img->useVirtualPos) {
HXLINE(  94)										index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE(  94)										index7 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x7)) ));
            									}
HXDLIN(  94)									int _hx_tmp17;
HXDLIN(  94)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)										_hx_tmp17 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE(  94)										_hx_tmp17 = c6;
            									}
HXDLIN(  94)									::iterMagic::Iimg_obj::set(this67,index7,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  97)		{
HXLINE(  97)			int _g28 = 0;
HXDLIN(  97)			int _g29 = placesX;
HXDLIN(  97)			while((_g28 < _g29)){
HXLINE(  97)				_g28 = (_g28 + 1);
HXDLIN(  97)				int x8 = (_g28 - 1);
HXDLIN(  97)				{
HXLINE(  97)					int _g30 = 0;
HXDLIN(  97)					int _g31 = placesY;
HXDLIN(  97)					while((_g30 < _g31)){
HXLINE(  97)						_g30 = (_g30 + 1);
HXDLIN(  97)						int y8 = (_g30 - 1);
HXLINE(  99)						{
HXLINE(  99)							int c7 = color;
HXDLIN(  99)							bool _hx_tmp18;
HXDLIN(  99)							if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  99)								_hx_tmp18 = img->transparent;
            							}
            							else {
HXLINE(  99)								_hx_tmp18 = false;
            							}
HXDLIN(  99)							if (_hx_tmp18) {
HXLINE(  99)								int location5;
HXDLIN(  99)								if (img->useVirtualPos) {
HXLINE(  99)									location5 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            								}
            								else {
HXLINE(  99)									location5 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            								}
HXDLIN(  99)								int this68 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN(  99)								int this69;
HXDLIN(  99)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  99)									this69 = ((((((this68 >> 24) & 255) << 24) | ((this68 & 255) << 16)) | (((this68 >> 8) & 255) << 8)) | ((this68 >> 16) & 255));
            								}
            								else {
HXLINE(  99)									this69 = this68;
            								}
HXDLIN(  99)								Float a15;
HXDLIN(  99)								int this70 = ((this69 >> 24) & 255);
HXDLIN(  99)								if ((this70 == 0)) {
HXLINE(  99)									a15 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									a15 = (( (Float)(this70) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float r15;
HXDLIN(  99)								int this71 = ((this69 >> 16) & 255);
HXDLIN(  99)								if ((this71 == 0)) {
HXLINE(  99)									r15 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									r15 = (( (Float)(this71) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float g15;
HXDLIN(  99)								int this72 = ((this69 >> 8) & 255);
HXDLIN(  99)								if ((this72 == 0)) {
HXLINE(  99)									g15 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									g15 = (( (Float)(this72) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float b16;
HXDLIN(  99)								int this73 = (this69 & 255);
HXDLIN(  99)								if ((this73 == 0)) {
HXLINE(  99)									b16 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									b16 = (( (Float)(this73) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float a25;
HXDLIN(  99)								int this74 = ((color >> 24) & 255);
HXDLIN(  99)								if ((this74 == 0)) {
HXLINE(  99)									a25 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									a25 = (( (Float)(this74) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float r25;
HXDLIN(  99)								int this75 = ((color >> 16) & 255);
HXDLIN(  99)								if ((this75 == 0)) {
HXLINE(  99)									r25 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									r25 = (( (Float)(this75) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float g25;
HXDLIN(  99)								int this76 = ((color >> 8) & 255);
HXDLIN(  99)								if ((this76 == 0)) {
HXLINE(  99)									g25 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									g25 = (( (Float)(this76) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float b26;
HXDLIN(  99)								int this77 = (color & 255);
HXDLIN(  99)								if ((this77 == 0)) {
HXLINE(  99)									b26 = ((Float)0.);
            								}
            								else {
HXLINE(  99)									b26 = (( (Float)(this77) ) / ( (Float)(255) ));
            								}
HXDLIN(  99)								Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  99)								int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  99)								int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  99)								int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN(  99)								int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  99)								int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN(  99)								{
HXLINE(  99)									int _hx_tmp19;
HXDLIN(  99)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  99)										_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            									}
            									else {
HXLINE(  99)										_hx_tmp19 = blended5;
            									}
HXDLIN(  99)									::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            								}
            							}
            							else {
HXLINE(  99)								::Dynamic this78 = img->image;
HXDLIN(  99)								int index8;
HXDLIN(  99)								if (img->useVirtualPos) {
HXLINE(  99)									index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            								}
            								else {
HXLINE(  99)									index8 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            								}
HXDLIN(  99)								int _hx_tmp20;
HXDLIN(  99)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  99)									_hx_tmp20 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXLINE(  99)									_hx_tmp20 = c7;
            								}
HXDLIN(  99)								::iterMagic::Iimg_obj::set(this78,index8,_hx_tmp20);
            							}
            						}
HXLINE( 100)						{
HXLINE( 100)							int x9 = ((x8 + placesX) + this1->width);
HXDLIN( 100)							{
HXLINE( 100)								int c8 = color;
HXDLIN( 100)								bool _hx_tmp21;
HXDLIN( 100)								if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 100)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXLINE( 100)									_hx_tmp21 = false;
            								}
HXDLIN( 100)								if (_hx_tmp21) {
HXLINE( 100)									int location6;
HXDLIN( 100)									if (img->useVirtualPos) {
HXLINE( 100)										location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 100)										location6 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN( 100)									int this79 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 100)									int this80;
HXDLIN( 100)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)										this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            									}
            									else {
HXLINE( 100)										this80 = this79;
            									}
HXDLIN( 100)									Float a16;
HXDLIN( 100)									int this81 = ((this80 >> 24) & 255);
HXDLIN( 100)									if ((this81 == 0)) {
HXLINE( 100)										a16 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										a16 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float r16;
HXDLIN( 100)									int this82 = ((this80 >> 16) & 255);
HXDLIN( 100)									if ((this82 == 0)) {
HXLINE( 100)										r16 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										r16 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float g16;
HXDLIN( 100)									int this83 = ((this80 >> 8) & 255);
HXDLIN( 100)									if ((this83 == 0)) {
HXLINE( 100)										g16 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										g16 = (( (Float)(this83) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float b17;
HXDLIN( 100)									int this84 = (this80 & 255);
HXDLIN( 100)									if ((this84 == 0)) {
HXLINE( 100)										b17 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float a26;
HXDLIN( 100)									int this85 = ((color >> 24) & 255);
HXDLIN( 100)									if ((this85 == 0)) {
HXLINE( 100)										a26 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										a26 = (( (Float)(this85) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float r26;
HXDLIN( 100)									int this86 = ((color >> 16) & 255);
HXDLIN( 100)									if ((this86 == 0)) {
HXLINE( 100)										r26 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										r26 = (( (Float)(this86) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float g26;
HXDLIN( 100)									int this87 = ((color >> 8) & 255);
HXDLIN( 100)									if ((this87 == 0)) {
HXLINE( 100)										g26 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										g26 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float b27;
HXDLIN( 100)									int this88 = (color & 255);
HXDLIN( 100)									if ((this88 == 0)) {
HXLINE( 100)										b27 = ((Float)0.);
            									}
            									else {
HXLINE( 100)										b27 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 100)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 100)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 100)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 100)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN( 100)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 100)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN( 100)									{
HXLINE( 100)										int _hx_tmp22;
HXDLIN( 100)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXLINE( 100)											_hx_tmp22 = blended6;
            										}
HXDLIN( 100)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXLINE( 100)									::Dynamic this89 = img->image;
HXDLIN( 100)									int index9;
HXDLIN( 100)									if (img->useVirtualPos) {
HXLINE( 100)										index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 100)										index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x9)) ));
            									}
HXDLIN( 100)									int _hx_tmp23;
HXDLIN( 100)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)										_hx_tmp23 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE( 100)										_hx_tmp23 = c8;
            									}
HXDLIN( 100)									::iterMagic::Iimg_obj::set(this89,index9,_hx_tmp23);
            								}
            							}
            						}
HXLINE( 101)						{
HXLINE( 101)							int x10 = ((x8 + placesX) + this1->width);
HXDLIN( 101)							int y9 = ((y8 + placesY) + this1->height);
HXDLIN( 101)							{
HXLINE( 101)								int c9 = color;
HXDLIN( 101)								bool _hx_tmp24;
HXDLIN( 101)								if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 101)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXLINE( 101)									_hx_tmp24 = false;
            								}
HXDLIN( 101)								if (_hx_tmp24) {
HXLINE( 101)									int location7;
HXDLIN( 101)									if (img->useVirtualPos) {
HXLINE( 101)										location7 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 101)										location7 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 101)									int this90 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 101)									int this91;
HXDLIN( 101)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)										this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            									}
            									else {
HXLINE( 101)										this91 = this90;
            									}
HXDLIN( 101)									Float a17;
HXDLIN( 101)									int this92 = ((this91 >> 24) & 255);
HXDLIN( 101)									if ((this92 == 0)) {
HXLINE( 101)										a17 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float r17;
HXDLIN( 101)									int this93 = ((this91 >> 16) & 255);
HXDLIN( 101)									if ((this93 == 0)) {
HXLINE( 101)										r17 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										r17 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float g17;
HXDLIN( 101)									int this94 = ((this91 >> 8) & 255);
HXDLIN( 101)									if ((this94 == 0)) {
HXLINE( 101)										g17 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										g17 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float b18;
HXDLIN( 101)									int this95 = (this91 & 255);
HXDLIN( 101)									if ((this95 == 0)) {
HXLINE( 101)										b18 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										b18 = (( (Float)(this95) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float a27;
HXDLIN( 101)									int this96 = ((color >> 24) & 255);
HXDLIN( 101)									if ((this96 == 0)) {
HXLINE( 101)										a27 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										a27 = (( (Float)(this96) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float r27;
HXDLIN( 101)									int this97 = ((color >> 16) & 255);
HXDLIN( 101)									if ((this97 == 0)) {
HXLINE( 101)										r27 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										r27 = (( (Float)(this97) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float g27;
HXDLIN( 101)									int this98 = ((color >> 8) & 255);
HXDLIN( 101)									if ((this98 == 0)) {
HXLINE( 101)										g27 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										g27 = (( (Float)(this98) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float b28;
HXDLIN( 101)									int this99 = (color & 255);
HXDLIN( 101)									if ((this99 == 0)) {
HXLINE( 101)										b28 = ((Float)0.);
            									}
            									else {
HXLINE( 101)										b28 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN( 101)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN( 101)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 101)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 101)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN( 101)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 101)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN( 101)									{
HXLINE( 101)										int _hx_tmp25;
HXDLIN( 101)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXLINE( 101)											_hx_tmp25 = blended7;
            										}
HXDLIN( 101)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXLINE( 101)									::Dynamic this100 = img->image;
HXDLIN( 101)									int index10;
HXDLIN( 101)									if (img->useVirtualPos) {
HXLINE( 101)										index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 101)										index10 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 101)									int _hx_tmp26;
HXDLIN( 101)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)										_hx_tmp26 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE( 101)										_hx_tmp26 = c9;
            									}
HXDLIN( 101)									::iterMagic::Iimg_obj::set(this100,index10,_hx_tmp26);
            								}
            							}
            						}
HXLINE( 102)						{
HXLINE( 102)							int y10 = ((y8 + placesY) + this1->width);
HXDLIN( 102)							{
HXLINE( 102)								int c10 = color;
HXDLIN( 102)								bool _hx_tmp27;
HXDLIN( 102)								if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 102)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXLINE( 102)									_hx_tmp27 = false;
            								}
HXDLIN( 102)								if (_hx_tmp27) {
HXLINE( 102)									int location8;
HXDLIN( 102)									if (img->useVirtualPos) {
HXLINE( 102)										location8 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE( 102)										location8 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN( 102)									int this101 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 102)									int this102;
HXDLIN( 102)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 102)										this102 = ((((((this101 >> 24) & 255) << 24) | ((this101 & 255) << 16)) | (((this101 >> 8) & 255) << 8)) | ((this101 >> 16) & 255));
            									}
            									else {
HXLINE( 102)										this102 = this101;
            									}
HXDLIN( 102)									Float a19;
HXDLIN( 102)									int this103 = ((this102 >> 24) & 255);
HXDLIN( 102)									if ((this103 == 0)) {
HXLINE( 102)										a19 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										a19 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float r18;
HXDLIN( 102)									int this104 = ((this102 >> 16) & 255);
HXDLIN( 102)									if ((this104 == 0)) {
HXLINE( 102)										r18 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										r18 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float g18;
HXDLIN( 102)									int this105 = ((this102 >> 8) & 255);
HXDLIN( 102)									if ((this105 == 0)) {
HXLINE( 102)										g18 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										g18 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float b19;
HXDLIN( 102)									int this106 = (this102 & 255);
HXDLIN( 102)									if ((this106 == 0)) {
HXLINE( 102)										b19 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										b19 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float a28;
HXDLIN( 102)									int this107 = ((color >> 24) & 255);
HXDLIN( 102)									if ((this107 == 0)) {
HXLINE( 102)										a28 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										a28 = (( (Float)(this107) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float r28;
HXDLIN( 102)									int this108 = ((color >> 16) & 255);
HXDLIN( 102)									if ((this108 == 0)) {
HXLINE( 102)										r28 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										r28 = (( (Float)(this108) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float g28;
HXDLIN( 102)									int this109 = ((color >> 8) & 255);
HXDLIN( 102)									if ((this109 == 0)) {
HXLINE( 102)										g28 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										g28 = (( (Float)(this109) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float b29;
HXDLIN( 102)									int this110 = (color & 255);
HXDLIN( 102)									if ((this110 == 0)) {
HXLINE( 102)										b29 = ((Float)0.);
            									}
            									else {
HXLINE( 102)										b29 = (( (Float)(this110) ) / ( (Float)(255) ));
            									}
HXDLIN( 102)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN( 102)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 102)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 102)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN( 102)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 102)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN( 102)									{
HXLINE( 102)										int _hx_tmp28;
HXDLIN( 102)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 102)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXLINE( 102)											_hx_tmp28 = blended8;
            										}
HXDLIN( 102)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXLINE( 102)									::Dynamic this111 = img->image;
HXDLIN( 102)									int index11;
HXDLIN( 102)									if (img->useVirtualPos) {
HXLINE( 102)										index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE( 102)										index11 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x8)) ));
            									}
HXDLIN( 102)									int _hx_tmp29;
HXDLIN( 102)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 102)										_hx_tmp29 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE( 102)										_hx_tmp29 = c10;
            									}
HXDLIN( 102)									::iterMagic::Iimg_obj::set(this111,index11,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 104)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RectanglePad_Impl__obj,borderPad,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::padImage( ::pi_xy::ImageStruct this1,int places){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_108_padImage)
HXDLIN( 108)		int width = (this1->width + (2 * places));
HXDLIN( 108)		int height = (this1->height + (2 * places));
HXDLIN( 108)		 ::Dynamic imageType = null();
HXDLIN( 108)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 108)		if (::hx::IsNull( imageType )) {
HXDLIN( 108)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 108)		::Dynamic _hx_tmp;
HXDLIN( 108)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 108)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 108)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 108)				{
HXDLIN( 108)					b->width = width;
HXDLIN( 108)					b->height = height;
HXDLIN( 108)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 108)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 108)					{
HXDLIN( 108)						int len = b->length;
HXDLIN( 108)						int w = 0;
HXDLIN( 108)						{
HXDLIN( 108)							int _g = 0;
HXDLIN( 108)							int _g1 = b->height;
HXDLIN( 108)							while((_g < _g1)){
HXDLIN( 108)								_g = (_g + 1);
HXDLIN( 108)								int y = (_g - 1);
HXDLIN( 108)								{
HXDLIN( 108)									int _g2 = 0;
HXDLIN( 108)									int _g3 = b->width;
HXDLIN( 108)									while((_g2 < _g3)){
HXDLIN( 108)										_g2 = (_g2 + 1);
HXDLIN( 108)										int x = (_g2 - 1);
HXDLIN( 108)										{
HXDLIN( 108)											w = (w + 1);
HXDLIN( 108)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 108)										{
HXDLIN( 108)											w = (w + 1);
HXDLIN( 108)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 108)										{
HXDLIN( 108)											w = (w + 1);
HXDLIN( 108)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 108)										{
HXDLIN( 108)											w = (w + 1);
HXDLIN( 108)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 108)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 108)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 108)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 108)				{
HXDLIN( 108)					a->width = width;
HXDLIN( 108)					a->height = height;
HXDLIN( 108)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 108)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 108)					{
HXDLIN( 108)						int _g4 = 0;
HXDLIN( 108)						int _g5 = a->length;
HXDLIN( 108)						while((_g4 < _g5)){
HXDLIN( 108)							_g4 = (_g4 + 1);
HXDLIN( 108)							int i = (_g4 - 1);
HXDLIN( 108)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 108)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 108)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 108)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 108)				{
HXDLIN( 108)					b1->width = width;
HXDLIN( 108)					b1->height = height;
HXDLIN( 108)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 108)					int size = (b1->length * 4);
HXDLIN( 108)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 108)					{
HXDLIN( 108)						int _g6 = 0;
HXDLIN( 108)						int _g7 = b1->length;
HXDLIN( 108)						while((_g6 < _g7)){
HXDLIN( 108)							_g6 = (_g6 + 1);
HXDLIN( 108)							int i1 = (_g6 - 1);
HXDLIN( 108)							{
HXDLIN( 108)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 108)								bool _hx_tmp1;
HXDLIN( 108)								if ((i1 >= 0)) {
HXDLIN( 108)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 108)									_hx_tmp1 = false;
            								}
HXDLIN( 108)								if (_hx_tmp1) {
HXDLIN( 108)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 108)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 108)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 108)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 108)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 108)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 108)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 108)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 108)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 108)				{
HXDLIN( 108)					v->width = width;
HXDLIN( 108)					v->height = height;
HXDLIN( 108)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 108)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 108)					{
HXDLIN( 108)						int _g8 = 0;
HXDLIN( 108)						int _g9 = v->length;
HXDLIN( 108)						while((_g8 < _g9)){
HXDLIN( 108)							_g8 = (_g8 + 1);
HXDLIN( 108)							int i2 = (_g8 - 1);
HXDLIN( 108)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 108)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 108)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 108)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 108)				{
HXDLIN( 108)					b2->width = width;
HXDLIN( 108)					b2->height = height;
HXDLIN( 108)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 108)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 108)					{
HXDLIN( 108)						int len1 = b2->length;
HXDLIN( 108)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 108)						if (::hx::IsNull( d->head )) {
HXDLIN( 108)							int _g10 = 0;
HXDLIN( 108)							int _g11 = len1;
HXDLIN( 108)							while((_g10 < _g11)){
HXDLIN( 108)								_g10 = (_g10 + 1);
HXDLIN( 108)								int i3 = (_g10 - 1);
HXDLIN( 108)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 108)							int _g12 = 0;
HXDLIN( 108)							int _g13 = len1;
HXDLIN( 108)							while((_g12 < _g13)){
HXDLIN( 108)								_g12 = (_g12 + 1);
HXDLIN( 108)								int i4 = (_g12 - 1);
HXDLIN( 108)								{
HXDLIN( 108)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 108)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 108)									{
HXDLIN( 108)										int _g14 = 0;
HXDLIN( 108)										int _g15 = i4;
HXDLIN( 108)										while((_g14 < _g15)){
HXDLIN( 108)											_g14 = (_g14 + 1);
HXDLIN( 108)											int i5 = (_g14 - 1);
HXDLIN( 108)											prev = l;
HXDLIN( 108)											l = l->next;
            										}
            									}
HXDLIN( 108)									if (::hx::IsNull( prev )) {
HXDLIN( 108)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 108)										l = null();
            									}
            									else {
HXDLIN( 108)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 108)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 108)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 108)		this2->image = _hx_tmp;
HXDLIN( 108)		this2->width = width;
HXDLIN( 108)		this2->height = height;
HXDLIN( 108)		this2->imageType = ( (int)(imageType) );
HXDLIN( 108)		 ::pi_xy::ImageStruct img = this2;
HXDLIN( 108)		{
HXDLIN( 108)			bool forceClear = false;
HXDLIN( 108)			{
HXDLIN( 108)				int _g16 = 0;
HXDLIN( 108)				int _g17 = this1->height;
HXDLIN( 108)				while((_g16 < _g17)){
HXDLIN( 108)					_g16 = (_g16 + 1);
HXDLIN( 108)					int dy = (_g16 - 1);
HXDLIN( 108)					{
HXDLIN( 108)						int _g18 = 0;
HXDLIN( 108)						int _g19 = this1->width;
HXDLIN( 108)						while((_g18 < _g19)){
HXDLIN( 108)							_g18 = (_g18 + 1);
HXDLIN( 108)							int dx = (_g18 - 1);
HXDLIN( 108)							::Dynamic this4 = this1->image;
HXDLIN( 108)							int index;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN( 108)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 108)							int col;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								col = c;
            							}
HXDLIN( 108)							bool _hx_tmp2;
HXDLIN( 108)							if (this1->useMask) {
HXDLIN( 108)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXDLIN( 108)								_hx_tmp2 = false;
            							}
HXDLIN( 108)							if (_hx_tmp2) {
HXDLIN( 108)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 108)								::Dynamic this6 = this5->image;
HXDLIN( 108)								int index1;
HXDLIN( 108)								if (this5->useVirtualPos) {
HXDLIN( 108)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXDLIN( 108)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN( 108)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 108)								int v1;
HXDLIN( 108)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 108)									v1 = c1;
            								}
HXDLIN( 108)								int maskPixel = v1;
HXDLIN( 108)								int this7 = col;
HXDLIN( 108)								if ((maskPixel == 0)) {
HXDLIN( 108)									col = this7;
            								}
            								else {
HXDLIN( 108)									Float m0;
HXDLIN( 108)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 108)									if ((this8 == 0)) {
HXDLIN( 108)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float m1;
HXDLIN( 108)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 108)									if ((this9 == 0)) {
HXDLIN( 108)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float m2;
HXDLIN( 108)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 108)									if ((this10 == 0)) {
HXDLIN( 108)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float m3;
HXDLIN( 108)									int this11 = (maskPixel & 255);
HXDLIN( 108)									if ((this11 == 0)) {
HXDLIN( 108)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 108)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 108)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 108)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 108)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 108)							if ((col != 0)) {
HXDLIN( 108)								int x1 = (places + dx);
HXDLIN( 108)								int y1 = (places + dy);
HXDLIN( 108)								int c2 = col;
HXDLIN( 108)								bool _hx_tmp3;
HXDLIN( 108)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp3 = false;
            								}
HXDLIN( 108)								if (_hx_tmp3) {
HXDLIN( 108)									int location;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 108)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 108)									int this13;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this13 = this12;
            									}
HXDLIN( 108)									Float a1;
HXDLIN( 108)									int this14 = ((this13 >> 24) & 255);
HXDLIN( 108)									if ((this14 == 0)) {
HXDLIN( 108)										a1 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r1;
HXDLIN( 108)									int this15 = ((this13 >> 16) & 255);
HXDLIN( 108)									if ((this15 == 0)) {
HXDLIN( 108)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g1;
HXDLIN( 108)									int this16 = ((this13 >> 8) & 255);
HXDLIN( 108)									if ((this16 == 0)) {
HXDLIN( 108)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b11;
HXDLIN( 108)									int this17 = (this13 & 255);
HXDLIN( 108)									if ((this17 == 0)) {
HXDLIN( 108)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a2;
HXDLIN( 108)									int this18 = ((col >> 24) & 255);
HXDLIN( 108)									if ((this18 == 0)) {
HXDLIN( 108)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r2;
HXDLIN( 108)									int this19 = ((col >> 16) & 255);
HXDLIN( 108)									if ((this19 == 0)) {
HXDLIN( 108)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g2;
HXDLIN( 108)									int this20 = ((col >> 8) & 255);
HXDLIN( 108)									if ((this20 == 0)) {
HXDLIN( 108)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b21;
HXDLIN( 108)									int this21 = (col & 255);
HXDLIN( 108)									if ((this21 == 0)) {
HXDLIN( 108)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 108)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 108)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 108)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 108)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 108)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp4;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp4 = blended;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this22 = img->image;
HXDLIN( 108)									int index2;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 108)									int _hx_tmp5;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp5 = c2;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXDLIN( 108)								if (forceClear) {
HXDLIN( 108)									::Dynamic this23 = img->image;
HXDLIN( 108)									int x2 = (places + dx);
HXDLIN( 108)									int y2 = (places + dy);
HXDLIN( 108)									int index3;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 108)		{
HXDLIN( 108)			int _g20 = 0;
HXDLIN( 108)			int _g21 = this1->width;
HXDLIN( 108)			while((_g20 < _g21)){
HXDLIN( 108)				_g20 = (_g20 + 1);
HXDLIN( 108)				int x3 = (_g20 - 1);
HXDLIN( 108)				{
HXDLIN( 108)					int _g22 = 0;
HXDLIN( 108)					int _g23 = places;
HXDLIN( 108)					while((_g22 < _g23)){
HXDLIN( 108)						_g22 = (_g22 + 1);
HXDLIN( 108)						int y3 = (_g22 - 1);
HXDLIN( 108)						{
HXDLIN( 108)							int x4 = (x3 + places);
HXDLIN( 108)							::Dynamic this24 = this1->image;
HXDLIN( 108)							int index4;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index4 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x3)) ));
            							}
HXDLIN( 108)							int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 108)							int color;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color = c3;
            							}
HXDLIN( 108)							int color1 = color;
HXDLIN( 108)							{
HXDLIN( 108)								int c4 = color1;
HXDLIN( 108)								bool _hx_tmp6;
HXDLIN( 108)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp6 = false;
            								}
HXDLIN( 108)								if (_hx_tmp6) {
HXDLIN( 108)									int location1;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 108)									int this25 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 108)									int this26;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this26 = this25;
            									}
HXDLIN( 108)									Float a11;
HXDLIN( 108)									int this27 = ((this26 >> 24) & 255);
HXDLIN( 108)									if ((this27 == 0)) {
HXDLIN( 108)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r11;
HXDLIN( 108)									int this28 = ((this26 >> 16) & 255);
HXDLIN( 108)									if ((this28 == 0)) {
HXDLIN( 108)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g11;
HXDLIN( 108)									int this29 = ((this26 >> 8) & 255);
HXDLIN( 108)									if ((this29 == 0)) {
HXDLIN( 108)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b12;
HXDLIN( 108)									int this30 = (this26 & 255);
HXDLIN( 108)									if ((this30 == 0)) {
HXDLIN( 108)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a21;
HXDLIN( 108)									int this31 = ((color1 >> 24) & 255);
HXDLIN( 108)									if ((this31 == 0)) {
HXDLIN( 108)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r21;
HXDLIN( 108)									int this32 = ((color1 >> 16) & 255);
HXDLIN( 108)									if ((this32 == 0)) {
HXDLIN( 108)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g21;
HXDLIN( 108)									int this33 = ((color1 >> 8) & 255);
HXDLIN( 108)									if ((this33 == 0)) {
HXDLIN( 108)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b22;
HXDLIN( 108)									int this34 = (color1 & 255);
HXDLIN( 108)									if ((this34 == 0)) {
HXDLIN( 108)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 108)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 108)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 108)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 108)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 108)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp7;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp7 = blended1;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this35 = img->image;
HXDLIN( 108)									int index5;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index5 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 108)									int _hx_tmp8;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp8 = c4;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp8);
            								}
            							}
            						}
HXDLIN( 108)						{
HXDLIN( 108)							int x5 = (x3 + places);
HXDLIN( 108)							int y4 = ((img->height - y3) - 1);
HXDLIN( 108)							int y5 = (this1->height - 1);
HXDLIN( 108)							::Dynamic this36 = this1->image;
HXDLIN( 108)							int index6;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index6 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x3)) ));
            							}
HXDLIN( 108)							int c5 = ::iterMagic::Iimg_obj::get(this36,index6);
HXDLIN( 108)							int color2;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color2 = c5;
            							}
HXDLIN( 108)							{
HXDLIN( 108)								int c6 = color2;
HXDLIN( 108)								bool _hx_tmp9;
HXDLIN( 108)								if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp9 = false;
            								}
HXDLIN( 108)								if (_hx_tmp9) {
HXDLIN( 108)									int location2;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location2 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN( 108)									int this37 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 108)									int this38;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this38 = ((((((this37 >> 24) & 255) << 24) | ((this37 & 255) << 16)) | (((this37 >> 8) & 255) << 8)) | ((this37 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this38 = this37;
            									}
HXDLIN( 108)									Float a12;
HXDLIN( 108)									int this39 = ((this38 >> 24) & 255);
HXDLIN( 108)									if ((this39 == 0)) {
HXDLIN( 108)										a12 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r12;
HXDLIN( 108)									int this40 = ((this38 >> 16) & 255);
HXDLIN( 108)									if ((this40 == 0)) {
HXDLIN( 108)										r12 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r12 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g12;
HXDLIN( 108)									int this41 = ((this38 >> 8) & 255);
HXDLIN( 108)									if ((this41 == 0)) {
HXDLIN( 108)										g12 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g12 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b13;
HXDLIN( 108)									int this42 = (this38 & 255);
HXDLIN( 108)									if ((this42 == 0)) {
HXDLIN( 108)										b13 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b13 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a22;
HXDLIN( 108)									int this43 = ((color2 >> 24) & 255);
HXDLIN( 108)									if ((this43 == 0)) {
HXDLIN( 108)										a22 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r22;
HXDLIN( 108)									int this44 = ((color2 >> 16) & 255);
HXDLIN( 108)									if ((this44 == 0)) {
HXDLIN( 108)										r22 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r22 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g22;
HXDLIN( 108)									int this45 = ((color2 >> 8) & 255);
HXDLIN( 108)									if ((this45 == 0)) {
HXDLIN( 108)										g22 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g22 = (( (Float)(this45) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b23;
HXDLIN( 108)									int this46 = (color2 & 255);
HXDLIN( 108)									if ((this46 == 0)) {
HXDLIN( 108)										b23 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b23 = (( (Float)(this46) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 108)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 108)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 108)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 108)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 108)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp10;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp10 = blended2;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this47 = img->image;
HXDLIN( 108)									int index7;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index7 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index7 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN( 108)									int _hx_tmp11;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp11 = c6;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this47,index7,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 108)		{
HXDLIN( 108)			int _g24 = 0;
HXDLIN( 108)			int _g25 = this1->height;
HXDLIN( 108)			while((_g24 < _g25)){
HXDLIN( 108)				_g24 = (_g24 + 1);
HXDLIN( 108)				int y6 = (_g24 - 1);
HXDLIN( 108)				{
HXDLIN( 108)					int _g26 = 0;
HXDLIN( 108)					int _g27 = places;
HXDLIN( 108)					while((_g26 < _g27)){
HXDLIN( 108)						_g26 = (_g26 + 1);
HXDLIN( 108)						int x6 = (_g26 - 1);
HXDLIN( 108)						{
HXDLIN( 108)							int y7 = (y6 + places);
HXDLIN( 108)							::Dynamic this48 = this1->image;
HXDLIN( 108)							int index8;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index8 = ::Std_obj::_hx_int((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index8 = ::Std_obj::_hx_int(( (Float)((y6 * this1->width)) ));
            							}
HXDLIN( 108)							int c7 = ::iterMagic::Iimg_obj::get(this48,index8);
HXDLIN( 108)							int color3;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color3 = c7;
            							}
HXDLIN( 108)							int color4 = color3;
HXDLIN( 108)							{
HXDLIN( 108)								int c8 = color4;
HXDLIN( 108)								bool _hx_tmp12;
HXDLIN( 108)								if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp12 = false;
            								}
HXDLIN( 108)								if (_hx_tmp12) {
HXDLIN( 108)									int location3;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location3 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x6)) ));
            									}
HXDLIN( 108)									int this49 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 108)									int this50;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this50 = ((((((this49 >> 24) & 255) << 24) | ((this49 & 255) << 16)) | (((this49 >> 8) & 255) << 8)) | ((this49 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this50 = this49;
            									}
HXDLIN( 108)									Float a13;
HXDLIN( 108)									int this51 = ((this50 >> 24) & 255);
HXDLIN( 108)									if ((this51 == 0)) {
HXDLIN( 108)										a13 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r13;
HXDLIN( 108)									int this52 = ((this50 >> 16) & 255);
HXDLIN( 108)									if ((this52 == 0)) {
HXDLIN( 108)										r13 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r13 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g13;
HXDLIN( 108)									int this53 = ((this50 >> 8) & 255);
HXDLIN( 108)									if ((this53 == 0)) {
HXDLIN( 108)										g13 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g13 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b14;
HXDLIN( 108)									int this54 = (this50 & 255);
HXDLIN( 108)									if ((this54 == 0)) {
HXDLIN( 108)										b14 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b14 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a23;
HXDLIN( 108)									int this55 = ((color4 >> 24) & 255);
HXDLIN( 108)									if ((this55 == 0)) {
HXDLIN( 108)										a23 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a23 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r23;
HXDLIN( 108)									int this56 = ((color4 >> 16) & 255);
HXDLIN( 108)									if ((this56 == 0)) {
HXDLIN( 108)										r23 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r23 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g23;
HXDLIN( 108)									int this57 = ((color4 >> 8) & 255);
HXDLIN( 108)									if ((this57 == 0)) {
HXDLIN( 108)										g23 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g23 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b24;
HXDLIN( 108)									int this58 = (color4 & 255);
HXDLIN( 108)									if ((this58 == 0)) {
HXDLIN( 108)										b24 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b24 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 108)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 108)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 108)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 108)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 108)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp13;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp13 = blended3;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this59 = img->image;
HXDLIN( 108)									int index9;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index9 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x6)) ));
            									}
HXDLIN( 108)									int _hx_tmp14;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp14 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp14 = c8;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this59,index9,_hx_tmp14);
            								}
            							}
            						}
HXDLIN( 108)						{
HXDLIN( 108)							int x7 = ((img->width - x6) - 1);
HXDLIN( 108)							int y8 = (y6 + places);
HXDLIN( 108)							int x8 = (this1->width - 1);
HXDLIN( 108)							::Dynamic this60 = this1->image;
HXDLIN( 108)							int index10;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index10 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x8)) ));
            							}
HXDLIN( 108)							int c9 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 108)							int color5;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color5 = c9;
            							}
HXDLIN( 108)							{
HXDLIN( 108)								int c10 = color5;
HXDLIN( 108)								bool _hx_tmp15;
HXDLIN( 108)								if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp15 = false;
            								}
HXDLIN( 108)								if (_hx_tmp15) {
HXDLIN( 108)									int location4;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location4 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            									}
HXDLIN( 108)									int this61 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 108)									int this62;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this62 = this61;
            									}
HXDLIN( 108)									Float a14;
HXDLIN( 108)									int this63 = ((this62 >> 24) & 255);
HXDLIN( 108)									if ((this63 == 0)) {
HXDLIN( 108)										a14 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r14;
HXDLIN( 108)									int this64 = ((this62 >> 16) & 255);
HXDLIN( 108)									if ((this64 == 0)) {
HXDLIN( 108)										r14 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r14 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g14;
HXDLIN( 108)									int this65 = ((this62 >> 8) & 255);
HXDLIN( 108)									if ((this65 == 0)) {
HXDLIN( 108)										g14 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g14 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b15;
HXDLIN( 108)									int this66 = (this62 & 255);
HXDLIN( 108)									if ((this66 == 0)) {
HXDLIN( 108)										b15 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b15 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a24;
HXDLIN( 108)									int this67 = ((color5 >> 24) & 255);
HXDLIN( 108)									if ((this67 == 0)) {
HXDLIN( 108)										a24 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a24 = (( (Float)(this67) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r24;
HXDLIN( 108)									int this68 = ((color5 >> 16) & 255);
HXDLIN( 108)									if ((this68 == 0)) {
HXDLIN( 108)										r24 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r24 = (( (Float)(this68) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g24;
HXDLIN( 108)									int this69 = ((color5 >> 8) & 255);
HXDLIN( 108)									if ((this69 == 0)) {
HXDLIN( 108)										g24 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g24 = (( (Float)(this69) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b25;
HXDLIN( 108)									int this70 = (color5 & 255);
HXDLIN( 108)									if ((this70 == 0)) {
HXDLIN( 108)										b25 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b25 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 108)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 108)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 108)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 108)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 108)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp16;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp16 = blended4;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this71 = img->image;
HXDLIN( 108)									int index11;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index11 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            									}
HXDLIN( 108)									int _hx_tmp17;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp17 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp17 = c10;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 108)		{
HXDLIN( 108)			int _g28 = 0;
HXDLIN( 108)			int _g29 = places;
HXDLIN( 108)			while((_g28 < _g29)){
HXDLIN( 108)				_g28 = (_g28 + 1);
HXDLIN( 108)				int x9 = (_g28 - 1);
HXDLIN( 108)				{
HXDLIN( 108)					int _g30 = 0;
HXDLIN( 108)					int _g31 = places;
HXDLIN( 108)					while((_g30 < _g31)){
HXDLIN( 108)						_g30 = (_g30 + 1);
HXDLIN( 108)						int y9 = (_g30 - 1);
HXDLIN( 108)						{
HXDLIN( 108)							::Dynamic this72 = this1->image;
HXDLIN( 108)							int index12;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index12 = ::Std_obj::_hx_int(( (Float)((0 * this1->width)) ));
            							}
HXDLIN( 108)							int c11 = ::iterMagic::Iimg_obj::get(this72,index12);
HXDLIN( 108)							int color6;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color6 = c11;
            							}
HXDLIN( 108)							int color7 = color6;
HXDLIN( 108)							{
HXDLIN( 108)								int c12 = color7;
HXDLIN( 108)								bool _hx_tmp18;
HXDLIN( 108)								if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp18 = false;
            								}
HXDLIN( 108)								if (_hx_tmp18) {
HXDLIN( 108)									int location5;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location5 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location5 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            									}
HXDLIN( 108)									int this73 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 108)									int this74;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this74 = ((((((this73 >> 24) & 255) << 24) | ((this73 & 255) << 16)) | (((this73 >> 8) & 255) << 8)) | ((this73 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this74 = this73;
            									}
HXDLIN( 108)									Float a15;
HXDLIN( 108)									int this75 = ((this74 >> 24) & 255);
HXDLIN( 108)									if ((this75 == 0)) {
HXDLIN( 108)										a15 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a15 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r15;
HXDLIN( 108)									int this76 = ((this74 >> 16) & 255);
HXDLIN( 108)									if ((this76 == 0)) {
HXDLIN( 108)										r15 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r15 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g15;
HXDLIN( 108)									int this77 = ((this74 >> 8) & 255);
HXDLIN( 108)									if ((this77 == 0)) {
HXDLIN( 108)										g15 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g15 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b16;
HXDLIN( 108)									int this78 = (this74 & 255);
HXDLIN( 108)									if ((this78 == 0)) {
HXDLIN( 108)										b16 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b16 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a25;
HXDLIN( 108)									int this79 = ((color7 >> 24) & 255);
HXDLIN( 108)									if ((this79 == 0)) {
HXDLIN( 108)										a25 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a25 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r25;
HXDLIN( 108)									int this80 = ((color7 >> 16) & 255);
HXDLIN( 108)									if ((this80 == 0)) {
HXDLIN( 108)										r25 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r25 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g25;
HXDLIN( 108)									int this81 = ((color7 >> 8) & 255);
HXDLIN( 108)									if ((this81 == 0)) {
HXDLIN( 108)										g25 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g25 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b26;
HXDLIN( 108)									int this82 = (color7 & 255);
HXDLIN( 108)									if ((this82 == 0)) {
HXDLIN( 108)										b26 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b26 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 108)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 108)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 108)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 108)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 108)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp19;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp19 = blended5;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this83 = img->image;
HXDLIN( 108)									int index13;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index13 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index13 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            									}
HXDLIN( 108)									int _hx_tmp20;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp20 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp20 = c12;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this83,index13,_hx_tmp20);
            								}
            							}
            						}
HXDLIN( 108)						{
HXDLIN( 108)							int x10 = ((x9 + places) + this1->width);
HXDLIN( 108)							int x11 = (this1->width - 1);
HXDLIN( 108)							::Dynamic this84 = this1->image;
HXDLIN( 108)							int index14;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index14 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x11)) ));
            							}
HXDLIN( 108)							int c13 = ::iterMagic::Iimg_obj::get(this84,index14);
HXDLIN( 108)							int color8;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color8 = c13;
            							}
HXDLIN( 108)							{
HXDLIN( 108)								int c14 = color8;
HXDLIN( 108)								bool _hx_tmp21;
HXDLIN( 108)								if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp21 = false;
            								}
HXDLIN( 108)								if (_hx_tmp21) {
HXDLIN( 108)									int location6;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location6 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 108)									int this85 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 108)									int this86;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this86 = ((((((this85 >> 24) & 255) << 24) | ((this85 & 255) << 16)) | (((this85 >> 8) & 255) << 8)) | ((this85 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this86 = this85;
            									}
HXDLIN( 108)									Float a16;
HXDLIN( 108)									int this87 = ((this86 >> 24) & 255);
HXDLIN( 108)									if ((this87 == 0)) {
HXDLIN( 108)										a16 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a16 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r16;
HXDLIN( 108)									int this88 = ((this86 >> 16) & 255);
HXDLIN( 108)									if ((this88 == 0)) {
HXDLIN( 108)										r16 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r16 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g16;
HXDLIN( 108)									int this89 = ((this86 >> 8) & 255);
HXDLIN( 108)									if ((this89 == 0)) {
HXDLIN( 108)										g16 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g16 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b17;
HXDLIN( 108)									int this90 = (this86 & 255);
HXDLIN( 108)									if ((this90 == 0)) {
HXDLIN( 108)										b17 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b17 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a26;
HXDLIN( 108)									int this91 = ((color8 >> 24) & 255);
HXDLIN( 108)									if ((this91 == 0)) {
HXDLIN( 108)										a26 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a26 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r26;
HXDLIN( 108)									int this92 = ((color8 >> 16) & 255);
HXDLIN( 108)									if ((this92 == 0)) {
HXDLIN( 108)										r26 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r26 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g26;
HXDLIN( 108)									int this93 = ((color8 >> 8) & 255);
HXDLIN( 108)									if ((this93 == 0)) {
HXDLIN( 108)										g26 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g26 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b27;
HXDLIN( 108)									int this94 = (color8 & 255);
HXDLIN( 108)									if ((this94 == 0)) {
HXDLIN( 108)										b27 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 108)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 108)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 108)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN( 108)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 108)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp22;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp22 = blended6;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this95 = img->image;
HXDLIN( 108)									int index15;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index15 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index15 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 108)									int _hx_tmp23;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp23 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp23 = c14;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this95,index15,_hx_tmp23);
            								}
            							}
            						}
HXDLIN( 108)						{
HXDLIN( 108)							int x12 = ((x9 + places) + this1->width);
HXDLIN( 108)							int y10 = ((y9 + places) + this1->height);
HXDLIN( 108)							int x13 = (this1->width - 1);
HXDLIN( 108)							int y11 = (this1->height - 1);
HXDLIN( 108)							::Dynamic this96 = this1->image;
HXDLIN( 108)							int index16;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index16 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x13) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index16 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x13)) ));
            							}
HXDLIN( 108)							int c15 = ::iterMagic::Iimg_obj::get(this96,index16);
HXDLIN( 108)							int color9;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color9 = c15;
            							}
HXDLIN( 108)							{
HXDLIN( 108)								int c16 = color9;
HXDLIN( 108)								bool _hx_tmp24;
HXDLIN( 108)								if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp24 = false;
            								}
HXDLIN( 108)								if (_hx_tmp24) {
HXDLIN( 108)									int location7;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location7 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location7 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 108)									int this97 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 108)									int this98;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this98 = ((((((this97 >> 24) & 255) << 24) | ((this97 & 255) << 16)) | (((this97 >> 8) & 255) << 8)) | ((this97 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this98 = this97;
            									}
HXDLIN( 108)									Float a17;
HXDLIN( 108)									int this99 = ((this98 >> 24) & 255);
HXDLIN( 108)									if ((this99 == 0)) {
HXDLIN( 108)										a17 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a17 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r17;
HXDLIN( 108)									int this100 = ((this98 >> 16) & 255);
HXDLIN( 108)									if ((this100 == 0)) {
HXDLIN( 108)										r17 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r17 = (( (Float)(this100) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g17;
HXDLIN( 108)									int this101 = ((this98 >> 8) & 255);
HXDLIN( 108)									if ((this101 == 0)) {
HXDLIN( 108)										g17 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g17 = (( (Float)(this101) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b18;
HXDLIN( 108)									int this102 = (this98 & 255);
HXDLIN( 108)									if ((this102 == 0)) {
HXDLIN( 108)										b18 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b18 = (( (Float)(this102) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a27;
HXDLIN( 108)									int this103 = ((color9 >> 24) & 255);
HXDLIN( 108)									if ((this103 == 0)) {
HXDLIN( 108)										a27 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a27 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r27;
HXDLIN( 108)									int this104 = ((color9 >> 16) & 255);
HXDLIN( 108)									if ((this104 == 0)) {
HXDLIN( 108)										r27 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r27 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g27;
HXDLIN( 108)									int this105 = ((color9 >> 8) & 255);
HXDLIN( 108)									if ((this105 == 0)) {
HXDLIN( 108)										g27 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g27 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b28;
HXDLIN( 108)									int this106 = (color9 & 255);
HXDLIN( 108)									if ((this106 == 0)) {
HXDLIN( 108)										b28 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b28 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN( 108)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 108)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 108)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN( 108)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 108)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp25;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp25 = blended7;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this107 = img->image;
HXDLIN( 108)									int index17;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index17 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index17 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 108)									int _hx_tmp26;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp26 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp26 = c16;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this107,index17,_hx_tmp26);
            								}
            							}
            						}
HXDLIN( 108)						{
HXDLIN( 108)							int y12 = ((y9 + places) + this1->width);
HXDLIN( 108)							int y13 = (this1->height - 1);
HXDLIN( 108)							::Dynamic this108 = this1->image;
HXDLIN( 108)							int index18;
HXDLIN( 108)							if (this1->useVirtualPos) {
HXDLIN( 108)								index18 = ::Std_obj::_hx_int((((( (Float)(y13) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXDLIN( 108)								index18 = ::Std_obj::_hx_int(( (Float)((y13 * this1->width)) ));
            							}
HXDLIN( 108)							int c17 = ::iterMagic::Iimg_obj::get(this108,index18);
HXDLIN( 108)							int color10;
HXDLIN( 108)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)								color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            							}
            							else {
HXDLIN( 108)								color10 = c17;
            							}
HXDLIN( 108)							{
HXDLIN( 108)								int c18 = color10;
HXDLIN( 108)								bool _hx_tmp27;
HXDLIN( 108)								if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 108)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXDLIN( 108)									_hx_tmp27 = false;
            								}
HXDLIN( 108)								if (_hx_tmp27) {
HXDLIN( 108)									int location8;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										location8 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										location8 = ::Std_obj::_hx_int(( (Float)(((y12 * img->width) + x9)) ));
            									}
HXDLIN( 108)									int this109 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 108)									int this110;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										this110 = ((((((this109 >> 24) & 255) << 24) | ((this109 & 255) << 16)) | (((this109 >> 8) & 255) << 8)) | ((this109 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										this110 = this109;
            									}
HXDLIN( 108)									Float a19;
HXDLIN( 108)									int this111 = ((this110 >> 24) & 255);
HXDLIN( 108)									if ((this111 == 0)) {
HXDLIN( 108)										a19 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a19 = (( (Float)(this111) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r18;
HXDLIN( 108)									int this112 = ((this110 >> 16) & 255);
HXDLIN( 108)									if ((this112 == 0)) {
HXDLIN( 108)										r18 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r18 = (( (Float)(this112) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g18;
HXDLIN( 108)									int this113 = ((this110 >> 8) & 255);
HXDLIN( 108)									if ((this113 == 0)) {
HXDLIN( 108)										g18 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g18 = (( (Float)(this113) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b19;
HXDLIN( 108)									int this114 = (this110 & 255);
HXDLIN( 108)									if ((this114 == 0)) {
HXDLIN( 108)										b19 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b19 = (( (Float)(this114) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a28;
HXDLIN( 108)									int this115 = ((color10 >> 24) & 255);
HXDLIN( 108)									if ((this115 == 0)) {
HXDLIN( 108)										a28 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										a28 = (( (Float)(this115) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float r28;
HXDLIN( 108)									int this116 = ((color10 >> 16) & 255);
HXDLIN( 108)									if ((this116 == 0)) {
HXDLIN( 108)										r28 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										r28 = (( (Float)(this116) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float g28;
HXDLIN( 108)									int this117 = ((color10 >> 8) & 255);
HXDLIN( 108)									if ((this117 == 0)) {
HXDLIN( 108)										g28 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										g28 = (( (Float)(this117) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float b29;
HXDLIN( 108)									int this118 = (color10 & 255);
HXDLIN( 108)									if ((this118 == 0)) {
HXDLIN( 108)										b29 = ((Float)0.);
            									}
            									else {
HXDLIN( 108)										b29 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 108)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN( 108)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 108)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 108)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN( 108)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 108)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN( 108)									{
HXDLIN( 108)										int _hx_tmp28;
HXDLIN( 108)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXDLIN( 108)											_hx_tmp28 = blended8;
            										}
HXDLIN( 108)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXDLIN( 108)									::Dynamic this119 = img->image;
HXDLIN( 108)									int index19;
HXDLIN( 108)									if (img->useVirtualPos) {
HXDLIN( 108)										index19 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXDLIN( 108)										index19 = ::Std_obj::_hx_int(( (Float)(((y12 * img->width) + x9)) ));
            									}
HXDLIN( 108)									int _hx_tmp29;
HXDLIN( 108)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 108)										_hx_tmp29 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXDLIN( 108)										_hx_tmp29 = c18;
            									}
HXDLIN( 108)									::iterMagic::Iimg_obj::set(this119,index19,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 108)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectanglePad_Impl__obj,padImage,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::padImageXY( ::pi_xy::ImageStruct this1,int placesX,int placesY){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_111_padImageXY)
HXLINE( 112)		int width = (this1->width + (2 * placesX));
HXDLIN( 112)		int height = (this1->height + (2 * placesY));
HXDLIN( 112)		 ::Dynamic imageType = null();
HXDLIN( 112)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 112)		if (::hx::IsNull( imageType )) {
HXLINE( 112)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 112)		::Dynamic _hx_tmp;
HXDLIN( 112)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 112)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 112)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 112)				{
HXLINE( 112)					b->width = width;
HXDLIN( 112)					b->height = height;
HXDLIN( 112)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 112)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 112)					{
HXLINE( 112)						int len = b->length;
HXDLIN( 112)						int w = 0;
HXDLIN( 112)						{
HXLINE( 112)							int _g = 0;
HXDLIN( 112)							int _g1 = b->height;
HXDLIN( 112)							while((_g < _g1)){
HXLINE( 112)								_g = (_g + 1);
HXDLIN( 112)								int y = (_g - 1);
HXDLIN( 112)								{
HXLINE( 112)									int _g2 = 0;
HXDLIN( 112)									int _g3 = b->width;
HXDLIN( 112)									while((_g2 < _g3)){
HXLINE( 112)										_g2 = (_g2 + 1);
HXDLIN( 112)										int x = (_g2 - 1);
HXDLIN( 112)										{
HXLINE( 112)											w = (w + 1);
HXDLIN( 112)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 112)										{
HXLINE( 112)											w = (w + 1);
HXDLIN( 112)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 112)										{
HXLINE( 112)											w = (w + 1);
HXDLIN( 112)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 112)										{
HXLINE( 112)											w = (w + 1);
HXDLIN( 112)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 112)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 112)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 112)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 112)				{
HXLINE( 112)					a->width = width;
HXDLIN( 112)					a->height = height;
HXDLIN( 112)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 112)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 112)					{
HXLINE( 112)						int _g4 = 0;
HXDLIN( 112)						int _g5 = a->length;
HXDLIN( 112)						while((_g4 < _g5)){
HXLINE( 112)							_g4 = (_g4 + 1);
HXDLIN( 112)							int i = (_g4 - 1);
HXDLIN( 112)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 112)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 112)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 112)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 112)				{
HXLINE( 112)					b1->width = width;
HXDLIN( 112)					b1->height = height;
HXDLIN( 112)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 112)					int size = (b1->length * 4);
HXDLIN( 112)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 112)					{
HXLINE( 112)						int _g6 = 0;
HXDLIN( 112)						int _g7 = b1->length;
HXDLIN( 112)						while((_g6 < _g7)){
HXLINE( 112)							_g6 = (_g6 + 1);
HXDLIN( 112)							int i1 = (_g6 - 1);
HXDLIN( 112)							{
HXLINE( 112)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 112)								bool _hx_tmp1;
HXDLIN( 112)								if ((i1 >= 0)) {
HXLINE( 112)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 112)									_hx_tmp1 = false;
            								}
HXDLIN( 112)								if (_hx_tmp1) {
HXLINE( 112)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 112)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 112)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 112)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 112)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 112)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 112)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 112)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 112)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 112)				{
HXLINE( 112)					v->width = width;
HXDLIN( 112)					v->height = height;
HXDLIN( 112)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 112)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 112)					{
HXLINE( 112)						int _g8 = 0;
HXDLIN( 112)						int _g9 = v->length;
HXDLIN( 112)						while((_g8 < _g9)){
HXLINE( 112)							_g8 = (_g8 + 1);
HXDLIN( 112)							int i2 = (_g8 - 1);
HXDLIN( 112)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 112)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 112)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 112)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 112)				{
HXLINE( 112)					b2->width = width;
HXDLIN( 112)					b2->height = height;
HXDLIN( 112)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 112)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 112)					{
HXLINE( 112)						int len1 = b2->length;
HXDLIN( 112)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 112)						if (::hx::IsNull( d->head )) {
HXLINE( 112)							int _g10 = 0;
HXDLIN( 112)							int _g11 = len1;
HXDLIN( 112)							while((_g10 < _g11)){
HXLINE( 112)								_g10 = (_g10 + 1);
HXDLIN( 112)								int i3 = (_g10 - 1);
HXDLIN( 112)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 112)							int _g12 = 0;
HXDLIN( 112)							int _g13 = len1;
HXDLIN( 112)							while((_g12 < _g13)){
HXLINE( 112)								_g12 = (_g12 + 1);
HXDLIN( 112)								int i4 = (_g12 - 1);
HXDLIN( 112)								{
HXLINE( 112)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 112)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 112)									{
HXLINE( 112)										int _g14 = 0;
HXDLIN( 112)										int _g15 = i4;
HXDLIN( 112)										while((_g14 < _g15)){
HXLINE( 112)											_g14 = (_g14 + 1);
HXDLIN( 112)											int i5 = (_g14 - 1);
HXDLIN( 112)											prev = l;
HXDLIN( 112)											l = l->next;
            										}
            									}
HXDLIN( 112)									if (::hx::IsNull( prev )) {
HXLINE( 112)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 112)										l = null();
            									}
            									else {
HXLINE( 112)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 112)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 112)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 112)		this2->image = _hx_tmp;
HXDLIN( 112)		this2->width = width;
HXDLIN( 112)		this2->height = height;
HXDLIN( 112)		this2->imageType = ( (int)(imageType) );
HXDLIN( 112)		 ::pi_xy::ImageStruct img = this2;
HXLINE( 113)		{
HXLINE( 113)			bool forceClear = false;
HXDLIN( 113)			{
HXLINE( 113)				int _g16 = 0;
HXDLIN( 113)				int _g17 = this1->height;
HXDLIN( 113)				while((_g16 < _g17)){
HXLINE( 113)					_g16 = (_g16 + 1);
HXDLIN( 113)					int dy = (_g16 - 1);
HXDLIN( 113)					{
HXLINE( 113)						int _g18 = 0;
HXDLIN( 113)						int _g19 = this1->width;
HXDLIN( 113)						while((_g18 < _g19)){
HXLINE( 113)							_g18 = (_g18 + 1);
HXDLIN( 113)							int dx = (_g18 - 1);
HXDLIN( 113)							::Dynamic this4 = this1->image;
HXDLIN( 113)							int index;
HXDLIN( 113)							if (this1->useVirtualPos) {
HXLINE( 113)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXLINE( 113)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN( 113)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 113)							int col;
HXDLIN( 113)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 113)								col = c;
            							}
HXDLIN( 113)							bool _hx_tmp2;
HXDLIN( 113)							if (this1->useMask) {
HXLINE( 113)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXLINE( 113)								_hx_tmp2 = false;
            							}
HXDLIN( 113)							if (_hx_tmp2) {
HXLINE( 113)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 113)								::Dynamic this6 = this5->image;
HXDLIN( 113)								int index1;
HXDLIN( 113)								if (this5->useVirtualPos) {
HXLINE( 113)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXLINE( 113)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN( 113)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 113)								int v1;
HXDLIN( 113)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 113)									v1 = c1;
            								}
HXDLIN( 113)								int maskPixel = v1;
HXDLIN( 113)								int this7 = col;
HXDLIN( 113)								if ((maskPixel == 0)) {
HXLINE( 113)									col = this7;
            								}
            								else {
HXLINE( 113)									Float m0;
HXDLIN( 113)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 113)									if ((this8 == 0)) {
HXLINE( 113)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float m1;
HXDLIN( 113)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 113)									if ((this9 == 0)) {
HXLINE( 113)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float m2;
HXDLIN( 113)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 113)									if ((this10 == 0)) {
HXLINE( 113)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float m3;
HXDLIN( 113)									int this11 = (maskPixel & 255);
HXDLIN( 113)									if ((this11 == 0)) {
HXLINE( 113)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 113)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 113)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 113)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 113)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 113)							if ((col != 0)) {
HXLINE( 113)								int x1 = (placesX + dx);
HXDLIN( 113)								int y1 = (placesY + dy);
HXDLIN( 113)								int c2 = col;
HXDLIN( 113)								bool _hx_tmp3;
HXDLIN( 113)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 113)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXLINE( 113)									_hx_tmp3 = false;
            								}
HXDLIN( 113)								if (_hx_tmp3) {
HXLINE( 113)									int location;
HXDLIN( 113)									if (img->useVirtualPos) {
HXLINE( 113)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE( 113)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 113)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 113)									int this13;
HXDLIN( 113)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXLINE( 113)										this13 = this12;
            									}
HXDLIN( 113)									Float a1;
HXDLIN( 113)									int this14 = ((this13 >> 24) & 255);
HXDLIN( 113)									if ((this14 == 0)) {
HXLINE( 113)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float r1;
HXDLIN( 113)									int this15 = ((this13 >> 16) & 255);
HXDLIN( 113)									if ((this15 == 0)) {
HXLINE( 113)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float g1;
HXDLIN( 113)									int this16 = ((this13 >> 8) & 255);
HXDLIN( 113)									if ((this16 == 0)) {
HXLINE( 113)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float b11;
HXDLIN( 113)									int this17 = (this13 & 255);
HXDLIN( 113)									if ((this17 == 0)) {
HXLINE( 113)										b11 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float a2;
HXDLIN( 113)									int this18 = ((col >> 24) & 255);
HXDLIN( 113)									if ((this18 == 0)) {
HXLINE( 113)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float r2;
HXDLIN( 113)									int this19 = ((col >> 16) & 255);
HXDLIN( 113)									if ((this19 == 0)) {
HXLINE( 113)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float g2;
HXDLIN( 113)									int this20 = ((col >> 8) & 255);
HXDLIN( 113)									if ((this20 == 0)) {
HXLINE( 113)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float b21;
HXDLIN( 113)									int this21 = (col & 255);
HXDLIN( 113)									if ((this21 == 0)) {
HXLINE( 113)										b21 = ((Float)0.);
            									}
            									else {
HXLINE( 113)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 113)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 113)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 113)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 113)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 113)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 113)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 113)									{
HXLINE( 113)										int _hx_tmp4;
HXDLIN( 113)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 113)											_hx_tmp4 = blended;
            										}
HXDLIN( 113)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE( 113)									::Dynamic this22 = img->image;
HXDLIN( 113)									int index2;
HXDLIN( 113)									if (img->useVirtualPos) {
HXLINE( 113)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE( 113)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 113)									int _hx_tmp5;
HXDLIN( 113)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE( 113)										_hx_tmp5 = c2;
            									}
HXDLIN( 113)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE( 113)								if (forceClear) {
HXLINE( 113)									::Dynamic this23 = img->image;
HXDLIN( 113)									int x2 = (placesX + dx);
HXDLIN( 113)									int y2 = (placesY + dy);
HXDLIN( 113)									int index3;
HXDLIN( 113)									if (img->useVirtualPos) {
HXLINE( 113)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXLINE( 113)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 113)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 115)		{
HXLINE( 115)			int _g20 = 0;
HXDLIN( 115)			int _g21 = this1->width;
HXDLIN( 115)			while((_g20 < _g21)){
HXLINE( 115)				_g20 = (_g20 + 1);
HXDLIN( 115)				int x3 = (_g20 - 1);
HXDLIN( 115)				{
HXLINE( 115)					int _g22 = 0;
HXDLIN( 115)					int _g23 = placesY;
HXDLIN( 115)					while((_g22 < _g23)){
HXLINE( 115)						_g22 = (_g22 + 1);
HXDLIN( 115)						int y3 = (_g22 - 1);
HXLINE( 117)						{
HXLINE( 117)							int x4 = (x3 + placesX);
HXDLIN( 117)							::Dynamic this24 = this1->image;
HXDLIN( 117)							int index4;
HXDLIN( 117)							if (this1->useVirtualPos) {
HXLINE( 117)								index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXLINE( 117)								index4 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x3)) ));
            							}
HXDLIN( 117)							int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 117)							int color;
HXDLIN( 117)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)								color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 117)								color = c3;
            							}
HXDLIN( 117)							int color1 = color;
HXDLIN( 117)							{
HXLINE( 117)								int c4 = color1;
HXDLIN( 117)								bool _hx_tmp6;
HXDLIN( 117)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 117)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXLINE( 117)									_hx_tmp6 = false;
            								}
HXDLIN( 117)								if (_hx_tmp6) {
HXLINE( 117)									int location1;
HXDLIN( 117)									if (img->useVirtualPos) {
HXLINE( 117)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 117)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 117)									int this25 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 117)									int this26;
HXDLIN( 117)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)										this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            									}
            									else {
HXLINE( 117)										this26 = this25;
            									}
HXDLIN( 117)									Float a11;
HXDLIN( 117)									int this27 = ((this26 >> 24) & 255);
HXDLIN( 117)									if ((this27 == 0)) {
HXLINE( 117)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float r11;
HXDLIN( 117)									int this28 = ((this26 >> 16) & 255);
HXDLIN( 117)									if ((this28 == 0)) {
HXLINE( 117)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float g11;
HXDLIN( 117)									int this29 = ((this26 >> 8) & 255);
HXDLIN( 117)									if ((this29 == 0)) {
HXLINE( 117)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float b12;
HXDLIN( 117)									int this30 = (this26 & 255);
HXDLIN( 117)									if ((this30 == 0)) {
HXLINE( 117)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float a21;
HXDLIN( 117)									int this31 = ((color1 >> 24) & 255);
HXDLIN( 117)									if ((this31 == 0)) {
HXLINE( 117)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float r21;
HXDLIN( 117)									int this32 = ((color1 >> 16) & 255);
HXDLIN( 117)									if ((this32 == 0)) {
HXLINE( 117)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float g21;
HXDLIN( 117)									int this33 = ((color1 >> 8) & 255);
HXDLIN( 117)									if ((this33 == 0)) {
HXLINE( 117)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float b22;
HXDLIN( 117)									int this34 = (color1 & 255);
HXDLIN( 117)									if ((this34 == 0)) {
HXLINE( 117)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 117)										b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 117)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 117)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 117)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 117)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 117)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 117)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 117)									{
HXLINE( 117)										int _hx_tmp7;
HXDLIN( 117)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 117)											_hx_tmp7 = blended1;
            										}
HXDLIN( 117)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 117)									::Dynamic this35 = img->image;
HXDLIN( 117)									int index5;
HXDLIN( 117)									if (img->useVirtualPos) {
HXLINE( 117)										index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 117)										index5 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 117)									int _hx_tmp8;
HXDLIN( 117)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 117)										_hx_tmp8 = c4;
            									}
HXDLIN( 117)									::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp8);
            								}
            							}
            						}
HXLINE( 119)						{
HXLINE( 119)							int x5 = (x3 + placesX);
HXDLIN( 119)							int y4 = ((img->height - y3) - 1);
HXDLIN( 119)							int y5 = (this1->height - 1);
HXDLIN( 119)							::Dynamic this36 = this1->image;
HXDLIN( 119)							int index6;
HXDLIN( 119)							if (this1->useVirtualPos) {
HXLINE( 119)								index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXLINE( 119)								index6 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x3)) ));
            							}
HXDLIN( 119)							int c5 = ::iterMagic::Iimg_obj::get(this36,index6);
HXDLIN( 119)							int color2;
HXDLIN( 119)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)								color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            							}
            							else {
HXLINE( 119)								color2 = c5;
            							}
HXDLIN( 119)							{
HXLINE( 119)								int c6 = color2;
HXDLIN( 119)								bool _hx_tmp9;
HXDLIN( 119)								if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 119)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXLINE( 119)									_hx_tmp9 = false;
            								}
HXDLIN( 119)								if (_hx_tmp9) {
HXLINE( 119)									int location2;
HXDLIN( 119)									if (img->useVirtualPos) {
HXLINE( 119)										location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE( 119)										location2 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN( 119)									int this37 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 119)									int this38;
HXDLIN( 119)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)										this38 = ((((((this37 >> 24) & 255) << 24) | ((this37 & 255) << 16)) | (((this37 >> 8) & 255) << 8)) | ((this37 >> 16) & 255));
            									}
            									else {
HXLINE( 119)										this38 = this37;
            									}
HXDLIN( 119)									Float a12;
HXDLIN( 119)									int this39 = ((this38 >> 24) & 255);
HXDLIN( 119)									if ((this39 == 0)) {
HXLINE( 119)										a12 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										a12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float r12;
HXDLIN( 119)									int this40 = ((this38 >> 16) & 255);
HXDLIN( 119)									if ((this40 == 0)) {
HXLINE( 119)										r12 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										r12 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float g12;
HXDLIN( 119)									int this41 = ((this38 >> 8) & 255);
HXDLIN( 119)									if ((this41 == 0)) {
HXLINE( 119)										g12 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										g12 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float b13;
HXDLIN( 119)									int this42 = (this38 & 255);
HXDLIN( 119)									if ((this42 == 0)) {
HXLINE( 119)										b13 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										b13 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float a22;
HXDLIN( 119)									int this43 = ((color2 >> 24) & 255);
HXDLIN( 119)									if ((this43 == 0)) {
HXLINE( 119)										a22 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										a22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float r22;
HXDLIN( 119)									int this44 = ((color2 >> 16) & 255);
HXDLIN( 119)									if ((this44 == 0)) {
HXLINE( 119)										r22 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										r22 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float g22;
HXDLIN( 119)									int this45 = ((color2 >> 8) & 255);
HXDLIN( 119)									if ((this45 == 0)) {
HXLINE( 119)										g22 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										g22 = (( (Float)(this45) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float b23;
HXDLIN( 119)									int this46 = (color2 & 255);
HXDLIN( 119)									if ((this46 == 0)) {
HXLINE( 119)										b23 = ((Float)0.);
            									}
            									else {
HXLINE( 119)										b23 = (( (Float)(this46) ) / ( (Float)(255) ));
            									}
HXDLIN( 119)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 119)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 119)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 119)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 119)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 119)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 119)									{
HXLINE( 119)										int _hx_tmp10;
HXDLIN( 119)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE( 119)											_hx_tmp10 = blended2;
            										}
HXDLIN( 119)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXLINE( 119)									::Dynamic this47 = img->image;
HXDLIN( 119)									int index7;
HXDLIN( 119)									if (img->useVirtualPos) {
HXLINE( 119)										index7 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE( 119)										index7 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            									}
HXDLIN( 119)									int _hx_tmp11;
HXDLIN( 119)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)										_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE( 119)										_hx_tmp11 = c6;
            									}
HXDLIN( 119)									::iterMagic::Iimg_obj::set(this47,index7,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 121)		{
HXLINE( 121)			int _g24 = 0;
HXDLIN( 121)			int _g25 = this1->height;
HXDLIN( 121)			while((_g24 < _g25)){
HXLINE( 121)				_g24 = (_g24 + 1);
HXDLIN( 121)				int y6 = (_g24 - 1);
HXDLIN( 121)				{
HXLINE( 121)					int _g26 = 0;
HXDLIN( 121)					int _g27 = placesX;
HXDLIN( 121)					while((_g26 < _g27)){
HXLINE( 121)						_g26 = (_g26 + 1);
HXDLIN( 121)						int x6 = (_g26 - 1);
HXLINE( 123)						{
HXLINE( 123)							int y7 = (y6 + placesY);
HXDLIN( 123)							::Dynamic this48 = this1->image;
HXDLIN( 123)							int index8;
HXDLIN( 123)							if (this1->useVirtualPos) {
HXLINE( 123)								index8 = ::Std_obj::_hx_int((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXLINE( 123)								index8 = ::Std_obj::_hx_int(( (Float)((y6 * this1->width)) ));
            							}
HXDLIN( 123)							int c7 = ::iterMagic::Iimg_obj::get(this48,index8);
HXDLIN( 123)							int color3;
HXDLIN( 123)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)								color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            							}
            							else {
HXLINE( 123)								color3 = c7;
            							}
HXDLIN( 123)							int color4 = color3;
HXDLIN( 123)							{
HXLINE( 123)								int c8 = color4;
HXDLIN( 123)								bool _hx_tmp12;
HXDLIN( 123)								if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 123)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXLINE( 123)									_hx_tmp12 = false;
            								}
HXDLIN( 123)								if (_hx_tmp12) {
HXLINE( 123)									int location3;
HXDLIN( 123)									if (img->useVirtualPos) {
HXLINE( 123)										location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE( 123)										location3 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x6)) ));
            									}
HXDLIN( 123)									int this49 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 123)									int this50;
HXDLIN( 123)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)										this50 = ((((((this49 >> 24) & 255) << 24) | ((this49 & 255) << 16)) | (((this49 >> 8) & 255) << 8)) | ((this49 >> 16) & 255));
            									}
            									else {
HXLINE( 123)										this50 = this49;
            									}
HXDLIN( 123)									Float a13;
HXDLIN( 123)									int this51 = ((this50 >> 24) & 255);
HXDLIN( 123)									if ((this51 == 0)) {
HXLINE( 123)										a13 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float r13;
HXDLIN( 123)									int this52 = ((this50 >> 16) & 255);
HXDLIN( 123)									if ((this52 == 0)) {
HXLINE( 123)										r13 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										r13 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float g13;
HXDLIN( 123)									int this53 = ((this50 >> 8) & 255);
HXDLIN( 123)									if ((this53 == 0)) {
HXLINE( 123)										g13 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										g13 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float b14;
HXDLIN( 123)									int this54 = (this50 & 255);
HXDLIN( 123)									if ((this54 == 0)) {
HXLINE( 123)										b14 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										b14 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float a23;
HXDLIN( 123)									int this55 = ((color4 >> 24) & 255);
HXDLIN( 123)									if ((this55 == 0)) {
HXLINE( 123)										a23 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										a23 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float r23;
HXDLIN( 123)									int this56 = ((color4 >> 16) & 255);
HXDLIN( 123)									if ((this56 == 0)) {
HXLINE( 123)										r23 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										r23 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float g23;
HXDLIN( 123)									int this57 = ((color4 >> 8) & 255);
HXDLIN( 123)									if ((this57 == 0)) {
HXLINE( 123)										g23 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										g23 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float b24;
HXDLIN( 123)									int this58 = (color4 & 255);
HXDLIN( 123)									if ((this58 == 0)) {
HXLINE( 123)										b24 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										b24 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 123)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 123)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 123)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 123)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 123)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 123)									{
HXLINE( 123)										int _hx_tmp13;
HXDLIN( 123)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE( 123)											_hx_tmp13 = blended3;
            										}
HXDLIN( 123)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXLINE( 123)									::Dynamic this59 = img->image;
HXDLIN( 123)									int index9;
HXDLIN( 123)									if (img->useVirtualPos) {
HXLINE( 123)										index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE( 123)										index9 = ::Std_obj::_hx_int(( (Float)(((y7 * img->width) + x6)) ));
            									}
HXDLIN( 123)									int _hx_tmp14;
HXDLIN( 123)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)										_hx_tmp14 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE( 123)										_hx_tmp14 = c8;
            									}
HXDLIN( 123)									::iterMagic::Iimg_obj::set(this59,index9,_hx_tmp14);
            								}
            							}
            						}
HXLINE( 125)						{
HXLINE( 125)							int x7 = ((img->width - x6) - 1);
HXDLIN( 125)							int y8 = (y6 + placesY);
HXDLIN( 125)							int x8 = (this1->width - 1);
HXDLIN( 125)							::Dynamic this60 = this1->image;
HXDLIN( 125)							int index10;
HXDLIN( 125)							if (this1->useVirtualPos) {
HXLINE( 125)								index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            							}
            							else {
HXLINE( 125)								index10 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x8)) ));
            							}
HXDLIN( 125)							int c9 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 125)							int color5;
HXDLIN( 125)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)								color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            							}
            							else {
HXLINE( 125)								color5 = c9;
            							}
HXDLIN( 125)							{
HXLINE( 125)								int c10 = color5;
HXDLIN( 125)								bool _hx_tmp15;
HXDLIN( 125)								if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 125)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXLINE( 125)									_hx_tmp15 = false;
            								}
HXDLIN( 125)								if (_hx_tmp15) {
HXLINE( 125)									int location4;
HXDLIN( 125)									if (img->useVirtualPos) {
HXLINE( 125)										location4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE( 125)										location4 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            									}
HXDLIN( 125)									int this61 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 125)									int this62;
HXDLIN( 125)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)										this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            									}
            									else {
HXLINE( 125)										this62 = this61;
            									}
HXDLIN( 125)									Float a14;
HXDLIN( 125)									int this63 = ((this62 >> 24) & 255);
HXDLIN( 125)									if ((this63 == 0)) {
HXLINE( 125)										a14 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float r14;
HXDLIN( 125)									int this64 = ((this62 >> 16) & 255);
HXDLIN( 125)									if ((this64 == 0)) {
HXLINE( 125)										r14 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										r14 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float g14;
HXDLIN( 125)									int this65 = ((this62 >> 8) & 255);
HXDLIN( 125)									if ((this65 == 0)) {
HXLINE( 125)										g14 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										g14 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float b15;
HXDLIN( 125)									int this66 = (this62 & 255);
HXDLIN( 125)									if ((this66 == 0)) {
HXLINE( 125)										b15 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										b15 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float a24;
HXDLIN( 125)									int this67 = ((color5 >> 24) & 255);
HXDLIN( 125)									if ((this67 == 0)) {
HXLINE( 125)										a24 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										a24 = (( (Float)(this67) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float r24;
HXDLIN( 125)									int this68 = ((color5 >> 16) & 255);
HXDLIN( 125)									if ((this68 == 0)) {
HXLINE( 125)										r24 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										r24 = (( (Float)(this68) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float g24;
HXDLIN( 125)									int this69 = ((color5 >> 8) & 255);
HXDLIN( 125)									if ((this69 == 0)) {
HXLINE( 125)										g24 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										g24 = (( (Float)(this69) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float b25;
HXDLIN( 125)									int this70 = (color5 & 255);
HXDLIN( 125)									if ((this70 == 0)) {
HXLINE( 125)										b25 = ((Float)0.);
            									}
            									else {
HXLINE( 125)										b25 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN( 125)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 125)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 125)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 125)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 125)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 125)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN( 125)									{
HXLINE( 125)										int _hx_tmp16;
HXDLIN( 125)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXLINE( 125)											_hx_tmp16 = blended4;
            										}
HXDLIN( 125)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXLINE( 125)									::Dynamic this71 = img->image;
HXDLIN( 125)									int index11;
HXDLIN( 125)									if (img->useVirtualPos) {
HXLINE( 125)										index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            									}
            									else {
HXLINE( 125)										index11 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            									}
HXDLIN( 125)									int _hx_tmp17;
HXDLIN( 125)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)										_hx_tmp17 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE( 125)										_hx_tmp17 = c10;
            									}
HXDLIN( 125)									::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 128)		{
HXLINE( 128)			int _g28 = 0;
HXDLIN( 128)			int _g29 = placesX;
HXDLIN( 128)			while((_g28 < _g29)){
HXLINE( 128)				_g28 = (_g28 + 1);
HXDLIN( 128)				int x9 = (_g28 - 1);
HXDLIN( 128)				{
HXLINE( 128)					int _g30 = 0;
HXDLIN( 128)					int _g31 = placesY;
HXDLIN( 128)					while((_g30 < _g31)){
HXLINE( 128)						_g30 = (_g30 + 1);
HXDLIN( 128)						int y9 = (_g30 - 1);
HXLINE( 130)						{
HXLINE( 130)							::Dynamic this72 = this1->image;
HXDLIN( 130)							int index12;
HXDLIN( 130)							if (this1->useVirtualPos) {
HXLINE( 130)								index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXLINE( 130)								index12 = ::Std_obj::_hx_int(( (Float)((0 * this1->width)) ));
            							}
HXDLIN( 130)							int c11 = ::iterMagic::Iimg_obj::get(this72,index12);
HXDLIN( 130)							int color6;
HXDLIN( 130)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 130)								color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            							}
            							else {
HXLINE( 130)								color6 = c11;
            							}
HXDLIN( 130)							int color7 = color6;
HXDLIN( 130)							{
HXLINE( 130)								int c12 = color7;
HXDLIN( 130)								bool _hx_tmp18;
HXDLIN( 130)								if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 130)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXLINE( 130)									_hx_tmp18 = false;
            								}
HXDLIN( 130)								if (_hx_tmp18) {
HXLINE( 130)									int location5;
HXDLIN( 130)									if (img->useVirtualPos) {
HXLINE( 130)										location5 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 130)										location5 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            									}
HXDLIN( 130)									int this73 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 130)									int this74;
HXDLIN( 130)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 130)										this74 = ((((((this73 >> 24) & 255) << 24) | ((this73 & 255) << 16)) | (((this73 >> 8) & 255) << 8)) | ((this73 >> 16) & 255));
            									}
            									else {
HXLINE( 130)										this74 = this73;
            									}
HXDLIN( 130)									Float a15;
HXDLIN( 130)									int this75 = ((this74 >> 24) & 255);
HXDLIN( 130)									if ((this75 == 0)) {
HXLINE( 130)										a15 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										a15 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float r15;
HXDLIN( 130)									int this76 = ((this74 >> 16) & 255);
HXDLIN( 130)									if ((this76 == 0)) {
HXLINE( 130)										r15 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										r15 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float g15;
HXDLIN( 130)									int this77 = ((this74 >> 8) & 255);
HXDLIN( 130)									if ((this77 == 0)) {
HXLINE( 130)										g15 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										g15 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float b16;
HXDLIN( 130)									int this78 = (this74 & 255);
HXDLIN( 130)									if ((this78 == 0)) {
HXLINE( 130)										b16 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										b16 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float a25;
HXDLIN( 130)									int this79 = ((color7 >> 24) & 255);
HXDLIN( 130)									if ((this79 == 0)) {
HXLINE( 130)										a25 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										a25 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float r25;
HXDLIN( 130)									int this80 = ((color7 >> 16) & 255);
HXDLIN( 130)									if ((this80 == 0)) {
HXLINE( 130)										r25 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										r25 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float g25;
HXDLIN( 130)									int this81 = ((color7 >> 8) & 255);
HXDLIN( 130)									if ((this81 == 0)) {
HXLINE( 130)										g25 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										g25 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float b26;
HXDLIN( 130)									int this82 = (color7 & 255);
HXDLIN( 130)									if ((this82 == 0)) {
HXLINE( 130)										b26 = ((Float)0.);
            									}
            									else {
HXLINE( 130)										b26 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN( 130)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 130)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 130)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 130)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 130)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 130)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN( 130)									{
HXLINE( 130)										int _hx_tmp19;
HXDLIN( 130)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 130)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXLINE( 130)											_hx_tmp19 = blended5;
            										}
HXDLIN( 130)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXLINE( 130)									::Dynamic this83 = img->image;
HXDLIN( 130)									int index13;
HXDLIN( 130)									if (img->useVirtualPos) {
HXLINE( 130)										index13 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 130)										index13 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            									}
HXDLIN( 130)									int _hx_tmp20;
HXDLIN( 130)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 130)										_hx_tmp20 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXLINE( 130)										_hx_tmp20 = c12;
            									}
HXDLIN( 130)									::iterMagic::Iimg_obj::set(this83,index13,_hx_tmp20);
            								}
            							}
            						}
HXLINE( 131)						{
HXLINE( 131)							int x10 = ((x9 + placesX) + this1->width);
HXDLIN( 131)							int x11 = (this1->width - 1);
HXDLIN( 131)							::Dynamic this84 = this1->image;
HXDLIN( 131)							int index14;
HXDLIN( 131)							if (this1->useVirtualPos) {
HXLINE( 131)								index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            							}
            							else {
HXLINE( 131)								index14 = ::Std_obj::_hx_int(( (Float)(((0 * this1->width) + x11)) ));
            							}
HXDLIN( 131)							int c13 = ::iterMagic::Iimg_obj::get(this84,index14);
HXDLIN( 131)							int color8;
HXDLIN( 131)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 131)								color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            							}
            							else {
HXLINE( 131)								color8 = c13;
            							}
HXDLIN( 131)							{
HXLINE( 131)								int c14 = color8;
HXDLIN( 131)								bool _hx_tmp21;
HXDLIN( 131)								if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 131)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXLINE( 131)									_hx_tmp21 = false;
            								}
HXDLIN( 131)								if (_hx_tmp21) {
HXLINE( 131)									int location6;
HXDLIN( 131)									if (img->useVirtualPos) {
HXLINE( 131)										location6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 131)										location6 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 131)									int this85 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 131)									int this86;
HXDLIN( 131)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 131)										this86 = ((((((this85 >> 24) & 255) << 24) | ((this85 & 255) << 16)) | (((this85 >> 8) & 255) << 8)) | ((this85 >> 16) & 255));
            									}
            									else {
HXLINE( 131)										this86 = this85;
            									}
HXDLIN( 131)									Float a16;
HXDLIN( 131)									int this87 = ((this86 >> 24) & 255);
HXDLIN( 131)									if ((this87 == 0)) {
HXLINE( 131)										a16 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										a16 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float r16;
HXDLIN( 131)									int this88 = ((this86 >> 16) & 255);
HXDLIN( 131)									if ((this88 == 0)) {
HXLINE( 131)										r16 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										r16 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float g16;
HXDLIN( 131)									int this89 = ((this86 >> 8) & 255);
HXDLIN( 131)									if ((this89 == 0)) {
HXLINE( 131)										g16 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										g16 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float b17;
HXDLIN( 131)									int this90 = (this86 & 255);
HXDLIN( 131)									if ((this90 == 0)) {
HXLINE( 131)										b17 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										b17 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float a26;
HXDLIN( 131)									int this91 = ((color8 >> 24) & 255);
HXDLIN( 131)									if ((this91 == 0)) {
HXLINE( 131)										a26 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										a26 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float r26;
HXDLIN( 131)									int this92 = ((color8 >> 16) & 255);
HXDLIN( 131)									if ((this92 == 0)) {
HXLINE( 131)										r26 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										r26 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float g26;
HXDLIN( 131)									int this93 = ((color8 >> 8) & 255);
HXDLIN( 131)									if ((this93 == 0)) {
HXLINE( 131)										g26 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										g26 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float b27;
HXDLIN( 131)									int this94 = (color8 & 255);
HXDLIN( 131)									if ((this94 == 0)) {
HXLINE( 131)										b27 = ((Float)0.);
            									}
            									else {
HXLINE( 131)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 131)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 131)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 131)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 131)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN( 131)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 131)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN( 131)									{
HXLINE( 131)										int _hx_tmp22;
HXDLIN( 131)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 131)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXLINE( 131)											_hx_tmp22 = blended6;
            										}
HXDLIN( 131)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXLINE( 131)									::Dynamic this95 = img->image;
HXDLIN( 131)									int index15;
HXDLIN( 131)									if (img->useVirtualPos) {
HXLINE( 131)										index15 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 131)										index15 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x10)) ));
            									}
HXDLIN( 131)									int _hx_tmp23;
HXDLIN( 131)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 131)										_hx_tmp23 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXLINE( 131)										_hx_tmp23 = c14;
            									}
HXDLIN( 131)									::iterMagic::Iimg_obj::set(this95,index15,_hx_tmp23);
            								}
            							}
            						}
HXLINE( 132)						{
HXLINE( 132)							int x12 = ((x9 + placesX) + this1->width);
HXDLIN( 132)							int y10 = ((y9 + placesY) + this1->height);
HXDLIN( 132)							int x13 = (this1->width - 1);
HXDLIN( 132)							int y11 = (this1->height - 1);
HXDLIN( 132)							::Dynamic this96 = this1->image;
HXDLIN( 132)							int index16;
HXDLIN( 132)							if (this1->useVirtualPos) {
HXLINE( 132)								index16 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x13) - this1->virtualX));
            							}
            							else {
HXLINE( 132)								index16 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x13)) ));
            							}
HXDLIN( 132)							int c15 = ::iterMagic::Iimg_obj::get(this96,index16);
HXDLIN( 132)							int color9;
HXDLIN( 132)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)								color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            							}
            							else {
HXLINE( 132)								color9 = c15;
            							}
HXDLIN( 132)							{
HXLINE( 132)								int c16 = color9;
HXDLIN( 132)								bool _hx_tmp24;
HXDLIN( 132)								if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 132)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXLINE( 132)									_hx_tmp24 = false;
            								}
HXDLIN( 132)								if (_hx_tmp24) {
HXLINE( 132)									int location7;
HXDLIN( 132)									if (img->useVirtualPos) {
HXLINE( 132)										location7 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXLINE( 132)										location7 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 132)									int this97 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 132)									int this98;
HXDLIN( 132)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)										this98 = ((((((this97 >> 24) & 255) << 24) | ((this97 & 255) << 16)) | (((this97 >> 8) & 255) << 8)) | ((this97 >> 16) & 255));
            									}
            									else {
HXLINE( 132)										this98 = this97;
            									}
HXDLIN( 132)									Float a17;
HXDLIN( 132)									int this99 = ((this98 >> 24) & 255);
HXDLIN( 132)									if ((this99 == 0)) {
HXLINE( 132)										a17 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										a17 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float r17;
HXDLIN( 132)									int this100 = ((this98 >> 16) & 255);
HXDLIN( 132)									if ((this100 == 0)) {
HXLINE( 132)										r17 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										r17 = (( (Float)(this100) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float g17;
HXDLIN( 132)									int this101 = ((this98 >> 8) & 255);
HXDLIN( 132)									if ((this101 == 0)) {
HXLINE( 132)										g17 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										g17 = (( (Float)(this101) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float b18;
HXDLIN( 132)									int this102 = (this98 & 255);
HXDLIN( 132)									if ((this102 == 0)) {
HXLINE( 132)										b18 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										b18 = (( (Float)(this102) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float a27;
HXDLIN( 132)									int this103 = ((color9 >> 24) & 255);
HXDLIN( 132)									if ((this103 == 0)) {
HXLINE( 132)										a27 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										a27 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float r27;
HXDLIN( 132)									int this104 = ((color9 >> 16) & 255);
HXDLIN( 132)									if ((this104 == 0)) {
HXLINE( 132)										r27 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										r27 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float g27;
HXDLIN( 132)									int this105 = ((color9 >> 8) & 255);
HXDLIN( 132)									if ((this105 == 0)) {
HXLINE( 132)										g27 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										g27 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float b28;
HXDLIN( 132)									int this106 = (color9 & 255);
HXDLIN( 132)									if ((this106 == 0)) {
HXLINE( 132)										b28 = ((Float)0.);
            									}
            									else {
HXLINE( 132)										b28 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN( 132)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN( 132)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 132)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 132)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN( 132)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 132)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN( 132)									{
HXLINE( 132)										int _hx_tmp25;
HXDLIN( 132)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXLINE( 132)											_hx_tmp25 = blended7;
            										}
HXDLIN( 132)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXLINE( 132)									::Dynamic this107 = img->image;
HXDLIN( 132)									int index17;
HXDLIN( 132)									if (img->useVirtualPos) {
HXLINE( 132)										index17 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXLINE( 132)										index17 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 132)									int _hx_tmp26;
HXDLIN( 132)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)										_hx_tmp26 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            									}
            									else {
HXLINE( 132)										_hx_tmp26 = c16;
            									}
HXDLIN( 132)									::iterMagic::Iimg_obj::set(this107,index17,_hx_tmp26);
            								}
            							}
            						}
HXLINE( 133)						{
HXLINE( 133)							int y12 = ((y9 + placesY) + this1->width);
HXDLIN( 133)							int y13 = (this1->height - 1);
HXDLIN( 133)							::Dynamic this108 = this1->image;
HXDLIN( 133)							int index18;
HXDLIN( 133)							if (this1->useVirtualPos) {
HXLINE( 133)								index18 = ::Std_obj::_hx_int((((( (Float)(y13) ) - this1->virtualY) * ( (Float)(this1->width) )) - this1->virtualX));
            							}
            							else {
HXLINE( 133)								index18 = ::Std_obj::_hx_int(( (Float)((y13 * this1->width)) ));
            							}
HXDLIN( 133)							int c17 = ::iterMagic::Iimg_obj::get(this108,index18);
HXDLIN( 133)							int color10;
HXDLIN( 133)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 133)								color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            							}
            							else {
HXLINE( 133)								color10 = c17;
            							}
HXDLIN( 133)							{
HXLINE( 133)								int c18 = color10;
HXDLIN( 133)								bool _hx_tmp27;
HXDLIN( 133)								if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 133)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXLINE( 133)									_hx_tmp27 = false;
            								}
HXDLIN( 133)								if (_hx_tmp27) {
HXLINE( 133)									int location8;
HXDLIN( 133)									if (img->useVirtualPos) {
HXLINE( 133)										location8 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 133)										location8 = ::Std_obj::_hx_int(( (Float)(((y12 * img->width) + x9)) ));
            									}
HXDLIN( 133)									int this109 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 133)									int this110;
HXDLIN( 133)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 133)										this110 = ((((((this109 >> 24) & 255) << 24) | ((this109 & 255) << 16)) | (((this109 >> 8) & 255) << 8)) | ((this109 >> 16) & 255));
            									}
            									else {
HXLINE( 133)										this110 = this109;
            									}
HXDLIN( 133)									Float a19;
HXDLIN( 133)									int this111 = ((this110 >> 24) & 255);
HXDLIN( 133)									if ((this111 == 0)) {
HXLINE( 133)										a19 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										a19 = (( (Float)(this111) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float r18;
HXDLIN( 133)									int this112 = ((this110 >> 16) & 255);
HXDLIN( 133)									if ((this112 == 0)) {
HXLINE( 133)										r18 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										r18 = (( (Float)(this112) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float g18;
HXDLIN( 133)									int this113 = ((this110 >> 8) & 255);
HXDLIN( 133)									if ((this113 == 0)) {
HXLINE( 133)										g18 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										g18 = (( (Float)(this113) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float b19;
HXDLIN( 133)									int this114 = (this110 & 255);
HXDLIN( 133)									if ((this114 == 0)) {
HXLINE( 133)										b19 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										b19 = (( (Float)(this114) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float a28;
HXDLIN( 133)									int this115 = ((color10 >> 24) & 255);
HXDLIN( 133)									if ((this115 == 0)) {
HXLINE( 133)										a28 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										a28 = (( (Float)(this115) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float r28;
HXDLIN( 133)									int this116 = ((color10 >> 16) & 255);
HXDLIN( 133)									if ((this116 == 0)) {
HXLINE( 133)										r28 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										r28 = (( (Float)(this116) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float g28;
HXDLIN( 133)									int this117 = ((color10 >> 8) & 255);
HXDLIN( 133)									if ((this117 == 0)) {
HXLINE( 133)										g28 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										g28 = (( (Float)(this117) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float b29;
HXDLIN( 133)									int this118 = (color10 & 255);
HXDLIN( 133)									if ((this118 == 0)) {
HXLINE( 133)										b29 = ((Float)0.);
            									}
            									else {
HXLINE( 133)										b29 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 133)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN( 133)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 133)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 133)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN( 133)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 133)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN( 133)									{
HXLINE( 133)										int _hx_tmp28;
HXDLIN( 133)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 133)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXLINE( 133)											_hx_tmp28 = blended8;
            										}
HXDLIN( 133)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXLINE( 133)									::Dynamic this119 = img->image;
HXDLIN( 133)									int index19;
HXDLIN( 133)									if (img->useVirtualPos) {
HXLINE( 133)										index19 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            									}
            									else {
HXLINE( 133)										index19 = ::Std_obj::_hx_int(( (Float)(((y12 * img->width) + x9)) ));
            									}
HXDLIN( 133)									int _hx_tmp29;
HXDLIN( 133)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 133)										_hx_tmp29 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXLINE( 133)										_hx_tmp29 = c18;
            									}
HXDLIN( 133)									::iterMagic::Iimg_obj::set(this119,index19,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 135)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectanglePad_Impl__obj,padImageXY,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::padWrapImage( ::pi_xy::ImageStruct this1,int places){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_139_padWrapImage)
HXDLIN( 139)		int width = (this1->width + (2 * places));
HXDLIN( 139)		int height = (this1->height + (2 * places));
HXDLIN( 139)		 ::Dynamic imageType = null();
HXDLIN( 139)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 139)		if (::hx::IsNull( imageType )) {
HXDLIN( 139)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 139)		::Dynamic _hx_tmp;
HXDLIN( 139)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 139)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 139)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 139)				{
HXDLIN( 139)					b->width = width;
HXDLIN( 139)					b->height = height;
HXDLIN( 139)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 139)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 139)					{
HXDLIN( 139)						int len = b->length;
HXDLIN( 139)						int w = 0;
HXDLIN( 139)						{
HXDLIN( 139)							int _g = 0;
HXDLIN( 139)							int _g1 = b->height;
HXDLIN( 139)							while((_g < _g1)){
HXDLIN( 139)								_g = (_g + 1);
HXDLIN( 139)								int y = (_g - 1);
HXDLIN( 139)								{
HXDLIN( 139)									int _g2 = 0;
HXDLIN( 139)									int _g3 = b->width;
HXDLIN( 139)									while((_g2 < _g3)){
HXDLIN( 139)										_g2 = (_g2 + 1);
HXDLIN( 139)										int x = (_g2 - 1);
HXDLIN( 139)										{
HXDLIN( 139)											w = (w + 1);
HXDLIN( 139)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 139)										{
HXDLIN( 139)											w = (w + 1);
HXDLIN( 139)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 139)										{
HXDLIN( 139)											w = (w + 1);
HXDLIN( 139)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 139)										{
HXDLIN( 139)											w = (w + 1);
HXDLIN( 139)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 139)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 139)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 139)				{
HXDLIN( 139)					a->width = width;
HXDLIN( 139)					a->height = height;
HXDLIN( 139)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 139)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 139)					{
HXDLIN( 139)						int _g4 = 0;
HXDLIN( 139)						int _g5 = a->length;
HXDLIN( 139)						while((_g4 < _g5)){
HXDLIN( 139)							_g4 = (_g4 + 1);
HXDLIN( 139)							int i = (_g4 - 1);
HXDLIN( 139)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 139)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 139)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 139)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 139)				{
HXDLIN( 139)					b1->width = width;
HXDLIN( 139)					b1->height = height;
HXDLIN( 139)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 139)					int size = (b1->length * 4);
HXDLIN( 139)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 139)					{
HXDLIN( 139)						int _g6 = 0;
HXDLIN( 139)						int _g7 = b1->length;
HXDLIN( 139)						while((_g6 < _g7)){
HXDLIN( 139)							_g6 = (_g6 + 1);
HXDLIN( 139)							int i1 = (_g6 - 1);
HXDLIN( 139)							{
HXDLIN( 139)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 139)								bool _hx_tmp1;
HXDLIN( 139)								if ((i1 >= 0)) {
HXDLIN( 139)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 139)									_hx_tmp1 = false;
            								}
HXDLIN( 139)								if (_hx_tmp1) {
HXDLIN( 139)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 139)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 139)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 139)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 139)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 139)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 139)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 139)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 139)				{
HXDLIN( 139)					v->width = width;
HXDLIN( 139)					v->height = height;
HXDLIN( 139)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 139)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 139)					{
HXDLIN( 139)						int _g8 = 0;
HXDLIN( 139)						int _g9 = v->length;
HXDLIN( 139)						while((_g8 < _g9)){
HXDLIN( 139)							_g8 = (_g8 + 1);
HXDLIN( 139)							int i2 = (_g8 - 1);
HXDLIN( 139)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 139)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 139)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 139)				{
HXDLIN( 139)					b2->width = width;
HXDLIN( 139)					b2->height = height;
HXDLIN( 139)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 139)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 139)					{
HXDLIN( 139)						int len1 = b2->length;
HXDLIN( 139)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 139)						if (::hx::IsNull( d->head )) {
HXDLIN( 139)							int _g10 = 0;
HXDLIN( 139)							int _g11 = len1;
HXDLIN( 139)							while((_g10 < _g11)){
HXDLIN( 139)								_g10 = (_g10 + 1);
HXDLIN( 139)								int i3 = (_g10 - 1);
HXDLIN( 139)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 139)							int _g12 = 0;
HXDLIN( 139)							int _g13 = len1;
HXDLIN( 139)							while((_g12 < _g13)){
HXDLIN( 139)								_g12 = (_g12 + 1);
HXDLIN( 139)								int i4 = (_g12 - 1);
HXDLIN( 139)								{
HXDLIN( 139)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 139)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 139)									{
HXDLIN( 139)										int _g14 = 0;
HXDLIN( 139)										int _g15 = i4;
HXDLIN( 139)										while((_g14 < _g15)){
HXDLIN( 139)											_g14 = (_g14 + 1);
HXDLIN( 139)											int i5 = (_g14 - 1);
HXDLIN( 139)											prev = l;
HXDLIN( 139)											l = l->next;
            										}
            									}
HXDLIN( 139)									if (::hx::IsNull( prev )) {
HXDLIN( 139)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 139)										l = null();
            									}
            									else {
HXDLIN( 139)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 139)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 139)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 139)		this2->image = _hx_tmp;
HXDLIN( 139)		this2->width = width;
HXDLIN( 139)		this2->height = height;
HXDLIN( 139)		this2->imageType = ( (int)(imageType) );
HXDLIN( 139)		 ::pi_xy::ImageStruct img = this2;
HXDLIN( 139)		{
HXDLIN( 139)			bool forceClear = false;
HXDLIN( 139)			{
HXDLIN( 139)				int _g16 = 0;
HXDLIN( 139)				int _g17 = this1->height;
HXDLIN( 139)				while((_g16 < _g17)){
HXDLIN( 139)					_g16 = (_g16 + 1);
HXDLIN( 139)					int dy = (_g16 - 1);
HXDLIN( 139)					{
HXDLIN( 139)						int _g18 = 0;
HXDLIN( 139)						int _g19 = this1->width;
HXDLIN( 139)						while((_g18 < _g19)){
HXDLIN( 139)							_g18 = (_g18 + 1);
HXDLIN( 139)							int dx = (_g18 - 1);
HXDLIN( 139)							::Dynamic this4 = this1->image;
HXDLIN( 139)							int index;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN( 139)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 139)							int col;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								col = c;
            							}
HXDLIN( 139)							bool _hx_tmp2;
HXDLIN( 139)							if (this1->useMask) {
HXDLIN( 139)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXDLIN( 139)								_hx_tmp2 = false;
            							}
HXDLIN( 139)							if (_hx_tmp2) {
HXDLIN( 139)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 139)								::Dynamic this6 = this5->image;
HXDLIN( 139)								int index1;
HXDLIN( 139)								if (this5->useVirtualPos) {
HXDLIN( 139)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXDLIN( 139)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN( 139)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 139)								int v1;
HXDLIN( 139)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 139)									v1 = c1;
            								}
HXDLIN( 139)								int maskPixel = v1;
HXDLIN( 139)								int this7 = col;
HXDLIN( 139)								if ((maskPixel == 0)) {
HXDLIN( 139)									col = this7;
            								}
            								else {
HXDLIN( 139)									Float m0;
HXDLIN( 139)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 139)									if ((this8 == 0)) {
HXDLIN( 139)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float m1;
HXDLIN( 139)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 139)									if ((this9 == 0)) {
HXDLIN( 139)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float m2;
HXDLIN( 139)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 139)									if ((this10 == 0)) {
HXDLIN( 139)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float m3;
HXDLIN( 139)									int this11 = (maskPixel & 255);
HXDLIN( 139)									if ((this11 == 0)) {
HXDLIN( 139)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 139)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 139)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 139)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 139)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 139)							if ((col != 0)) {
HXDLIN( 139)								int x1 = (places + dx);
HXDLIN( 139)								int y1 = (places + dy);
HXDLIN( 139)								int c2 = col;
HXDLIN( 139)								bool _hx_tmp3;
HXDLIN( 139)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp3 = false;
            								}
HXDLIN( 139)								if (_hx_tmp3) {
HXDLIN( 139)									int location;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 139)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 139)									int this13;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this13 = this12;
            									}
HXDLIN( 139)									Float a1;
HXDLIN( 139)									int this14 = ((this13 >> 24) & 255);
HXDLIN( 139)									if ((this14 == 0)) {
HXDLIN( 139)										a1 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r1;
HXDLIN( 139)									int this15 = ((this13 >> 16) & 255);
HXDLIN( 139)									if ((this15 == 0)) {
HXDLIN( 139)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g1;
HXDLIN( 139)									int this16 = ((this13 >> 8) & 255);
HXDLIN( 139)									if ((this16 == 0)) {
HXDLIN( 139)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b11;
HXDLIN( 139)									int this17 = (this13 & 255);
HXDLIN( 139)									if ((this17 == 0)) {
HXDLIN( 139)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a2;
HXDLIN( 139)									int this18 = ((col >> 24) & 255);
HXDLIN( 139)									if ((this18 == 0)) {
HXDLIN( 139)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r2;
HXDLIN( 139)									int this19 = ((col >> 16) & 255);
HXDLIN( 139)									if ((this19 == 0)) {
HXDLIN( 139)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g2;
HXDLIN( 139)									int this20 = ((col >> 8) & 255);
HXDLIN( 139)									if ((this20 == 0)) {
HXDLIN( 139)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b21;
HXDLIN( 139)									int this21 = (col & 255);
HXDLIN( 139)									if ((this21 == 0)) {
HXDLIN( 139)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 139)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp4;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp4 = blended;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this22 = img->image;
HXDLIN( 139)									int index2;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 139)									int _hx_tmp5;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp5 = c2;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXDLIN( 139)								if (forceClear) {
HXDLIN( 139)									::Dynamic this23 = img->image;
HXDLIN( 139)									int x2 = (places + dx);
HXDLIN( 139)									int y2 = (places + dy);
HXDLIN( 139)									int index3;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 139)		{
HXDLIN( 139)			int _g20 = 0;
HXDLIN( 139)			int _g21 = this1->width;
HXDLIN( 139)			while((_g20 < _g21)){
HXDLIN( 139)				_g20 = (_g20 + 1);
HXDLIN( 139)				int x3 = (_g20 - 1);
HXDLIN( 139)				{
HXDLIN( 139)					int _g22 = 0;
HXDLIN( 139)					int _g23 = places;
HXDLIN( 139)					while((_g22 < _g23)){
HXDLIN( 139)						_g22 = (_g22 + 1);
HXDLIN( 139)						int y3 = (_g22 - 1);
HXDLIN( 139)						{
HXDLIN( 139)							int x4 = (x3 + places);
HXDLIN( 139)							int y4 = (((this1->height - 1) - places) + y3);
HXDLIN( 139)							::Dynamic this24 = this1->image;
HXDLIN( 139)							int index4;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index4 = ::Std_obj::_hx_int(( (Float)(((y4 * this1->width) + x3)) ));
            							}
HXDLIN( 139)							int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 139)							int color;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color = c3;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c4 = color;
HXDLIN( 139)								bool _hx_tmp6;
HXDLIN( 139)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp6 = false;
            								}
HXDLIN( 139)								if (_hx_tmp6) {
HXDLIN( 139)									int location1;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 139)									int this25 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 139)									int this26;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this26 = this25;
            									}
HXDLIN( 139)									Float a11;
HXDLIN( 139)									int this27 = ((this26 >> 24) & 255);
HXDLIN( 139)									if ((this27 == 0)) {
HXDLIN( 139)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r11;
HXDLIN( 139)									int this28 = ((this26 >> 16) & 255);
HXDLIN( 139)									if ((this28 == 0)) {
HXDLIN( 139)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g11;
HXDLIN( 139)									int this29 = ((this26 >> 8) & 255);
HXDLIN( 139)									if ((this29 == 0)) {
HXDLIN( 139)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b12;
HXDLIN( 139)									int this30 = (this26 & 255);
HXDLIN( 139)									if ((this30 == 0)) {
HXDLIN( 139)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a21;
HXDLIN( 139)									int this31 = ((color >> 24) & 255);
HXDLIN( 139)									if ((this31 == 0)) {
HXDLIN( 139)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r21;
HXDLIN( 139)									int this32 = ((color >> 16) & 255);
HXDLIN( 139)									if ((this32 == 0)) {
HXDLIN( 139)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g21;
HXDLIN( 139)									int this33 = ((color >> 8) & 255);
HXDLIN( 139)									if ((this33 == 0)) {
HXDLIN( 139)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b22;
HXDLIN( 139)									int this34 = (color & 255);
HXDLIN( 139)									if ((this34 == 0)) {
HXDLIN( 139)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 139)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 139)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 139)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 139)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 139)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp7;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp7 = blended1;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this35 = img->image;
HXDLIN( 139)									int index5;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index5 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 139)									int _hx_tmp8;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp8 = c4;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp8);
            								}
            							}
            						}
HXDLIN( 139)						{
HXDLIN( 139)							int x5 = (x3 + places);
HXDLIN( 139)							int y5 = ((img->height - y3) - 1);
HXDLIN( 139)							int y6 = (places - y3);
HXDLIN( 139)							::Dynamic this36 = this1->image;
HXDLIN( 139)							int index6;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this1->width) + x3)) ));
            							}
HXDLIN( 139)							int c5 = ::iterMagic::Iimg_obj::get(this36,index6);
HXDLIN( 139)							int color1;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color1 = c5;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c6 = color1;
HXDLIN( 139)								bool _hx_tmp9;
HXDLIN( 139)								if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp9 = false;
            								}
HXDLIN( 139)								if (_hx_tmp9) {
HXDLIN( 139)									int location2;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x5)) ));
            									}
HXDLIN( 139)									int this37 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 139)									int this38;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this38 = ((((((this37 >> 24) & 255) << 24) | ((this37 & 255) << 16)) | (((this37 >> 8) & 255) << 8)) | ((this37 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this38 = this37;
            									}
HXDLIN( 139)									Float a12;
HXDLIN( 139)									int this39 = ((this38 >> 24) & 255);
HXDLIN( 139)									if ((this39 == 0)) {
HXDLIN( 139)										a12 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r12;
HXDLIN( 139)									int this40 = ((this38 >> 16) & 255);
HXDLIN( 139)									if ((this40 == 0)) {
HXDLIN( 139)										r12 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r12 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g12;
HXDLIN( 139)									int this41 = ((this38 >> 8) & 255);
HXDLIN( 139)									if ((this41 == 0)) {
HXDLIN( 139)										g12 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g12 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b13;
HXDLIN( 139)									int this42 = (this38 & 255);
HXDLIN( 139)									if ((this42 == 0)) {
HXDLIN( 139)										b13 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b13 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a22;
HXDLIN( 139)									int this43 = ((color1 >> 24) & 255);
HXDLIN( 139)									if ((this43 == 0)) {
HXDLIN( 139)										a22 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r22;
HXDLIN( 139)									int this44 = ((color1 >> 16) & 255);
HXDLIN( 139)									if ((this44 == 0)) {
HXDLIN( 139)										r22 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r22 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g22;
HXDLIN( 139)									int this45 = ((color1 >> 8) & 255);
HXDLIN( 139)									if ((this45 == 0)) {
HXDLIN( 139)										g22 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g22 = (( (Float)(this45) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b23;
HXDLIN( 139)									int this46 = (color1 & 255);
HXDLIN( 139)									if ((this46 == 0)) {
HXDLIN( 139)										b23 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b23 = (( (Float)(this46) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 139)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 139)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 139)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 139)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 139)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp10;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp10 = blended2;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this47 = img->image;
HXDLIN( 139)									int index7;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x5)) ));
            									}
HXDLIN( 139)									int _hx_tmp11;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp11 = c6;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this47,index7,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 139)		{
HXDLIN( 139)			int _g24 = 0;
HXDLIN( 139)			int _g25 = this1->height;
HXDLIN( 139)			while((_g24 < _g25)){
HXDLIN( 139)				_g24 = (_g24 + 1);
HXDLIN( 139)				int y7 = (_g24 - 1);
HXDLIN( 139)				{
HXDLIN( 139)					int _g26 = 0;
HXDLIN( 139)					int _g27 = places;
HXDLIN( 139)					while((_g26 < _g27)){
HXDLIN( 139)						_g26 = (_g26 + 1);
HXDLIN( 139)						int x6 = (_g26 - 1);
HXDLIN( 139)						{
HXDLIN( 139)							int y8 = (y7 + places);
HXDLIN( 139)							int x7 = (((this1->width - 1) - places) + x6);
HXDLIN( 139)							::Dynamic this48 = this1->image;
HXDLIN( 139)							int index8;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index8 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            							}
HXDLIN( 139)							int c7 = ::iterMagic::Iimg_obj::get(this48,index8);
HXDLIN( 139)							int color2;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color2 = c7;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c8 = color2;
HXDLIN( 139)								bool _hx_tmp12;
HXDLIN( 139)								if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp12 = false;
            								}
HXDLIN( 139)								if (_hx_tmp12) {
HXDLIN( 139)									int location3;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x6)) ));
            									}
HXDLIN( 139)									int this49 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 139)									int this50;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this50 = ((((((this49 >> 24) & 255) << 24) | ((this49 & 255) << 16)) | (((this49 >> 8) & 255) << 8)) | ((this49 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this50 = this49;
            									}
HXDLIN( 139)									Float a13;
HXDLIN( 139)									int this51 = ((this50 >> 24) & 255);
HXDLIN( 139)									if ((this51 == 0)) {
HXDLIN( 139)										a13 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r13;
HXDLIN( 139)									int this52 = ((this50 >> 16) & 255);
HXDLIN( 139)									if ((this52 == 0)) {
HXDLIN( 139)										r13 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r13 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g13;
HXDLIN( 139)									int this53 = ((this50 >> 8) & 255);
HXDLIN( 139)									if ((this53 == 0)) {
HXDLIN( 139)										g13 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g13 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b14;
HXDLIN( 139)									int this54 = (this50 & 255);
HXDLIN( 139)									if ((this54 == 0)) {
HXDLIN( 139)										b14 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b14 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a23;
HXDLIN( 139)									int this55 = ((color2 >> 24) & 255);
HXDLIN( 139)									if ((this55 == 0)) {
HXDLIN( 139)										a23 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a23 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r23;
HXDLIN( 139)									int this56 = ((color2 >> 16) & 255);
HXDLIN( 139)									if ((this56 == 0)) {
HXDLIN( 139)										r23 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r23 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g23;
HXDLIN( 139)									int this57 = ((color2 >> 8) & 255);
HXDLIN( 139)									if ((this57 == 0)) {
HXDLIN( 139)										g23 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g23 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b24;
HXDLIN( 139)									int this58 = (color2 & 255);
HXDLIN( 139)									if ((this58 == 0)) {
HXDLIN( 139)										b24 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b24 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 139)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 139)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 139)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 139)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 139)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp13;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp13 = blended3;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this59 = img->image;
HXDLIN( 139)									int index9;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x6)) ));
            									}
HXDLIN( 139)									int _hx_tmp14;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp14 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp14 = c8;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this59,index9,_hx_tmp14);
            								}
            							}
            						}
HXDLIN( 139)						{
HXDLIN( 139)							int x8 = ((img->width - x6) - 1);
HXDLIN( 139)							int y9 = (y7 + places);
HXDLIN( 139)							int x9 = (places - x6);
HXDLIN( 139)							::Dynamic this60 = this1->image;
HXDLIN( 139)							int index10;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x9) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index10 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x9)) ));
            							}
HXDLIN( 139)							int c9 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 139)							int color3;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color3 = c9;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c10 = color3;
HXDLIN( 139)								bool _hx_tmp15;
HXDLIN( 139)								if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp15 = false;
            								}
HXDLIN( 139)								if (_hx_tmp15) {
HXDLIN( 139)									int location4;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            									}
HXDLIN( 139)									int this61 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 139)									int this62;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this62 = this61;
            									}
HXDLIN( 139)									Float a14;
HXDLIN( 139)									int this63 = ((this62 >> 24) & 255);
HXDLIN( 139)									if ((this63 == 0)) {
HXDLIN( 139)										a14 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r14;
HXDLIN( 139)									int this64 = ((this62 >> 16) & 255);
HXDLIN( 139)									if ((this64 == 0)) {
HXDLIN( 139)										r14 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r14 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g14;
HXDLIN( 139)									int this65 = ((this62 >> 8) & 255);
HXDLIN( 139)									if ((this65 == 0)) {
HXDLIN( 139)										g14 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g14 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b15;
HXDLIN( 139)									int this66 = (this62 & 255);
HXDLIN( 139)									if ((this66 == 0)) {
HXDLIN( 139)										b15 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b15 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a24;
HXDLIN( 139)									int this67 = ((color3 >> 24) & 255);
HXDLIN( 139)									if ((this67 == 0)) {
HXDLIN( 139)										a24 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a24 = (( (Float)(this67) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r24;
HXDLIN( 139)									int this68 = ((color3 >> 16) & 255);
HXDLIN( 139)									if ((this68 == 0)) {
HXDLIN( 139)										r24 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r24 = (( (Float)(this68) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g24;
HXDLIN( 139)									int this69 = ((color3 >> 8) & 255);
HXDLIN( 139)									if ((this69 == 0)) {
HXDLIN( 139)										g24 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g24 = (( (Float)(this69) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b25;
HXDLIN( 139)									int this70 = (color3 & 255);
HXDLIN( 139)									if ((this70 == 0)) {
HXDLIN( 139)										b25 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b25 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 139)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 139)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 139)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 139)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 139)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp16;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp16 = blended4;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this71 = img->image;
HXDLIN( 139)									int index11;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            									}
HXDLIN( 139)									int _hx_tmp17;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp17 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp17 = c10;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 139)		{
HXDLIN( 139)			int _g28 = 0;
HXDLIN( 139)			int _g29 = places;
HXDLIN( 139)			while((_g28 < _g29)){
HXDLIN( 139)				_g28 = (_g28 + 1);
HXDLIN( 139)				int x10 = (_g28 - 1);
HXDLIN( 139)				{
HXDLIN( 139)					int _g30 = 0;
HXDLIN( 139)					int _g31 = places;
HXDLIN( 139)					while((_g30 < _g31)){
HXDLIN( 139)						_g30 = (_g30 + 1);
HXDLIN( 139)						int y10 = (_g30 - 1);
HXDLIN( 139)						{
HXDLIN( 139)							int x11 = (((this1->width - 1) - places) + x10);
HXDLIN( 139)							int y11 = (((this1->height - 1) - places) + y10);
HXDLIN( 139)							::Dynamic this72 = this1->image;
HXDLIN( 139)							int index12;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index12 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            							}
HXDLIN( 139)							int c11 = ::iterMagic::Iimg_obj::get(this72,index12);
HXDLIN( 139)							int color4;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color4 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color4 = c11;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c12 = color4;
HXDLIN( 139)								bool _hx_tmp18;
HXDLIN( 139)								if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp18 = false;
            								}
HXDLIN( 139)								if (_hx_tmp18) {
HXDLIN( 139)									int location5;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            									}
HXDLIN( 139)									int this73 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 139)									int this74;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this74 = ((((((this73 >> 24) & 255) << 24) | ((this73 & 255) << 16)) | (((this73 >> 8) & 255) << 8)) | ((this73 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this74 = this73;
            									}
HXDLIN( 139)									Float a15;
HXDLIN( 139)									int this75 = ((this74 >> 24) & 255);
HXDLIN( 139)									if ((this75 == 0)) {
HXDLIN( 139)										a15 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a15 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r15;
HXDLIN( 139)									int this76 = ((this74 >> 16) & 255);
HXDLIN( 139)									if ((this76 == 0)) {
HXDLIN( 139)										r15 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r15 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g15;
HXDLIN( 139)									int this77 = ((this74 >> 8) & 255);
HXDLIN( 139)									if ((this77 == 0)) {
HXDLIN( 139)										g15 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g15 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b16;
HXDLIN( 139)									int this78 = (this74 & 255);
HXDLIN( 139)									if ((this78 == 0)) {
HXDLIN( 139)										b16 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b16 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a25;
HXDLIN( 139)									int this79 = ((color4 >> 24) & 255);
HXDLIN( 139)									if ((this79 == 0)) {
HXDLIN( 139)										a25 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a25 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r25;
HXDLIN( 139)									int this80 = ((color4 >> 16) & 255);
HXDLIN( 139)									if ((this80 == 0)) {
HXDLIN( 139)										r25 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r25 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g25;
HXDLIN( 139)									int this81 = ((color4 >> 8) & 255);
HXDLIN( 139)									if ((this81 == 0)) {
HXDLIN( 139)										g25 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g25 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b26;
HXDLIN( 139)									int this82 = (color4 & 255);
HXDLIN( 139)									if ((this82 == 0)) {
HXDLIN( 139)										b26 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b26 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 139)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 139)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 139)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 139)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 139)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp19;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp19 = blended5;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this83 = img->image;
HXDLIN( 139)									int index13;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            									}
HXDLIN( 139)									int _hx_tmp20;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp20 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp20 = c12;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this83,index13,_hx_tmp20);
            								}
            							}
            						}
HXDLIN( 139)						{
HXDLIN( 139)							int x12 = ((x10 + places) + this1->width);
HXDLIN( 139)							int y12 = (((this1->height - 1) - places) + y10);
HXDLIN( 139)							::Dynamic this84 = this1->image;
HXDLIN( 139)							int index14;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index14 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index14 = ::Std_obj::_hx_int(( (Float)(((y12 * this1->width) + x10)) ));
            							}
HXDLIN( 139)							int c13 = ::iterMagic::Iimg_obj::get(this84,index14);
HXDLIN( 139)							int color5;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color5 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color5 = c13;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c14 = color5;
HXDLIN( 139)								bool _hx_tmp21;
HXDLIN( 139)								if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp21 = false;
            								}
HXDLIN( 139)								if (_hx_tmp21) {
HXDLIN( 139)									int location6;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 139)									int this85 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 139)									int this86;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this86 = ((((((this85 >> 24) & 255) << 24) | ((this85 & 255) << 16)) | (((this85 >> 8) & 255) << 8)) | ((this85 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this86 = this85;
            									}
HXDLIN( 139)									Float a16;
HXDLIN( 139)									int this87 = ((this86 >> 24) & 255);
HXDLIN( 139)									if ((this87 == 0)) {
HXDLIN( 139)										a16 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a16 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r16;
HXDLIN( 139)									int this88 = ((this86 >> 16) & 255);
HXDLIN( 139)									if ((this88 == 0)) {
HXDLIN( 139)										r16 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r16 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g16;
HXDLIN( 139)									int this89 = ((this86 >> 8) & 255);
HXDLIN( 139)									if ((this89 == 0)) {
HXDLIN( 139)										g16 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g16 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b17;
HXDLIN( 139)									int this90 = (this86 & 255);
HXDLIN( 139)									if ((this90 == 0)) {
HXDLIN( 139)										b17 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b17 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a26;
HXDLIN( 139)									int this91 = ((color5 >> 24) & 255);
HXDLIN( 139)									if ((this91 == 0)) {
HXDLIN( 139)										a26 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a26 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r26;
HXDLIN( 139)									int this92 = ((color5 >> 16) & 255);
HXDLIN( 139)									if ((this92 == 0)) {
HXDLIN( 139)										r26 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r26 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g26;
HXDLIN( 139)									int this93 = ((color5 >> 8) & 255);
HXDLIN( 139)									if ((this93 == 0)) {
HXDLIN( 139)										g26 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g26 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b27;
HXDLIN( 139)									int this94 = (color5 & 255);
HXDLIN( 139)									if ((this94 == 0)) {
HXDLIN( 139)										b27 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 139)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 139)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 139)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN( 139)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 139)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp22;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp22 = blended6;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this95 = img->image;
HXDLIN( 139)									int index15;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 139)									int _hx_tmp23;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp23 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp23 = c14;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this95,index15,_hx_tmp23);
            								}
            							}
            						}
HXDLIN( 139)						{
HXDLIN( 139)							int x13 = ((x10 + places) + this1->width);
HXDLIN( 139)							int y13 = ((y10 + places) + this1->height);
HXDLIN( 139)							::Dynamic this96 = this1->image;
HXDLIN( 139)							int index16;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index16 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index16 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            							}
HXDLIN( 139)							int c15 = ::iterMagic::Iimg_obj::get(this96,index16);
HXDLIN( 139)							int color6;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color6 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color6 = c15;
            							}
HXDLIN( 139)							int color7 = color6;
HXDLIN( 139)							{
HXDLIN( 139)								int c16 = color7;
HXDLIN( 139)								bool _hx_tmp24;
HXDLIN( 139)								if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp24 = false;
            								}
HXDLIN( 139)								if (_hx_tmp24) {
HXDLIN( 139)									int location7;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location7 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location7 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x13)) ));
            									}
HXDLIN( 139)									int this97 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 139)									int this98;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this98 = ((((((this97 >> 24) & 255) << 24) | ((this97 & 255) << 16)) | (((this97 >> 8) & 255) << 8)) | ((this97 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this98 = this97;
            									}
HXDLIN( 139)									Float a17;
HXDLIN( 139)									int this99 = ((this98 >> 24) & 255);
HXDLIN( 139)									if ((this99 == 0)) {
HXDLIN( 139)										a17 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a17 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r17;
HXDLIN( 139)									int this100 = ((this98 >> 16) & 255);
HXDLIN( 139)									if ((this100 == 0)) {
HXDLIN( 139)										r17 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r17 = (( (Float)(this100) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g17;
HXDLIN( 139)									int this101 = ((this98 >> 8) & 255);
HXDLIN( 139)									if ((this101 == 0)) {
HXDLIN( 139)										g17 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g17 = (( (Float)(this101) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b18;
HXDLIN( 139)									int this102 = (this98 & 255);
HXDLIN( 139)									if ((this102 == 0)) {
HXDLIN( 139)										b18 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b18 = (( (Float)(this102) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a27;
HXDLIN( 139)									int this103 = ((color7 >> 24) & 255);
HXDLIN( 139)									if ((this103 == 0)) {
HXDLIN( 139)										a27 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a27 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r27;
HXDLIN( 139)									int this104 = ((color7 >> 16) & 255);
HXDLIN( 139)									if ((this104 == 0)) {
HXDLIN( 139)										r27 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r27 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g27;
HXDLIN( 139)									int this105 = ((color7 >> 8) & 255);
HXDLIN( 139)									if ((this105 == 0)) {
HXDLIN( 139)										g27 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g27 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b28;
HXDLIN( 139)									int this106 = (color7 & 255);
HXDLIN( 139)									if ((this106 == 0)) {
HXDLIN( 139)										b28 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b28 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN( 139)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 139)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 139)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN( 139)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 139)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp25;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp25 = blended7;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this107 = img->image;
HXDLIN( 139)									int index17;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index17 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x13)) ));
            									}
HXDLIN( 139)									int _hx_tmp26;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp26 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp26 = c16;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this107,index17,_hx_tmp26);
            								}
            							}
            						}
HXDLIN( 139)						{
HXDLIN( 139)							int y14 = ((y10 + places) + this1->width);
HXDLIN( 139)							int x14 = (((this1->width - 1) - places) + x10);
HXDLIN( 139)							::Dynamic this108 = this1->image;
HXDLIN( 139)							int index18;
HXDLIN( 139)							if (this1->useVirtualPos) {
HXDLIN( 139)								index18 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x14) - this1->virtualX));
            							}
            							else {
HXDLIN( 139)								index18 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x14)) ));
            							}
HXDLIN( 139)							int c17 = ::iterMagic::Iimg_obj::get(this108,index18);
HXDLIN( 139)							int color8;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)								color8 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            							}
            							else {
HXDLIN( 139)								color8 = c17;
            							}
HXDLIN( 139)							{
HXDLIN( 139)								int c18 = color8;
HXDLIN( 139)								bool _hx_tmp27;
HXDLIN( 139)								if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 139)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXDLIN( 139)									_hx_tmp27 = false;
            								}
HXDLIN( 139)								if (_hx_tmp27) {
HXDLIN( 139)									int location8;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										location8 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										location8 = ::Std_obj::_hx_int(( (Float)(((y14 * img->width) + x10)) ));
            									}
HXDLIN( 139)									int this109 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 139)									int this110;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										this110 = ((((((this109 >> 24) & 255) << 24) | ((this109 & 255) << 16)) | (((this109 >> 8) & 255) << 8)) | ((this109 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										this110 = this109;
            									}
HXDLIN( 139)									Float a19;
HXDLIN( 139)									int this111 = ((this110 >> 24) & 255);
HXDLIN( 139)									if ((this111 == 0)) {
HXDLIN( 139)										a19 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a19 = (( (Float)(this111) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r18;
HXDLIN( 139)									int this112 = ((this110 >> 16) & 255);
HXDLIN( 139)									if ((this112 == 0)) {
HXDLIN( 139)										r18 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r18 = (( (Float)(this112) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g18;
HXDLIN( 139)									int this113 = ((this110 >> 8) & 255);
HXDLIN( 139)									if ((this113 == 0)) {
HXDLIN( 139)										g18 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g18 = (( (Float)(this113) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b19;
HXDLIN( 139)									int this114 = (this110 & 255);
HXDLIN( 139)									if ((this114 == 0)) {
HXDLIN( 139)										b19 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b19 = (( (Float)(this114) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a28;
HXDLIN( 139)									int this115 = ((color8 >> 24) & 255);
HXDLIN( 139)									if ((this115 == 0)) {
HXDLIN( 139)										a28 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										a28 = (( (Float)(this115) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r28;
HXDLIN( 139)									int this116 = ((color8 >> 16) & 255);
HXDLIN( 139)									if ((this116 == 0)) {
HXDLIN( 139)										r28 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										r28 = (( (Float)(this116) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g28;
HXDLIN( 139)									int this117 = ((color8 >> 8) & 255);
HXDLIN( 139)									if ((this117 == 0)) {
HXDLIN( 139)										g28 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										g28 = (( (Float)(this117) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b29;
HXDLIN( 139)									int this118 = (color8 & 255);
HXDLIN( 139)									if ((this118 == 0)) {
HXDLIN( 139)										b29 = ((Float)0.);
            									}
            									else {
HXDLIN( 139)										b29 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN( 139)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 139)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 139)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN( 139)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 139)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN( 139)									{
HXDLIN( 139)										int _hx_tmp28;
HXDLIN( 139)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXDLIN( 139)											_hx_tmp28 = blended8;
            										}
HXDLIN( 139)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXDLIN( 139)									::Dynamic this119 = img->image;
HXDLIN( 139)									int index19;
HXDLIN( 139)									if (img->useVirtualPos) {
HXDLIN( 139)										index19 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXDLIN( 139)										index19 = ::Std_obj::_hx_int(( (Float)(((y14 * img->width) + x10)) ));
            									}
HXDLIN( 139)									int _hx_tmp29;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 139)										_hx_tmp29 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXDLIN( 139)										_hx_tmp29 = c18;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(this119,index19,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 139)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectanglePad_Impl__obj,padWrapImage,return )

 ::pi_xy::ImageStruct RectanglePad_Impl__obj::padWrapImageXY( ::pi_xy::ImageStruct this1,int placesX,int placesY){
            	HX_GC_STACKFRAME(&_hx_pos_684e147a04b272d1_144_padWrapImageXY)
HXLINE( 145)		int width = (this1->width + (2 * placesX));
HXDLIN( 145)		int height = (this1->height + (2 * placesY));
HXDLIN( 145)		 ::Dynamic imageType = null();
HXDLIN( 145)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 145)		if (::hx::IsNull( imageType )) {
HXLINE( 145)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 145)		::Dynamic _hx_tmp;
HXDLIN( 145)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 145)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 145)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 145)				{
HXLINE( 145)					b->width = width;
HXDLIN( 145)					b->height = height;
HXDLIN( 145)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 145)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 145)					{
HXLINE( 145)						int len = b->length;
HXDLIN( 145)						int w = 0;
HXDLIN( 145)						{
HXLINE( 145)							int _g = 0;
HXDLIN( 145)							int _g1 = b->height;
HXDLIN( 145)							while((_g < _g1)){
HXLINE( 145)								_g = (_g + 1);
HXDLIN( 145)								int y = (_g - 1);
HXDLIN( 145)								{
HXLINE( 145)									int _g2 = 0;
HXDLIN( 145)									int _g3 = b->width;
HXDLIN( 145)									while((_g2 < _g3)){
HXLINE( 145)										_g2 = (_g2 + 1);
HXDLIN( 145)										int x = (_g2 - 1);
HXDLIN( 145)										{
HXLINE( 145)											w = (w + 1);
HXDLIN( 145)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 145)										{
HXLINE( 145)											w = (w + 1);
HXDLIN( 145)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 145)										{
HXLINE( 145)											w = (w + 1);
HXDLIN( 145)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 145)										{
HXLINE( 145)											w = (w + 1);
HXDLIN( 145)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 145)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 145)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 145)				{
HXLINE( 145)					a->width = width;
HXDLIN( 145)					a->height = height;
HXDLIN( 145)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 145)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 145)					{
HXLINE( 145)						int _g4 = 0;
HXDLIN( 145)						int _g5 = a->length;
HXDLIN( 145)						while((_g4 < _g5)){
HXLINE( 145)							_g4 = (_g4 + 1);
HXDLIN( 145)							int i = (_g4 - 1);
HXDLIN( 145)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 145)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 145)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 145)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 145)				{
HXLINE( 145)					b1->width = width;
HXDLIN( 145)					b1->height = height;
HXDLIN( 145)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 145)					int size = (b1->length * 4);
HXDLIN( 145)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 145)					{
HXLINE( 145)						int _g6 = 0;
HXDLIN( 145)						int _g7 = b1->length;
HXDLIN( 145)						while((_g6 < _g7)){
HXLINE( 145)							_g6 = (_g6 + 1);
HXDLIN( 145)							int i1 = (_g6 - 1);
HXDLIN( 145)							{
HXLINE( 145)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 145)								bool _hx_tmp1;
HXDLIN( 145)								if ((i1 >= 0)) {
HXLINE( 145)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 145)									_hx_tmp1 = false;
            								}
HXDLIN( 145)								if (_hx_tmp1) {
HXLINE( 145)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 145)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 145)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 145)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 145)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 145)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 145)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 145)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 145)				{
HXLINE( 145)					v->width = width;
HXDLIN( 145)					v->height = height;
HXDLIN( 145)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 145)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 145)					{
HXLINE( 145)						int _g8 = 0;
HXDLIN( 145)						int _g9 = v->length;
HXDLIN( 145)						while((_g8 < _g9)){
HXLINE( 145)							_g8 = (_g8 + 1);
HXDLIN( 145)							int i2 = (_g8 - 1);
HXDLIN( 145)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 145)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 145)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 145)				{
HXLINE( 145)					b2->width = width;
HXDLIN( 145)					b2->height = height;
HXDLIN( 145)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 145)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 145)					{
HXLINE( 145)						int len1 = b2->length;
HXDLIN( 145)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 145)						if (::hx::IsNull( d->head )) {
HXLINE( 145)							int _g10 = 0;
HXDLIN( 145)							int _g11 = len1;
HXDLIN( 145)							while((_g10 < _g11)){
HXLINE( 145)								_g10 = (_g10 + 1);
HXDLIN( 145)								int i3 = (_g10 - 1);
HXDLIN( 145)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 145)							int _g12 = 0;
HXDLIN( 145)							int _g13 = len1;
HXDLIN( 145)							while((_g12 < _g13)){
HXLINE( 145)								_g12 = (_g12 + 1);
HXDLIN( 145)								int i4 = (_g12 - 1);
HXDLIN( 145)								{
HXLINE( 145)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 145)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 145)									{
HXLINE( 145)										int _g14 = 0;
HXDLIN( 145)										int _g15 = i4;
HXDLIN( 145)										while((_g14 < _g15)){
HXLINE( 145)											_g14 = (_g14 + 1);
HXDLIN( 145)											int i5 = (_g14 - 1);
HXDLIN( 145)											prev = l;
HXDLIN( 145)											l = l->next;
            										}
            									}
HXDLIN( 145)									if (::hx::IsNull( prev )) {
HXLINE( 145)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 145)										l = null();
            									}
            									else {
HXLINE( 145)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 145)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 145)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 145)		this2->image = _hx_tmp;
HXDLIN( 145)		this2->width = width;
HXDLIN( 145)		this2->height = height;
HXDLIN( 145)		this2->imageType = ( (int)(imageType) );
HXDLIN( 145)		 ::pi_xy::ImageStruct img = this2;
HXLINE( 146)		{
HXLINE( 146)			bool forceClear = false;
HXDLIN( 146)			{
HXLINE( 146)				int _g16 = 0;
HXDLIN( 146)				int _g17 = this1->height;
HXDLIN( 146)				while((_g16 < _g17)){
HXLINE( 146)					_g16 = (_g16 + 1);
HXDLIN( 146)					int dy = (_g16 - 1);
HXDLIN( 146)					{
HXLINE( 146)						int _g18 = 0;
HXDLIN( 146)						int _g19 = this1->width;
HXDLIN( 146)						while((_g18 < _g19)){
HXLINE( 146)							_g18 = (_g18 + 1);
HXDLIN( 146)							int dx = (_g18 - 1);
HXDLIN( 146)							::Dynamic this4 = this1->image;
HXDLIN( 146)							int index;
HXDLIN( 146)							if (this1->useVirtualPos) {
HXLINE( 146)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            							}
            							else {
HXLINE( 146)								index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            							}
HXDLIN( 146)							int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 146)							int col;
HXDLIN( 146)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 146)								col = c;
            							}
HXDLIN( 146)							bool _hx_tmp2;
HXDLIN( 146)							if (this1->useMask) {
HXLINE( 146)								_hx_tmp2 = ::hx::IsNotNull( this1->mask );
            							}
            							else {
HXLINE( 146)								_hx_tmp2 = false;
            							}
HXDLIN( 146)							if (_hx_tmp2) {
HXLINE( 146)								 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 146)								::Dynamic this6 = this5->image;
HXDLIN( 146)								int index1;
HXDLIN( 146)								if (this5->useVirtualPos) {
HXLINE( 146)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            								}
            								else {
HXLINE( 146)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            								}
HXDLIN( 146)								int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 146)								int v1;
HXDLIN( 146)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 146)									v1 = c1;
            								}
HXDLIN( 146)								int maskPixel = v1;
HXDLIN( 146)								int this7 = col;
HXDLIN( 146)								if ((maskPixel == 0)) {
HXLINE( 146)									col = this7;
            								}
            								else {
HXLINE( 146)									Float m0;
HXDLIN( 146)									int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 146)									if ((this8 == 0)) {
HXLINE( 146)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float m1;
HXDLIN( 146)									int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 146)									if ((this9 == 0)) {
HXLINE( 146)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float m2;
HXDLIN( 146)									int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 146)									if ((this10 == 0)) {
HXLINE( 146)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float m3;
HXDLIN( 146)									int this11 = (maskPixel & 255);
HXDLIN( 146)									if ((this11 == 0)) {
HXLINE( 146)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 146)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 146)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 146)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 146)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 146)							if ((col != 0)) {
HXLINE( 146)								int x1 = (placesX + dx);
HXDLIN( 146)								int y1 = (placesY + dy);
HXDLIN( 146)								int c2 = col;
HXDLIN( 146)								bool _hx_tmp3;
HXDLIN( 146)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 146)									_hx_tmp3 = img->transparent;
            								}
            								else {
HXLINE( 146)									_hx_tmp3 = false;
            								}
HXDLIN( 146)								if (_hx_tmp3) {
HXLINE( 146)									int location;
HXDLIN( 146)									if (img->useVirtualPos) {
HXLINE( 146)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE( 146)										location = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 146)									int this12 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 146)									int this13;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										this13 = this12;
            									}
HXDLIN( 146)									Float a1;
HXDLIN( 146)									int this14 = ((this13 >> 24) & 255);
HXDLIN( 146)									if ((this14 == 0)) {
HXLINE( 146)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float r1;
HXDLIN( 146)									int this15 = ((this13 >> 16) & 255);
HXDLIN( 146)									if ((this15 == 0)) {
HXLINE( 146)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float g1;
HXDLIN( 146)									int this16 = ((this13 >> 8) & 255);
HXDLIN( 146)									if ((this16 == 0)) {
HXLINE( 146)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float b11;
HXDLIN( 146)									int this17 = (this13 & 255);
HXDLIN( 146)									if ((this17 == 0)) {
HXLINE( 146)										b11 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float a2;
HXDLIN( 146)									int this18 = ((col >> 24) & 255);
HXDLIN( 146)									if ((this18 == 0)) {
HXLINE( 146)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float r2;
HXDLIN( 146)									int this19 = ((col >> 16) & 255);
HXDLIN( 146)									if ((this19 == 0)) {
HXLINE( 146)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float g2;
HXDLIN( 146)									int this20 = ((col >> 8) & 255);
HXDLIN( 146)									if ((this20 == 0)) {
HXLINE( 146)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float b21;
HXDLIN( 146)									int this21 = (col & 255);
HXDLIN( 146)									if ((this21 == 0)) {
HXLINE( 146)										b21 = ((Float)0.);
            									}
            									else {
HXLINE( 146)										b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 146)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 146)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 146)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 146)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 146)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 146)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 146)									{
HXLINE( 146)										int _hx_tmp4;
HXDLIN( 146)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 146)											_hx_tmp4 = blended;
            										}
HXDLIN( 146)										::iterMagic::Iimg_obj::set(img->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE( 146)									::Dynamic this22 = img->image;
HXDLIN( 146)									int index2;
HXDLIN( 146)									if (img->useVirtualPos) {
HXLINE( 146)										index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - img->virtualY) * ( (Float)(img->width) )) + x1) - img->virtualX));
            									}
            									else {
HXLINE( 146)										index2 = ::Std_obj::_hx_int(( (Float)(((y1 * img->width) + x1)) ));
            									}
HXDLIN( 146)									int _hx_tmp5;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										_hx_tmp5 = c2;
            									}
HXDLIN( 146)									::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE( 146)								if (forceClear) {
HXLINE( 146)									::Dynamic this23 = img->image;
HXDLIN( 146)									int x2 = (placesX + dx);
HXDLIN( 146)									int y2 = (placesY + dy);
HXDLIN( 146)									int index3;
HXDLIN( 146)									if (img->useVirtualPos) {
HXLINE( 146)										index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXLINE( 146)										index3 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 146)									::iterMagic::Iimg_obj::set(this23,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 148)		{
HXLINE( 148)			int _g20 = 0;
HXDLIN( 148)			int _g21 = this1->width;
HXDLIN( 148)			while((_g20 < _g21)){
HXLINE( 148)				_g20 = (_g20 + 1);
HXDLIN( 148)				int x3 = (_g20 - 1);
HXDLIN( 148)				{
HXLINE( 148)					int _g22 = 0;
HXDLIN( 148)					int _g23 = placesY;
HXDLIN( 148)					while((_g22 < _g23)){
HXLINE( 148)						_g22 = (_g22 + 1);
HXDLIN( 148)						int y3 = (_g22 - 1);
HXLINE( 150)						{
HXLINE( 150)							int x4 = (x3 + placesX);
HXDLIN( 150)							int y4 = (((this1->height - 1) - placesY) + y3);
HXDLIN( 150)							::Dynamic this24 = this1->image;
HXDLIN( 150)							int index4;
HXDLIN( 150)							if (this1->useVirtualPos) {
HXLINE( 150)								index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXLINE( 150)								index4 = ::Std_obj::_hx_int(( (Float)(((y4 * this1->width) + x3)) ));
            							}
HXDLIN( 150)							int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 150)							int color;
HXDLIN( 150)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)								color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 150)								color = c3;
            							}
HXDLIN( 150)							{
HXLINE( 150)								int c4 = color;
HXDLIN( 150)								bool _hx_tmp6;
HXDLIN( 150)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 150)									_hx_tmp6 = img->transparent;
            								}
            								else {
HXLINE( 150)									_hx_tmp6 = false;
            								}
HXDLIN( 150)								if (_hx_tmp6) {
HXLINE( 150)									int location1;
HXDLIN( 150)									if (img->useVirtualPos) {
HXLINE( 150)										location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 150)										location1 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 150)									int this25 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 150)									int this26;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										this26 = this25;
            									}
HXDLIN( 150)									Float a11;
HXDLIN( 150)									int this27 = ((this26 >> 24) & 255);
HXDLIN( 150)									if ((this27 == 0)) {
HXLINE( 150)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float r11;
HXDLIN( 150)									int this28 = ((this26 >> 16) & 255);
HXDLIN( 150)									if ((this28 == 0)) {
HXLINE( 150)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float g11;
HXDLIN( 150)									int this29 = ((this26 >> 8) & 255);
HXDLIN( 150)									if ((this29 == 0)) {
HXLINE( 150)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float b12;
HXDLIN( 150)									int this30 = (this26 & 255);
HXDLIN( 150)									if ((this30 == 0)) {
HXLINE( 150)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float a21;
HXDLIN( 150)									int this31 = ((color >> 24) & 255);
HXDLIN( 150)									if ((this31 == 0)) {
HXLINE( 150)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float r21;
HXDLIN( 150)									int this32 = ((color >> 16) & 255);
HXDLIN( 150)									if ((this32 == 0)) {
HXLINE( 150)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float g21;
HXDLIN( 150)									int this33 = ((color >> 8) & 255);
HXDLIN( 150)									if ((this33 == 0)) {
HXLINE( 150)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float b22;
HXDLIN( 150)									int this34 = (color & 255);
HXDLIN( 150)									if ((this34 == 0)) {
HXLINE( 150)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 150)										b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 150)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 150)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 150)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 150)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 150)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 150)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 150)									{
HXLINE( 150)										int _hx_tmp7;
HXDLIN( 150)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 150)											_hx_tmp7 = blended1;
            										}
HXDLIN( 150)										::iterMagic::Iimg_obj::set(img->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 150)									::Dynamic this35 = img->image;
HXDLIN( 150)									int index5;
HXDLIN( 150)									if (img->useVirtualPos) {
HXLINE( 150)										index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 150)										index5 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 150)									int _hx_tmp8;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										_hx_tmp8 = c4;
            									}
HXDLIN( 150)									::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp8);
            								}
            							}
            						}
HXLINE( 152)						{
HXLINE( 152)							int x5 = (x3 + placesX);
HXDLIN( 152)							int y5 = ((img->height - y3) - 1);
HXDLIN( 152)							int y6 = (placesY - y3);
HXDLIN( 152)							::Dynamic this36 = this1->image;
HXDLIN( 152)							int index6;
HXDLIN( 152)							if (this1->useVirtualPos) {
HXLINE( 152)								index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            							}
            							else {
HXLINE( 152)								index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this1->width) + x3)) ));
            							}
HXDLIN( 152)							int c5 = ::iterMagic::Iimg_obj::get(this36,index6);
HXDLIN( 152)							int color1;
HXDLIN( 152)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)								color1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            							}
            							else {
HXLINE( 152)								color1 = c5;
            							}
HXDLIN( 152)							{
HXLINE( 152)								int c6 = color1;
HXDLIN( 152)								bool _hx_tmp9;
HXDLIN( 152)								if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 152)									_hx_tmp9 = img->transparent;
            								}
            								else {
HXLINE( 152)									_hx_tmp9 = false;
            								}
HXDLIN( 152)								if (_hx_tmp9) {
HXLINE( 152)									int location2;
HXDLIN( 152)									if (img->useVirtualPos) {
HXLINE( 152)										location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE( 152)										location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x5)) ));
            									}
HXDLIN( 152)									int this37 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 152)									int this38;
HXDLIN( 152)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)										this38 = ((((((this37 >> 24) & 255) << 24) | ((this37 & 255) << 16)) | (((this37 >> 8) & 255) << 8)) | ((this37 >> 16) & 255));
            									}
            									else {
HXLINE( 152)										this38 = this37;
            									}
HXDLIN( 152)									Float a12;
HXDLIN( 152)									int this39 = ((this38 >> 24) & 255);
HXDLIN( 152)									if ((this39 == 0)) {
HXLINE( 152)										a12 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										a12 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float r12;
HXDLIN( 152)									int this40 = ((this38 >> 16) & 255);
HXDLIN( 152)									if ((this40 == 0)) {
HXLINE( 152)										r12 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										r12 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float g12;
HXDLIN( 152)									int this41 = ((this38 >> 8) & 255);
HXDLIN( 152)									if ((this41 == 0)) {
HXLINE( 152)										g12 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										g12 = (( (Float)(this41) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float b13;
HXDLIN( 152)									int this42 = (this38 & 255);
HXDLIN( 152)									if ((this42 == 0)) {
HXLINE( 152)										b13 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										b13 = (( (Float)(this42) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float a22;
HXDLIN( 152)									int this43 = ((color1 >> 24) & 255);
HXDLIN( 152)									if ((this43 == 0)) {
HXLINE( 152)										a22 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										a22 = (( (Float)(this43) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float r22;
HXDLIN( 152)									int this44 = ((color1 >> 16) & 255);
HXDLIN( 152)									if ((this44 == 0)) {
HXLINE( 152)										r22 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										r22 = (( (Float)(this44) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float g22;
HXDLIN( 152)									int this45 = ((color1 >> 8) & 255);
HXDLIN( 152)									if ((this45 == 0)) {
HXLINE( 152)										g22 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										g22 = (( (Float)(this45) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float b23;
HXDLIN( 152)									int this46 = (color1 & 255);
HXDLIN( 152)									if ((this46 == 0)) {
HXLINE( 152)										b23 = ((Float)0.);
            									}
            									else {
HXLINE( 152)										b23 = (( (Float)(this46) ) / ( (Float)(255) ));
            									}
HXDLIN( 152)									Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 152)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 152)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 152)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 152)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 152)									int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 152)									{
HXLINE( 152)										int _hx_tmp10;
HXDLIN( 152)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)											_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE( 152)											_hx_tmp10 = blended2;
            										}
HXDLIN( 152)										::iterMagic::Iimg_obj::set(img->image,location2,_hx_tmp10);
            									}
            								}
            								else {
HXLINE( 152)									::Dynamic this47 = img->image;
HXDLIN( 152)									int index7;
HXDLIN( 152)									if (img->useVirtualPos) {
HXLINE( 152)										index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            									}
            									else {
HXLINE( 152)										index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x5)) ));
            									}
HXDLIN( 152)									int _hx_tmp11;
HXDLIN( 152)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)										_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE( 152)										_hx_tmp11 = c6;
            									}
HXDLIN( 152)									::iterMagic::Iimg_obj::set(this47,index7,_hx_tmp11);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 154)		{
HXLINE( 154)			int _g24 = 0;
HXDLIN( 154)			int _g25 = this1->height;
HXDLIN( 154)			while((_g24 < _g25)){
HXLINE( 154)				_g24 = (_g24 + 1);
HXDLIN( 154)				int y7 = (_g24 - 1);
HXDLIN( 154)				{
HXLINE( 154)					int _g26 = 0;
HXDLIN( 154)					int _g27 = placesX;
HXDLIN( 154)					while((_g26 < _g27)){
HXLINE( 154)						_g26 = (_g26 + 1);
HXDLIN( 154)						int x6 = (_g26 - 1);
HXLINE( 156)						{
HXLINE( 156)							int y8 = (y7 + placesY);
HXDLIN( 156)							int x7 = (((this1->width - 1) - placesX) + x6);
HXDLIN( 156)							::Dynamic this48 = this1->image;
HXDLIN( 156)							int index8;
HXDLIN( 156)							if (this1->useVirtualPos) {
HXLINE( 156)								index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            							}
            							else {
HXLINE( 156)								index8 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            							}
HXDLIN( 156)							int c7 = ::iterMagic::Iimg_obj::get(this48,index8);
HXDLIN( 156)							int color2;
HXDLIN( 156)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)								color2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            							}
            							else {
HXLINE( 156)								color2 = c7;
            							}
HXDLIN( 156)							{
HXLINE( 156)								int c8 = color2;
HXDLIN( 156)								bool _hx_tmp12;
HXDLIN( 156)								if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 156)									_hx_tmp12 = img->transparent;
            								}
            								else {
HXLINE( 156)									_hx_tmp12 = false;
            								}
HXDLIN( 156)								if (_hx_tmp12) {
HXLINE( 156)									int location3;
HXDLIN( 156)									if (img->useVirtualPos) {
HXLINE( 156)										location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE( 156)										location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x6)) ));
            									}
HXDLIN( 156)									int this49 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 156)									int this50;
HXDLIN( 156)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)										this50 = ((((((this49 >> 24) & 255) << 24) | ((this49 & 255) << 16)) | (((this49 >> 8) & 255) << 8)) | ((this49 >> 16) & 255));
            									}
            									else {
HXLINE( 156)										this50 = this49;
            									}
HXDLIN( 156)									Float a13;
HXDLIN( 156)									int this51 = ((this50 >> 24) & 255);
HXDLIN( 156)									if ((this51 == 0)) {
HXLINE( 156)										a13 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float r13;
HXDLIN( 156)									int this52 = ((this50 >> 16) & 255);
HXDLIN( 156)									if ((this52 == 0)) {
HXLINE( 156)										r13 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										r13 = (( (Float)(this52) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float g13;
HXDLIN( 156)									int this53 = ((this50 >> 8) & 255);
HXDLIN( 156)									if ((this53 == 0)) {
HXLINE( 156)										g13 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										g13 = (( (Float)(this53) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float b14;
HXDLIN( 156)									int this54 = (this50 & 255);
HXDLIN( 156)									if ((this54 == 0)) {
HXLINE( 156)										b14 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										b14 = (( (Float)(this54) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float a23;
HXDLIN( 156)									int this55 = ((color2 >> 24) & 255);
HXDLIN( 156)									if ((this55 == 0)) {
HXLINE( 156)										a23 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										a23 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float r23;
HXDLIN( 156)									int this56 = ((color2 >> 16) & 255);
HXDLIN( 156)									if ((this56 == 0)) {
HXLINE( 156)										r23 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										r23 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float g23;
HXDLIN( 156)									int this57 = ((color2 >> 8) & 255);
HXDLIN( 156)									if ((this57 == 0)) {
HXLINE( 156)										g23 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										g23 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float b24;
HXDLIN( 156)									int this58 = (color2 & 255);
HXDLIN( 156)									if ((this58 == 0)) {
HXLINE( 156)										b24 = ((Float)0.);
            									}
            									else {
HXLINE( 156)										b24 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 156)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 156)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 156)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 156)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 156)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 156)									int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 156)									{
HXLINE( 156)										int _hx_tmp13;
HXDLIN( 156)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)											_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE( 156)											_hx_tmp13 = blended3;
            										}
HXDLIN( 156)										::iterMagic::Iimg_obj::set(img->image,location3,_hx_tmp13);
            									}
            								}
            								else {
HXLINE( 156)									::Dynamic this59 = img->image;
HXDLIN( 156)									int index9;
HXDLIN( 156)									if (img->useVirtualPos) {
HXLINE( 156)										index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            									}
            									else {
HXLINE( 156)										index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x6)) ));
            									}
HXDLIN( 156)									int _hx_tmp14;
HXDLIN( 156)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)										_hx_tmp14 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE( 156)										_hx_tmp14 = c8;
            									}
HXDLIN( 156)									::iterMagic::Iimg_obj::set(this59,index9,_hx_tmp14);
            								}
            							}
            						}
HXLINE( 158)						{
HXLINE( 158)							int x8 = ((img->width - x6) - 1);
HXDLIN( 158)							int y9 = (y7 + placesY);
HXDLIN( 158)							int x9 = (placesX - x6);
HXDLIN( 158)							::Dynamic this60 = this1->image;
HXDLIN( 158)							int index10;
HXDLIN( 158)							if (this1->useVirtualPos) {
HXLINE( 158)								index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x9) - this1->virtualX));
            							}
            							else {
HXLINE( 158)								index10 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x9)) ));
            							}
HXDLIN( 158)							int c9 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 158)							int color3;
HXDLIN( 158)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)								color3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            							}
            							else {
HXLINE( 158)								color3 = c9;
            							}
HXDLIN( 158)							{
HXLINE( 158)								int c10 = color3;
HXDLIN( 158)								bool _hx_tmp15;
HXDLIN( 158)								if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 158)									_hx_tmp15 = img->transparent;
            								}
            								else {
HXLINE( 158)									_hx_tmp15 = false;
            								}
HXDLIN( 158)								if (_hx_tmp15) {
HXLINE( 158)									int location4;
HXDLIN( 158)									if (img->useVirtualPos) {
HXLINE( 158)										location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE( 158)										location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            									}
HXDLIN( 158)									int this61 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 158)									int this62;
HXDLIN( 158)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)										this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            									}
            									else {
HXLINE( 158)										this62 = this61;
            									}
HXDLIN( 158)									Float a14;
HXDLIN( 158)									int this63 = ((this62 >> 24) & 255);
HXDLIN( 158)									if ((this63 == 0)) {
HXLINE( 158)										a14 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float r14;
HXDLIN( 158)									int this64 = ((this62 >> 16) & 255);
HXDLIN( 158)									if ((this64 == 0)) {
HXLINE( 158)										r14 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										r14 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float g14;
HXDLIN( 158)									int this65 = ((this62 >> 8) & 255);
HXDLIN( 158)									if ((this65 == 0)) {
HXLINE( 158)										g14 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										g14 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float b15;
HXDLIN( 158)									int this66 = (this62 & 255);
HXDLIN( 158)									if ((this66 == 0)) {
HXLINE( 158)										b15 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										b15 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float a24;
HXDLIN( 158)									int this67 = ((color3 >> 24) & 255);
HXDLIN( 158)									if ((this67 == 0)) {
HXLINE( 158)										a24 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										a24 = (( (Float)(this67) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float r24;
HXDLIN( 158)									int this68 = ((color3 >> 16) & 255);
HXDLIN( 158)									if ((this68 == 0)) {
HXLINE( 158)										r24 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										r24 = (( (Float)(this68) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float g24;
HXDLIN( 158)									int this69 = ((color3 >> 8) & 255);
HXDLIN( 158)									if ((this69 == 0)) {
HXLINE( 158)										g24 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										g24 = (( (Float)(this69) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float b25;
HXDLIN( 158)									int this70 = (color3 & 255);
HXDLIN( 158)									if ((this70 == 0)) {
HXLINE( 158)										b25 = ((Float)0.);
            									}
            									else {
HXLINE( 158)										b25 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN( 158)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 158)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 158)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 158)									int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 158)									int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 158)									int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b7);
HXDLIN( 158)									{
HXLINE( 158)										int _hx_tmp16;
HXDLIN( 158)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)											_hx_tmp16 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXLINE( 158)											_hx_tmp16 = blended4;
            										}
HXDLIN( 158)										::iterMagic::Iimg_obj::set(img->image,location4,_hx_tmp16);
            									}
            								}
            								else {
HXLINE( 158)									::Dynamic this71 = img->image;
HXDLIN( 158)									int index11;
HXDLIN( 158)									if (img->useVirtualPos) {
HXLINE( 158)										index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            									}
            									else {
HXLINE( 158)										index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            									}
HXDLIN( 158)									int _hx_tmp17;
HXDLIN( 158)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)										_hx_tmp17 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE( 158)										_hx_tmp17 = c10;
            									}
HXDLIN( 158)									::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp17);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 161)		{
HXLINE( 161)			int _g28 = 0;
HXDLIN( 161)			int _g29 = placesX;
HXDLIN( 161)			while((_g28 < _g29)){
HXLINE( 161)				_g28 = (_g28 + 1);
HXDLIN( 161)				int x10 = (_g28 - 1);
HXDLIN( 161)				{
HXLINE( 161)					int _g30 = 0;
HXDLIN( 161)					int _g31 = placesY;
HXDLIN( 161)					while((_g30 < _g31)){
HXLINE( 161)						_g30 = (_g30 + 1);
HXDLIN( 161)						int y10 = (_g30 - 1);
HXLINE( 163)						{
HXLINE( 163)							int x11 = (((this1->width - 1) - placesX) + x10);
HXDLIN( 163)							int y11 = (((this1->height - 1) - placesY) + y10);
HXDLIN( 163)							::Dynamic this72 = this1->image;
HXDLIN( 163)							int index12;
HXDLIN( 163)							if (this1->useVirtualPos) {
HXLINE( 163)								index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            							}
            							else {
HXLINE( 163)								index12 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            							}
HXDLIN( 163)							int c11 = ::iterMagic::Iimg_obj::get(this72,index12);
HXDLIN( 163)							int color4;
HXDLIN( 163)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)								color4 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            							}
            							else {
HXLINE( 163)								color4 = c11;
            							}
HXDLIN( 163)							{
HXLINE( 163)								int c12 = color4;
HXDLIN( 163)								bool _hx_tmp18;
HXDLIN( 163)								if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 163)									_hx_tmp18 = img->transparent;
            								}
            								else {
HXLINE( 163)									_hx_tmp18 = false;
            								}
HXDLIN( 163)								if (_hx_tmp18) {
HXLINE( 163)									int location5;
HXDLIN( 163)									if (img->useVirtualPos) {
HXLINE( 163)										location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 163)										location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            									}
HXDLIN( 163)									int this73 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 163)									int this74;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										this74 = ((((((this73 >> 24) & 255) << 24) | ((this73 & 255) << 16)) | (((this73 >> 8) & 255) << 8)) | ((this73 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										this74 = this73;
            									}
HXDLIN( 163)									Float a15;
HXDLIN( 163)									int this75 = ((this74 >> 24) & 255);
HXDLIN( 163)									if ((this75 == 0)) {
HXLINE( 163)										a15 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										a15 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float r15;
HXDLIN( 163)									int this76 = ((this74 >> 16) & 255);
HXDLIN( 163)									if ((this76 == 0)) {
HXLINE( 163)										r15 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										r15 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float g15;
HXDLIN( 163)									int this77 = ((this74 >> 8) & 255);
HXDLIN( 163)									if ((this77 == 0)) {
HXLINE( 163)										g15 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										g15 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float b16;
HXDLIN( 163)									int this78 = (this74 & 255);
HXDLIN( 163)									if ((this78 == 0)) {
HXLINE( 163)										b16 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										b16 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float a25;
HXDLIN( 163)									int this79 = ((color4 >> 24) & 255);
HXDLIN( 163)									if ((this79 == 0)) {
HXLINE( 163)										a25 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										a25 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float r25;
HXDLIN( 163)									int this80 = ((color4 >> 16) & 255);
HXDLIN( 163)									if ((this80 == 0)) {
HXLINE( 163)										r25 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										r25 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float g25;
HXDLIN( 163)									int this81 = ((color4 >> 8) & 255);
HXDLIN( 163)									if ((this81 == 0)) {
HXLINE( 163)										g25 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										g25 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float b26;
HXDLIN( 163)									int this82 = (color4 & 255);
HXDLIN( 163)									if ((this82 == 0)) {
HXLINE( 163)										b26 = ((Float)0.);
            									}
            									else {
HXLINE( 163)										b26 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN( 163)									Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 163)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 163)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 163)									int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 163)									int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 163)									int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b8);
HXDLIN( 163)									{
HXLINE( 163)										int _hx_tmp19;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											_hx_tmp19 = blended5;
            										}
HXDLIN( 163)										::iterMagic::Iimg_obj::set(img->image,location5,_hx_tmp19);
            									}
            								}
            								else {
HXLINE( 163)									::Dynamic this83 = img->image;
HXDLIN( 163)									int index13;
HXDLIN( 163)									if (img->useVirtualPos) {
HXLINE( 163)										index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 163)										index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            									}
HXDLIN( 163)									int _hx_tmp20;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										_hx_tmp20 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										_hx_tmp20 = c12;
            									}
HXDLIN( 163)									::iterMagic::Iimg_obj::set(this83,index13,_hx_tmp20);
            								}
            							}
            						}
HXLINE( 164)						{
HXLINE( 164)							int x12 = ((x10 + placesX) + this1->width);
HXDLIN( 164)							int y12 = (((this1->height - 1) - placesY) + y10);
HXDLIN( 164)							::Dynamic this84 = this1->image;
HXDLIN( 164)							int index14;
HXDLIN( 164)							if (this1->useVirtualPos) {
HXLINE( 164)								index14 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            							}
            							else {
HXLINE( 164)								index14 = ::Std_obj::_hx_int(( (Float)(((y12 * this1->width) + x10)) ));
            							}
HXDLIN( 164)							int c13 = ::iterMagic::Iimg_obj::get(this84,index14);
HXDLIN( 164)							int color5;
HXDLIN( 164)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)								color5 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            							}
            							else {
HXLINE( 164)								color5 = c13;
            							}
HXDLIN( 164)							{
HXLINE( 164)								int c14 = color5;
HXDLIN( 164)								bool _hx_tmp21;
HXDLIN( 164)								if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 164)									_hx_tmp21 = img->transparent;
            								}
            								else {
HXLINE( 164)									_hx_tmp21 = false;
            								}
HXDLIN( 164)								if (_hx_tmp21) {
HXLINE( 164)									int location6;
HXDLIN( 164)									if (img->useVirtualPos) {
HXLINE( 164)										location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXLINE( 164)										location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 164)									int this85 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 164)									int this86;
HXDLIN( 164)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)										this86 = ((((((this85 >> 24) & 255) << 24) | ((this85 & 255) << 16)) | (((this85 >> 8) & 255) << 8)) | ((this85 >> 16) & 255));
            									}
            									else {
HXLINE( 164)										this86 = this85;
            									}
HXDLIN( 164)									Float a16;
HXDLIN( 164)									int this87 = ((this86 >> 24) & 255);
HXDLIN( 164)									if ((this87 == 0)) {
HXLINE( 164)										a16 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										a16 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float r16;
HXDLIN( 164)									int this88 = ((this86 >> 16) & 255);
HXDLIN( 164)									if ((this88 == 0)) {
HXLINE( 164)										r16 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										r16 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float g16;
HXDLIN( 164)									int this89 = ((this86 >> 8) & 255);
HXDLIN( 164)									if ((this89 == 0)) {
HXLINE( 164)										g16 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										g16 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float b17;
HXDLIN( 164)									int this90 = (this86 & 255);
HXDLIN( 164)									if ((this90 == 0)) {
HXLINE( 164)										b17 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										b17 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float a26;
HXDLIN( 164)									int this91 = ((color5 >> 24) & 255);
HXDLIN( 164)									if ((this91 == 0)) {
HXLINE( 164)										a26 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										a26 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float r26;
HXDLIN( 164)									int this92 = ((color5 >> 16) & 255);
HXDLIN( 164)									if ((this92 == 0)) {
HXLINE( 164)										r26 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										r26 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float g26;
HXDLIN( 164)									int this93 = ((color5 >> 8) & 255);
HXDLIN( 164)									if ((this93 == 0)) {
HXLINE( 164)										g26 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										g26 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float b27;
HXDLIN( 164)									int this94 = (color5 & 255);
HXDLIN( 164)									if ((this94 == 0)) {
HXLINE( 164)										b27 = ((Float)0.);
            									}
            									else {
HXLINE( 164)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 164)									Float a36 = (a16 * (( (Float)(1) ) - a26));
HXDLIN( 164)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 164)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 164)									int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a36) + (b27 * a26))));
HXDLIN( 164)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 164)									int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b9);
HXDLIN( 164)									{
HXLINE( 164)										int _hx_tmp22;
HXDLIN( 164)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)											_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXLINE( 164)											_hx_tmp22 = blended6;
            										}
HXDLIN( 164)										::iterMagic::Iimg_obj::set(img->image,location6,_hx_tmp22);
            									}
            								}
            								else {
HXLINE( 164)									::Dynamic this95 = img->image;
HXDLIN( 164)									int index15;
HXDLIN( 164)									if (img->useVirtualPos) {
HXLINE( 164)										index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            									}
            									else {
HXLINE( 164)										index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            									}
HXDLIN( 164)									int _hx_tmp23;
HXDLIN( 164)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)										_hx_tmp23 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            									}
            									else {
HXLINE( 164)										_hx_tmp23 = c14;
            									}
HXDLIN( 164)									::iterMagic::Iimg_obj::set(this95,index15,_hx_tmp23);
            								}
            							}
            						}
HXLINE( 165)						{
HXLINE( 165)							int x13 = ((x10 + placesX) + this1->width);
HXDLIN( 165)							int y13 = ((y10 + placesY) + this1->height);
HXDLIN( 165)							::Dynamic this96 = this1->image;
HXDLIN( 165)							int index16;
HXDLIN( 165)							if (this1->useVirtualPos) {
HXLINE( 165)								index16 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            							}
            							else {
HXLINE( 165)								index16 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            							}
HXDLIN( 165)							int c15 = ::iterMagic::Iimg_obj::get(this96,index16);
HXDLIN( 165)							int color6;
HXDLIN( 165)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)								color6 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            							}
            							else {
HXLINE( 165)								color6 = c15;
            							}
HXDLIN( 165)							int color7 = color6;
HXDLIN( 165)							{
HXLINE( 165)								int c16 = color7;
HXDLIN( 165)								bool _hx_tmp24;
HXDLIN( 165)								if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 165)									_hx_tmp24 = img->transparent;
            								}
            								else {
HXLINE( 165)									_hx_tmp24 = false;
            								}
HXDLIN( 165)								if (_hx_tmp24) {
HXLINE( 165)									int location7;
HXDLIN( 165)									if (img->useVirtualPos) {
HXLINE( 165)										location7 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            									}
            									else {
HXLINE( 165)										location7 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x13)) ));
            									}
HXDLIN( 165)									int this97 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 165)									int this98;
HXDLIN( 165)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)										this98 = ((((((this97 >> 24) & 255) << 24) | ((this97 & 255) << 16)) | (((this97 >> 8) & 255) << 8)) | ((this97 >> 16) & 255));
            									}
            									else {
HXLINE( 165)										this98 = this97;
            									}
HXDLIN( 165)									Float a17;
HXDLIN( 165)									int this99 = ((this98 >> 24) & 255);
HXDLIN( 165)									if ((this99 == 0)) {
HXLINE( 165)										a17 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										a17 = (( (Float)(this99) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float r17;
HXDLIN( 165)									int this100 = ((this98 >> 16) & 255);
HXDLIN( 165)									if ((this100 == 0)) {
HXLINE( 165)										r17 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										r17 = (( (Float)(this100) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float g17;
HXDLIN( 165)									int this101 = ((this98 >> 8) & 255);
HXDLIN( 165)									if ((this101 == 0)) {
HXLINE( 165)										g17 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										g17 = (( (Float)(this101) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float b18;
HXDLIN( 165)									int this102 = (this98 & 255);
HXDLIN( 165)									if ((this102 == 0)) {
HXLINE( 165)										b18 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										b18 = (( (Float)(this102) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float a27;
HXDLIN( 165)									int this103 = ((color7 >> 24) & 255);
HXDLIN( 165)									if ((this103 == 0)) {
HXLINE( 165)										a27 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										a27 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float r27;
HXDLIN( 165)									int this104 = ((color7 >> 16) & 255);
HXDLIN( 165)									if ((this104 == 0)) {
HXLINE( 165)										r27 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										r27 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float g27;
HXDLIN( 165)									int this105 = ((color7 >> 8) & 255);
HXDLIN( 165)									if ((this105 == 0)) {
HXLINE( 165)										g27 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										g27 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float b28;
HXDLIN( 165)									int this106 = (color7 & 255);
HXDLIN( 165)									if ((this106 == 0)) {
HXLINE( 165)										b28 = ((Float)0.);
            									}
            									else {
HXLINE( 165)										b28 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN( 165)									Float a37 = (a17 * (( (Float)(1) ) - a27));
HXDLIN( 165)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 165)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 165)									int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a37) + (b28 * a27))));
HXDLIN( 165)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 165)									int blended7 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b10);
HXDLIN( 165)									{
HXLINE( 165)										int _hx_tmp25;
HXDLIN( 165)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)											_hx_tmp25 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXLINE( 165)											_hx_tmp25 = blended7;
            										}
HXDLIN( 165)										::iterMagic::Iimg_obj::set(img->image,location7,_hx_tmp25);
            									}
            								}
            								else {
HXLINE( 165)									::Dynamic this107 = img->image;
HXDLIN( 165)									int index17;
HXDLIN( 165)									if (img->useVirtualPos) {
HXLINE( 165)										index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            									}
            									else {
HXLINE( 165)										index17 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x13)) ));
            									}
HXDLIN( 165)									int _hx_tmp26;
HXDLIN( 165)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)										_hx_tmp26 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            									}
            									else {
HXLINE( 165)										_hx_tmp26 = c16;
            									}
HXDLIN( 165)									::iterMagic::Iimg_obj::set(this107,index17,_hx_tmp26);
            								}
            							}
            						}
HXLINE( 166)						{
HXLINE( 166)							int y14 = ((y10 + placesY) + this1->width);
HXDLIN( 166)							int x14 = (((this1->width - 1) - placesX) + x10);
HXDLIN( 166)							::Dynamic this108 = this1->image;
HXDLIN( 166)							int index18;
HXDLIN( 166)							if (this1->useVirtualPos) {
HXLINE( 166)								index18 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x14) - this1->virtualX));
            							}
            							else {
HXLINE( 166)								index18 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x14)) ));
            							}
HXDLIN( 166)							int c17 = ::iterMagic::Iimg_obj::get(this108,index18);
HXDLIN( 166)							int color8;
HXDLIN( 166)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)								color8 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            							}
            							else {
HXLINE( 166)								color8 = c17;
            							}
HXDLIN( 166)							{
HXLINE( 166)								int c18 = color8;
HXDLIN( 166)								bool _hx_tmp27;
HXDLIN( 166)								if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 166)									_hx_tmp27 = img->transparent;
            								}
            								else {
HXLINE( 166)									_hx_tmp27 = false;
            								}
HXDLIN( 166)								if (_hx_tmp27) {
HXLINE( 166)									int location8;
HXDLIN( 166)									if (img->useVirtualPos) {
HXLINE( 166)										location8 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 166)										location8 = ::Std_obj::_hx_int(( (Float)(((y14 * img->width) + x10)) ));
            									}
HXDLIN( 166)									int this109 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 166)									int this110;
HXDLIN( 166)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)										this110 = ((((((this109 >> 24) & 255) << 24) | ((this109 & 255) << 16)) | (((this109 >> 8) & 255) << 8)) | ((this109 >> 16) & 255));
            									}
            									else {
HXLINE( 166)										this110 = this109;
            									}
HXDLIN( 166)									Float a19;
HXDLIN( 166)									int this111 = ((this110 >> 24) & 255);
HXDLIN( 166)									if ((this111 == 0)) {
HXLINE( 166)										a19 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										a19 = (( (Float)(this111) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float r18;
HXDLIN( 166)									int this112 = ((this110 >> 16) & 255);
HXDLIN( 166)									if ((this112 == 0)) {
HXLINE( 166)										r18 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										r18 = (( (Float)(this112) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float g18;
HXDLIN( 166)									int this113 = ((this110 >> 8) & 255);
HXDLIN( 166)									if ((this113 == 0)) {
HXLINE( 166)										g18 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										g18 = (( (Float)(this113) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float b19;
HXDLIN( 166)									int this114 = (this110 & 255);
HXDLIN( 166)									if ((this114 == 0)) {
HXLINE( 166)										b19 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										b19 = (( (Float)(this114) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float a28;
HXDLIN( 166)									int this115 = ((color8 >> 24) & 255);
HXDLIN( 166)									if ((this115 == 0)) {
HXLINE( 166)										a28 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										a28 = (( (Float)(this115) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float r28;
HXDLIN( 166)									int this116 = ((color8 >> 16) & 255);
HXDLIN( 166)									if ((this116 == 0)) {
HXLINE( 166)										r28 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										r28 = (( (Float)(this116) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float g28;
HXDLIN( 166)									int this117 = ((color8 >> 8) & 255);
HXDLIN( 166)									if ((this117 == 0)) {
HXLINE( 166)										g28 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										g28 = (( (Float)(this117) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float b29;
HXDLIN( 166)									int this118 = (color8 & 255);
HXDLIN( 166)									if ((this118 == 0)) {
HXLINE( 166)										b29 = ((Float)0.);
            									}
            									else {
HXLINE( 166)										b29 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 166)									Float a38 = (a19 * (( (Float)(1) ) - a28));
HXDLIN( 166)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 166)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 166)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a38) + (b29 * a28))));
HXDLIN( 166)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 166)									int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b20);
HXDLIN( 166)									{
HXLINE( 166)										int _hx_tmp28;
HXDLIN( 166)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)											_hx_tmp28 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            										}
            										else {
HXLINE( 166)											_hx_tmp28 = blended8;
            										}
HXDLIN( 166)										::iterMagic::Iimg_obj::set(img->image,location8,_hx_tmp28);
            									}
            								}
            								else {
HXLINE( 166)									::Dynamic this119 = img->image;
HXDLIN( 166)									int index19;
HXDLIN( 166)									if (img->useVirtualPos) {
HXLINE( 166)										index19 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            									}
            									else {
HXLINE( 166)										index19 = ::Std_obj::_hx_int(( (Float)(((y14 * img->width) + x10)) ));
            									}
HXDLIN( 166)									int _hx_tmp29;
HXDLIN( 166)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)										_hx_tmp29 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXLINE( 166)										_hx_tmp29 = c18;
            									}
HXDLIN( 166)									::iterMagic::Iimg_obj::set(this119,index19,_hx_tmp29);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 168)		return img;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectanglePad_Impl__obj,padWrapImageXY,return )


RectanglePad_Impl__obj::RectanglePad_Impl__obj()
{
}

bool RectanglePad_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"padImage") ) { outValue = padImage_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"borderPad") ) { outValue = borderPad_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"padImageXY") ) { outValue = padImageXY_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"padWrapImage") ) { outValue = padWrapImage_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorPadImage") ) { outValue = colorPadImage_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"padWrapImageXY") ) { outValue = padWrapImageXY_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"colorPadImageXY") ) { outValue = colorPadImageXY_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *RectanglePad_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *RectanglePad_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class RectanglePad_Impl__obj::__mClass;

static ::String RectanglePad_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("colorPadImage",8b,59,bd,16),
	HX_("colorPadImageXY",4c,5f,ef,43),
	HX_("borderPad",c7,97,98,80),
	HX_("padImage",08,91,fa,13),
	HX_("padImageXY",09,30,87,f4),
	HX_("padWrapImage",5e,e5,cf,b7),
	HX_("padWrapImageXY",df,c5,9a,37),
	::String(null())
};

void RectanglePad_Impl__obj::__register()
{
	RectanglePad_Impl__obj _hx_dummy;
	RectanglePad_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._RectanglePad.RectanglePad_Impl_",a0,1b,b5,51);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RectanglePad_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(RectanglePad_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< RectanglePad_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RectanglePad_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RectanglePad_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _RectanglePad
