// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_haxe_Timer
#include <haxe/Timer.h>
#endif
#ifndef INCLUDED_nme_app_Application
#include <nme/app/Application.h>
#endif
#ifndef INCLUDED_nme_app_FrameTimer
#include <nme/app/FrameTimer.h>
#endif
#ifndef INCLUDED_nme_app_IPollClient
#include <nme/app/IPollClient.h>
#endif
#ifndef INCLUDED_nme_app_Window
#include <nme/app/Window.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_15_new,"nme.app.FrameTimer","new",0x71397abf,"nme.app.FrameTimer.new","nme/app/FrameTimer.hx",15,0x2031a3cf)
HX_LOCAL_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_27_destory,"nme.app.FrameTimer","destory",0x3d97aeb3,"nme.app.FrameTimer.destory","nme/app/FrameTimer.hx",27,0x2031a3cf)
HX_LOCAL_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_31_set_fps,"nme.app.FrameTimer","set_fps",0x32d7e76b,"nme.app.FrameTimer.set_fps","nme/app/FrameTimer.hx",31,0x2031a3cf)
HX_LOCAL_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_39_onPoll,"nme.app.FrameTimer","onPoll",0xf63261ff,"nme.app.FrameTimer.onPoll","nme/app/FrameTimer.hx",39,0x2031a3cf)
HX_LOCAL_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_79_invalidate,"nme.app.FrameTimer","invalidate",0xe66608fc,"nme.app.FrameTimer.invalidate","nme/app/FrameTimer.hx",79,0x2031a3cf)
HX_LOCAL_STACK_FRAME(_hx_pos_10a32bcbe2eaf805_83_getNextWake,"nme.app.FrameTimer","getNextWake",0x15e866cc,"nme.app.FrameTimer.getNextWake","nme/app/FrameTimer.hx",83,0x2031a3cf)
namespace nme{
namespace app{

void FrameTimer_obj::__construct( ::nme::app::Window inWindow,Float inFps){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_15_new)
HXLINE(  16)		this->set_fps(inFps);
HXLINE(  17)		this->lastRender = ((Float)0.0);
HXLINE(  18)		this->window = inWindow;
HXLINE(  19)		this->invalid = false;
HXLINE(  20)		this->catchup = false;
HXLINE(  21)		this->offTarget = ((Float)0.0);
HXLINE(  22)		::nme::app::Application_obj::addPollClient(::hx::ObjectPtr<OBJ_>(this),true);
            	}

Dynamic FrameTimer_obj::__CreateEmpty() { return new FrameTimer_obj; }

void *FrameTimer_obj::_hx_vtable = 0;

Dynamic FrameTimer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FrameTimer_obj > _hx_result = new FrameTimer_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool FrameTimer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x13299753;
}

static ::nme::app::IPollClient_obj _hx_nme_app_FrameTimer__hx_nme_app_IPollClient= {
	( void (::hx::Object::*)(Float))&::nme::app::FrameTimer_obj::onPoll,
	( Float (::hx::Object::*)(Float,Float))&::nme::app::FrameTimer_obj::getNextWake,
};

void *FrameTimer_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x83491b18: return &_hx_nme_app_FrameTimer__hx_nme_app_IPollClient;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void FrameTimer_obj::destory(){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_27_destory)
HXDLIN(  27)		::nme::app::Application_obj::removePollClient(::hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FrameTimer_obj,destory,(void))

Float FrameTimer_obj::set_fps(Float inFps){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_31_set_fps)
HXLINE(  32)		this->fps = inFps;
HXLINE(  33)		Float _hx_tmp;
HXDLIN(  33)		if ((this->fps > 0)) {
HXLINE(  33)			_hx_tmp = (((Float)1.0) / this->fps);
            		}
            		else {
HXLINE(  33)			_hx_tmp = ((Float)0.0);
            		}
HXDLIN(  33)		this->framePeriod = _hx_tmp;
HXLINE(  34)		return inFps;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FrameTimer_obj,set_fps,return )

void FrameTimer_obj::onPoll(Float timestamp){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_39_onPoll)
HXDLIN(  39)		if (this->window->active) {
HXLINE(  41)			bool wasInvalid = this->invalid;
HXLINE(  42)			this->invalid = false;
HXLINE(  52)			bool _hx_tmp;
HXDLIN(  52)			if ((this->fps > 0)) {
HXLINE(  52)				_hx_tmp = (timestamp >= (((this->lastRender - this->offTarget) + this->framePeriod) - ((Float)0.0005)));
            			}
            			else {
HXLINE(  52)				_hx_tmp = false;
            			}
HXDLIN(  52)			if (_hx_tmp) {
HXLINE(  54)				if (this->catchup) {
HXLINE(  56)					this->offTarget = (timestamp - (this->lastRender + this->framePeriod));
HXLINE(  57)					if ((this->offTarget > this->framePeriod)) {
HXLINE(  58)						this->offTarget = this->framePeriod;
            					}
HXLINE(  59)					if ((this->offTarget < -(this->framePeriod))) {
HXLINE(  60)						this->offTarget = -(this->framePeriod);
            					}
            				}
            				else {
HXLINE(  63)					this->offTarget = ((Float)0.0);
            				}
HXLINE(  65)				this->lastRender = timestamp;
HXLINE(  66)				this->window->onNewFrame();
            			}
            			else {
HXLINE(  68)				if (wasInvalid) {
HXLINE(  70)					this->offTarget = ((Float)0.0);
HXLINE(  71)					this->window->onInvalidFrame();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FrameTimer_obj,onPoll,(void))

void FrameTimer_obj::invalidate(){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_79_invalidate)
HXDLIN(  79)		this->invalid = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FrameTimer_obj,invalidate,(void))

Float FrameTimer_obj::getNextWake(Float defaultWake,Float timestamp){
            	HX_STACKFRAME(&_hx_pos_10a32bcbe2eaf805_83_getNextWake)
HXLINE(  84)		if (!(this->window->active)) {
HXLINE(  85)			return defaultWake;
            		}
HXLINE(  87)		if (this->invalid) {
HXLINE(  88)			return ((Float)0.0);
            		}
HXLINE(  90)		if ((this->framePeriod == ((Float)0.0))) {
HXLINE(  91)			return defaultWake;
            		}
HXLINE(  93)		Float next = (this->lastRender + this->framePeriod);
HXDLIN(  93)		Float next1 = (next - ::haxe::Timer_obj::stamp());
HXLINE(  94)		if ((next1 < defaultWake)) {
HXLINE(  95)			return next1;
            		}
HXLINE(  97)		return defaultWake;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FrameTimer_obj,getNextWake,return )


::hx::ObjectPtr< FrameTimer_obj > FrameTimer_obj::__new( ::nme::app::Window inWindow,Float inFps) {
	::hx::ObjectPtr< FrameTimer_obj > __this = new FrameTimer_obj();
	__this->__construct(inWindow,inFps);
	return __this;
}

::hx::ObjectPtr< FrameTimer_obj > FrameTimer_obj::__alloc(::hx::Ctx *_hx_ctx, ::nme::app::Window inWindow,Float inFps) {
	FrameTimer_obj *__this = (FrameTimer_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FrameTimer_obj), true, "nme.app.FrameTimer"));
	*(void **)__this = FrameTimer_obj::_hx_vtable;
	__this->__construct(inWindow,inFps);
	return __this;
}

FrameTimer_obj::FrameTimer_obj()
{
}

void FrameTimer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FrameTimer);
	HX_MARK_MEMBER_NAME(fps,"fps");
	HX_MARK_MEMBER_NAME(lastRender,"lastRender");
	HX_MARK_MEMBER_NAME(framePeriod,"framePeriod");
	HX_MARK_MEMBER_NAME(window,"window");
	HX_MARK_MEMBER_NAME(invalid,"invalid");
	HX_MARK_MEMBER_NAME(catchup,"catchup");
	HX_MARK_MEMBER_NAME(offTarget,"offTarget");
	HX_MARK_END_CLASS();
}

void FrameTimer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(fps,"fps");
	HX_VISIT_MEMBER_NAME(lastRender,"lastRender");
	HX_VISIT_MEMBER_NAME(framePeriod,"framePeriod");
	HX_VISIT_MEMBER_NAME(window,"window");
	HX_VISIT_MEMBER_NAME(invalid,"invalid");
	HX_VISIT_MEMBER_NAME(catchup,"catchup");
	HX_VISIT_MEMBER_NAME(offTarget,"offTarget");
}

::hx::Val FrameTimer_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fps") ) { return ::hx::Val( fps ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"window") ) { return ::hx::Val( window ); }
		if (HX_FIELD_EQ(inName,"onPoll") ) { return ::hx::Val( onPoll_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"invalid") ) { return ::hx::Val( invalid ); }
		if (HX_FIELD_EQ(inName,"catchup") ) { return ::hx::Val( catchup ); }
		if (HX_FIELD_EQ(inName,"destory") ) { return ::hx::Val( destory_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fps") ) { return ::hx::Val( set_fps_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"offTarget") ) { return ::hx::Val( offTarget ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"lastRender") ) { return ::hx::Val( lastRender ); }
		if (HX_FIELD_EQ(inName,"invalidate") ) { return ::hx::Val( invalidate_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framePeriod") ) { return ::hx::Val( framePeriod ); }
		if (HX_FIELD_EQ(inName,"getNextWake") ) { return ::hx::Val( getNextWake_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FrameTimer_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fps") ) { if (inCallProp != ::hx::paccNever) return ::hx::Val( set_fps(inValue.Cast< Float >()) );fps=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"window") ) { window=inValue.Cast<  ::nme::app::Window >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"invalid") ) { invalid=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"catchup") ) { catchup=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"offTarget") ) { offTarget=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"lastRender") ) { lastRender=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framePeriod") ) { framePeriod=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FrameTimer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("fps",e9,c7,4d,00));
	outFields->push(HX_("lastRender",4c,4e,04,d0));
	outFields->push(HX_("framePeriod",0e,2d,63,19));
	outFields->push(HX_("window",f0,93,8c,52));
	outFields->push(HX_("invalid",f7,da,47,3b));
	outFields->push(HX_("catchup",56,a7,a5,e9));
	outFields->push(HX_("offTarget",20,b8,d4,8d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FrameTimer_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(FrameTimer_obj,fps),HX_("fps",e9,c7,4d,00)},
	{::hx::fsFloat,(int)offsetof(FrameTimer_obj,lastRender),HX_("lastRender",4c,4e,04,d0)},
	{::hx::fsFloat,(int)offsetof(FrameTimer_obj,framePeriod),HX_("framePeriod",0e,2d,63,19)},
	{::hx::fsObject /*  ::nme::app::Window */ ,(int)offsetof(FrameTimer_obj,window),HX_("window",f0,93,8c,52)},
	{::hx::fsBool,(int)offsetof(FrameTimer_obj,invalid),HX_("invalid",f7,da,47,3b)},
	{::hx::fsBool,(int)offsetof(FrameTimer_obj,catchup),HX_("catchup",56,a7,a5,e9)},
	{::hx::fsFloat,(int)offsetof(FrameTimer_obj,offTarget),HX_("offTarget",20,b8,d4,8d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FrameTimer_obj_sStaticStorageInfo = 0;
#endif

static ::String FrameTimer_obj_sMemberFields[] = {
	HX_("fps",e9,c7,4d,00),
	HX_("lastRender",4c,4e,04,d0),
	HX_("framePeriod",0e,2d,63,19),
	HX_("window",f0,93,8c,52),
	HX_("invalid",f7,da,47,3b),
	HX_("catchup",56,a7,a5,e9),
	HX_("offTarget",20,b8,d4,8d),
	HX_("destory",d4,e8,83,24),
	HX_("set_fps",8c,21,c4,19),
	HX_("onPoll",fe,86,e6,ec),
	HX_("invalidate",7b,19,2a,87),
	HX_("getNextWake",6d,c5,b2,20),
	::String(null()) };

::hx::Class FrameTimer_obj::__mClass;

void FrameTimer_obj::__register()
{
	FrameTimer_obj _hx_dummy;
	FrameTimer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("nme.app.FrameTimer",4d,af,9f,21);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FrameTimer_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FrameTimer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FrameTimer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FrameTimer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nme
} // end namespace app
