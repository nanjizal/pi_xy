// Generated by Haxe 4.3.0-rc.1+
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = "Math";
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_GenericCell = function(elt,next) {
	this.elt = elt;
	this.next = next;
};
haxe_ds_GenericCell.__name__ = "haxe.ds.GenericCell";
haxe_ds_GenericCell.prototype = {
	__class__: haxe_ds_GenericCell
};
var haxe_ds_GenericStack = function() {
};
haxe_ds_GenericStack.__name__ = "haxe.ds.GenericStack";
haxe_ds_GenericStack.prototype = {
	__class__: haxe_ds_GenericStack
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.prototype = {
	getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,__class__: haxe_io_Bytes
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var htmlHelper_canvas_CanvasSetup = function(allowOverSample) {
	if(allowOverSample == null) {
		allowOverSample = true;
	}
	this.factor = 4.;
	this.divertTrace = new htmlHelper_tools_DivertTrace();
	var e = null;
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	this.canvasWrapper = this1;
	this.canvasWrapper.width = 1024;
	this.canvasWrapper.height = 768;
	var dom = this.canvasWrapper;
	var style = dom.style;
	style.background = "black";
	window.document.body.appendChild(this.canvasWrapper);
	var this1 = new htmlHelper_canvas_CanvasPlus(this.canvasWrapper.getContext("2d",null),10,10);
	this1.me.lineWidth = 1;
	var tmp = StringTools.hex(16744272,6);
	this1.me.strokeStyle = "#" + tmp;
	this.surface = this1;
	var me = this.surface.me;
	if(allowOverSample) {
		this.overSampleCanvas();
	}
};
htmlHelper_canvas_CanvasSetup.__name__ = "htmlHelper.canvas.CanvasSetup";
htmlHelper_canvas_CanvasSetup.prototype = {
	overSampleCanvas: function() {
		var ctx = this.surface.me;
		var canvas = this.canvasWrapper;
		var width = canvas.width;
		var height = canvas.height;
		canvas.width = 0 | (width * this.factor | 0);
		canvas.height = 0 | (height * this.factor | 0);
		var dom = this.canvasWrapper;
		var style = dom.style;
		style.width = width + "px";
		style.height = height + "px";
		ctx.scale(this.factor,this.factor);
	}
	,__class__: htmlHelper_canvas_CanvasSetup
};
var htmlHelper_canvas_CanvasPlus = function(me,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.me = me;
};
htmlHelper_canvas_CanvasPlus.__name__ = "htmlHelper.canvas.CanvasPlus";
htmlHelper_canvas_CanvasPlus.prototype = {
	__class__: htmlHelper_canvas_CanvasPlus
};
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = "htmlHelper.tools.DivertTrace";
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
	,__class__: htmlHelper_tools_DivertTrace
};
var iterMagic_Iimg = function() { };
iterMagic_Iimg.__name__ = "iterMagic.Iimg";
iterMagic_Iimg.__isInterface__ = true;
iterMagic_Iimg.prototype = {
	__class__: iterMagic_Iimg
};
var iterMagic_ArrIntImg = function() {
};
iterMagic_ArrIntImg.__name__ = "iterMagic.ArrIntImg";
iterMagic_ArrIntImg.__interfaces__ = [iterMagic_Iimg];
iterMagic_ArrIntImg.prototype = {
	set: function(index,value) {
		this.data[index] = value;
		return value;
	}
	,get: function(index) {
		return this.data[index];
	}
	,__class__: iterMagic_ArrIntImg
};
var iterMagic_VecIntImg = function() {
};
iterMagic_VecIntImg.__name__ = "iterMagic.VecIntImg";
iterMagic_VecIntImg.__interfaces__ = [iterMagic_Iimg];
iterMagic_VecIntImg.prototype = {
	set: function(index,value) {
		this.data[index] = value;
		return value;
	}
	,get: function(index) {
		return this.data[index];
	}
	,__class__: iterMagic_VecIntImg
};
var iterMagic_BytesImg = function() {
};
iterMagic_BytesImg.__name__ = "iterMagic.BytesImg";
iterMagic_BytesImg.__interfaces__ = [iterMagic_Iimg];
iterMagic_BytesImg.prototype = {
	set: function(index,value) {
		this.data.setInt32(index * 4 | 0,value);
		return value;
	}
	,get: function(index) {
		return this.data.getInt32(index * 4 | 0);
	}
	,__class__: iterMagic_BytesImg
};
var iterMagic_U32ArrImg = function() {
};
iterMagic_U32ArrImg.__name__ = "iterMagic.U32ArrImg";
iterMagic_U32ArrImg.__interfaces__ = [iterMagic_Iimg];
iterMagic_U32ArrImg.prototype = {
	set: function(index,value) {
		this.data[index] = value;
		return value;
	}
	,get: function(index) {
		return this.data[index];
	}
	,__class__: iterMagic_U32ArrImg
};
var iterMagic_StackIntImg = function() {
};
iterMagic_StackIntImg.__name__ = "iterMagic.StackIntImg";
iterMagic_StackIntImg.__interfaces__ = [iterMagic_Iimg];
iterMagic_StackIntImg.prototype = {
	set: function(index,value) {
		var l = this.data.head;
		var prev = null;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) {
			var i = _g++;
			prev = l;
			l = l.next;
		}
		if(prev == null) {
			this.data.head = new haxe_ds_GenericCell(value,l.next);
			l = null;
		} else {
			prev.next = new haxe_ds_GenericCell(value,l.next);
			l = null;
		}
		return value;
	}
	,get: function(index) {
		var l = this.data.head;
		var prev = l;
		++index;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) {
			var i = _g++;
			prev = l;
			l = l.next;
		}
		return prev.elt;
	}
	,__class__: iterMagic_StackIntImg
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var pi_$xy_ImageStruct = function() {
	this.useMask = false;
	this.useVirtualPos = false;
	this.virtualY = 0;
	this.virtualX = 0;
	this.transparent = false;
	this.isLittle = pi_$xy_Endian_isLittleEndian;
	this.transparent = false;
};
pi_$xy_ImageStruct.__name__ = "pi_xy.ImageStruct";
pi_$xy_ImageStruct.prototype = {
	__class__: pi_$xy_ImageStruct
};
var pi_$xy_algo_QuadPoints_$ = function(ax,ay,bx,by,cx,cy,dx,dy) {
	this.ax = ax;
	this.ay = ay;
	this.bx = bx;
	this.by = by;
	this.cx = cx;
	this.cy = cy;
	this.dx = dx;
	this.dy = dy;
};
pi_$xy_algo_QuadPoints_$.__name__ = "pi_xy.algo.QuadPoints_";
pi_$xy_algo_QuadPoints_$.prototype = {
	__class__: pi_$xy_algo_QuadPoints_$
};
var pi_$xy_algo_IhitObj = function() { };
pi_$xy_algo_IhitObj.__name__ = "pi_xy.algo.IhitObj";
pi_$xy_algo_IhitObj.__isInterface__ = true;
var pi_$xy_algo_HitQuad = function(ax,ay,bx,by,cx,cy,dx,dy,preCalculated) {
	if(preCalculated == null) {
		preCalculated = true;
	}
	pi_$xy_algo_QuadPoints_$.call(this,ax,ay,bx,by,cx,cy,dx,dy);
	if(preCalculated) {
		this.triABD = new pi_$xy_algo_HitTri(this.ax,this.ay,this.bx,this.by,this.dx,this.dy,true);
		this.triBCD = new pi_$xy_algo_HitTri(this.bx,this.by,this.cx,this.cy,this.dx,this.dy,true);
		var a = this.ax;
		var b = this.bx;
		var c = this.cx;
		var d = this.dx;
		var min = Math.floor(a);
		var max = Math.ceil(a);
		if(b < min) {
			min = Math.floor(b);
		} else if(b > max) {
			max = Math.ceil(b);
		}
		if(c < min) {
			min = Math.floor(c);
		} else if(c > max) {
			max = Math.ceil(c);
		}
		if(d < min) {
			min = Math.floor(d);
		} else if(d > max) {
			max = Math.ceil(d);
		}
		var ii_min = min;
		var ii_max = max;
		var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
		this.xIter4 = this1;
		var a = this.ay;
		var b = this.by;
		var c = this.cy;
		var d = this.dy;
		var min = Math.floor(a);
		var max = Math.ceil(a);
		if(b < min) {
			min = Math.floor(b);
		} else if(b > max) {
			max = Math.ceil(b);
		}
		if(c < min) {
			min = Math.floor(c);
		} else if(c > max) {
			max = Math.ceil(c);
		}
		if(d < min) {
			min = Math.floor(d);
		} else if(d > max) {
			max = Math.ceil(d);
		}
		var ii_min = min;
		var ii_max = max;
		var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
		this.yIter4 = this1;
	}
};
pi_$xy_algo_HitQuad.__name__ = "pi_xy.algo.HitQuad";
pi_$xy_algo_HitQuad.__interfaces__ = [pi_$xy_algo_IhitObj];
pi_$xy_algo_HitQuad.__super__ = pi_$xy_algo_QuadPoints_$;
pi_$xy_algo_HitQuad.prototype = $extend(pi_$xy_algo_QuadPoints_$.prototype,{
	__class__: pi_$xy_algo_HitQuad
});
var pi_$xy_algo_TriPoints_$ = function(ax,ay,bx,by,cx,cy) {
	var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	this.ax = ax;
	this.ay = ay;
	this.bx = bx;
	this.by = by;
	this.cx = cx;
	this.cy = cy;
};
pi_$xy_algo_TriPoints_$.__name__ = "pi_xy.algo.TriPoints_";
pi_$xy_algo_TriPoints_$.prototype = {
	__class__: pi_$xy_algo_TriPoints_$
};
var pi_$xy_algo_HitTri = function(ax,ay,bx,by,cx,cy,preCalculated) {
	if(preCalculated == null) {
		preCalculated = true;
	}
	this.undoImage = null;
	pi_$xy_algo_TriPoints_$.call(this,ax,ay,bx,by,cx,cy);
	this.preCalculated = preCalculated;
	if(preCalculated) {
		this.s0 = this.ay * this.cx - this.ax * this.cy;
		this.sx = this.cy - this.ay;
		this.sy = this.ax - this.cx;
		this.t0 = this.ax * this.by - this.ay * this.bx;
		this.tx = this.ay - this.by;
		this.ty = this.bx - this.ax;
		this.A = -this.by * this.cx + this.ay * (-this.bx + this.cx) + this.ax * (this.by - this.cy) + this.bx * this.cy;
		var a = this.ax;
		var b = this.bx;
		var c = this.cx;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.xIter3 = tmp;
		var a = this.ay;
		var b = this.by;
		var c = this.cy;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.yIter3 = tmp;
	}
};
pi_$xy_algo_HitTri.__name__ = "pi_xy.algo.HitTri";
pi_$xy_algo_HitTri.__interfaces__ = [pi_$xy_algo_IhitObj];
pi_$xy_algo_HitTri.__super__ = pi_$xy_algo_TriPoints_$;
pi_$xy_algo_HitTri.prototype = $extend(pi_$xy_algo_TriPoints_$.prototype,{
	__class__: pi_$xy_algo_HitTri
});
var pi_$xy_algo_HitTriArray = function(triArr) {
	this.triArr = triArr;
};
pi_$xy_algo_HitTriArray.__name__ = "pi_xy.algo.HitTriArray";
pi_$xy_algo_HitTriArray.__interfaces__ = [pi_$xy_algo_IhitObj];
pi_$xy_algo_HitTriArray.prototype = {
	__class__: pi_$xy_algo_HitTriArray
};
var pi_$xy_algo_HitTriScalar = {};
pi_$xy_algo_HitTriScalar.medianABx = function(this1) {
	return (this1.ax + this1.bx) / 2;
};
pi_$xy_algo_HitTriScalar.medianBCx = function(this1) {
	return (this1.bx + this1.cx) / 2;
};
pi_$xy_algo_HitTriScalar.medianCAx = function(this1) {
	return (this1.cx + this1.ax) / 2;
};
pi_$xy_algo_HitTriScalar.medianABy = function(this1) {
	return (this1.ay + this1.by) / 2;
};
pi_$xy_algo_HitTriScalar.medianBCy = function(this1) {
	return (this1.by + this1.cy) / 2;
};
pi_$xy_algo_HitTriScalar.medianCAy = function(this1) {
	return (this1.cy + this1.ay) / 2;
};
var pi_$xy_application_Arcs = function() {
	this.arcChord2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n        fill=\"0xFF00A6FF\" \n        startAngle=\"190\" sweepAngle=\"90\"\n        arcType=\"chord\">\n    </ArcForm>";
	this.arcEllipse2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n        fill=\"0xFFFF00EE\" \n        startAngle=\"-43\" sweepAngle=\"108\"\n        arcType=\"ellipse\">\n    </ArcForm>";
	this.arcPie2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n        fill=\"0xFF00FF00\" \n        startAngle=\"120\" sweepAngle=\"70\"\n        arcType=\"pie\">\n    </ArcForm>";
	this.arcChord = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n        fill=\"0xFF00A6FF\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"chord\">\n    </ArcForm>";
	this.arcEllipse = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n        fill=\"0xFFFF00EE\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"ellipse\">\n    </ArcForm>";
	this.arcPie = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n        fill=\"0xFF00FF00\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"pie\">\n    </ArcForm>";
	this.aGrid = "<LineGridShape\n        left = \"100\"  top = \"100\"\n        width = \"2048\" height = \"1536\"\n        delta = \"100\" deltaH = \"100\"\n        strokeColor=\"0xfF003300\" strokeWidth=\"3\">\n    </LineGridShape>";
	this.backGround = "<RectangleForm\n        left = \"-1\"\n        top = \"-1\"\n        width = \"3073\"\n        height = \"2305\"\n        fill = \"0xFF000203\">\n    </RectangleForm>";
	this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
	var surface = this.canvasSetup.surface;
	var imageType = null;
	var this1 = new pi_$xy_ImageStruct();
	if(imageType == null) {
		imageType = pi_$xy_ImageStruct.defaultType;
	}
	var imageType1 = imageType;
	if(imageType1 == null) {
		imageType1 = 2;
	}
	var tmp;
	switch(imageType1) {
	case 0:
		var byt = new iterMagic_BytesImg();
		var b = byt;
		b.width = 4096;
		b.height = 3072;
		b.length = 12582912;
		b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
		var len = b.length;
		var w = 0;
		var _g = 0;
		var _g1 = b.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = b.width;
			while(_g2 < _g3) {
				var x = _g2++;
				b.data.b[w++] = 0;
				b.data.b[w++] = 0;
				b.data.b[w++] = 0;
				b.data.b[w++] = 0;
			}
		}
		tmp = b;
		break;
	case 1:
		var arrI = new iterMagic_ArrIntImg();
		var a = arrI;
		a.width = 4096;
		a.height = 3072;
		a.data = [];
		a.length = 12582912;
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			a.data[i] = 0;
		}
		tmp = a;
		break;
	case 2:
		var u32a = new iterMagic_U32ArrImg();
		var b = u32a;
		b.width = 4096;
		b.height = 3072;
		b.length = 12582912;
		var this2 = new Uint32Array(b.length);
		b.data = this2;
		var _g = 0;
		var _g1 = b.length;
		while(_g < _g1) {
			var i = _g++;
			b.data[i] = 0;
		}
		tmp = b;
		break;
	case 3:
		var vec = new iterMagic_VecIntImg();
		var v = vec;
		v.width = 4096;
		v.height = 3072;
		v.length = 12582912;
		var this2 = new Array(v.length);
		v.data = this2;
		var _g = 0;
		var _g1 = v.length;
		while(_g < _g1) {
			var i = _g++;
			v.data[i] = 0;
		}
		tmp = v;
		break;
	case 4:
		var sInt = new iterMagic_StackIntImg();
		var b = sInt;
		b.width = 4096;
		b.height = 3072;
		b.length = 12582912;
		b.data = new haxe_ds_GenericStack();
		var len = b.length;
		var d = b.data;
		if(d.head == null) {
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				d.head = new haxe_ds_GenericCell(0,d.head);
			}
		} else {
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				var l = b.data.head;
				var prev = null;
				var _g2 = 0;
				var _g3 = i;
				while(_g2 < _g3) {
					var i1 = _g2++;
					prev = l;
					l = l.next;
				}
				if(prev == null) {
					b.data.head = new haxe_ds_GenericCell(0,l.next);
					l = null;
				} else {
					prev.next = new haxe_ds_GenericCell(0,l.next);
					l = null;
				}
			}
		}
		tmp = b;
		break;
	}
	this1.image = tmp;
	this1.width = 4096;
	this1.height = 3072;
	this1.imageType = imageType;
	var pixelImage = this1;
	pixelImage.transparent = true;
	var parser = new pi_$xy_triangleGML_TriangleGML(pixelImage);
	parser.addShape(this.backGround,10,10);
	parser.addShape(this.aGrid,10,10);
	parser.addShape(this.arcPie,10,0);
	parser.addShape(this.arcEllipse,10,500);
	parser.addShape(this.arcChord,10,1000);
	parser.addShape(this.arcPie2,1210,0);
	parser.addShape(this.arcEllipse2,1210,500);
	parser.addShape(this.arcChord2,1210,1000);
	parser.renderPromise().then(function(_) {
		var this1 = pixelImage;
		var ctx = surface.me;
		var here = this1;
		var base = this1;
		if(base.useMask && base.mask != null) {
			var width = here.width;
			var height = here.height;
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var temp = this1;
			var _g = 0;
			var _g1 = here.image.length;
			while(_g < _g1) {
				var i = _g++;
				var this1 = here.image.get(i);
				var p0 = this1;
				var this2 = here.mask.image.get(i);
				var m1 = this2;
				var value;
				if(m1 == 0) {
					var this3 = p0;
					value = this3;
				} else {
					var this4 = m1 >> 24 & 255;
					var m0 = this4 == 0 ? 0. : this4 / 255;
					var this5 = m1 >> 16 & 255;
					var m11 = this5 == 0 ? 0. : this5 / 255;
					var this6 = m1 >> 8 & 255;
					var m2 = this6 == 0 ? 0. : this6 / 255;
					var this7 = m1 & 255;
					var m3 = this7 == 0 ? 0. : this7 / 255;
					var ch0 = (1. - m0) * (p0 >> 24 & 255) | 0;
					var ch1 = (1. - m11) * (p0 >> 16 & 255) | 0;
					var ch2 = (1. - m2) * (p0 >> 8 & 255) | 0;
					var ch3 = (1. - m3) * (p0 & 255) | 0;
					value = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
				}
				temp.image.set(i,value);
			}
			var this1 = new Uint32Array(temp.width * temp.height | 0);
			var temp1 = this1;
			var _g = 0;
			var _g1 = temp.image.length;
			while(_g < _g1) {
				var i = _g++;
				temp1[i] = temp.image.get(i);
			}
			var dataimg = temp1;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,here.width,here.height);
			if(base.useVirtualPos) {
				ctx.putImageData(imageData,0 - base.virtualX,0 - base.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		} else {
			var this1 = new Uint32Array(here.width * here.height | 0);
			var temp = this1;
			var _g = 0;
			var _g1 = here.image.length;
			while(_g < _g1) {
				var i = _g++;
				temp[i] = here.image.get(i);
			}
			var dataimg = temp;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,here.width,here.height);
			if(base.useVirtualPos) {
				ctx.putImageData(imageData,0 - base.virtualX,0 - base.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		}
		return here;
	});
};
pi_$xy_application_Arcs.__name__ = "pi_xy.application.Arcs";
pi_$xy_application_Arcs.prototype = {
	__class__: pi_$xy_application_Arcs
};
function pi_$xy_application_Arcs_main() {
	new pi_$xy_application_Arcs();
}
var pi_$xy_iter_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
pi_$xy_iter_IntIterStart.__name__ = "pi_xy.iter.IntIterStart";
pi_$xy_iter_IntIterStart.prototype = {
	__class__: pi_$xy_iter_IntIterStart
};
var pi_$xy_triangleGML_triGML_ShapeInterface = function() { };
pi_$xy_triangleGML_triGML_ShapeInterface.__name__ = "pi_xy.triangleGML.triGML.ShapeInterface";
pi_$xy_triangleGML_triGML_ShapeInterface.__isInterface__ = true;
pi_$xy_triangleGML_triGML_ShapeInterface.prototype = {
	__class__: pi_$xy_triangleGML_triGML_ShapeInterface
};
var pi_$xy_triangleGML_triGML_GroupShape = function(opacity,visibility) {
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	this.scaleY = 1.;
	this.scaleX = 1.;
	this.skewY = 0.;
	this.skewX = 0.;
	this.transformCentreY = 0.;
	this.transformCentreX = 0.;
	this.rotation = 0.;
	this.externalSoft = false;
	this.edgeSoft = 0;
	this.hitObj = null;
	this.offY = 0.;
	this.offX = 0.;
	this.visibility = visibility;
	this.opacity = opacity;
};
pi_$xy_triangleGML_triGML_GroupShape.__name__ = "pi_xy.triangleGML.triGML.GroupShape";
pi_$xy_triangleGML_triGML_GroupShape.__interfaces__ = [pi_$xy_triangleGML_triGML_ShapeInterface];
pi_$xy_triangleGML_triGML_GroupShape.prototype = {
	setParameter: function(name,value) {
		switch(name) {
		case "edgeSoft":
			this.edgeSoft = parseFloat(value);
			break;
		case "externalSoft":
			this.externalSoft = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "opacity":
			this.opacity = parseFloat(value);
			break;
		case "rotation":
			var degree = parseFloat(value);
			this.rotation = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "scale":
			this.scaleX = this.scaleY = parseFloat(value);
			break;
		case "scaleX":
			this.scaleX = parseFloat(value);
			break;
		case "scaleY":
			this.scaleY = parseFloat(value);
			break;
		case "skewX":
			this.skewX = parseFloat(value);
			break;
		case "skewY":
			this.skewY = parseFloat(value);
			break;
		case "theta":
			this.rotation = parseFloat(value);
			break;
		case "transformCentreX":
			this.transformCentreX = parseFloat(value);
			break;
		case "transformCentreY":
			this.transformCentreY = parseFloat(value);
			break;
		case "visibility":
			this.visibility = value.toLowerCase() == "true";
			break;
		default:
			haxe_Log.trace("property not found " + name,{ fileName : "src/pi_xy/triangleGML/triGML/GroupShape.hx", lineNumber : 58, className : "pi_xy.triangleGML.triGML.GroupShape", methodName : "setParameter"});
		}
	}
	,translate: function(x,y) {
		this.offX = x;
		this.offY = y;
	}
	,setImage: function(name,imageTool) {
		return imageTool;
	}
	,__class__: pi_$xy_triangleGML_triGML_GroupShape
};
var pi_$xy_triangleGML_triGML_BasicShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray) {
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_GroupShape.call(this,opacity,visibility);
	this.strokeColor = strokeColor;
	this.strokeWidth = strokeWidth;
	this.strokeDashGapArray = strokeDashGapArray;
};
pi_$xy_triangleGML_triGML_BasicShape.__name__ = "pi_xy.triangleGML.triGML.BasicShape";
pi_$xy_triangleGML_triGML_BasicShape.__super__ = pi_$xy_triangleGML_triGML_GroupShape;
pi_$xy_triangleGML_triGML_BasicShape.prototype = $extend(pi_$xy_triangleGML_triGML_GroupShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "strokeColor":
			this.strokeColor = Std.parseInt(value);
			break;
		case "strokeDashGapArray":
			this.strokeDashGapArray = null;
			break;
		case "strokeWidth":
			this.strokeWidth = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_GroupShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_BasicShape
});
var pi_$xy_triangleGML_triGML_FillForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill) {
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.fill = fill;
};
pi_$xy_triangleGML_triGML_FillForm.__name__ = "pi_xy.triangleGML.triGML.FillForm";
pi_$xy_triangleGML_triGML_FillForm.__super__ = pi_$xy_triangleGML_triGML_BasicShape;
pi_$xy_triangleGML_triGML_FillForm.prototype = $extend(pi_$xy_triangleGML_triGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		if(name == "fill") {
			this.fill = Std.parseInt(value);
		} else {
			pi_$xy_triangleGML_triGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_FillForm
});
var pi_$xy_triangleGML_triGML_shape_form_ArcForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType) {
	if(arcType == null) {
		arcType = "pie";
	}
	if(sweepAngle == null) {
		sweepAngle = 0.;
	}
	if(startAngle == null) {
		startAngle = 0.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.startAngle = startAngle;
	this.sweepAngle = sweepAngle;
	this.arcType = arcType;
	this.rx = width / 2;
	this.ry = height / 2;
};
pi_$xy_triangleGML_triGML_shape_form_ArcForm_$.__name__ = "pi_xy.triangleGML.triGML.shape.form.ArcForm_";
pi_$xy_triangleGML_triGML_shape_form_ArcForm_$.__super__ = pi_$xy_triangleGML_triGML_FillForm;
pi_$xy_triangleGML_triGML_shape_form_ArcForm_$.prototype = $extend(pi_$xy_triangleGML_triGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "arcType":
			this.arcType = js_Boot.__cast(value , String);
			break;
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "startAngle":
			var degree = parseFloat(value);
			this.startAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "sweepAngle":
			var degree = parseFloat(value);
			this.sweepAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_FillForm.prototype.setParameter.call(this,name,value);
		}
		this.rx = this.width / 2;
		this.ry = this.height / 2;
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_form_ArcForm_$
});
var pi_$xy_triangleGML_ArcForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType) {
	pi_$xy_triangleGML_triGML_shape_form_ArcForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType);
};
pi_$xy_triangleGML_ArcForm.__name__ = "pi_xy.triangleGML.ArcForm";
pi_$xy_triangleGML_ArcForm.__super__ = pi_$xy_triangleGML_triGML_shape_form_ArcForm_$;
pi_$xy_triangleGML_ArcForm.prototype = $extend(pi_$xy_triangleGML_triGML_shape_form_ArcForm_$.prototype,{
	render: function(pixelImage) {
		var width = Math.ceil(this.width);
		var height = Math.ceil(this.height);
		var imageType = null;
		var this1 = new pi_$xy_ImageStruct();
		if(imageType == null) {
			imageType = pi_$xy_ImageStruct.defaultType;
		}
		var imageType1 = imageType;
		if(imageType1 == null) {
			imageType1 = 2;
		}
		var tmp;
		switch(imageType1) {
		case 0:
			var byt = new iterMagic_BytesImg();
			var b = byt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
			var len = b.length;
			var w = 0;
			var _g = 0;
			var _g1 = b.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = b.width;
				while(_g2 < _g3) {
					var x = _g2++;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
				}
			}
			tmp = b;
			break;
		case 1:
			var arrI = new iterMagic_ArrIntImg();
			var a = arrI;
			a.width = width;
			a.height = height;
			a.data = [];
			a.length = width * height | 0;
			var _g = 0;
			var _g1 = a.length;
			while(_g < _g1) {
				var i = _g++;
				a.data[i] = 0;
			}
			tmp = a;
			break;
		case 2:
			var u32a = new iterMagic_U32ArrImg();
			var b = u32a;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			var this2 = new Uint32Array(b.length);
			b.data = this2;
			var _g = 0;
			var _g1 = b.length;
			while(_g < _g1) {
				var i = _g++;
				b.data[i] = 0;
			}
			tmp = b;
			break;
		case 3:
			var vec = new iterMagic_VecIntImg();
			var v = vec;
			v.width = width;
			v.height = height;
			v.length = width * height | 0;
			var this2 = new Array(v.length);
			v.data = this2;
			var _g = 0;
			var _g1 = v.length;
			while(_g < _g1) {
				var i = _g++;
				v.data[i] = 0;
			}
			tmp = v;
			break;
		case 4:
			var sInt = new iterMagic_StackIntImg();
			var b = sInt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_ds_GenericStack();
			var len = b.length;
			var d = b.data;
			if(d.head == null) {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					d.head = new haxe_ds_GenericCell(0,d.head);
				}
			} else {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					var l = b.data.head;
					var prev = null;
					var _g2 = 0;
					var _g3 = i;
					while(_g2 < _g3) {
						var i1 = _g2++;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp = b;
			break;
		}
		this1.image = tmp;
		this1.width = width;
		this1.height = height;
		this1.imageType = imageType;
		var temp = this1;
		temp.transparent = false;
		switch(this.arcType) {
		case "chord":
			this.chord(temp);
			break;
		case "ellipse":
			this.ellipse(temp);
			break;
		case "pie":
			this.pie(temp);
			break;
		}
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
				var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
						var this11 = pixelImage.image.get(location);
						var this12 = this11;
						var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
					}
				}
			}
		}
		temp = null;
		return pixelImage;
	}
	,chord: function(temp) {
		this.ellipse(temp);
		var endAngle = this.startAngle + this.sweepAngle;
		var bx = this.rx * Math.cos(this.startAngle) + this.rx;
		var by = this.ry * Math.sin(this.startAngle) + this.ry;
		var cx = this.rx * Math.cos(endAngle) + this.rx;
		var cy = this.ry * Math.sin(endAngle) + this.ry;
		if(this.sweepAngle < Math.PI) {
			var bxS = (this.rx - this.strokeWidth) * Math.cos(this.startAngle) + this.rx;
			var byS = (this.ry - this.strokeWidth) * Math.sin(this.startAngle) + this.ry;
			var cxS = (this.rx - this.strokeWidth) * Math.cos(endAngle + 0.01) + this.rx;
			var cyS = (this.ry - this.strokeWidth) * Math.sin(endAngle + 0.01) + this.ry;
			var this1 = temp;
			var d = this.strokeWidth;
			var r_x = this.rx - d / 2 | 0;
			var r_y = this.ry - d / 2 | 0;
			var r_w = d | 0;
			var r_h = d | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this2 = 0;
				var c = this2;
				if((c >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
					var this3 = this1.image.get(location);
					var this4 = this3;
					var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
					var this6 = this5 >> 24 & 255;
					var a1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this5 >> 16 & 255;
					var r1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this5 >> 8 & 255;
					var g1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this5 & 255;
					var b1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var a2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var r2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var g2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var b2 = this13 == 0 ? 0. : this13 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var ax = this.rx;
			var ay = this.ry;
			var color = this.strokeColor;
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit = false;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit1 = hasHit;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var this1 = temp;
			var ax = this.rx;
			var ay = this.ry;
			var bx1 = bxS;
			var by1 = byS;
			var cx1 = cxS;
			var cy1 = cyS;
			var hasHit = false;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit1 = hasHit;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = 0;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = 0;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = 0;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = 0;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = 0;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
		} else {
			var this1 = temp;
			var ax = this.rx;
			var ay = this.ry;
			var rx = this.rx;
			var ry = this.ry;
			var color = this.strokeColor;
			var currAngle = endAngle;
			var bx1 = rx * Math.cos(currAngle) + ax;
			var by1 = ry * Math.sin(currAngle) + ay;
			currAngle = endAngle + (2 * Math.PI - this.sweepAngle + 0.01);
			var cx1 = rx * Math.cos(currAngle) + ax;
			var cy1 = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx2 = bx1;
			var by2 = by1;
			var cx2 = cx1;
			var cy2 = cy1;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by2 - bx2 * ay + (bx2 * cy2 - cx2 * by2) + (cx2 * ay - ax * cy2) > 0;
			if(!adjustWinding) {
				var bx_ = bx2;
				var by_ = by2;
				bx2 = cx2;
				by2 = cy2;
				cx2 = bx_;
				cy2 = by_;
			}
			var hasHit = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var s0 = ay * cx2 - ax * cy2;
			var sx = cy2 - ay;
			var sy = ax - cx2;
			var t0 = ax * by2 - ay * bx2;
			var tx = ay - by2;
			var ty = bx2 - ax;
			var A = -by2 * cx2 + ay * (-bx2 + cx2) + ax * (by2 - cy2) + bx2 * cy2;
			var xIter3;
			if(ax > bx2) {
				if(ax > cx2) {
					var ii_min = bx2 > cx2 ? Math.floor(cx2) : Math.floor(bx2);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx2);
					var ii_max = Math.ceil(cx2);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx2 > cx2) {
				var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
				var ii_max = Math.ceil(bx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by2) {
				if(ay > cy2) {
					var ii_min = by2 > cy2 ? Math.floor(cy2) : Math.floor(by2);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by2);
					var ii_max = Math.ceil(cy2);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by2 > cy2) {
				var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
				var ii_max = Math.ceil(by2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx2,by2,cx2,cy2,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var this1 = temp;
			var ax = this.rx;
			var ay = this.ry;
			var rx = this.rx - this.strokeWidth;
			var ry = this.ry - this.strokeWidth;
			var color = this.fill;
			var currAngle = endAngle;
			var bx1 = rx * Math.cos(currAngle) + ax;
			var by1 = ry * Math.sin(currAngle) + ay;
			currAngle = endAngle + (2 * Math.PI - this.sweepAngle + 0.01);
			var cx1 = rx * Math.cos(currAngle) + ax;
			var cy1 = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx2 = bx1;
			var by2 = by1;
			var cx2 = cx1;
			var cy2 = cy1;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by2 - bx2 * ay + (bx2 * cy2 - cx2 * by2) + (cx2 * ay - ax * cy2) > 0;
			if(!adjustWinding) {
				var bx_ = bx2;
				var by_ = by2;
				bx2 = cx2;
				by2 = cy2;
				cx2 = bx_;
				cy2 = by_;
			}
			var hasHit = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var s0 = ay * cx2 - ax * cy2;
			var sx = cy2 - ay;
			var sy = ax - cx2;
			var t0 = ax * by2 - ay * bx2;
			var tx = ay - by2;
			var ty = bx2 - ax;
			var A = -by2 * cx2 + ay * (-bx2 + cx2) + ax * (by2 - cy2) + bx2 * cy2;
			var xIter3;
			if(ax > bx2) {
				if(ax > cx2) {
					var ii_min = bx2 > cx2 ? Math.floor(cx2) : Math.floor(bx2);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx2);
					var ii_max = Math.ceil(cx2);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx2 > cx2) {
				var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
				var ii_max = Math.ceil(bx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by2) {
				if(ay > cy2) {
					var ii_min = by2 > cy2 ? Math.floor(cy2) : Math.floor(by2);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by2);
					var ii_max = Math.ceil(cy2);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by2 > cy2) {
				var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
				var ii_max = Math.ceil(by2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx2,by2,cx2,cy2,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var this1 = temp;
			var color = this.strokeColor;
			var o = by - cy;
			var a = bx - cx;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx1 = h;
			var cy1 = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = cx + (ax * cos - ay * sin);
			ay = cy + (ay * cos + ax * sin);
			ax = temp;
			temp = cx + (bx * cos - by * sin);
			by = cy + (by * cos + bx * sin);
			bx = temp;
			temp = cx + (cx1 * cos - cy1 * sin);
			cy1 = cy + (cy1 * cos + cx1 * sin);
			cx1 = temp;
			temp = cx + (dx * cos - dy * sin);
			dy = cy + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var this2 = this1;
				var r_x = ax - 6. | 0;
				var r_y = ay - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -65536;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = bx - 6. | 0;
				var r_y = by - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16711936;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = cx1 - 6. | 0;
				var r_y = cy1 - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16776961;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = dx - 6. | 0;
				var r_y = dy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -1048336;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 240;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx = dx;
			var cy = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy - cx * by1) + (cx * ay - ax * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx;
				by1 = cy;
				cx = bx_;
				cy = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx - ax * cy;
			var sx = cy - ay;
			var sy = ax - cx;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx + ay * (-bx1 + cx) + ax * (by1 - cy) + bx1 * cy;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx) {
					var ii_min = bx1 > cx ? Math.floor(cx) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy) {
					var ii_min = by1 > cy ? Math.floor(cy) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx,cy,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx1;
			var by1 = cy1;
			var cx = dx;
			var cy = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx;
				by1 = cy;
				cx = bx_;
				cy = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx - bx * cy;
			var sx = cy - by;
			var sy = bx - cx;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx) {
					var ii_min = bx1 > cx ? Math.floor(cx) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy) {
					var ii_min = by1 > cy ? Math.floor(cy) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx,cy,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx1,cy1,dx,dy,true);
			}
		}
	}
	,ellipse: function(temp) {
		var this1 = temp;
		var ax = this.rx;
		var ay = this.ry;
		var rx = this.rx;
		var ry = this.ry;
		var startRadian = this.startAngle;
		var sweepRadian = this.sweepAngle;
		var color = this.strokeColor;
		var rSmall = rx > ry ? ry : rx;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var theta = 1.41213 * Math.PI / noSides;
		var currAngle = startRadian;
		var tot = Math.floor(sweepRadian / theta);
		theta += (sweepRadian / theta - tot) / noSides;
		tot = Math.floor(sweepRadian / theta);
		var bx = rx * Math.cos(currAngle) + ax;
		var by = ry * Math.sin(currAngle) + ay;
		var cx = 0.;
		var cy = 0.;
		var arrTri = [];
		var _g = 1;
		var _g1 = tot + 1;
		while(_g < _g1) {
			var i = _g++;
			currAngle = startRadian + i * theta;
			cx = rx * Math.cos(currAngle) + ax;
			cy = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min1 = Math.floor(bx1);
					var ii_max1 = Math.ceil(cx1);
					var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
					xIter3 = this3;
				}
			} else if(bx1 > cx1) {
				var ii_min2 = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max2 = Math.ceil(bx1);
				var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
				xIter3 = this4;
			} else {
				var ii_min3 = Math.floor(ax);
				var ii_max3 = Math.ceil(cx1);
				var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
				xIter3 = this5;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min4 = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max4 = Math.ceil(ay);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
					yIter3 = this6;
				} else {
					var ii_min5 = Math.floor(by1);
					var ii_max5 = Math.ceil(cy1);
					var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
					yIter3 = this7;
				}
			} else if(by1 > cy1) {
				var ii_min6 = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max6 = Math.ceil(by1);
				var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
				yIter3 = this8;
			} else {
				var ii_min7 = Math.floor(ay);
				var ii_max7 = Math.ceil(cy1);
				var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
				yIter3 = this9;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this10 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g2 = 0;
					var _g3 = b.height;
					while(_g2 < _g3) {
						var y = _g2++;
						var _g4 = 0;
						var _g5 = b.width;
						while(_g4 < _g5) {
							var x = _g4++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g6 = 0;
					var _g7 = a.length;
					while(_g6 < _g7) {
						var i1 = _g6++;
						a.data[i1] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b1 = u32a;
					b1.width = width;
					b1.height = height;
					b1.length = width * height | 0;
					var this11 = new Uint32Array(b1.length);
					b1.data = this11;
					var _g8 = 0;
					var _g9 = b1.length;
					while(_g8 < _g9) {
						var i2 = _g8++;
						b1.data[i2] = 0;
					}
					undoImage1 = b1;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this12 = new Array(v.length);
					v.data = this12;
					var _g10 = 0;
					var _g11 = v.length;
					while(_g10 < _g11) {
						var i3 = _g10++;
						v.data[i3] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b2 = sInt;
					b2.width = width;
					b2.height = height;
					b2.length = width * height | 0;
					b2.data = new haxe_ds_GenericStack();
					var len1 = b2.length;
					var d = b2.data;
					if(d.head == null) {
						var _g12 = 0;
						var _g13 = len1;
						while(_g12 < _g13) {
							var i4 = _g12++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g14 = 0;
						var _g15 = len1;
						while(_g14 < _g15) {
							var i5 = _g14++;
							var l = b2.data.head;
							var prev = null;
							var _g16 = 0;
							var _g17 = i5;
							while(_g16 < _g17) {
								var i6 = _g16++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b2.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b2;
					break;
				}
				this10.image = undoImage1;
				this10.width = width;
				this10.height = height;
				this10.imageType = imageType;
				undoImage = this10;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g18 = rectTop;
				var _g19 = yIter3.max;
				while(_g18 < _g19) {
					var dy = _g18++;
					var _g20 = rectLeft;
					var _g21 = rectRight;
					while(_g20 < _g21) {
						var dx = _g20++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this13 = this1.mask;
							var c1 = this13.image.get(this13.useVirtualPos ? (dy - this13.virtualY) * this13.width + dx - this13.virtualX | 0 : dy * this13.width + dx | 0);
							var this14 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this14;
							var this15 = col;
							var this16 = this15;
							if(maskPixel == 0) {
								var this17 = this16;
								col = this17;
							} else {
								var this18 = maskPixel >> 24 & 255;
								var m0 = this18 == 0 ? 0. : this18 / 255;
								var this19 = maskPixel >> 16 & 255;
								var m1 = this19 == 0 ? 0. : this19 / 255;
								var this20 = maskPixel >> 8 & 255;
								var m2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = maskPixel & 255;
								var m3 = this21 == 0 ? 0. : this21 / 255;
								var ch0 = (1. - m0) * (this16 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this16 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this16 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this16 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x1 = dx - rectLeft;
							var y1 = dy - rectTop;
							var this22 = col;
							var c2 = this22;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
								var this23 = undoImage.image.get(location);
								var this24 = this23;
								var this25 = pi_$xy_Endian_isLittleEndian ? (this24 >> 24 & 255) << 24 | (this24 & 255) << 16 | (this24 >> 8 & 255) << 8 | this24 >> 16 & 255 : this24;
								var this26 = this25 >> 24 & 255;
								var a1 = this26 == 0 ? 0. : this26 / 255;
								var this27 = this25 >> 16 & 255;
								var r1 = this27 == 0 ? 0. : this27 / 255;
								var this28 = this25 >> 8 & 255;
								var g1 = this28 == 0 ? 0. : this28 / 255;
								var this29 = this25 & 255;
								var b11 = this29 == 0 ? 0. : this29 / 255;
								var this30 = col >> 24 & 255;
								var a2 = this30 == 0 ? 0. : this30 / 255;
								var this31 = col >> 16 & 255;
								var r2 = this31 == 0 ? 0. : this31 / 255;
								var this32 = col >> 8 & 255;
								var g2 = this32 == 0 ? 0. : this32 / 255;
								var this33 = col & 255;
								var b21 = this33 == 0 ? 0. : this33 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r << 16 | g << 8 | b3;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x2 = _g_min++;
				sxx = sx * x2;
				txx = tx * x2;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y2 = _g_min1++;
					s = s0 + sxx + sy * y2;
					t = t0 + txx + ty * y2;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this34 = color;
						var c3 = this34;
						if((c3 >> 24 & 255) < 254 && this1.transparent) {
							var location1 = this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0;
							var this35 = this1.image.get(location1);
							var this36 = this35;
							var this37 = pi_$xy_Endian_isLittleEndian ? (this36 >> 24 & 255) << 24 | (this36 & 255) << 16 | (this36 >> 8 & 255) << 8 | this36 >> 16 & 255 : this36;
							var this38 = this37 >> 24 & 255;
							var a11 = this38 == 0 ? 0. : this38 / 255;
							var this39 = this37 >> 16 & 255;
							var r11 = this39 == 0 ? 0. : this39 / 255;
							var this40 = this37 >> 8 & 255;
							var g11 = this40 == 0 ? 0. : this40 / 255;
							var this41 = this37 & 255;
							var b12 = this41 == 0 ? 0. : this41 / 255;
							var this42 = color >> 24 & 255;
							var a21 = this42 == 0 ? 0. : this42 / 255;
							var this43 = color >> 16 & 255;
							var r21 = this43 == 0 ? 0. : this43 / 255;
							var this44 = color >> 8 & 255;
							var g21 = this44 == 0 ? 0. : this44 / 255;
							var this45 = color & 255;
							var b22 = this45 == 0 ? 0. : this45 / 255;
							var a31 = a11 * (1 - a21);
							var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
							var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
							var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
							var a5 = 255 * (a31 + a21) | 0;
							var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
							this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
						} else {
							this1.image.set(this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			var triHit;
			if(hasHit2 == true) {
				var v1 = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v1.undoImage = undoImage;
					v1.undoX = xIter3.start;
					v1.undoY = yIter3.start;
				}
				triHit = v1;
			} else {
				triHit = null;
			}
			bx = cx;
			by = cy;
		}
		currAngle = startRadian + sweepRadian;
		cx = rx * Math.cos(currAngle) + ax;
		cy = ry * Math.sin(currAngle) + ay;
		var hasHit = false;
		if(hasHit == null) {
			hasHit = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit = hasHit1;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo1) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var triHit;
		if(hasHit == true) {
			var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo1) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			triHit = v;
		} else {
			triHit = null;
		}
		arrTri = null;
		var this1 = temp;
		var ax = this.rx;
		var ay = this.ry;
		var rx = this.rx - this.strokeWidth;
		var ry = this.ry - this.strokeWidth;
		var startRadian = this.startAngle;
		var sweepRadian = this.sweepAngle;
		var color = this.fill;
		var rSmall = rx > ry ? ry : rx;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var theta = 1.41213 * Math.PI / noSides;
		var currAngle = startRadian;
		var tot = Math.floor(sweepRadian / theta);
		theta += (sweepRadian / theta - tot) / noSides;
		tot = Math.floor(sweepRadian / theta);
		var bx = rx * Math.cos(currAngle) + ax;
		var by = ry * Math.sin(currAngle) + ay;
		var cx = 0.;
		var cy = 0.;
		var arrTri = [];
		var _g = 1;
		var _g1 = tot + 1;
		while(_g < _g1) {
			var i = _g++;
			currAngle = startRadian + i * theta;
			cx = rx * Math.cos(currAngle) + ax;
			cy = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min1 = Math.floor(bx1);
					var ii_max1 = Math.ceil(cx1);
					var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
					xIter3 = this3;
				}
			} else if(bx1 > cx1) {
				var ii_min2 = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max2 = Math.ceil(bx1);
				var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
				xIter3 = this4;
			} else {
				var ii_min3 = Math.floor(ax);
				var ii_max3 = Math.ceil(cx1);
				var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
				xIter3 = this5;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min4 = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max4 = Math.ceil(ay);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
					yIter3 = this6;
				} else {
					var ii_min5 = Math.floor(by1);
					var ii_max5 = Math.ceil(cy1);
					var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
					yIter3 = this7;
				}
			} else if(by1 > cy1) {
				var ii_min6 = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max6 = Math.ceil(by1);
				var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
				yIter3 = this8;
			} else {
				var ii_min7 = Math.floor(ay);
				var ii_max7 = Math.ceil(cy1);
				var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
				yIter3 = this9;
			}
			var undoImage = null;
			if(hasUndo1) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this10 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g2 = 0;
					var _g3 = b.height;
					while(_g2 < _g3) {
						var y = _g2++;
						var _g4 = 0;
						var _g5 = b.width;
						while(_g4 < _g5) {
							var x = _g4++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g6 = 0;
					var _g7 = a.length;
					while(_g6 < _g7) {
						var i1 = _g6++;
						a.data[i1] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b1 = u32a;
					b1.width = width;
					b1.height = height;
					b1.length = width * height | 0;
					var this11 = new Uint32Array(b1.length);
					b1.data = this11;
					var _g8 = 0;
					var _g9 = b1.length;
					while(_g8 < _g9) {
						var i2 = _g8++;
						b1.data[i2] = 0;
					}
					undoImage1 = b1;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this12 = new Array(v.length);
					v.data = this12;
					var _g10 = 0;
					var _g11 = v.length;
					while(_g10 < _g11) {
						var i3 = _g10++;
						v.data[i3] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b2 = sInt;
					b2.width = width;
					b2.height = height;
					b2.length = width * height | 0;
					b2.data = new haxe_ds_GenericStack();
					var len1 = b2.length;
					var d = b2.data;
					if(d.head == null) {
						var _g12 = 0;
						var _g13 = len1;
						while(_g12 < _g13) {
							var i4 = _g12++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g14 = 0;
						var _g15 = len1;
						while(_g14 < _g15) {
							var i5 = _g14++;
							var l = b2.data.head;
							var prev = null;
							var _g16 = 0;
							var _g17 = i5;
							while(_g16 < _g17) {
								var i6 = _g16++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b2.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b2;
					break;
				}
				this10.image = undoImage1;
				this10.width = width;
				this10.height = height;
				this10.imageType = imageType;
				undoImage = this10;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g18 = rectTop;
				var _g19 = yIter3.max;
				while(_g18 < _g19) {
					var dy = _g18++;
					var _g20 = rectLeft;
					var _g21 = rectRight;
					while(_g20 < _g21) {
						var dx = _g20++;
						var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this13 = this1.mask;
							var c1 = this13.image.get(this13.useVirtualPos ? (dy - this13.virtualY) * this13.width + dx - this13.virtualX | 0 : dy * this13.width + dx | 0);
							var this14 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this14;
							var this15 = col;
							var this16 = this15;
							if(maskPixel == 0) {
								var this17 = this16;
								col = this17;
							} else {
								var this18 = maskPixel >> 24 & 255;
								var m0 = this18 == 0 ? 0. : this18 / 255;
								var this19 = maskPixel >> 16 & 255;
								var m1 = this19 == 0 ? 0. : this19 / 255;
								var this20 = maskPixel >> 8 & 255;
								var m2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = maskPixel & 255;
								var m3 = this21 == 0 ? 0. : this21 / 255;
								var ch0 = (1. - m0) * (this16 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this16 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this16 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this16 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x1 = dx - rectLeft;
							var y1 = dy - rectTop;
							var this22 = col;
							var c2 = this22;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
								var this23 = undoImage.image.get(location);
								var this24 = this23;
								var this25 = pi_$xy_Endian_isLittleEndian ? (this24 >> 24 & 255) << 24 | (this24 & 255) << 16 | (this24 >> 8 & 255) << 8 | this24 >> 16 & 255 : this24;
								var this26 = this25 >> 24 & 255;
								var a1 = this26 == 0 ? 0. : this26 / 255;
								var this27 = this25 >> 16 & 255;
								var r1 = this27 == 0 ? 0. : this27 / 255;
								var this28 = this25 >> 8 & 255;
								var g1 = this28 == 0 ? 0. : this28 / 255;
								var this29 = this25 & 255;
								var b11 = this29 == 0 ? 0. : this29 / 255;
								var this30 = col >> 24 & 255;
								var a2 = this30 == 0 ? 0. : this30 / 255;
								var this31 = col >> 16 & 255;
								var r2 = this31 == 0 ? 0. : this31 / 255;
								var this32 = col >> 8 & 255;
								var g2 = this32 == 0 ? 0. : this32 / 255;
								var this33 = col & 255;
								var b21 = this33 == 0 ? 0. : this33 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r << 16 | g << 8 | b3;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x2 = _g_min++;
				sxx = sx * x2;
				txx = tx * x2;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y2 = _g_min1++;
					s = s0 + sxx + sy * y2;
					t = t0 + txx + ty * y2;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this34 = color;
						var c3 = this34;
						if((c3 >> 24 & 255) < 254 && this1.transparent) {
							var location1 = this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0;
							var this35 = this1.image.get(location1);
							var this36 = this35;
							var this37 = pi_$xy_Endian_isLittleEndian ? (this36 >> 24 & 255) << 24 | (this36 & 255) << 16 | (this36 >> 8 & 255) << 8 | this36 >> 16 & 255 : this36;
							var this38 = this37 >> 24 & 255;
							var a11 = this38 == 0 ? 0. : this38 / 255;
							var this39 = this37 >> 16 & 255;
							var r11 = this39 == 0 ? 0. : this39 / 255;
							var this40 = this37 >> 8 & 255;
							var g11 = this40 == 0 ? 0. : this40 / 255;
							var this41 = this37 & 255;
							var b12 = this41 == 0 ? 0. : this41 / 255;
							var this42 = color >> 24 & 255;
							var a21 = this42 == 0 ? 0. : this42 / 255;
							var this43 = color >> 16 & 255;
							var r21 = this43 == 0 ? 0. : this43 / 255;
							var this44 = color >> 8 & 255;
							var g21 = this44 == 0 ? 0. : this44 / 255;
							var this45 = color & 255;
							var b22 = this45 == 0 ? 0. : this45 / 255;
							var a31 = a11 * (1 - a21);
							var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
							var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
							var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
							var a5 = 255 * (a31 + a21) | 0;
							var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
							this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
						} else {
							this1.image.set(this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			var triHit;
			if(hasHit2 == true) {
				var v1 = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v1.undoImage = undoImage;
					v1.undoX = xIter3.start;
					v1.undoY = yIter3.start;
				}
				triHit = v1;
			} else {
				triHit = null;
			}
			bx = cx;
			by = cy;
		}
		currAngle = startRadian + sweepRadian;
		cx = rx * Math.cos(currAngle) + ax;
		cy = ry * Math.sin(currAngle) + ay;
		var hasHit = false;
		if(hasHit == null) {
			hasHit = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit = hasHit1;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo1) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var triHit;
		if(hasHit == true) {
			var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo1) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			triHit = v;
		} else {
			triHit = null;
		}
		arrTri = null;
	}
	,pie: function(temp) {
		this.ellipse(temp);
		var bx = this.rx * Math.cos(this.startAngle) + this.rx;
		var by = this.ry * Math.sin(this.startAngle) + this.ry;
		var currAngle = this.startAngle + this.sweepAngle / 2;
		var ax = this.strokeWidth * Math.cos(currAngle) + this.rx;
		var ay = this.strokeWidth * Math.sin(currAngle) + this.ry;
		currAngle = this.startAngle + this.sweepAngle;
		var cx = this.rx * Math.cos(currAngle) + this.rx;
		var cy = this.ry * Math.sin(currAngle) + this.ry;
		var this1 = temp;
		var px = this.rx;
		var py = this.ry;
		var color = this.strokeColor;
		var o = by - py;
		var a = bx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var hasHit = true;
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx1 = h;
		var cy1 = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp1 = 0.;
		temp1 = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp1;
		temp1 = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp1;
		temp1 = px + (cx1 * cos - cy1 * sin);
		cy1 = py + (cy1 * cos + cx1 * sin);
		cx1 = temp1;
		temp1 = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp1;
		if(debugCorners) {
			var this2 = this1;
			var r_x = ax - 6. | 0;
			var r_y = ay - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -65536;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 0;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = bx - 6. | 0;
			var r_y = by - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -16711936;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 255;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 0;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = cx1 - 6. | 0;
			var r_y = cy1 - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -16776961;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 255;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = dx - 6. | 0;
			var r_y = dy - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -1048336;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 240;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
		}
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx2 = dx;
		var cy2 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy2 - cx2 * by1) + (cx2 * ay - ax * cy2) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx2;
			by1 = cy2;
			cx2 = bx_;
			cy2 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = ay * cx2 - ax * cy2;
		var sx = cy2 - ay;
		var sy = ax - cx2;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx2 + ay * (-bx1 + cx2) + ax * (by1 - cy2) + bx1 * cy2;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx2) {
				var ii_min = bx1 > cx2 ? Math.floor(cx2) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx2) {
			var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx2);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy2) {
				var ii_min = by1 > cy2 ? Math.floor(cy2) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy2) {
			var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy2);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx2,cy2,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		var bx1 = cx1;
		var by1 = cy1;
		var cx2 = dx;
		var cy2 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy2 - cx2 * by1) + (cx2 * by - bx * cy2) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx2;
			by1 = cy2;
			cx2 = bx_;
			cy2 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = by * cx2 - bx * cy2;
		var sx = cy2 - by;
		var sy = bx - cx2;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx2 + by * (-bx1 + cx2) + bx * (by1 - cy2) + bx1 * cy2;
		var xIter3;
		if(bx > bx1) {
			if(bx > cx2) {
				var ii_min = bx1 > cx2 ? Math.floor(cx2) : Math.floor(bx1);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx2) {
			var ii_min = bx > cx2 ? Math.floor(cx2) : Math.ceil(bx);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(bx);
			var ii_max = Math.ceil(cx2);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(by > by1) {
			if(by > cy2) {
				var ii_min = by1 > cy2 ? Math.floor(cy2) : Math.floor(by1);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy2);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy2) {
			var ii_min = by > cy2 ? Math.floor(cy2) : Math.ceil(by);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(by);
			var ii_max = Math.ceil(cy2);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx2,cy2,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		if(hasHit1 == true) {
			var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx1,cy1,dx,dy,true);
		}
		var this1 = temp;
		var px = this.rx;
		var py = this.ry;
		var color = this.strokeColor;
		var o = cy - py;
		var a = cx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var hasHit = true;
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var this2 = this1;
			var r_x = ax - 6. | 0;
			var r_y = ay - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -65536;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 0;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = bx - 6. | 0;
			var r_y = by - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -16711936;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 255;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 0;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = cx - 6. | 0;
			var r_y = cy - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -16776961;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 255;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this2 = this1;
			var r_x = dx - 6. | 0;
			var r_y = dy - 6. | 0;
			var r_w = 12;
			var r_h = 12;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this3 = -1048336;
				var c = this3;
				if((c >> 24 & 255) < 254 && this2.transparent) {
					var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
					var this4 = this2.image.get(location);
					var this5 = this4;
					var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
					var this7 = this6 >> 24 & 255;
					var a1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this6 >> 16 & 255;
					var r1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this6 >> 8 & 255;
					var g1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = this6 & 255;
					var b1 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var a2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var r2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var g2 = this13 == 0 ? 0. : this13 / 255;
					var this14 = 240;
					var b2 = this14 == 0 ? 0. : this14 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
		}
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx1 = dx;
		var cy1 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = by * cx1 - bx * cy1;
		var sx = cy1 - by;
		var sy = bx - cx1;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(bx > bx1) {
			if(bx > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx1) {
			var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(bx);
			var ii_max = Math.ceil(cx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(by > by1) {
			if(by > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy1) {
			var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(by);
			var ii_max = Math.ceil(cy1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		if(hasHit1 == true) {
			var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
		}
	}
	,__class__: pi_$xy_triangleGML_ArcForm
});
var pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight) {
	if(arrowHeight == null) {
		arrowHeight = 0.;
	}
	if(arrowWidth == null) {
		arrowWidth = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(reverseFlare == null) {
		reverseFlare = false;
	}
	if(flare == null) {
		flare = false;
	}
	if(both == null) {
		both = false;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.both = both;
	this.flare = flare;
	this.reverseFlare = reverseFlare;
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.arrowHeight = arrowHeight;
	this.arrowWidth = arrowWidth;
};
pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$.__name__ = "pi_xy.triangleGML.triGML.shape.contour.ArrowShape_";
pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$.__super__ = pi_$xy_triangleGML_triGML_BasicShape;
pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$.prototype = $extend(pi_$xy_triangleGML_triGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "arrowHeight":
			this.arrowHeight = parseFloat(value);
			break;
		case "arrowWidth":
			this.arrowWidth = parseFloat(value);
			break;
		case "both":
			this.both = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "flare":
			this.flare = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "reverseFlare":
			this.reverseFlare = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$
});
var pi_$xy_triangleGML_ArrowShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight) {
	pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight);
};
pi_$xy_triangleGML_ArrowShape.__name__ = "pi_xy.triangleGML.ArrowShape";
pi_$xy_triangleGML_ArrowShape.__super__ = pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$;
pi_$xy_triangleGML_ArrowShape.prototype = $extend(pi_$xy_triangleGML_triGML_shape_contour_ArrowShape_$.prototype,{
	render: function(pixelImage) {
		var px = this.x1 + this.offX;
		var qx = this.x2 + this.offX;
		var py = this.y1 + this.offY;
		var qy = this.y2 + this.offY;
		var arrowFixed = this.arrowHeight > 0. || this.arrowWidth > 0.;
		var hasSoftEdge = this.edgeSoft != 0;
		var doubleSided = this.both;
		haxe_Log.trace("render arrow",{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 18, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrowHeight",{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 19, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrowWidth",{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 20, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("fixed arrow " + (arrowFixed == null ? "null" : "" + arrowFixed),{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 22, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrow soft edge " + (hasSoftEdge == null ? "null" : "" + hasSoftEdge),{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 23, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrow double sided " + Std.string(this.both),{ fileName : "src/pi_xy/triangleGML/ArrowShape.hx", lineNumber : 24, className : "pi_xy.triangleGML.ArrowShape", methodName : "render"});
		var this1 = pixelImage;
		var qx = this.arrowWidth;
		var qy = this.arrowHeight;
		var thick = this.strokeWidth;
		var color = this.strokeColor;
		var flare = false;
		var reverseFlare = false;
		var hasHit = true;
		if(hasHit == null) {
			hasHit = false;
		}
		if(reverseFlare == null) {
			reverseFlare = false;
		}
		if(flare == null) {
			flare = false;
		}
		var goldenRatio = 1.61803398875;
		var o = qy - py;
		var a = qx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var thicker = 2 * thick * goldenRatio;
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = thick / 2;
		var radius2 = thicker / 2;
		var h2 = h / goldenRatio;
		var hitQuad;
		if(flare) {
			if(reverseFlare) {
				var hasHit1 = true;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var sin1 = Math.sin(theta);
				var cos1 = Math.cos(theta);
				var radius1 = thick / 2;
				var radius21 = (thicker - (thicker - thick) / goldenRatio) / 2;
				var dx = 0.1;
				var dy = radius1;
				var cx = h2;
				var cy = radius21;
				var bx = h2;
				var by = -radius21;
				var ax = 0.1;
				var ay = -radius1;
				var temp = 0.;
				temp = px + (ax * cos1 - ay * sin1);
				ay = py + (ay * cos1 + ax * sin1);
				ax = temp;
				temp = px + (bx * cos1 - by * sin1);
				by = py + (by * cos1 + bx * sin1);
				bx = temp;
				temp = px + (cx * cos1 - cy * sin1);
				cy = py + (cy * cos1 + cx * sin1);
				cx = temp;
				temp = px + (dx * cos1 - dy * sin1);
				dy = py + (dy * cos1 + dx * sin1);
				dx = temp;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var bx1 = bx;
				var by1 = by;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = ay * cx1 - ax * cy1;
				var sx = cy1 - ay;
				var sy = ax - cx1;
				var t0 = ax * by1 - ay * bx1;
				var tx = ay - by1;
				var ty = bx1 - ax;
				var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(ax > bx1) {
					if(ax > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(ax);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > cx1) {
					var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(ax);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(ay > by1) {
					if(ay > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(ay);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > cy1) {
					var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(ay);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				if(hasUndo) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this2 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g = 0;
						var _g1 = b.height;
						while(_g < _g1) {
							var y = _g++;
							var _g2 = 0;
							var _g3 = b.width;
							while(_g2 < _g3) {
								var x = _g2++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g = 0;
						var _g1 = a.length;
						while(_g < _g1) {
							var i = _g++;
							a.data[i] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b = u32a;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						var this3 = new Uint32Array(b.length);
						b.data = this3;
						var _g = 0;
						var _g1 = b.length;
						while(_g < _g1) {
							var i = _g++;
							b.data[i] = 0;
						}
						undoImage1 = b;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this3 = new Array(v.length);
						v.data = this3;
						var _g = 0;
						var _g1 = v.length;
						while(_g < _g1) {
							var i = _g++;
							v.data[i] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b = sInt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_ds_GenericStack();
						var len = b.length;
						var d = b.data;
						if(d.head == null) {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								var l = b.data.head;
								var prev = null;
								var _g2 = 0;
								var _g3 = i;
								while(_g2 < _g3) {
									var i1 = _g2++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b;
						break;
					}
					this2.image = undoImage1;
					this2.width = width;
					this2.height = height;
					this2.imageType = imageType;
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this1.useMask && this1.mask != null) {
								var this2 = this1.mask;
								var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
								var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this3;
								var this4 = col;
								var this5 = this4;
								if(maskPixel == 0) {
									var this6 = this5;
									col = this6;
								} else {
									var this7 = maskPixel >> 24 & 255;
									var m0 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 16 & 255;
									var m1 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel >> 8 & 255;
									var m2 = this9 == 0 ? 0. : this9 / 255;
									var this10 = maskPixel & 255;
									var m3 = this10 == 0 ? 0. : this10 / 255;
									var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this5 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this11 = col;
								var c2 = this11;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this12 = undoImage.image.get(location);
									var this13 = this12;
									var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
									var this15 = this14 >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this14 >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this14 >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = this14 & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = col & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && this1.transparent) {
								var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
								var this3 = this1.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				var bx1 = cx;
				var by1 = cy;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = by * cx1 - bx * cy1;
				var sx = cy1 - by;
				var sy = bx - cx1;
				var t0 = bx * by1 - by * bx1;
				var tx = by - by1;
				var ty = bx1 - bx;
				var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(bx > bx1) {
					if(bx > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(bx);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > cx1) {
					var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(by > by1) {
					if(by > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(by);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > cy1) {
					var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				if(hasUndo) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this2 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g = 0;
						var _g1 = b.height;
						while(_g < _g1) {
							var y = _g++;
							var _g2 = 0;
							var _g3 = b.width;
							while(_g2 < _g3) {
								var x = _g2++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g = 0;
						var _g1 = a.length;
						while(_g < _g1) {
							var i = _g++;
							a.data[i] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b = u32a;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						var this3 = new Uint32Array(b.length);
						b.data = this3;
						var _g = 0;
						var _g1 = b.length;
						while(_g < _g1) {
							var i = _g++;
							b.data[i] = 0;
						}
						undoImage1 = b;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this3 = new Array(v.length);
						v.data = this3;
						var _g = 0;
						var _g1 = v.length;
						while(_g < _g1) {
							var i = _g++;
							v.data[i] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b = sInt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_ds_GenericStack();
						var len = b.length;
						var d = b.data;
						if(d.head == null) {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								var l = b.data.head;
								var prev = null;
								var _g2 = 0;
								var _g3 = i;
								while(_g2 < _g3) {
									var i1 = _g2++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b;
						break;
					}
					this2.image = undoImage1;
					this2.width = width;
					this2.height = height;
					this2.imageType = imageType;
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this1.useMask && this1.mask != null) {
								var this2 = this1.mask;
								var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
								var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this3;
								var this4 = col;
								var this5 = this4;
								if(maskPixel == 0) {
									var this6 = this5;
									col = this6;
								} else {
									var this7 = maskPixel >> 24 & 255;
									var m0 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 16 & 255;
									var m1 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel >> 8 & 255;
									var m2 = this9 == 0 ? 0. : this9 / 255;
									var this10 = maskPixel & 255;
									var m3 = this10 == 0 ? 0. : this10 / 255;
									var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this5 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this11 = col;
								var c2 = this11;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this12 = undoImage.image.get(location);
									var this13 = this12;
									var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
									var this15 = this14 >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this14 >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this14 >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = this14 & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = col & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && this1.transparent) {
								var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
								var this3 = this1.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				if(hasHit2 == true) {
					var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hitQuad = v;
				} else {
					hitQuad = null;
				}
			} else {
				var hasHit1 = true;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var sin1 = Math.sin(theta);
				var cos1 = Math.cos(theta);
				var radius1 = (thicker - (thicker - thick) / goldenRatio) / 2;
				var radius21 = thick / 2;
				var dx = 0.1;
				var dy = radius1;
				var cx = h2;
				var cy = radius21;
				var bx = h2;
				var by = -radius21;
				var ax = 0.1;
				var ay = -radius1;
				var temp = 0.;
				temp = px + (ax * cos1 - ay * sin1);
				ay = py + (ay * cos1 + ax * sin1);
				ax = temp;
				temp = px + (bx * cos1 - by * sin1);
				by = py + (by * cos1 + bx * sin1);
				bx = temp;
				temp = px + (cx * cos1 - cy * sin1);
				cy = py + (cy * cos1 + cx * sin1);
				cx = temp;
				temp = px + (dx * cos1 - dy * sin1);
				dy = py + (dy * cos1 + dx * sin1);
				dx = temp;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var bx1 = bx;
				var by1 = by;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = ay * cx1 - ax * cy1;
				var sx = cy1 - ay;
				var sy = ax - cx1;
				var t0 = ax * by1 - ay * bx1;
				var tx = ay - by1;
				var ty = bx1 - ax;
				var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(ax > bx1) {
					if(ax > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(ax);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > cx1) {
					var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(ax);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(ay > by1) {
					if(ay > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(ay);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > cy1) {
					var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(ay);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				if(hasUndo) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this2 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g = 0;
						var _g1 = b.height;
						while(_g < _g1) {
							var y = _g++;
							var _g2 = 0;
							var _g3 = b.width;
							while(_g2 < _g3) {
								var x = _g2++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g = 0;
						var _g1 = a.length;
						while(_g < _g1) {
							var i = _g++;
							a.data[i] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b = u32a;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						var this3 = new Uint32Array(b.length);
						b.data = this3;
						var _g = 0;
						var _g1 = b.length;
						while(_g < _g1) {
							var i = _g++;
							b.data[i] = 0;
						}
						undoImage1 = b;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this3 = new Array(v.length);
						v.data = this3;
						var _g = 0;
						var _g1 = v.length;
						while(_g < _g1) {
							var i = _g++;
							v.data[i] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b = sInt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_ds_GenericStack();
						var len = b.length;
						var d = b.data;
						if(d.head == null) {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								var l = b.data.head;
								var prev = null;
								var _g2 = 0;
								var _g3 = i;
								while(_g2 < _g3) {
									var i1 = _g2++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b;
						break;
					}
					this2.image = undoImage1;
					this2.width = width;
					this2.height = height;
					this2.imageType = imageType;
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this1.useMask && this1.mask != null) {
								var this2 = this1.mask;
								var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
								var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this3;
								var this4 = col;
								var this5 = this4;
								if(maskPixel == 0) {
									var this6 = this5;
									col = this6;
								} else {
									var this7 = maskPixel >> 24 & 255;
									var m0 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 16 & 255;
									var m1 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel >> 8 & 255;
									var m2 = this9 == 0 ? 0. : this9 / 255;
									var this10 = maskPixel & 255;
									var m3 = this10 == 0 ? 0. : this10 / 255;
									var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this5 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this11 = col;
								var c2 = this11;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this12 = undoImage.image.get(location);
									var this13 = this12;
									var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
									var this15 = this14 >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this14 >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this14 >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = this14 & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = col & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && this1.transparent) {
								var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
								var this3 = this1.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				var bx1 = cx;
				var by1 = cy;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = by * cx1 - bx * cy1;
				var sx = cy1 - by;
				var sy = bx - cx1;
				var t0 = bx * by1 - by * bx1;
				var tx = by - by1;
				var ty = bx1 - bx;
				var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(bx > bx1) {
					if(bx > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(bx);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > cx1) {
					var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(by > by1) {
					if(by > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(by);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > cy1) {
					var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				if(hasUndo) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this2 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g = 0;
						var _g1 = b.height;
						while(_g < _g1) {
							var y = _g++;
							var _g2 = 0;
							var _g3 = b.width;
							while(_g2 < _g3) {
								var x = _g2++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g = 0;
						var _g1 = a.length;
						while(_g < _g1) {
							var i = _g++;
							a.data[i] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b = u32a;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						var this3 = new Uint32Array(b.length);
						b.data = this3;
						var _g = 0;
						var _g1 = b.length;
						while(_g < _g1) {
							var i = _g++;
							b.data[i] = 0;
						}
						undoImage1 = b;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this3 = new Array(v.length);
						v.data = this3;
						var _g = 0;
						var _g1 = v.length;
						while(_g < _g1) {
							var i = _g++;
							v.data[i] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b = sInt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_ds_GenericStack();
						var len = b.length;
						var d = b.data;
						if(d.head == null) {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g = 0;
							var _g1 = len;
							while(_g < _g1) {
								var i = _g++;
								var l = b.data.head;
								var prev = null;
								var _g2 = 0;
								var _g3 = i;
								while(_g2 < _g3) {
									var i1 = _g2++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b;
						break;
					}
					this2.image = undoImage1;
					this2.width = width;
					this2.height = height;
					this2.imageType = imageType;
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this1.useMask && this1.mask != null) {
								var this2 = this1.mask;
								var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
								var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this3;
								var this4 = col;
								var this5 = this4;
								if(maskPixel == 0) {
									var this6 = this5;
									col = this6;
								} else {
									var this7 = maskPixel >> 24 & 255;
									var m0 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 16 & 255;
									var m1 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel >> 8 & 255;
									var m2 = this9 == 0 ? 0. : this9 / 255;
									var this10 = maskPixel & 255;
									var m3 = this10 == 0 ? 0. : this10 / 255;
									var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this5 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this11 = col;
								var c2 = this11;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this12 = undoImage.image.get(location);
									var this13 = this12;
									var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
									var this15 = this14 >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this14 >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this14 >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = this14 & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = col & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && this1.transparent) {
								var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
								var this3 = this1.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				if(hasHit2 == true) {
					var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hitQuad = v;
				} else {
					hitQuad = null;
				}
			}
		} else {
			var hasHit1 = true;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var sin1 = Math.sin(theta);
			var cos1 = Math.cos(theta);
			var radius = thick / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h2;
			var cy = radius;
			var bx = h2;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos1 - ay * sin1);
			ay = py + (ay * cos1 + ax * sin1);
			ax = temp;
			temp = px + (bx * cos1 - by * sin1);
			by = py + (by * cos1 + bx * sin1);
			bx = temp;
			temp = px + (cx * cos1 - cy * sin1);
			cy = py + (cy * cos1 + cx * sin1);
			cx = temp;
			temp = px + (dx * cos1 - dy * sin1);
			dy = py + (dy * cos1 + dx * sin1);
			dx = temp;
			var hasHit2 = hasHit1;
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit1 = hasHit2;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit3 = hasHit1;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit3 == null) {
				hasHit3 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit3 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit1 = hasHit2;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit3 = hasHit1;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit3 == null) {
				hasHit3 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit3 == true) {
				var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				hitQuad = v;
			} else {
				hitQuad = null;
			}
		}
		var cx = h2;
		var cy = radius2;
		var bx = h2;
		var by = -radius2;
		var temp = 0.;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = qx * by1 - bx1 * qy + (bx1 * cy1 - cx1 * by1) + (cx1 * qy - qx * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit1;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = qy * cx1 - qx * cy1;
		var sx = cy1 - qy;
		var sy = qx - cx1;
		var t0 = qx * by1 - qy * bx1;
		var tx = qy - by1;
		var ty = bx1 - qx;
		var A = -by1 * cx1 + qy * (-bx1 + cx1) + qx * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(qx > bx1) {
			if(qx > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(qx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
		} else if(bx1 > cx1) {
			var ii_min = qx > cx1 ? Math.floor(cx1) : Math.ceil(qx);
			var ii_max = Math.ceil(bx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(qx);
			var ii_max = Math.ceil(cx1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
		var yIter3;
		if(qy > by1) {
			if(qy > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(qy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
		} else if(by1 > cy1) {
			var ii_min = qy > cy1 ? Math.floor(cy1) : Math.ceil(qy);
			var ii_max = Math.ceil(by1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(qy);
			var ii_max = Math.ceil(cy1);
			var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
		var undoImage = null;
		if(hasUndo) {
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var hitTri;
		if(hasHit2 == true) {
			var v = new pi_$xy_algo_HitTri(qx,qy,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			hitTri = v;
		} else {
			hitTri = null;
		}
		if(hasHit) {
			var hitArr = new pi_$xy_algo_HitTriArray([hitTri]);
			if(hitQuad != null) {
				hitArr.triArr.push(hitQuad.triABD);
			}
			hitArr.triArr.push(hitQuad.triBCD);
		}
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_ArrowShape
});
var pi_$xy_triangleGML_triGML_shape_form_CircleForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	if(diameter == null) {
		diameter = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.diameter = diameter;
};
pi_$xy_triangleGML_triGML_shape_form_CircleForm_$.__name__ = "pi_xy.triangleGML.triGML.shape.form.CircleForm_";
pi_$xy_triangleGML_triGML_shape_form_CircleForm_$.__super__ = pi_$xy_triangleGML_triGML_FillForm;
pi_$xy_triangleGML_triGML_shape_form_CircleForm_$.prototype = $extend(pi_$xy_triangleGML_triGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "diameter":
			this.diameter = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_form_CircleForm_$
});
var pi_$xy_triangleGML_CircleForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	pi_$xy_triangleGML_triGML_shape_form_CircleForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter);
};
pi_$xy_triangleGML_CircleForm.__name__ = "pi_xy.triangleGML.CircleForm";
pi_$xy_triangleGML_CircleForm.__super__ = pi_$xy_triangleGML_triGML_shape_form_CircleForm_$;
pi_$xy_triangleGML_CircleForm.prototype = $extend(pi_$xy_triangleGML_triGML_shape_form_CircleForm_$.prototype,{
	render: function(pixelImage) {
		var width = Math.ceil(this.diameter);
		var height = Math.ceil(this.diameter);
		var imageType = null;
		var this1 = new pi_$xy_ImageStruct();
		if(imageType == null) {
			imageType = pi_$xy_ImageStruct.defaultType;
		}
		var imageType1 = imageType;
		if(imageType1 == null) {
			imageType1 = 2;
		}
		var tmp;
		switch(imageType1) {
		case 0:
			var byt = new iterMagic_BytesImg();
			var b = byt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
			var len = b.length;
			var w = 0;
			var _g = 0;
			var _g1 = b.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = b.width;
				while(_g2 < _g3) {
					var x = _g2++;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
				}
			}
			tmp = b;
			break;
		case 1:
			var arrI = new iterMagic_ArrIntImg();
			var a = arrI;
			a.width = width;
			a.height = height;
			a.data = [];
			a.length = width * height | 0;
			var _g = 0;
			var _g1 = a.length;
			while(_g < _g1) {
				var i = _g++;
				a.data[i] = 0;
			}
			tmp = a;
			break;
		case 2:
			var u32a = new iterMagic_U32ArrImg();
			var b = u32a;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			var this2 = new Uint32Array(b.length);
			b.data = this2;
			var _g = 0;
			var _g1 = b.length;
			while(_g < _g1) {
				var i = _g++;
				b.data[i] = 0;
			}
			tmp = b;
			break;
		case 3:
			var vec = new iterMagic_VecIntImg();
			var v = vec;
			v.width = width;
			v.height = height;
			v.length = width * height | 0;
			var this2 = new Array(v.length);
			v.data = this2;
			var _g = 0;
			var _g1 = v.length;
			while(_g < _g1) {
				var i = _g++;
				v.data[i] = 0;
			}
			tmp = v;
			break;
		case 4:
			var sInt = new iterMagic_StackIntImg();
			var b = sInt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_ds_GenericStack();
			var len = b.length;
			var d = b.data;
			if(d.head == null) {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					d.head = new haxe_ds_GenericCell(0,d.head);
				}
			} else {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					var l = b.data.head;
					var prev = null;
					var _g2 = 0;
					var _g3 = i;
					while(_g2 < _g3) {
						var i1 = _g2++;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp = b;
			break;
		}
		this1.image = tmp;
		this1.width = width;
		this1.height = height;
		this1.imageType = imageType;
		var temp = this1;
		temp.transparent = false;
		this.buildCircle(temp);
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
				var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
						var this11 = pixelImage.image.get(location);
						var this12 = this11;
						var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
					}
				}
			}
		}
		temp = null;
		return pixelImage;
	}
	,buildCircle: function(temp) {
		var w = Math.round(this.strokeWidth / 2);
		var r = this.diameter / 2;
		var innerR = this.diameter / 2 - 4 * w;
		var cx = this.diameter / 2;
		var cy = this.diameter / 2;
		var phi = 0.;
		var innerCx = cx - w / 4;
		var innerCy = cy - w / 4;
		var this1 = temp;
		var color = this.strokeColor;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = r > r ? r : r;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi2 = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi2 == null) {
			phi2 = 0.;
		}
		var phi1 = phi2;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = r * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - r * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
			lastY = r * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + r * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
		} else {
			lastX = cx + r * Math.cos(sides1 * theta + omega);
			lastY = cy + r * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega + 0.01);
				var ctheta = Math.cos(i * theta + omega + 0.01);
				var nextX = r * ctheta * cphi - r * stheta * sphi + cx;
				var nextY = r * ctheta * sphi + r * stheta * cphi + cy;
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + r * Math.cos(i * theta + omega + 0.01);
				var nextY = cy + r * Math.sin(i * theta + omega + 0.01);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
		var this1 = temp;
		var color = this.fill;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = innerR > innerR ? innerR : innerR;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi == null) {
			phi = 0.;
		}
		var phi1 = phi;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = innerR * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerR * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
			lastY = innerR * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerR * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
		} else {
			lastX = innerCx + innerR * Math.cos(sides1 * theta + omega);
			lastY = innerCy + innerR * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega + 0.01);
				var ctheta = Math.cos(i * theta + omega + 0.01);
				var nextX = innerR * ctheta * cphi - innerR * stheta * sphi + innerCx;
				var nextY = innerR * ctheta * sphi + innerR * stheta * cphi + innerCy;
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var xIter3;
				if(innerCx > bx) {
					if(innerCx > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(innerCx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(innerCx);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(innerCy > by) {
					if(innerCy > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(innerCy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(innerCy);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(innerCx,innerCy,bx,by,cx,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = innerCx + innerR * Math.cos(i * theta + omega + 0.01);
				var nextY = innerCy + innerR * Math.sin(i * theta + omega + 0.01);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var xIter3;
				if(innerCx > bx) {
					if(innerCx > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(innerCx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(innerCx);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(innerCy > by) {
					if(innerCy > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(innerCy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(innerCy);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(innerCx,innerCy,bx,by,cx,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
	}
	,__class__: pi_$xy_triangleGML_CircleForm
});
var pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height) {
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
};
pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$.__name__ = "pi_xy.triangleGML.triGML.shape.form.EllipseForm_";
pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$.__super__ = pi_$xy_triangleGML_triGML_FillForm;
pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$.prototype = $extend(pi_$xy_triangleGML_triGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$
});
var pi_$xy_triangleGML_EllipseForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height) {
	pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height);
};
pi_$xy_triangleGML_EllipseForm.__name__ = "pi_xy.triangleGML.EllipseForm";
pi_$xy_triangleGML_EllipseForm.__super__ = pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$;
pi_$xy_triangleGML_EllipseForm.prototype = $extend(pi_$xy_triangleGML_triGML_shape_form_EllipseForm_$.prototype,{
	render: function(pixelImage) {
		var width = Math.ceil(this.width);
		var height = Math.ceil(this.height);
		var imageType = null;
		var this1 = new pi_$xy_ImageStruct();
		if(imageType == null) {
			imageType = pi_$xy_ImageStruct.defaultType;
		}
		var imageType1 = imageType;
		if(imageType1 == null) {
			imageType1 = 2;
		}
		var tmp;
		switch(imageType1) {
		case 0:
			var byt = new iterMagic_BytesImg();
			var b = byt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
			var len = b.length;
			var w = 0;
			var _g = 0;
			var _g1 = b.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = b.width;
				while(_g2 < _g3) {
					var x = _g2++;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
				}
			}
			tmp = b;
			break;
		case 1:
			var arrI = new iterMagic_ArrIntImg();
			var a = arrI;
			a.width = width;
			a.height = height;
			a.data = [];
			a.length = width * height | 0;
			var _g = 0;
			var _g1 = a.length;
			while(_g < _g1) {
				var i = _g++;
				a.data[i] = 0;
			}
			tmp = a;
			break;
		case 2:
			var u32a = new iterMagic_U32ArrImg();
			var b = u32a;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			var this2 = new Uint32Array(b.length);
			b.data = this2;
			var _g = 0;
			var _g1 = b.length;
			while(_g < _g1) {
				var i = _g++;
				b.data[i] = 0;
			}
			tmp = b;
			break;
		case 3:
			var vec = new iterMagic_VecIntImg();
			var v = vec;
			v.width = width;
			v.height = height;
			v.length = width * height | 0;
			var this2 = new Array(v.length);
			v.data = this2;
			var _g = 0;
			var _g1 = v.length;
			while(_g < _g1) {
				var i = _g++;
				v.data[i] = 0;
			}
			tmp = v;
			break;
		case 4:
			var sInt = new iterMagic_StackIntImg();
			var b = sInt;
			b.width = width;
			b.height = height;
			b.length = width * height | 0;
			b.data = new haxe_ds_GenericStack();
			var len = b.length;
			var d = b.data;
			if(d.head == null) {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					d.head = new haxe_ds_GenericCell(0,d.head);
				}
			} else {
				var _g = 0;
				var _g1 = len;
				while(_g < _g1) {
					var i = _g++;
					var l = b.data.head;
					var prev = null;
					var _g2 = 0;
					var _g3 = i;
					while(_g2 < _g3) {
						var i1 = _g2++;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp = b;
			break;
		}
		this1.image = tmp;
		this1.width = width;
		this1.height = height;
		this1.imageType = imageType;
		var temp = this1;
		temp.transparent = false;
		var rW = this.width / 2;
		var rH = this.height / 2;
		var innerRw = rW - this.strokeWidth / 2;
		var innerRh = rH - this.strokeWidth / 2;
		var cx = rW;
		var cy = rH;
		var phi = 0;
		var innerCx = cx + this.strokeWidth;
		var innerCy = cy + this.strokeWidth;
		if(this.edgeSoft == 0.) {
			var this1 = temp;
			var color = this.strokeColor;
			var phi1 = phi;
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = rW > rH ? rH : rW;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = rW * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - rH * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
				lastY = rW * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + rH * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
			} else {
				lastX = cx + rW * Math.cos(sides1 * theta + omega);
				lastY = cy + rH * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = rW * ctheta * cphi - rH * stheta * sphi + cx;
					var nextY = rW * ctheta * sphi + rH * stheta * cphi + cy;
					var this2 = this1;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = cy * cx1 - cx * cy1;
					var sx = cy1 - cy;
					var sy = cx - cx1;
					var t0 = cx * by - cy * bx;
					var tx = cy - by;
					var ty = bx - cx;
					var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
					var xIter3;
					if(cx > bx) {
						if(cx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(cx);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this3;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this4;
						}
					} else if(bx > cx1) {
						var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
						var ii_max2 = Math.ceil(bx);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this5;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(cx1);
						var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this6;
					}
					var yIter3;
					if(cy > by) {
						if(cy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(cy);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this7;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this8;
						}
					} else if(by > cy1) {
						var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
						var ii_max6 = Math.ceil(by);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this9;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(cy1);
						var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this10;
					}
					var undoImage = null;
					if(hasUndo1) {
						var width = xIter3.max - xIter3.start + 1;
						var height = yIter3.max - yIter3.start + 1;
						var imageType = null;
						var this11 = new pi_$xy_ImageStruct();
						if(imageType == null) {
							imageType = pi_$xy_ImageStruct.defaultType;
						}
						var imageType1 = imageType;
						if(imageType1 == null) {
							imageType1 = 2;
						}
						var undoImage1;
						switch(imageType1) {
						case 0:
							var byt = new iterMagic_BytesImg();
							var b = byt;
							b.width = width;
							b.height = height;
							b.length = width * height | 0;
							b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
							var len = b.length;
							var w = 0;
							var _g2 = 0;
							var _g3 = b.height;
							while(_g2 < _g3) {
								var y = _g2++;
								var _g4 = 0;
								var _g5 = b.width;
								while(_g4 < _g5) {
									var x = _g4++;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
								}
							}
							undoImage1 = b;
							break;
						case 1:
							var arrI = new iterMagic_ArrIntImg();
							var a = arrI;
							a.width = width;
							a.height = height;
							a.data = [];
							a.length = width * height | 0;
							var _g6 = 0;
							var _g7 = a.length;
							while(_g6 < _g7) {
								var i1 = _g6++;
								a.data[i1] = 0;
							}
							undoImage1 = a;
							break;
						case 2:
							var u32a = new iterMagic_U32ArrImg();
							var b1 = u32a;
							b1.width = width;
							b1.height = height;
							b1.length = width * height | 0;
							var this12 = new Uint32Array(b1.length);
							b1.data = this12;
							var _g8 = 0;
							var _g9 = b1.length;
							while(_g8 < _g9) {
								var i2 = _g8++;
								b1.data[i2] = 0;
							}
							undoImage1 = b1;
							break;
						case 3:
							var vec = new iterMagic_VecIntImg();
							var v = vec;
							v.width = width;
							v.height = height;
							v.length = width * height | 0;
							var this13 = new Array(v.length);
							v.data = this13;
							var _g10 = 0;
							var _g11 = v.length;
							while(_g10 < _g11) {
								var i3 = _g10++;
								v.data[i3] = 0;
							}
							undoImage1 = v;
							break;
						case 4:
							var sInt = new iterMagic_StackIntImg();
							var b2 = sInt;
							b2.width = width;
							b2.height = height;
							b2.length = width * height | 0;
							b2.data = new haxe_ds_GenericStack();
							var len1 = b2.length;
							var d = b2.data;
							if(d.head == null) {
								var _g12 = 0;
								var _g13 = len1;
								while(_g12 < _g13) {
									var i4 = _g12++;
									d.head = new haxe_ds_GenericCell(0,d.head);
								}
							} else {
								var _g14 = 0;
								var _g15 = len1;
								while(_g14 < _g15) {
									var i5 = _g14++;
									var l = b2.data.head;
									var prev = null;
									var _g16 = 0;
									var _g17 = i5;
									while(_g16 < _g17) {
										var i6 = _g16++;
										prev = l;
										l = l.next;
									}
									if(prev == null) {
										b2.data.head = new haxe_ds_GenericCell(0,l.next);
										l = null;
									} else {
										prev.next = new haxe_ds_GenericCell(0,l.next);
										l = null;
									}
								}
							}
							undoImage1 = b2;
							break;
						}
						this11.image = undoImage1;
						this11.width = width;
						this11.height = height;
						this11.imageType = imageType;
						undoImage = this11;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g18 = rectTop;
						var _g19 = yIter3.max;
						while(_g18 < _g19) {
							var dy = _g18++;
							var _g20 = rectLeft;
							var _g21 = rectRight;
							while(_g20 < _g21) {
								var dx = _g20++;
								var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
								var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(this2.useMask && this2.mask != null) {
									var this14 = this2.mask;
									var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
									var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this15;
									var this16 = col;
									var this17 = this16;
									if(maskPixel == 0) {
										var this18 = this17;
										col = this18;
									} else {
										var this19 = maskPixel >> 24 & 255;
										var m0 = this19 == 0 ? 0. : this19 / 255;
										var this20 = maskPixel >> 16 & 255;
										var m1 = this20 == 0 ? 0. : this20 / 255;
										var this21 = maskPixel >> 8 & 255;
										var m2 = this21 == 0 ? 0. : this21 / 255;
										var this22 = maskPixel & 255;
										var m3 = this22 == 0 ? 0. : this22 / 255;
										var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this17 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x1 = dx - rectLeft;
									var y1 = dy - rectTop;
									var this23 = col;
									var c2 = this23;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
										var this24 = undoImage.image.get(location);
										var this25 = this24;
										var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
										var this27 = this26 >> 24 & 255;
										var a1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = this26 >> 16 & 255;
										var r1 = this28 == 0 ? 0. : this28 / 255;
										var this29 = this26 >> 8 & 255;
										var g1 = this29 == 0 ? 0. : this29 / 255;
										var this30 = this26 & 255;
										var b11 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col >> 24 & 255;
										var a2 = this31 == 0 ? 0. : this31 / 255;
										var this32 = col >> 16 & 255;
										var r2 = this32 == 0 ? 0. : this32 / 255;
										var this33 = col >> 8 & 255;
										var g2 = this33 == 0 ? 0. : this33 / 255;
										var this34 = col & 255;
										var b21 = this34 == 0 ? 0. : this34 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
										var a4 = 255 * (a3 + a2) | 0;
										var blended = a4 << 24 | r << 16 | g << 8 | b3;
										undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
									} else {
										undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x2 = _g_min++;
						sxx = sx * x2;
						txx = tx * x2;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y2 = _g_min1++;
							s = s0 + sxx + sy * y2;
							t = t0 + txx + ty * y2;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this35 = color;
								var c3 = this35;
								if((c3 >> 24 & 255) < 254 && this2.transparent) {
									var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
									var this36 = this2.image.get(location1);
									var this37 = this36;
									var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
									var this39 = this38 >> 24 & 255;
									var a11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = this38 >> 16 & 255;
									var r11 = this40 == 0 ? 0. : this40 / 255;
									var this41 = this38 >> 8 & 255;
									var g11 = this41 == 0 ? 0. : this41 / 255;
									var this42 = this38 & 255;
									var b12 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color >> 24 & 255;
									var a21 = this43 == 0 ? 0. : this43 / 255;
									var this44 = color >> 16 & 255;
									var r21 = this44 == 0 ? 0. : this44 / 255;
									var this45 = color >> 8 & 255;
									var g21 = this45 == 0 ? 0. : this45 / 255;
									var this46 = color & 255;
									var b22 = this46 == 0 ? 0. : this46 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
									this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v1.undoImage = undoImage;
							v1.undoX = xIter3.start;
							v1.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = cx + rW * Math.cos(i * theta + omega + 0.01);
					var nextY = cy + rH * Math.sin(i * theta + omega + 0.01);
					var this2 = this1;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = cy * cx1 - cx * cy1;
					var sx = cy1 - cy;
					var sy = cx - cx1;
					var t0 = cx * by - cy * bx;
					var tx = cy - by;
					var ty = bx - cx;
					var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
					var xIter3;
					if(cx > bx) {
						if(cx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(cx);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this3;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this4;
						}
					} else if(bx > cx1) {
						var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
						var ii_max2 = Math.ceil(bx);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this5;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(cx1);
						var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this6;
					}
					var yIter3;
					if(cy > by) {
						if(cy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(cy);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this7;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this8;
						}
					} else if(by > cy1) {
						var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
						var ii_max6 = Math.ceil(by);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this9;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(cy1);
						var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this10;
					}
					var undoImage = null;
					if(hasUndo1) {
						var width = xIter3.max - xIter3.start + 1;
						var height = yIter3.max - yIter3.start + 1;
						var imageType = null;
						var this11 = new pi_$xy_ImageStruct();
						if(imageType == null) {
							imageType = pi_$xy_ImageStruct.defaultType;
						}
						var imageType1 = imageType;
						if(imageType1 == null) {
							imageType1 = 2;
						}
						var undoImage1;
						switch(imageType1) {
						case 0:
							var byt = new iterMagic_BytesImg();
							var b = byt;
							b.width = width;
							b.height = height;
							b.length = width * height | 0;
							b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
							var len = b.length;
							var w = 0;
							var _g2 = 0;
							var _g3 = b.height;
							while(_g2 < _g3) {
								var y = _g2++;
								var _g4 = 0;
								var _g5 = b.width;
								while(_g4 < _g5) {
									var x = _g4++;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
								}
							}
							undoImage1 = b;
							break;
						case 1:
							var arrI = new iterMagic_ArrIntImg();
							var a = arrI;
							a.width = width;
							a.height = height;
							a.data = [];
							a.length = width * height | 0;
							var _g6 = 0;
							var _g7 = a.length;
							while(_g6 < _g7) {
								var i1 = _g6++;
								a.data[i1] = 0;
							}
							undoImage1 = a;
							break;
						case 2:
							var u32a = new iterMagic_U32ArrImg();
							var b1 = u32a;
							b1.width = width;
							b1.height = height;
							b1.length = width * height | 0;
							var this12 = new Uint32Array(b1.length);
							b1.data = this12;
							var _g8 = 0;
							var _g9 = b1.length;
							while(_g8 < _g9) {
								var i2 = _g8++;
								b1.data[i2] = 0;
							}
							undoImage1 = b1;
							break;
						case 3:
							var vec = new iterMagic_VecIntImg();
							var v = vec;
							v.width = width;
							v.height = height;
							v.length = width * height | 0;
							var this13 = new Array(v.length);
							v.data = this13;
							var _g10 = 0;
							var _g11 = v.length;
							while(_g10 < _g11) {
								var i3 = _g10++;
								v.data[i3] = 0;
							}
							undoImage1 = v;
							break;
						case 4:
							var sInt = new iterMagic_StackIntImg();
							var b2 = sInt;
							b2.width = width;
							b2.height = height;
							b2.length = width * height | 0;
							b2.data = new haxe_ds_GenericStack();
							var len1 = b2.length;
							var d = b2.data;
							if(d.head == null) {
								var _g12 = 0;
								var _g13 = len1;
								while(_g12 < _g13) {
									var i4 = _g12++;
									d.head = new haxe_ds_GenericCell(0,d.head);
								}
							} else {
								var _g14 = 0;
								var _g15 = len1;
								while(_g14 < _g15) {
									var i5 = _g14++;
									var l = b2.data.head;
									var prev = null;
									var _g16 = 0;
									var _g17 = i5;
									while(_g16 < _g17) {
										var i6 = _g16++;
										prev = l;
										l = l.next;
									}
									if(prev == null) {
										b2.data.head = new haxe_ds_GenericCell(0,l.next);
										l = null;
									} else {
										prev.next = new haxe_ds_GenericCell(0,l.next);
										l = null;
									}
								}
							}
							undoImage1 = b2;
							break;
						}
						this11.image = undoImage1;
						this11.width = width;
						this11.height = height;
						this11.imageType = imageType;
						undoImage = this11;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g18 = rectTop;
						var _g19 = yIter3.max;
						while(_g18 < _g19) {
							var dy = _g18++;
							var _g20 = rectLeft;
							var _g21 = rectRight;
							while(_g20 < _g21) {
								var dx = _g20++;
								var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
								var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(this2.useMask && this2.mask != null) {
									var this14 = this2.mask;
									var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
									var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this15;
									var this16 = col;
									var this17 = this16;
									if(maskPixel == 0) {
										var this18 = this17;
										col = this18;
									} else {
										var this19 = maskPixel >> 24 & 255;
										var m0 = this19 == 0 ? 0. : this19 / 255;
										var this20 = maskPixel >> 16 & 255;
										var m1 = this20 == 0 ? 0. : this20 / 255;
										var this21 = maskPixel >> 8 & 255;
										var m2 = this21 == 0 ? 0. : this21 / 255;
										var this22 = maskPixel & 255;
										var m3 = this22 == 0 ? 0. : this22 / 255;
										var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this17 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x1 = dx - rectLeft;
									var y1 = dy - rectTop;
									var this23 = col;
									var c2 = this23;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
										var this24 = undoImage.image.get(location);
										var this25 = this24;
										var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
										var this27 = this26 >> 24 & 255;
										var a1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = this26 >> 16 & 255;
										var r1 = this28 == 0 ? 0. : this28 / 255;
										var this29 = this26 >> 8 & 255;
										var g1 = this29 == 0 ? 0. : this29 / 255;
										var this30 = this26 & 255;
										var b11 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col >> 24 & 255;
										var a2 = this31 == 0 ? 0. : this31 / 255;
										var this32 = col >> 16 & 255;
										var r2 = this32 == 0 ? 0. : this32 / 255;
										var this33 = col >> 8 & 255;
										var g2 = this33 == 0 ? 0. : this33 / 255;
										var this34 = col & 255;
										var b21 = this34 == 0 ? 0. : this34 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
										var a4 = 255 * (a3 + a2) | 0;
										var blended = a4 << 24 | r << 16 | g << 8 | b3;
										undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
									} else {
										undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x2 = _g_min++;
						sxx = sx * x2;
						txx = tx * x2;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y2 = _g_min1++;
							s = s0 + sxx + sy * y2;
							t = t0 + txx + ty * y2;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this35 = color;
								var c3 = this35;
								if((c3 >> 24 & 255) < 254 && this2.transparent) {
									var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
									var this36 = this2.image.get(location1);
									var this37 = this36;
									var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
									var this39 = this38 >> 24 & 255;
									var a11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = this38 >> 16 & 255;
									var r11 = this40 == 0 ? 0. : this40 / 255;
									var this41 = this38 >> 8 & 255;
									var g11 = this41 == 0 ? 0. : this41 / 255;
									var this42 = this38 & 255;
									var b12 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color >> 24 & 255;
									var a21 = this43 == 0 ? 0. : this43 / 255;
									var this44 = color >> 16 & 255;
									var r21 = this44 == 0 ? 0. : this44 / 255;
									var this45 = color >> 8 & 255;
									var g21 = this45 == 0 ? 0. : this45 / 255;
									var this46 = color & 255;
									var b22 = this46 == 0 ? 0. : this46 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
									this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v1.undoImage = undoImage;
							v1.undoX = xIter3.start;
							v1.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
			var this1 = temp;
			var color = this.fill;
			var phi1 = phi;
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = innerRw > innerRh ? innerRh : innerRw;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = innerRw * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerRh * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
				lastY = innerRw * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerRh * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
			} else {
				lastX = innerCx + innerRw * Math.cos(sides1 * theta + omega);
				lastY = innerCy + innerRh * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = innerRw * ctheta * cphi - innerRh * stheta * sphi + innerCx;
					var nextY = innerRw * ctheta * sphi + innerRh * stheta * cphi + innerCy;
					var this2 = this1;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = innerCx * by - bx * innerCy + (bx * cy1 - cx1 * by) + (cx1 * innerCy - innerCx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = innerCy * cx1 - innerCx * cy1;
					var sx = cy1 - innerCy;
					var sy = innerCx - cx1;
					var t0 = innerCx * by - innerCy * bx;
					var tx = innerCy - by;
					var ty = bx - innerCx;
					var A = -by * cx1 + innerCy * (-bx + cx1) + innerCx * (by - cy1) + bx * cy1;
					var xIter3;
					if(innerCx > bx) {
						if(innerCx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(innerCx);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this3;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this4;
						}
					} else if(bx > cx1) {
						var ii_min2 = innerCx > cx1 ? Math.floor(cx1) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(bx);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this5;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(cx1);
						var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this6;
					}
					var yIter3;
					if(innerCy > by) {
						if(innerCy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(innerCy);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this7;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this8;
						}
					} else if(by > cy1) {
						var ii_min6 = innerCy > cy1 ? Math.floor(cy1) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(by);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this9;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(cy1);
						var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this10;
					}
					var undoImage = null;
					if(hasUndo1) {
						var width = xIter3.max - xIter3.start + 1;
						var height = yIter3.max - yIter3.start + 1;
						var imageType = null;
						var this11 = new pi_$xy_ImageStruct();
						if(imageType == null) {
							imageType = pi_$xy_ImageStruct.defaultType;
						}
						var imageType1 = imageType;
						if(imageType1 == null) {
							imageType1 = 2;
						}
						var undoImage1;
						switch(imageType1) {
						case 0:
							var byt = new iterMagic_BytesImg();
							var b = byt;
							b.width = width;
							b.height = height;
							b.length = width * height | 0;
							b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
							var len = b.length;
							var w = 0;
							var _g2 = 0;
							var _g3 = b.height;
							while(_g2 < _g3) {
								var y = _g2++;
								var _g4 = 0;
								var _g5 = b.width;
								while(_g4 < _g5) {
									var x = _g4++;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
								}
							}
							undoImage1 = b;
							break;
						case 1:
							var arrI = new iterMagic_ArrIntImg();
							var a = arrI;
							a.width = width;
							a.height = height;
							a.data = [];
							a.length = width * height | 0;
							var _g6 = 0;
							var _g7 = a.length;
							while(_g6 < _g7) {
								var i1 = _g6++;
								a.data[i1] = 0;
							}
							undoImage1 = a;
							break;
						case 2:
							var u32a = new iterMagic_U32ArrImg();
							var b1 = u32a;
							b1.width = width;
							b1.height = height;
							b1.length = width * height | 0;
							var this12 = new Uint32Array(b1.length);
							b1.data = this12;
							var _g8 = 0;
							var _g9 = b1.length;
							while(_g8 < _g9) {
								var i2 = _g8++;
								b1.data[i2] = 0;
							}
							undoImage1 = b1;
							break;
						case 3:
							var vec = new iterMagic_VecIntImg();
							var v = vec;
							v.width = width;
							v.height = height;
							v.length = width * height | 0;
							var this13 = new Array(v.length);
							v.data = this13;
							var _g10 = 0;
							var _g11 = v.length;
							while(_g10 < _g11) {
								var i3 = _g10++;
								v.data[i3] = 0;
							}
							undoImage1 = v;
							break;
						case 4:
							var sInt = new iterMagic_StackIntImg();
							var b2 = sInt;
							b2.width = width;
							b2.height = height;
							b2.length = width * height | 0;
							b2.data = new haxe_ds_GenericStack();
							var len1 = b2.length;
							var d = b2.data;
							if(d.head == null) {
								var _g12 = 0;
								var _g13 = len1;
								while(_g12 < _g13) {
									var i4 = _g12++;
									d.head = new haxe_ds_GenericCell(0,d.head);
								}
							} else {
								var _g14 = 0;
								var _g15 = len1;
								while(_g14 < _g15) {
									var i5 = _g14++;
									var l = b2.data.head;
									var prev = null;
									var _g16 = 0;
									var _g17 = i5;
									while(_g16 < _g17) {
										var i6 = _g16++;
										prev = l;
										l = l.next;
									}
									if(prev == null) {
										b2.data.head = new haxe_ds_GenericCell(0,l.next);
										l = null;
									} else {
										prev.next = new haxe_ds_GenericCell(0,l.next);
										l = null;
									}
								}
							}
							undoImage1 = b2;
							break;
						}
						this11.image = undoImage1;
						this11.width = width;
						this11.height = height;
						this11.imageType = imageType;
						undoImage = this11;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g18 = rectTop;
						var _g19 = yIter3.max;
						while(_g18 < _g19) {
							var dy = _g18++;
							var _g20 = rectLeft;
							var _g21 = rectRight;
							while(_g20 < _g21) {
								var dx = _g20++;
								var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
								var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(this2.useMask && this2.mask != null) {
									var this14 = this2.mask;
									var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
									var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this15;
									var this16 = col;
									var this17 = this16;
									if(maskPixel == 0) {
										var this18 = this17;
										col = this18;
									} else {
										var this19 = maskPixel >> 24 & 255;
										var m0 = this19 == 0 ? 0. : this19 / 255;
										var this20 = maskPixel >> 16 & 255;
										var m1 = this20 == 0 ? 0. : this20 / 255;
										var this21 = maskPixel >> 8 & 255;
										var m2 = this21 == 0 ? 0. : this21 / 255;
										var this22 = maskPixel & 255;
										var m3 = this22 == 0 ? 0. : this22 / 255;
										var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this17 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x1 = dx - rectLeft;
									var y1 = dy - rectTop;
									var this23 = col;
									var c2 = this23;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
										var this24 = undoImage.image.get(location);
										var this25 = this24;
										var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
										var this27 = this26 >> 24 & 255;
										var a1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = this26 >> 16 & 255;
										var r1 = this28 == 0 ? 0. : this28 / 255;
										var this29 = this26 >> 8 & 255;
										var g1 = this29 == 0 ? 0. : this29 / 255;
										var this30 = this26 & 255;
										var b11 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col >> 24 & 255;
										var a2 = this31 == 0 ? 0. : this31 / 255;
										var this32 = col >> 16 & 255;
										var r2 = this32 == 0 ? 0. : this32 / 255;
										var this33 = col >> 8 & 255;
										var g2 = this33 == 0 ? 0. : this33 / 255;
										var this34 = col & 255;
										var b21 = this34 == 0 ? 0. : this34 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
										var a4 = 255 * (a3 + a2) | 0;
										var blended = a4 << 24 | r << 16 | g << 8 | b3;
										undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
									} else {
										undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x2 = _g_min++;
						sxx = sx * x2;
						txx = tx * x2;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y2 = _g_min1++;
							s = s0 + sxx + sy * y2;
							t = t0 + txx + ty * y2;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this35 = color;
								var c3 = this35;
								if((c3 >> 24 & 255) < 254 && this2.transparent) {
									var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
									var this36 = this2.image.get(location1);
									var this37 = this36;
									var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
									var this39 = this38 >> 24 & 255;
									var a11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = this38 >> 16 & 255;
									var r11 = this40 == 0 ? 0. : this40 / 255;
									var this41 = this38 >> 8 & 255;
									var g11 = this41 == 0 ? 0. : this41 / 255;
									var this42 = this38 & 255;
									var b12 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color >> 24 & 255;
									var a21 = this43 == 0 ? 0. : this43 / 255;
									var this44 = color >> 16 & 255;
									var r21 = this44 == 0 ? 0. : this44 / 255;
									var this45 = color >> 8 & 255;
									var g21 = this45 == 0 ? 0. : this45 / 255;
									var this46 = color & 255;
									var b22 = this46 == 0 ? 0. : this46 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
									this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v1 = new pi_$xy_algo_HitTri(innerCx,innerCy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v1.undoImage = undoImage;
							v1.undoX = xIter3.start;
							v1.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = innerCx + innerRw * Math.cos(i * theta + omega + 0.01);
					var nextY = innerCy + innerRh * Math.sin(i * theta + omega + 0.01);
					var this2 = this1;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = innerCx * by - bx * innerCy + (bx * cy1 - cx1 * by) + (cx1 * innerCy - innerCx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = innerCy * cx1 - innerCx * cy1;
					var sx = cy1 - innerCy;
					var sy = innerCx - cx1;
					var t0 = innerCx * by - innerCy * bx;
					var tx = innerCy - by;
					var ty = bx - innerCx;
					var A = -by * cx1 + innerCy * (-bx + cx1) + innerCx * (by - cy1) + bx * cy1;
					var xIter3;
					if(innerCx > bx) {
						if(innerCx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(innerCx);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this3;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this4;
						}
					} else if(bx > cx1) {
						var ii_min2 = innerCx > cx1 ? Math.floor(cx1) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(bx);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this5;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(cx1);
						var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this6;
					}
					var yIter3;
					if(innerCy > by) {
						if(innerCy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(innerCy);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this7;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this8;
						}
					} else if(by > cy1) {
						var ii_min6 = innerCy > cy1 ? Math.floor(cy1) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(by);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this9;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(cy1);
						var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this10;
					}
					var undoImage = null;
					if(hasUndo1) {
						var width = xIter3.max - xIter3.start + 1;
						var height = yIter3.max - yIter3.start + 1;
						var imageType = null;
						var this11 = new pi_$xy_ImageStruct();
						if(imageType == null) {
							imageType = pi_$xy_ImageStruct.defaultType;
						}
						var imageType1 = imageType;
						if(imageType1 == null) {
							imageType1 = 2;
						}
						var undoImage1;
						switch(imageType1) {
						case 0:
							var byt = new iterMagic_BytesImg();
							var b = byt;
							b.width = width;
							b.height = height;
							b.length = width * height | 0;
							b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
							var len = b.length;
							var w = 0;
							var _g2 = 0;
							var _g3 = b.height;
							while(_g2 < _g3) {
								var y = _g2++;
								var _g4 = 0;
								var _g5 = b.width;
								while(_g4 < _g5) {
									var x = _g4++;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
									b.data.b[w++] = 0;
								}
							}
							undoImage1 = b;
							break;
						case 1:
							var arrI = new iterMagic_ArrIntImg();
							var a = arrI;
							a.width = width;
							a.height = height;
							a.data = [];
							a.length = width * height | 0;
							var _g6 = 0;
							var _g7 = a.length;
							while(_g6 < _g7) {
								var i1 = _g6++;
								a.data[i1] = 0;
							}
							undoImage1 = a;
							break;
						case 2:
							var u32a = new iterMagic_U32ArrImg();
							var b1 = u32a;
							b1.width = width;
							b1.height = height;
							b1.length = width * height | 0;
							var this12 = new Uint32Array(b1.length);
							b1.data = this12;
							var _g8 = 0;
							var _g9 = b1.length;
							while(_g8 < _g9) {
								var i2 = _g8++;
								b1.data[i2] = 0;
							}
							undoImage1 = b1;
							break;
						case 3:
							var vec = new iterMagic_VecIntImg();
							var v = vec;
							v.width = width;
							v.height = height;
							v.length = width * height | 0;
							var this13 = new Array(v.length);
							v.data = this13;
							var _g10 = 0;
							var _g11 = v.length;
							while(_g10 < _g11) {
								var i3 = _g10++;
								v.data[i3] = 0;
							}
							undoImage1 = v;
							break;
						case 4:
							var sInt = new iterMagic_StackIntImg();
							var b2 = sInt;
							b2.width = width;
							b2.height = height;
							b2.length = width * height | 0;
							b2.data = new haxe_ds_GenericStack();
							var len1 = b2.length;
							var d = b2.data;
							if(d.head == null) {
								var _g12 = 0;
								var _g13 = len1;
								while(_g12 < _g13) {
									var i4 = _g12++;
									d.head = new haxe_ds_GenericCell(0,d.head);
								}
							} else {
								var _g14 = 0;
								var _g15 = len1;
								while(_g14 < _g15) {
									var i5 = _g14++;
									var l = b2.data.head;
									var prev = null;
									var _g16 = 0;
									var _g17 = i5;
									while(_g16 < _g17) {
										var i6 = _g16++;
										prev = l;
										l = l.next;
									}
									if(prev == null) {
										b2.data.head = new haxe_ds_GenericCell(0,l.next);
										l = null;
									} else {
										prev.next = new haxe_ds_GenericCell(0,l.next);
										l = null;
									}
								}
							}
							undoImage1 = b2;
							break;
						}
						this11.image = undoImage1;
						this11.width = width;
						this11.height = height;
						this11.imageType = imageType;
						undoImage = this11;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g18 = rectTop;
						var _g19 = yIter3.max;
						while(_g18 < _g19) {
							var dy = _g18++;
							var _g20 = rectLeft;
							var _g21 = rectRight;
							while(_g20 < _g21) {
								var dx = _g20++;
								var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
								var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(this2.useMask && this2.mask != null) {
									var this14 = this2.mask;
									var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
									var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this15;
									var this16 = col;
									var this17 = this16;
									if(maskPixel == 0) {
										var this18 = this17;
										col = this18;
									} else {
										var this19 = maskPixel >> 24 & 255;
										var m0 = this19 == 0 ? 0. : this19 / 255;
										var this20 = maskPixel >> 16 & 255;
										var m1 = this20 == 0 ? 0. : this20 / 255;
										var this21 = maskPixel >> 8 & 255;
										var m2 = this21 == 0 ? 0. : this21 / 255;
										var this22 = maskPixel & 255;
										var m3 = this22 == 0 ? 0. : this22 / 255;
										var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this17 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x1 = dx - rectLeft;
									var y1 = dy - rectTop;
									var this23 = col;
									var c2 = this23;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
										var this24 = undoImage.image.get(location);
										var this25 = this24;
										var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
										var this27 = this26 >> 24 & 255;
										var a1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = this26 >> 16 & 255;
										var r1 = this28 == 0 ? 0. : this28 / 255;
										var this29 = this26 >> 8 & 255;
										var g1 = this29 == 0 ? 0. : this29 / 255;
										var this30 = this26 & 255;
										var b11 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col >> 24 & 255;
										var a2 = this31 == 0 ? 0. : this31 / 255;
										var this32 = col >> 16 & 255;
										var r2 = this32 == 0 ? 0. : this32 / 255;
										var this33 = col >> 8 & 255;
										var g2 = this33 == 0 ? 0. : this33 / 255;
										var this34 = col & 255;
										var b21 = this34 == 0 ? 0. : this34 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
										var a4 = 255 * (a3 + a2) | 0;
										var blended = a4 << 24 | r << 16 | g << 8 | b3;
										undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
									} else {
										undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x2 = _g_min++;
						sxx = sx * x2;
						txx = tx * x2;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y2 = _g_min1++;
							s = s0 + sxx + sy * y2;
							t = t0 + txx + ty * y2;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this35 = color;
								var c3 = this35;
								if((c3 >> 24 & 255) < 254 && this2.transparent) {
									var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
									var this36 = this2.image.get(location1);
									var this37 = this36;
									var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
									var this39 = this38 >> 24 & 255;
									var a11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = this38 >> 16 & 255;
									var r11 = this40 == 0 ? 0. : this40 / 255;
									var this41 = this38 >> 8 & 255;
									var g11 = this41 == 0 ? 0. : this41 / 255;
									var this42 = this38 & 255;
									var b12 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color >> 24 & 255;
									var a21 = this43 == 0 ? 0. : this43 / 255;
									var this44 = color >> 16 & 255;
									var r21 = this44 == 0 ? 0. : this44 / 255;
									var this45 = color >> 8 & 255;
									var g21 = this45 == 0 ? 0. : this45 / 255;
									var this46 = color & 255;
									var b22 = this46 == 0 ? 0. : this46 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
									this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v1 = new pi_$xy_algo_HitTri(innerCx,innerCy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v1.undoImage = undoImage;
							v1.undoX = xIter3.start;
							v1.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
		} else {
			var this1 = temp;
			var color = this.strokeColor;
			var phi1 = phi;
			var softC = this.edgeSoft;
			if(softC == null) {
				softC = 10;
			}
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = rW > rH ? rH : rW;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			var softC1 = softC;
			if(softC1 == null) {
				softC1 = 10.;
			}
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var softC = softC1;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(softC == null) {
				softC = 10;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = rW * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - rH * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
				lastY = rW * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + rH * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
			} else {
				lastX = cx + rW * Math.cos(sides1 * theta + omega);
				lastY = cy + rH * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = rW * ctheta * cphi - rH * stheta * sphi + cx;
					var nextY = rW * ctheta * sphi + rH * stheta * cphi + cy;
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = cx - nextX;
					var acy = cy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(cx > lastX) {
						if(cx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(cx);
							var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this2;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this3;
						}
					} else if(lastX > nextX) {
						var ii_min2 = cx > nextX ? Math.floor(nextX) : Math.ceil(cx);
						var ii_max2 = Math.ceil(lastX);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this4;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(nextX);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this5;
					}
					var yIter3;
					if(cy > lastY) {
						if(cy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(cy);
							var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this6;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this7;
						}
					} else if(lastY > nextY) {
						var ii_min6 = cy > nextY ? Math.floor(nextY) : Math.ceil(cy);
						var ii_max6 = Math.ceil(lastY);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this8;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(nextY);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this9;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this10 = i1;
								var a = this10;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this11 = i2;
								var r = this11;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this12 = i3;
								var g = this12;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this13 = i4;
								var b = this13;
								var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
								if(this1.transparent && a < 254) {
									var this14 = this1.image.get(location);
									var this15 = this14;
									var old = pi_$xy_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this16 = old >> 24 & 255;
									var a1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 16 & 255;
									var r1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old >> 8 & 255;
									var g1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = old & 255;
									var b1 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 24 & 255;
									var a2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 16 & 255;
									var r2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs >> 8 & 255;
									var g2 = this22 == 0 ? 0. : this22 / 255;
									var this23 = rhs & 255;
									var b2 = this23 == 0 ? 0. : this23 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = cx;
					var ay = cy;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var adjustWinding = ax * by - bx * ay + (bx * cy1 - cx1 * by) + (cx1 * ay - ax * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx1;
					var v_cy = cy1;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this24 = new pi_$xy_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this24;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this25 = new pi_$xy_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this25;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this26 = new pi_$xy_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this26;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this27 = new pi_$xy_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this27;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this28 = new pi_$xy_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this28;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this29 = new pi_$xy_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this29;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this30 = new pi_$xy_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this30;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this31 = new pi_$xy_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this31;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = cx + rW * Math.cos(i * theta + omega + 0.01);
					var nextY = cy + rH * Math.sin(i * theta + omega + 0.01);
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = cx - nextX;
					var acy = cy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(cx > lastX) {
						if(cx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(cx);
							var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this2;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this3;
						}
					} else if(lastX > nextX) {
						var ii_min2 = cx > nextX ? Math.floor(nextX) : Math.ceil(cx);
						var ii_max2 = Math.ceil(lastX);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this4;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(nextX);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this5;
					}
					var yIter3;
					if(cy > lastY) {
						if(cy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(cy);
							var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this6;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this7;
						}
					} else if(lastY > nextY) {
						var ii_min6 = cy > nextY ? Math.floor(nextY) : Math.ceil(cy);
						var ii_max6 = Math.ceil(lastY);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this8;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(nextY);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this9;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this10 = i1;
								var a = this10;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this11 = i2;
								var r = this11;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this12 = i3;
								var g = this12;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this13 = i4;
								var b = this13;
								var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
								if(this1.transparent && a < 254) {
									var this14 = this1.image.get(location);
									var this15 = this14;
									var old = pi_$xy_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this16 = old >> 24 & 255;
									var a1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 16 & 255;
									var r1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old >> 8 & 255;
									var g1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = old & 255;
									var b1 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 24 & 255;
									var a2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 16 & 255;
									var r2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs >> 8 & 255;
									var g2 = this22 == 0 ? 0. : this22 / 255;
									var this23 = rhs & 255;
									var b2 = this23 == 0 ? 0. : this23 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = cx;
					var ay = cy;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var adjustWinding = ax * by - bx * ay + (bx * cy1 - cx1 * by) + (cx1 * ay - ax * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx1;
					var v_cy = cy1;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this24 = new pi_$xy_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this24;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this25 = new pi_$xy_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this25;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this26 = new pi_$xy_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this26;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this27 = new pi_$xy_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this27;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this28 = new pi_$xy_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this28;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this29 = new pi_$xy_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this29;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this30 = new pi_$xy_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this30;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this31 = new pi_$xy_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this31;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
			var this1 = temp;
			var color = this.fill;
			var phi1 = phi;
			var softC = this.edgeSoft;
			if(softC == null) {
				softC = 10;
			}
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = innerRw > innerRh ? innerRh : innerRw;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi = phi1;
			var sides = noSides;
			var softC1 = softC;
			if(softC1 == null) {
				softC1 = 10.;
			}
			if(sides == null) {
				sides = 36;
			}
			if(phi == null) {
				phi = 0.;
			}
			var phi1 = phi;
			var sides1 = sides;
			var softC = softC1;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(softC == null) {
				softC = 10;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = innerRw * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerRh * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
				lastY = innerRw * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerRh * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
			} else {
				lastX = innerCx + innerRw * Math.cos(sides1 * theta + omega);
				lastY = innerCy + innerRh * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = innerRw * ctheta * cphi - innerRh * stheta * sphi + innerCx;
					var nextY = innerRw * ctheta * sphi + innerRh * stheta * cphi + innerCy;
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = innerCx - nextX;
					var acy = innerCy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(innerCx > lastX) {
						if(innerCx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(innerCx);
							var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this2;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this3;
						}
					} else if(lastX > nextX) {
						var ii_min2 = innerCx > nextX ? Math.floor(nextX) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(lastX);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this4;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(nextX);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this5;
					}
					var yIter3;
					if(innerCy > lastY) {
						if(innerCy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(innerCy);
							var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this6;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this7;
						}
					} else if(lastY > nextY) {
						var ii_min6 = innerCy > nextY ? Math.floor(nextY) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(lastY);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this8;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(nextY);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this9;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this10 = i1;
								var a = this10;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this11 = i2;
								var r = this11;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this12 = i3;
								var g = this12;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this13 = i4;
								var b = this13;
								var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
								if(this1.transparent && a < 254) {
									var this14 = this1.image.get(location);
									var this15 = this14;
									var old = pi_$xy_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this16 = old >> 24 & 255;
									var a1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 16 & 255;
									var r1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old >> 8 & 255;
									var g1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = old & 255;
									var b1 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 24 & 255;
									var a2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 16 & 255;
									var r2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs >> 8 & 255;
									var g2 = this22 == 0 ? 0. : this22 / 255;
									var this23 = rhs & 255;
									var b2 = this23 == 0 ? 0. : this23 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = innerCx;
					var ay = innerCy;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var bx = lastX;
					var by = lastY;
					var cx = nextX;
					var cy = nextY;
					var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx;
						by = cy;
						cx = bx_;
						cy = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx;
					var v_cy = cy;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this24 = new pi_$xy_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this24;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this25 = new pi_$xy_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this25;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this26 = new pi_$xy_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this26;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this27 = new pi_$xy_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this27;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this28 = new pi_$xy_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this28;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this29 = new pi_$xy_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this29;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this30 = new pi_$xy_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this30;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this31 = new pi_$xy_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this31;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = innerCx + innerRw * Math.cos(i * theta + omega + 0.01);
					var nextY = innerCy + innerRh * Math.sin(i * theta + omega + 0.01);
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = innerCx - nextX;
					var acy = innerCy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(innerCx > lastX) {
						if(innerCx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(innerCx);
							var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this2;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this3 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this3;
						}
					} else if(lastX > nextX) {
						var ii_min2 = innerCx > nextX ? Math.floor(nextX) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(lastX);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this4;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(nextX);
						var this5 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this5;
					}
					var yIter3;
					if(innerCy > lastY) {
						if(innerCy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(innerCy);
							var this6 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this6;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this7 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this7;
						}
					} else if(lastY > nextY) {
						var ii_min6 = innerCy > nextY ? Math.floor(nextY) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(lastY);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this8;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(nextY);
						var this9 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this9;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this10 = i1;
								var a = this10;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this11 = i2;
								var r = this11;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this12 = i3;
								var g = this12;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this13 = i4;
								var b = this13;
								var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
								if(this1.transparent && a < 254) {
									var this14 = this1.image.get(location);
									var this15 = this14;
									var old = pi_$xy_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this16 = old >> 24 & 255;
									var a1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 16 & 255;
									var r1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old >> 8 & 255;
									var g1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = old & 255;
									var b1 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 24 & 255;
									var a2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 16 & 255;
									var r2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs >> 8 & 255;
									var g2 = this22 == 0 ? 0. : this22 / 255;
									var this23 = rhs & 255;
									var b2 = this23 == 0 ? 0. : this23 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = innerCx;
					var ay = innerCy;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var bx = lastX;
					var by = lastY;
					var cx = nextX;
					var cy = nextY;
					var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx;
						by = cy;
						cx = bx_;
						cy = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx;
					var v_cy = cy;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this24 = new pi_$xy_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this24;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this25 = new pi_$xy_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this25;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this26 = new pi_$xy_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this26;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this27 = new pi_$xy_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this27;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this28 = new pi_$xy_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this28;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this29 = new pi_$xy_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this29;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this30 = new pi_$xy_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this30;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this31 = new pi_$xy_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this31;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
		}
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
				var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
						var this11 = pixelImage.image.get(location);
						var this12 = this11;
						var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
					}
				}
			}
		}
		temp = null;
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_EllipseForm
});
var pi_$xy_triangleGML_triGML_BasicGradient = function(opacity,visibility,cornerColors) {
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	this.cornerColors = [];
	pi_$xy_triangleGML_triGML_GroupShape.call(this,opacity,visibility);
	if(cornerColors != null) {
		this.cornerColors = cornerColors;
	}
};
pi_$xy_triangleGML_triGML_BasicGradient.__name__ = "pi_xy.triangleGML.triGML.BasicGradient";
pi_$xy_triangleGML_triGML_BasicGradient.__super__ = pi_$xy_triangleGML_triGML_GroupShape;
pi_$xy_triangleGML_triGML_BasicGradient.prototype = $extend(pi_$xy_triangleGML_triGML_GroupShape.prototype,{
	setParameter: function(name,value) {
		if(name == "cornerColors") {
			value = value.split("[")[1].split("]")[0];
			var _g = [];
			var _g1 = 0;
			var _g2 = value.split(",");
			while(_g1 < _g2.length) {
				var n = _g2[_g1];
				++_g1;
				_g.push(Std.parseInt(n));
			}
			this.cornerColors = _g;
		} else {
			pi_$xy_triangleGML_triGML_GroupShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_BasicGradient
});
var pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$ = function(opacity,visibility,x1,y1,x2,y2,colorA,colorB,colorC,colorD,strokeWidth) {
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(colorD == null) {
		colorD = -9240321;
	}
	if(colorC == null) {
		colorC = -16717057;
	}
	if(colorB == null) {
		colorB = -4194560;
	}
	if(colorA == null) {
		colorA = -26368;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicGradient.call(this,opacity,visibility,[colorA,colorB,colorC,colorD]);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.strokeWidth = strokeWidth;
};
pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.__name__ = "pi_xy.triangleGML.triGML.shape.gradient.LineGradient_";
pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.__super__ = pi_$xy_triangleGML_triGML_BasicGradient;
pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.prototype = $extend(pi_$xy_triangleGML_triGML_BasicGradient.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "colorA":
			this.cornerColors[0] = Std.parseInt(value);
			break;
		case "colorB":
			this.cornerColors[1] = Std.parseInt(value);
			break;
		case "colorBottom":
			this.cornerColors[4] = Std.parseInt(value);
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorC":
			this.cornerColors[2] = Std.parseInt(value);
			break;
		case "colorD":
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorFirst":
			this.cornerColors[0] = Std.parseInt(value);
			this.cornerColors[4] = Std.parseInt(value);
			break;
		case "colorSecond":
			this.cornerColors[2] = Std.parseInt(value);
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorTop":
			this.cornerColors[0] = Std.parseInt(value);
			this.cornerColors[2] = Std.parseInt(value);
			break;
		case "strokeWidth":
			this.strokeWidth = parseFloat(value);
			break;
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_BasicGradient.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$
});
var pi_$xy_triangleGML_LineGradient = function(opacity,visibility,x1,y1,x2,y2,colorA,colorB,colorC,colorD,strokeWidth) {
	pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.call(this,opacity,visibility,x1,y1,x2,y2,colorA,colorB,colorC,colorD,strokeWidth);
};
pi_$xy_triangleGML_LineGradient.__name__ = "pi_xy.triangleGML.LineGradient";
pi_$xy_triangleGML_LineGradient.__super__ = pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$;
pi_$xy_triangleGML_LineGradient.prototype = $extend(pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.prototype,{
	setParameter: function(name,value) {
		if(name == "luxury") {
			this.luxury = StringTools.trim(value).toLowerCase() == "true";
			haxe_Log.trace("setting luxury " + value,{ fileName : "src/pi_xy/triangleGML/LineGradient.hx", lineNumber : 13, className : "pi_xy.triangleGML.LineGradient", methodName : "setParameter"});
		} else {
			pi_$xy_triangleGML_triGML_shape_gradient_LineGradient_$.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var px = this.x1 + this.offX;
		var qx = this.x2 + this.offX;
		var py = this.y1 + this.offY;
		var qy = this.y2 + this.offY;
		if(this.luxury) {
			var colorA = this.cornerColors[0];
			var colorB = this.cornerColors[1];
			var colorC = this.cornerColors[2];
			var colorD = this.cornerColors[3];
			var __px = px;
			var __py = py;
			var __qx = qx;
			var __qy = qy;
			var __thick = this.strokeWidth;
			var o = __qy - __py;
			var a = __qx - __px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var lineInfo_px = __px;
			var lineInfo_py = __py;
			var lineInfo_thick = __thick;
			var lineInfo_long = h;
			var lineInfo_theta = theta;
			var radius = lineInfo_thick / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = lineInfo_long;
			var cy = radius;
			var bx = lineInfo_long;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var quadPoints_ax = ax;
			var quadPoints_ay = ay;
			var quadPoints_bx = bx;
			var quadPoints_by = by;
			var quadPoints_cx = cx;
			var quadPoints_cy = cy;
			var quadPoints_dx = dx;
			var quadPoints_dy = dy;
			var sin = Math.sin(lineInfo_theta);
			var cos = Math.cos(lineInfo_theta);
			var centreX = lineInfo_px;
			var centreY = lineInfo_py;
			var temp = 0.;
			temp = centreX + (quadPoints_ax * cos - quadPoints_ay * sin);
			quadPoints_ay = centreY + (quadPoints_ay * cos + quadPoints_ax * sin);
			quadPoints_ax = temp;
			temp = centreX + (quadPoints_bx * cos - quadPoints_by * sin);
			quadPoints_by = centreY + (quadPoints_by * cos + quadPoints_bx * sin);
			quadPoints_bx = temp;
			temp = centreX + (quadPoints_cx * cos - quadPoints_cy * sin);
			quadPoints_cy = centreY + (quadPoints_cy * cos + quadPoints_cx * sin);
			quadPoints_cx = temp;
			temp = centreX + (quadPoints_dx * cos - quadPoints_dy * sin);
			quadPoints_dy = centreY + (quadPoints_dy * cos + quadPoints_dx * sin);
			quadPoints_dx = temp;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var ax = quadPoints_ax;
			var ay = quadPoints_ay;
			var bx = quadPoints_bx;
			var by = quadPoints_by;
			var cx = quadPoints_dx;
			var cy = quadPoints_dy;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var softAB = true;
			var softBC = false;
			var softCA = true;
			var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx;
				var by_ = by;
				bx = cx;
				by = cy;
				cx = bx_;
				cy = by_;
			}
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCA1 = softCA;
			var hasHit2 = hasHit1;
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			if(softCA1 == null) {
				softCA1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			var aA = colorB >> 24 & 255;
			var rA = colorB >> 16 & 255;
			var gA = colorB >> 8 & 255;
			var bA = colorB & 255;
			var aB = colorA >> 24 & 255;
			var rB = colorA >> 16 & 255;
			var gB = colorA >> 8 & 255;
			var bB = colorA & 255;
			var aC = colorD >> 24 & 255;
			var rC = colorD >> 16 & 255;
			var gC = colorD >> 8 & 255;
			var bC = colorD & 255;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var hitTriScalar = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
			var barycentric_yIter3;
			var barycentric_xIter3;
			var barycentric_dot22;
			var barycentric_dot12;
			var barycentric_dot11;
			var barycentric_denom1;
			var barycentric_bcy;
			var barycentric_bcx;
			var barycentric_acy;
			var barycentric_acx;
			var preCalculated = true;
			if(preCalculated == null) {
				preCalculated = true;
			}
			var barycentric_ax = hitTriScalar.ax;
			var barycentric_ay = hitTriScalar.ay;
			var barycentric_bx = hitTriScalar.bx;
			var barycentric_by = hitTriScalar.by;
			var barycentric_cx = hitTriScalar.cx;
			var barycentric_cy = hitTriScalar.cy;
			var barycentric_preCalculated = preCalculated;
			if(preCalculated) {
				barycentric_bcx = barycentric_bx - barycentric_cx;
				barycentric_bcy = barycentric_by - barycentric_cy;
				barycentric_acx = barycentric_ax - barycentric_cx;
				barycentric_acy = barycentric_ay - barycentric_cy;
				var ax1 = barycentric_bcx;
				var ay1 = barycentric_bcy;
				barycentric_dot11 = ax1 * ax1 + ay1 * ay1;
				barycentric_dot12 = barycentric_bcx * barycentric_acx + barycentric_bcy * barycentric_acy;
				var ax1 = barycentric_acx;
				var ay1 = barycentric_acy;
				barycentric_dot22 = ax1 * ax1 + ay1 * ay1;
				barycentric_denom1 = 1 / (barycentric_dot11 * barycentric_dot22 - barycentric_dot12 * barycentric_dot12);
				var a1 = barycentric_ax;
				var b1 = barycentric_bx;
				var c = barycentric_cx;
				if(a1 > b1) {
					if(a1 > c) {
						var ii_min = b1 > c ? Math.floor(c) : Math.floor(b1);
						var ii_max = Math.ceil(a1);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_xIter3 = this1;
					} else {
						var ii_min = Math.floor(b1);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_xIter3 = this1;
					}
				} else if(b1 > c) {
					var ii_min = a1 > c ? Math.floor(c) : Math.ceil(a1);
					var ii_max = Math.ceil(b1);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_xIter3 = this1;
				} else {
					var ii_min = Math.floor(a1);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_xIter3 = this1;
				}
				var a1 = barycentric_ay;
				var b1 = barycentric_by;
				var c = barycentric_cy;
				if(a1 > b1) {
					if(a1 > c) {
						var ii_min = b1 > c ? Math.floor(c) : Math.floor(b1);
						var ii_max = Math.ceil(a1);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_yIter3 = this1;
					} else {
						var ii_min = Math.floor(b1);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_yIter3 = this1;
					}
				} else if(b1 > c) {
					var ii_min = a1 > c ? Math.floor(c) : Math.ceil(a1);
					var ii_max = Math.ceil(b1);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_yIter3 = this1;
				} else {
					var ii_min = Math.floor(a1);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_yIter3 = this1;
				}
			}
			var scaleA = softAB1 || softCA1 ? 1.5 : 1.;
			var scaleB = softAB1 || softBC1 ? 1.5 : 1.;
			var scaleC = softBC1 || softCA1 ? 1.5 : 1.;
			var x0 = 0.;
			var y0 = 0.;
			var isScaledA = true;
			var isScaledB = true;
			var isScaledC = true;
			if(isScaledA) {
				if(isScaledB) {
					if(isScaledC) {
						x0 = (hitTriScalar.ax + hitTriScalar.bx + hitTriScalar.cx) / 3;
						y0 = (hitTriScalar.ay + hitTriScalar.by + hitTriScalar.cy) / 3;
					} else {
						x0 = hitTriScalar.cx;
						y0 = hitTriScalar.cy;
					}
				} else if(isScaledC) {
					x0 = hitTriScalar.bx;
					y0 = hitTriScalar.by;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianBCx(hitTriScalar);
					y0 = pi_$xy_algo_HitTriScalar.medianBCy(hitTriScalar);
				}
			} else if(isScaledB) {
				if(isScaledC) {
					x0 = hitTriScalar.ax;
					y0 = hitTriScalar.ay;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianCAx(hitTriScalar);
					y0 = pi_$xy_algo_HitTriScalar.medianCAy(hitTriScalar);
				}
			} else if(isScaledC) {
				x0 = pi_$xy_algo_HitTriScalar.medianABx(hitTriScalar);
				y0 = pi_$xy_algo_HitTriScalar.medianABy(hitTriScalar);
			} else {
				x0 = (hitTriScalar.ax + hitTriScalar.bx + hitTriScalar.cx) / 3;
				y0 = (hitTriScalar.ay + hitTriScalar.by + hitTriScalar.cy) / 3;
			}
			var ax_;
			if(isScaledA) {
				var point = hitTriScalar.ax;
				point -= x0;
				point *= 0.999;
				point += x0;
				ax_ = point;
			} else {
				ax_ = hitTriScalar.ax;
			}
			var ay_;
			if(isScaledA) {
				var point = hitTriScalar.ay;
				point -= y0;
				point *= 0.999;
				point += y0;
				ay_ = point;
			} else {
				ay_ = hitTriScalar.ay;
			}
			var bx_;
			if(isScaledB) {
				var point = hitTriScalar.bx;
				point -= x0;
				point *= 0.999;
				point += x0;
				bx_ = point;
			} else {
				bx_ = hitTriScalar.bx;
			}
			var by_;
			if(isScaledB) {
				var point = hitTriScalar.by;
				point -= y0;
				point *= 0.999;
				point += y0;
				by_ = point;
			} else {
				by_ = hitTriScalar.by;
			}
			var cx_;
			if(isScaledC) {
				var point = hitTriScalar.cx;
				point -= x0;
				point *= 0.999;
				point += x0;
				cx_ = point;
			} else {
				cx_ = hitTriScalar.cx;
			}
			var cy_;
			if(isScaledC) {
				var point = hitTriScalar.cy;
				point -= y0;
				point *= 0.999;
				point += y0;
				cy_ = point;
			} else {
				cy_ = hitTriScalar.cy;
			}
			var scaled = new pi_$xy_algo_HitTri(ax_,ay_,bx_,by_,cx_,cy_,true);
			var x0 = 0.;
			var y0 = 0.;
			var isScaledA = scaleA != 1.;
			var isScaledB = scaleB != 1.;
			var isScaledC = scaleC != 1.;
			if(isScaledA) {
				if(isScaledB) {
					if(isScaledC) {
						x0 = (scaled.ax + scaled.bx + scaled.cx) / 3;
						y0 = (scaled.ay + scaled.by + scaled.cy) / 3;
					} else {
						x0 = scaled.cx;
						y0 = scaled.cy;
					}
				} else if(isScaledC) {
					x0 = scaled.bx;
					y0 = scaled.by;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianBCx(scaled);
					y0 = pi_$xy_algo_HitTriScalar.medianBCy(scaled);
				}
			} else if(isScaledB) {
				if(isScaledC) {
					x0 = scaled.ax;
					y0 = scaled.ay;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianCAx(scaled);
					y0 = pi_$xy_algo_HitTriScalar.medianCAy(scaled);
				}
			} else if(isScaledC) {
				x0 = pi_$xy_algo_HitTriScalar.medianABx(scaled);
				y0 = pi_$xy_algo_HitTriScalar.medianABy(scaled);
			} else {
				x0 = (scaled.ax + scaled.bx + scaled.cx) / 3;
				y0 = (scaled.ay + scaled.by + scaled.cy) / 3;
			}
			var ax_;
			if(isScaledA) {
				var point = scaled.ax;
				point -= x0;
				point *= scaleA;
				point += x0;
				ax_ = point;
			} else {
				ax_ = scaled.ax;
			}
			var ay_;
			if(isScaledA) {
				var point = scaled.ay;
				point -= y0;
				point *= scaleA;
				point += y0;
				ay_ = point;
			} else {
				ay_ = scaled.ay;
			}
			var bx_;
			if(isScaledB) {
				var point = scaled.bx;
				point -= x0;
				point *= scaleB;
				point += x0;
				bx_ = point;
			} else {
				bx_ = scaled.bx;
			}
			var by_;
			if(isScaledB) {
				var point = scaled.by;
				point -= y0;
				point *= scaleB;
				point += y0;
				by_ = point;
			} else {
				by_ = scaled.by;
			}
			var cx_;
			if(isScaledC) {
				var point = scaled.cx;
				point -= x0;
				point *= scaleC;
				point += x0;
				cx_ = point;
			} else {
				cx_ = scaled.cx;
			}
			var cy_;
			if(isScaledC) {
				var point = scaled.cy;
				point -= y0;
				point *= scaleC;
				point += y0;
				cy_ = point;
			} else {
				cy_ = scaled.cy;
			}
			scaled = new pi_$xy_algo_HitTri(ax_,ay_,bx_,by_,cx_,cy_,true);
			var this1 = hitTriScalar.xIter3;
			var _g_min = this1.start;
			var _g_max = this1.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var this1 = hitTriScalar.yIter3;
				var _g_min1 = this1.start;
				var _g_max1 = this1.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcx = px1 - barycentric_cx;
					var pcy = py1 - barycentric_cy;
					var dot31 = pcx * barycentric_bcx + pcy * barycentric_bcy;
					var dot32 = pcx * barycentric_acx + pcy * barycentric_acy;
					var ratioA = (barycentric_dot22 * dot31 - barycentric_dot12 * dot32) * barycentric_denom1;
					var ratioB = (barycentric_dot11 * dot32 - barycentric_dot12 * dot31) * barycentric_denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					var ratios_ratioA = ratioA;
					var ratios_ratioB = ratioB;
					var ratios_ratioC = ratioC;
					var v = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
					var min_ = v < ratios_ratioC ? v : ratios_ratioC;
					var isSoft;
					if(softAB1) {
						if(softBC1) {
							if(softCA1) {
								isSoft = true;
							} else if(min_ != ratios_ratioB) {
								var v1 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v1 < ratios_ratioC ? v1 : ratios_ratioC) == ratios_ratioC;
							} else {
								isSoft = true;
							}
						} else if(softCA1) {
							if(min_ != ratios_ratioA) {
								var v2 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v2 < ratios_ratioC ? v2 : ratios_ratioC) == ratios_ratioC;
							} else {
								isSoft = true;
							}
						} else {
							isSoft = min_ == ratios_ratioC;
						}
					} else if(softBC1) {
						if(softCA1) {
							if(min_ != ratios_ratioA) {
								var v3 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v3 < ratios_ratioC ? v3 : ratios_ratioC) == ratios_ratioB;
							} else {
								isSoft = true;
							}
						} else {
							isSoft = min_ == ratios_ratioB;
						}
					} else {
						isSoft = softCA1 && min_ == ratios_ratioA;
					}
					var x0 = -0.0739127852035666;
					var y0 = 0.703233176253404202;
					var x1 = -0.353553390593273564;
					var y1 = 0.61237243569579447;
					var x2 = -0.572061402817684139;
					var y2 = 0.415626937777453465;
					var x3 = -0.691654801480225401;
					var y3 = 0.147015766465198733;
					var x4 = -0.691654801480225512;
					var y4 = -0.147015766465198261;
					var averageX = 0.;
					var averageY = 0.;
					var hits = 0;
					var fractionTotal = 0.;
					var x = px1 + x0;
					var y = py1 + y0;
					var tmp;
					var tmp1;
					var this2 = hitTriScalar.xIter3;
					if(x > this2.start - 1 && x < this2.max + 1) {
						var this3 = hitTriScalar.yIter3;
						tmp1 = y > this3.start - 1 && y < this3.max + 1;
					} else {
						tmp1 = false;
					}
					if(tmp1) {
						var s = hitTriScalar.s0 + hitTriScalar.sx * x + hitTriScalar.sy * y;
						var t = hitTriScalar.t0 + hitTriScalar.tx * x + hitTriScalar.ty * y;
						tmp = s <= 0 || t <= 0 ? false : s + t < hitTriScalar.A;
					} else {
						tmp = false;
					}
					if(tmp) {
						++hits;
						averageX += x0;
						averageY += y0;
						fractionTotal += 0.2;
					}
					var x5 = px1 + x1;
					var y5 = py1 + y1;
					var tmp2;
					var tmp3;
					var this4 = hitTriScalar.xIter3;
					if(x5 > this4.start - 1 && x5 < this4.max + 1) {
						var this5 = hitTriScalar.yIter3;
						tmp3 = y5 > this5.start - 1 && y5 < this5.max + 1;
					} else {
						tmp3 = false;
					}
					if(tmp3) {
						var s1 = hitTriScalar.s0 + hitTriScalar.sx * x5 + hitTriScalar.sy * y5;
						var t1 = hitTriScalar.t0 + hitTriScalar.tx * x5 + hitTriScalar.ty * y5;
						tmp2 = s1 <= 0 || t1 <= 0 ? false : s1 + t1 < hitTriScalar.A;
					} else {
						tmp2 = false;
					}
					if(tmp2) {
						++hits;
						averageX += x1;
						averageY += y1;
						fractionTotal += 0.2;
					}
					var x6 = px1 + x2;
					var y6 = py1 + y2;
					var tmp4;
					var tmp5;
					var this6 = hitTriScalar.xIter3;
					if(x6 > this6.start - 1 && x6 < this6.max + 1) {
						var this7 = hitTriScalar.yIter3;
						tmp5 = y6 > this7.start - 1 && y6 < this7.max + 1;
					} else {
						tmp5 = false;
					}
					if(tmp5) {
						var s2 = hitTriScalar.s0 + hitTriScalar.sx * x6 + hitTriScalar.sy * y6;
						var t2 = hitTriScalar.t0 + hitTriScalar.tx * x6 + hitTriScalar.ty * y6;
						tmp4 = s2 <= 0 || t2 <= 0 ? false : s2 + t2 < hitTriScalar.A;
					} else {
						tmp4 = false;
					}
					if(tmp4) {
						++hits;
						averageX += x2;
						averageY += y2;
						fractionTotal += 0.2;
					}
					var x7 = px1 + x3;
					var y7 = py1 + y3;
					var tmp6;
					var tmp7;
					var this8 = hitTriScalar.xIter3;
					if(x7 > this8.start - 1 && x7 < this8.max + 1) {
						var this9 = hitTriScalar.yIter3;
						tmp7 = y7 > this9.start - 1 && y7 < this9.max + 1;
					} else {
						tmp7 = false;
					}
					if(tmp7) {
						var s3 = hitTriScalar.s0 + hitTriScalar.sx * x7 + hitTriScalar.sy * y7;
						var t3 = hitTriScalar.t0 + hitTriScalar.tx * x7 + hitTriScalar.ty * y7;
						tmp6 = s3 <= 0 || t3 <= 0 ? false : s3 + t3 < hitTriScalar.A;
					} else {
						tmp6 = false;
					}
					if(tmp6) {
						++hits;
						averageX += x3;
						averageY += y3;
						fractionTotal += 0.2;
					}
					var x8 = px1 + x4;
					var y8 = py1 + y4;
					var tmp8;
					var tmp9;
					var this10 = hitTriScalar.xIter3;
					if(x8 > this10.start - 1 && x8 < this10.max + 1) {
						var this11 = hitTriScalar.yIter3;
						tmp9 = y8 > this11.start - 1 && y8 < this11.max + 1;
					} else {
						tmp9 = false;
					}
					if(tmp9) {
						var s4 = hitTriScalar.s0 + hitTriScalar.sx * x8 + hitTriScalar.sy * y8;
						var t4 = hitTriScalar.t0 + hitTriScalar.tx * x8 + hitTriScalar.ty * y8;
						tmp8 = s4 <= 0 || t4 <= 0 ? false : s4 + t4 < hitTriScalar.A;
					} else {
						tmp8 = false;
					}
					if(tmp8) {
						++hits;
						averageX += x4;
						averageY += y4;
						fractionTotal += 0.2;
					}
					if(hits != 0) {
						averageX = px1 + averageX / hits;
						averageY = py1 + averageY / hits;
					} else {
						averageX = px1;
						averageY = py1;
					}
					var fractionTotal1 = fractionTotal;
					var sampleData_fractionTotal = fractionTotal1;
					var sampleData_averageX = averageX;
					var sampleData_averageY = averageY;
					var sampleData_notHit = fractionTotal1 == 0.;
					var aScale = sampleData_fractionTotal;
					if(!(aScale > 0.9)) {
						aScale = aScale * 0.8 + 0.2;
					}
					a = 0;
					r = 0;
					g = 0;
					b = 0;
					if(isSoft) {
						if(!sampleData_notHit) {
							var pcx1 = sampleData_averageX - barycentric_cx;
							var pcy1 = sampleData_averageY - barycentric_cy;
							var dot311 = pcx1 * barycentric_bcx + pcy1 * barycentric_bcy;
							var dot321 = pcx1 * barycentric_acx + pcy1 * barycentric_acy;
							var ratioA1 = (barycentric_dot22 * dot311 - barycentric_dot12 * dot321) * barycentric_denom1;
							var ratioB1 = (barycentric_dot11 * dot321 - barycentric_dot12 * dot311) * barycentric_denom1;
							var ratioC1 = 1.0 - ratioB1 - ratioA1;
							var ratiosAvg_ratioA = ratioA1;
							var ratiosAvg_ratioB = ratioB1;
							var ratiosAvg_ratioC = ratioC1;
							var ratioA_ = ratiosAvg_ratioA;
							var ratioB_ = ratiosAvg_ratioB;
							var ratioC_ = ratiosAvg_ratioC;
							var i = aA * ratioA_ + aB * ratioB_ + aC * ratioC_ | 0;
							if(i > 255) {
								i = 255;
							}
							if(i < 0) {
								i = 0;
							}
							var this12 = i;
							a = this12;
							var i1 = rA * ratioA_ + rB * ratioB_ + rC * ratioC_ | 0;
							if(i1 > 255) {
								i1 = 255;
							}
							if(i1 < 0) {
								i1 = 0;
							}
							var this13 = i1;
							r = this13;
							var i2 = gA * ratioA_ + gB * ratioB_ + gC * ratioC_ | 0;
							if(i2 > 255) {
								i2 = 255;
							}
							if(i2 < 0) {
								i2 = 0;
							}
							var this14 = i2;
							g = this14;
							var i3 = bA * ratioA_ + bB * ratioB_ + bC * ratioC_ | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this15 = i3;
							b = this15;
							var a1;
							if(aScale > 0.9) {
								a1 = a;
							} else {
								var i4 = a * aScale | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this16 = i4;
								a1 = this16;
							}
							var location = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
							if(pixelImage.transparent && a1 < 254) {
								var this17 = pixelImage.image.get(location);
								var this18 = this17;
								var old = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs = a1 << 24 | r << 16 | g << 8 | b;
								var this19 = old >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old >> 16 & 255;
								var r1 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old >> 8 & 255;
								var g1 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old & 255;
								var b1 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs >> 24 & 255;
								var a2 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs >> 16 & 255;
								var r2 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs >> 8 & 255;
								var g2 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs & 255;
								var b2 = this26 == 0 ? 0. : this26 / 255;
								var a3 = a11 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								pixelImage.image.set(location,pixelImage.isLittle ? a1 << 24 | b << 16 | g << 8 | r : a1 << 24 | r << 16 | g << 8 | b);
							}
						}
					} else {
						var ratioA2 = ratios_ratioA;
						var ratioB2 = ratios_ratioB;
						var ratioC2 = ratios_ratioC;
						var hitTotal = sampleData_fractionTotal;
						if(!sampleData_notHit) {
							var x01 = -0.0739127852035666;
							var y01 = 0.703233176253404202;
							var x11 = -0.353553390593273564;
							var y11 = 0.61237243569579447;
							var x21 = -0.572061402817684139;
							var y21 = 0.415626937777453465;
							var x31 = -0.691654801480225401;
							var y31 = 0.147015766465198733;
							var x41 = -0.691654801480225512;
							var y41 = -0.147015766465198261;
							var averageX1 = 0.;
							var averageY1 = 0.;
							var hits1 = 0;
							var fractionTotal2 = 0.;
							var x9 = px1 + x01;
							var y9 = py1 + y01;
							var tmp10;
							var tmp11;
							var this27 = scaled.xIter3;
							if(x9 > this27.start - 1 && x9 < this27.max + 1) {
								var this28 = scaled.yIter3;
								tmp11 = y9 > this28.start - 1 && y9 < this28.max + 1;
							} else {
								tmp11 = false;
							}
							if(tmp11) {
								var s5 = scaled.s0 + scaled.sx * x9 + scaled.sy * y9;
								var t5 = scaled.t0 + scaled.tx * x9 + scaled.ty * y9;
								tmp10 = s5 <= 0 || t5 <= 0 ? false : s5 + t5 < scaled.A;
							} else {
								tmp10 = false;
							}
							if(tmp10) {
								++hits1;
								averageX1 += x01;
								averageY1 += y01;
								fractionTotal2 += 0.2;
							}
							var x10 = px1 + x11;
							var y10 = py1 + y11;
							var tmp12;
							var tmp13;
							var this29 = scaled.xIter3;
							if(x10 > this29.start - 1 && x10 < this29.max + 1) {
								var this30 = scaled.yIter3;
								tmp13 = y10 > this30.start - 1 && y10 < this30.max + 1;
							} else {
								tmp13 = false;
							}
							if(tmp13) {
								var s6 = scaled.s0 + scaled.sx * x10 + scaled.sy * y10;
								var t6 = scaled.t0 + scaled.tx * x10 + scaled.ty * y10;
								tmp12 = s6 <= 0 || t6 <= 0 ? false : s6 + t6 < scaled.A;
							} else {
								tmp12 = false;
							}
							if(tmp12) {
								++hits1;
								averageX1 += x11;
								averageY1 += y11;
								fractionTotal2 += 0.2;
							}
							var x12 = px1 + x21;
							var y12 = py1 + y21;
							var tmp14;
							var tmp15;
							var this31 = scaled.xIter3;
							if(x12 > this31.start - 1 && x12 < this31.max + 1) {
								var this32 = scaled.yIter3;
								tmp15 = y12 > this32.start - 1 && y12 < this32.max + 1;
							} else {
								tmp15 = false;
							}
							if(tmp15) {
								var s7 = scaled.s0 + scaled.sx * x12 + scaled.sy * y12;
								var t7 = scaled.t0 + scaled.tx * x12 + scaled.ty * y12;
								tmp14 = s7 <= 0 || t7 <= 0 ? false : s7 + t7 < scaled.A;
							} else {
								tmp14 = false;
							}
							if(tmp14) {
								++hits1;
								averageX1 += x21;
								averageY1 += y21;
								fractionTotal2 += 0.2;
							}
							var x13 = px1 + x31;
							var y13 = py1 + y31;
							var tmp16;
							var tmp17;
							var this33 = scaled.xIter3;
							if(x13 > this33.start - 1 && x13 < this33.max + 1) {
								var this34 = scaled.yIter3;
								tmp17 = y13 > this34.start - 1 && y13 < this34.max + 1;
							} else {
								tmp17 = false;
							}
							if(tmp17) {
								var s8 = scaled.s0 + scaled.sx * x13 + scaled.sy * y13;
								var t8 = scaled.t0 + scaled.tx * x13 + scaled.ty * y13;
								tmp16 = s8 <= 0 || t8 <= 0 ? false : s8 + t8 < scaled.A;
							} else {
								tmp16 = false;
							}
							if(tmp16) {
								++hits1;
								averageX1 += x31;
								averageY1 += y31;
								fractionTotal2 += 0.2;
							}
							var x14 = px1 + x41;
							var y14 = py1 + y41;
							var tmp18;
							var tmp19;
							var this35 = scaled.xIter3;
							if(x14 > this35.start - 1 && x14 < this35.max + 1) {
								var this36 = scaled.yIter3;
								tmp19 = y14 > this36.start - 1 && y14 < this36.max + 1;
							} else {
								tmp19 = false;
							}
							if(tmp19) {
								var s9 = scaled.s0 + scaled.sx * x14 + scaled.sy * y14;
								var t9 = scaled.t0 + scaled.tx * x14 + scaled.ty * y14;
								tmp18 = s9 <= 0 || t9 <= 0 ? false : s9 + t9 < scaled.A;
							} else {
								tmp18 = false;
							}
							if(tmp18) {
								++hits1;
								averageX1 += x41;
								averageY1 += y41;
								fractionTotal2 += 0.2;
							}
							if(hits1 != 0) {
								averageX1 = px1 + averageX1 / hits1;
								averageY1 = py1 + averageY1 / hits1;
							} else {
								averageX1 = px1;
								averageY1 = py1;
							}
							var fractionTotal3 = fractionTotal2;
							var sampleScaled_fractionTotal = fractionTotal3;
							var sampleScaled_averageX = averageX1;
							var sampleScaled_averageY = averageY1;
							var sampleScaled_notHit = fractionTotal3 == 0.;
							var scaledTotal = sampleScaled_fractionTotal;
							if(scaledTotal > hitTotal || hitTotal == 1.) {
								var pcx2 = sampleData_averageX - barycentric_cx;
								var pcy2 = sampleData_averageY - barycentric_cy;
								var dot312 = pcx2 * barycentric_bcx + pcy2 * barycentric_bcy;
								var dot322 = pcx2 * barycentric_acx + pcy2 * barycentric_acy;
								var ratioA3 = (barycentric_dot22 * dot312 - barycentric_dot12 * dot322) * barycentric_denom1;
								var ratioB3 = (barycentric_dot11 * dot322 - barycentric_dot12 * dot312) * barycentric_denom1;
								var ratioC3 = 1.0 - ratioB3 - ratioA3;
								var ratiosAvg_ratioA1 = ratioA3;
								var ratiosAvg_ratioB1 = ratioB3;
								var ratiosAvg_ratioC1 = ratioC3;
								var ratioA_1 = ratiosAvg_ratioA1;
								var ratioB_1 = ratiosAvg_ratioB1;
								var ratioC_1 = ratiosAvg_ratioC1;
								var i5 = aA * ratioA_1 + aB * ratioB_1 + aC * ratioC_1 | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this37 = i5;
								a = this37;
								var i6 = rA * ratioA_1 + rB * ratioB_1 + rC * ratioC_1 | 0;
								if(i6 > 255) {
									i6 = 255;
								}
								if(i6 < 0) {
									i6 = 0;
								}
								var this38 = i6;
								r = this38;
								var i7 = gA * ratioA_1 + gB * ratioB_1 + gC * ratioC_1 | 0;
								if(i7 > 255) {
									i7 = 255;
								}
								if(i7 < 0) {
									i7 = 0;
								}
								var this39 = i7;
								g = this39;
								var i8 = bA * ratioA_1 + bB * ratioB_1 + bC * ratioC_1 | 0;
								if(i8 > 255) {
									i8 = 255;
								}
								if(i8 < 0) {
									i8 = 0;
								}
								var this40 = i8;
								b = this40;
								var location1 = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
								if(pixelImage.transparent && a < 254) {
									var this41 = pixelImage.image.get(location1);
									var this42 = this41;
									var old1 = pi_$xy_Endian_isLittleEndian ? (this42 >> 24 & 255) << 24 | (this42 & 255) << 16 | (this42 >> 8 & 255) << 8 | this42 >> 16 & 255 : this42;
									var rhs1 = a << 24 | r << 16 | g << 8 | b;
									var this43 = old1 >> 24 & 255;
									var a12 = this43 == 0 ? 0. : this43 / 255;
									var this44 = old1 >> 16 & 255;
									var r11 = this44 == 0 ? 0. : this44 / 255;
									var this45 = old1 >> 8 & 255;
									var g11 = this45 == 0 ? 0. : this45 / 255;
									var this46 = old1 & 255;
									var b11 = this46 == 0 ? 0. : this46 / 255;
									var this47 = rhs1 >> 24 & 255;
									var a21 = this47 == 0 ? 0. : this47 / 255;
									var this48 = rhs1 >> 16 & 255;
									var r21 = this48 == 0 ? 0. : this48 / 255;
									var this49 = rhs1 >> 8 & 255;
									var g21 = this49 == 0 ? 0. : this49 / 255;
									var this50 = rhs1 & 255;
									var b21 = this50 == 0 ? 0. : this50 / 255;
									var a31 = a12 * (1 - a21);
									var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
									pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									pixelImage.image.set(location1,pixelImage.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
							} else {
								var pcx3 = sampleData_averageX - barycentric_cx;
								var pcy3 = sampleData_averageY - barycentric_cy;
								var dot313 = pcx3 * barycentric_bcx + pcy3 * barycentric_bcy;
								var dot323 = pcx3 * barycentric_acx + pcy3 * barycentric_acy;
								var ratioA4 = (barycentric_dot22 * dot313 - barycentric_dot12 * dot323) * barycentric_denom1;
								var ratioB4 = (barycentric_dot11 * dot323 - barycentric_dot12 * dot313) * barycentric_denom1;
								var ratioC4 = 1.0 - ratioB4 - ratioA4;
								var ratiosAvg_ratioA2 = ratioA4;
								var ratiosAvg_ratioB2 = ratioB4;
								var ratiosAvg_ratioC2 = ratioC4;
								var ratioA_2 = ratiosAvg_ratioA2;
								var ratioB_2 = ratiosAvg_ratioB2;
								var ratioC_2 = ratiosAvg_ratioC2;
								var i9 = aA * ratioA_2 + aB * ratioB_2 + aC * ratioC_2 | 0;
								if(i9 > 255) {
									i9 = 255;
								}
								if(i9 < 0) {
									i9 = 0;
								}
								var this51 = i9;
								a = this51;
								var i10 = rA * ratioA_2 + rB * ratioB_2 + rC * ratioC_2 | 0;
								if(i10 > 255) {
									i10 = 255;
								}
								if(i10 < 0) {
									i10 = 0;
								}
								var this52 = i10;
								r = this52;
								var i11 = gA * ratioA_2 + gB * ratioB_2 + gC * ratioC_2 | 0;
								if(i11 > 255) {
									i11 = 255;
								}
								if(i11 < 0) {
									i11 = 0;
								}
								var this53 = i11;
								g = this53;
								var i12 = bA * ratioA_2 + bB * ratioB_2 + bC * ratioC_2 | 0;
								if(i12 > 255) {
									i12 = 255;
								}
								if(i12 < 0) {
									i12 = 0;
								}
								var this54 = i12;
								b = this54;
								var a6;
								if(aScale > 0.9) {
									a6 = a;
								} else {
									var i13 = a * aScale | 0;
									if(i13 > 255) {
										i13 = 255;
									}
									if(i13 < 0) {
										i13 = 0;
									}
									var this55 = i13;
									a6 = this55;
								}
								var location2 = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
								if(pixelImage.transparent && a6 < 254) {
									var this56 = pixelImage.image.get(location2);
									var this57 = this56;
									var old2 = pi_$xy_Endian_isLittleEndian ? (this57 >> 24 & 255) << 24 | (this57 & 255) << 16 | (this57 >> 8 & 255) << 8 | this57 >> 16 & 255 : this57;
									var rhs2 = a6 << 24 | r << 16 | g << 8 | b;
									var this58 = old2 >> 24 & 255;
									var a13 = this58 == 0 ? 0. : this58 / 255;
									var this59 = old2 >> 16 & 255;
									var r12 = this59 == 0 ? 0. : this59 / 255;
									var this60 = old2 >> 8 & 255;
									var g12 = this60 == 0 ? 0. : this60 / 255;
									var this61 = old2 & 255;
									var b12 = this61 == 0 ? 0. : this61 / 255;
									var this62 = rhs2 >> 24 & 255;
									var a22 = this62 == 0 ? 0. : this62 / 255;
									var this63 = rhs2 >> 16 & 255;
									var r22 = this63 == 0 ? 0. : this63 / 255;
									var this64 = rhs2 >> 8 & 255;
									var g22 = this64 == 0 ? 0. : this64 / 255;
									var this65 = rhs2 & 255;
									var b22 = this65 == 0 ? 0. : this65 / 255;
									var a32 = a13 * (1 - a22);
									var r5 = 255 * (r12 * a32 + r22 * a22) | 0;
									var g5 = 255 * (g12 * a32 + g22 * a22) | 0;
									var b5 = 255 * (b12 * a32 + b22 * a22) | 0;
									var a7 = 255 * (a32 + a22) | 0;
									var blended2 = a7 << 24 | r5 << 16 | g5 << 8 | b5;
									pixelImage.image.set(location2,pi_$xy_Endian_isLittleEndian ? (blended2 >> 24 & 255) << 24 | (blended2 & 255) << 16 | (blended2 >> 8 & 255) << 8 | blended2 >> 16 & 255 : blended2);
								} else {
									pixelImage.image.set(location2,pixelImage.isLittle ? a6 << 24 | b << 16 | g << 8 | r : a6 << 24 | r << 16 | g << 8 | b);
								}
							}
						}
					}
				}
			}
			if(hasHit2 == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
			}
			var ax = quadPoints_bx;
			var ay = quadPoints_by;
			var bx = quadPoints_cx;
			var by = quadPoints_cy;
			var cx = quadPoints_dx;
			var cy = quadPoints_dy;
			var hasHit1 = false;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var softAB = true;
			var softBC = true;
			var softCA = false;
			var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx;
				var by_ = by;
				bx = cx;
				by = cy;
				cx = bx_;
				cy = by_;
			}
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCA1 = softCA;
			var hasHit2 = hasHit1;
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			if(softCA1 == null) {
				softCA1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			var aA = colorC >> 24 & 255;
			var rA = colorC >> 16 & 255;
			var gA = colorC >> 8 & 255;
			var bA = colorC & 255;
			var aB = colorB >> 24 & 255;
			var rB = colorB >> 16 & 255;
			var gB = colorB >> 8 & 255;
			var bB = colorB & 255;
			var aC = colorD >> 24 & 255;
			var rC = colorD >> 16 & 255;
			var gC = colorD >> 8 & 255;
			var bC = colorD & 255;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var hitTriScalar = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
			var barycentric_yIter3;
			var barycentric_xIter3;
			var barycentric_dot22;
			var barycentric_dot12;
			var barycentric_dot11;
			var barycentric_denom1;
			var barycentric_bcy;
			var barycentric_bcx;
			var barycentric_acy;
			var barycentric_acx;
			var preCalculated = true;
			if(preCalculated == null) {
				preCalculated = true;
			}
			var barycentric_ax = hitTriScalar.ax;
			var barycentric_ay = hitTriScalar.ay;
			var barycentric_bx = hitTriScalar.bx;
			var barycentric_by = hitTriScalar.by;
			var barycentric_cx = hitTriScalar.cx;
			var barycentric_cy = hitTriScalar.cy;
			var barycentric_preCalculated = preCalculated;
			if(preCalculated) {
				barycentric_bcx = barycentric_bx - barycentric_cx;
				barycentric_bcy = barycentric_by - barycentric_cy;
				barycentric_acx = barycentric_ax - barycentric_cx;
				barycentric_acy = barycentric_ay - barycentric_cy;
				var ax1 = barycentric_bcx;
				var ay1 = barycentric_bcy;
				barycentric_dot11 = ax1 * ax1 + ay1 * ay1;
				barycentric_dot12 = barycentric_bcx * barycentric_acx + barycentric_bcy * barycentric_acy;
				var ax1 = barycentric_acx;
				var ay1 = barycentric_acy;
				barycentric_dot22 = ax1 * ax1 + ay1 * ay1;
				barycentric_denom1 = 1 / (barycentric_dot11 * barycentric_dot22 - barycentric_dot12 * barycentric_dot12);
				var a1 = barycentric_ax;
				var b1 = barycentric_bx;
				var c = barycentric_cx;
				if(a1 > b1) {
					if(a1 > c) {
						var ii_min = b1 > c ? Math.floor(c) : Math.floor(b1);
						var ii_max = Math.ceil(a1);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_xIter3 = this1;
					} else {
						var ii_min = Math.floor(b1);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_xIter3 = this1;
					}
				} else if(b1 > c) {
					var ii_min = a1 > c ? Math.floor(c) : Math.ceil(a1);
					var ii_max = Math.ceil(b1);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_xIter3 = this1;
				} else {
					var ii_min = Math.floor(a1);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_xIter3 = this1;
				}
				var a1 = barycentric_ay;
				var b1 = barycentric_by;
				var c = barycentric_cy;
				if(a1 > b1) {
					if(a1 > c) {
						var ii_min = b1 > c ? Math.floor(c) : Math.floor(b1);
						var ii_max = Math.ceil(a1);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_yIter3 = this1;
					} else {
						var ii_min = Math.floor(b1);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						barycentric_yIter3 = this1;
					}
				} else if(b1 > c) {
					var ii_min = a1 > c ? Math.floor(c) : Math.ceil(a1);
					var ii_max = Math.ceil(b1);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_yIter3 = this1;
				} else {
					var ii_min = Math.floor(a1);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					barycentric_yIter3 = this1;
				}
			}
			var scaleA = softAB1 || softCA1 ? 1.5 : 1.;
			var scaleB = softAB1 || softBC1 ? 1.5 : 1.;
			var scaleC = softBC1 || softCA1 ? 1.5 : 1.;
			var x0 = 0.;
			var y0 = 0.;
			var isScaledA = true;
			var isScaledB = true;
			var isScaledC = true;
			if(isScaledA) {
				if(isScaledB) {
					if(isScaledC) {
						x0 = (hitTriScalar.ax + hitTriScalar.bx + hitTriScalar.cx) / 3;
						y0 = (hitTriScalar.ay + hitTriScalar.by + hitTriScalar.cy) / 3;
					} else {
						x0 = hitTriScalar.cx;
						y0 = hitTriScalar.cy;
					}
				} else if(isScaledC) {
					x0 = hitTriScalar.bx;
					y0 = hitTriScalar.by;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianBCx(hitTriScalar);
					y0 = pi_$xy_algo_HitTriScalar.medianBCy(hitTriScalar);
				}
			} else if(isScaledB) {
				if(isScaledC) {
					x0 = hitTriScalar.ax;
					y0 = hitTriScalar.ay;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianCAx(hitTriScalar);
					y0 = pi_$xy_algo_HitTriScalar.medianCAy(hitTriScalar);
				}
			} else if(isScaledC) {
				x0 = pi_$xy_algo_HitTriScalar.medianABx(hitTriScalar);
				y0 = pi_$xy_algo_HitTriScalar.medianABy(hitTriScalar);
			} else {
				x0 = (hitTriScalar.ax + hitTriScalar.bx + hitTriScalar.cx) / 3;
				y0 = (hitTriScalar.ay + hitTriScalar.by + hitTriScalar.cy) / 3;
			}
			var ax_;
			if(isScaledA) {
				var point = hitTriScalar.ax;
				point -= x0;
				point *= 0.999;
				point += x0;
				ax_ = point;
			} else {
				ax_ = hitTriScalar.ax;
			}
			var ay_;
			if(isScaledA) {
				var point = hitTriScalar.ay;
				point -= y0;
				point *= 0.999;
				point += y0;
				ay_ = point;
			} else {
				ay_ = hitTriScalar.ay;
			}
			var bx_;
			if(isScaledB) {
				var point = hitTriScalar.bx;
				point -= x0;
				point *= 0.999;
				point += x0;
				bx_ = point;
			} else {
				bx_ = hitTriScalar.bx;
			}
			var by_;
			if(isScaledB) {
				var point = hitTriScalar.by;
				point -= y0;
				point *= 0.999;
				point += y0;
				by_ = point;
			} else {
				by_ = hitTriScalar.by;
			}
			var cx_;
			if(isScaledC) {
				var point = hitTriScalar.cx;
				point -= x0;
				point *= 0.999;
				point += x0;
				cx_ = point;
			} else {
				cx_ = hitTriScalar.cx;
			}
			var cy_;
			if(isScaledC) {
				var point = hitTriScalar.cy;
				point -= y0;
				point *= 0.999;
				point += y0;
				cy_ = point;
			} else {
				cy_ = hitTriScalar.cy;
			}
			var scaled = new pi_$xy_algo_HitTri(ax_,ay_,bx_,by_,cx_,cy_,true);
			var x0 = 0.;
			var y0 = 0.;
			var isScaledA = scaleA != 1.;
			var isScaledB = scaleB != 1.;
			var isScaledC = scaleC != 1.;
			if(isScaledA) {
				if(isScaledB) {
					if(isScaledC) {
						x0 = (scaled.ax + scaled.bx + scaled.cx) / 3;
						y0 = (scaled.ay + scaled.by + scaled.cy) / 3;
					} else {
						x0 = scaled.cx;
						y0 = scaled.cy;
					}
				} else if(isScaledC) {
					x0 = scaled.bx;
					y0 = scaled.by;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianBCx(scaled);
					y0 = pi_$xy_algo_HitTriScalar.medianBCy(scaled);
				}
			} else if(isScaledB) {
				if(isScaledC) {
					x0 = scaled.ax;
					y0 = scaled.ay;
				} else {
					x0 = pi_$xy_algo_HitTriScalar.medianCAx(scaled);
					y0 = pi_$xy_algo_HitTriScalar.medianCAy(scaled);
				}
			} else if(isScaledC) {
				x0 = pi_$xy_algo_HitTriScalar.medianABx(scaled);
				y0 = pi_$xy_algo_HitTriScalar.medianABy(scaled);
			} else {
				x0 = (scaled.ax + scaled.bx + scaled.cx) / 3;
				y0 = (scaled.ay + scaled.by + scaled.cy) / 3;
			}
			var ax_;
			if(isScaledA) {
				var point = scaled.ax;
				point -= x0;
				point *= scaleA;
				point += x0;
				ax_ = point;
			} else {
				ax_ = scaled.ax;
			}
			var ay_;
			if(isScaledA) {
				var point = scaled.ay;
				point -= y0;
				point *= scaleA;
				point += y0;
				ay_ = point;
			} else {
				ay_ = scaled.ay;
			}
			var bx_;
			if(isScaledB) {
				var point = scaled.bx;
				point -= x0;
				point *= scaleB;
				point += x0;
				bx_ = point;
			} else {
				bx_ = scaled.bx;
			}
			var by_;
			if(isScaledB) {
				var point = scaled.by;
				point -= y0;
				point *= scaleB;
				point += y0;
				by_ = point;
			} else {
				by_ = scaled.by;
			}
			var cx_;
			if(isScaledC) {
				var point = scaled.cx;
				point -= x0;
				point *= scaleC;
				point += x0;
				cx_ = point;
			} else {
				cx_ = scaled.cx;
			}
			var cy_;
			if(isScaledC) {
				var point = scaled.cy;
				point -= y0;
				point *= scaleC;
				point += y0;
				cy_ = point;
			} else {
				cy_ = scaled.cy;
			}
			scaled = new pi_$xy_algo_HitTri(ax_,ay_,bx_,by_,cx_,cy_,true);
			var this1 = hitTriScalar.xIter3;
			var _g_min = this1.start;
			var _g_max = this1.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var this1 = hitTriScalar.yIter3;
				var _g_min1 = this1.start;
				var _g_max1 = this1.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcx = px1 - barycentric_cx;
					var pcy = py1 - barycentric_cy;
					var dot31 = pcx * barycentric_bcx + pcy * barycentric_bcy;
					var dot32 = pcx * barycentric_acx + pcy * barycentric_acy;
					var ratioA = (barycentric_dot22 * dot31 - barycentric_dot12 * dot32) * barycentric_denom1;
					var ratioB = (barycentric_dot11 * dot32 - barycentric_dot12 * dot31) * barycentric_denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					var ratios_ratioA = ratioA;
					var ratios_ratioB = ratioB;
					var ratios_ratioC = ratioC;
					var v = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
					var min_ = v < ratios_ratioC ? v : ratios_ratioC;
					var isSoft;
					if(softAB1) {
						if(softBC1) {
							if(softCA1) {
								isSoft = true;
							} else if(min_ != ratios_ratioB) {
								var v1 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v1 < ratios_ratioC ? v1 : ratios_ratioC) == ratios_ratioC;
							} else {
								isSoft = true;
							}
						} else if(softCA1) {
							if(min_ != ratios_ratioA) {
								var v2 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v2 < ratios_ratioC ? v2 : ratios_ratioC) == ratios_ratioC;
							} else {
								isSoft = true;
							}
						} else {
							isSoft = min_ == ratios_ratioC;
						}
					} else if(softBC1) {
						if(softCA1) {
							if(min_ != ratios_ratioA) {
								var v3 = ratios_ratioA < ratios_ratioB ? ratios_ratioA : ratios_ratioB;
								isSoft = (v3 < ratios_ratioC ? v3 : ratios_ratioC) == ratios_ratioB;
							} else {
								isSoft = true;
							}
						} else {
							isSoft = min_ == ratios_ratioB;
						}
					} else {
						isSoft = softCA1 && min_ == ratios_ratioA;
					}
					var x0 = -0.0739127852035666;
					var y0 = 0.703233176253404202;
					var x1 = -0.353553390593273564;
					var y1 = 0.61237243569579447;
					var x2 = -0.572061402817684139;
					var y2 = 0.415626937777453465;
					var x3 = -0.691654801480225401;
					var y3 = 0.147015766465198733;
					var x4 = -0.691654801480225512;
					var y4 = -0.147015766465198261;
					var averageX = 0.;
					var averageY = 0.;
					var hits = 0;
					var fractionTotal = 0.;
					var x = px1 + x0;
					var y = py1 + y0;
					var tmp;
					var tmp1;
					var this2 = hitTriScalar.xIter3;
					if(x > this2.start - 1 && x < this2.max + 1) {
						var this3 = hitTriScalar.yIter3;
						tmp1 = y > this3.start - 1 && y < this3.max + 1;
					} else {
						tmp1 = false;
					}
					if(tmp1) {
						var s = hitTriScalar.s0 + hitTriScalar.sx * x + hitTriScalar.sy * y;
						var t = hitTriScalar.t0 + hitTriScalar.tx * x + hitTriScalar.ty * y;
						tmp = s <= 0 || t <= 0 ? false : s + t < hitTriScalar.A;
					} else {
						tmp = false;
					}
					if(tmp) {
						++hits;
						averageX += x0;
						averageY += y0;
						fractionTotal += 0.2;
					}
					var x5 = px1 + x1;
					var y5 = py1 + y1;
					var tmp2;
					var tmp3;
					var this4 = hitTriScalar.xIter3;
					if(x5 > this4.start - 1 && x5 < this4.max + 1) {
						var this5 = hitTriScalar.yIter3;
						tmp3 = y5 > this5.start - 1 && y5 < this5.max + 1;
					} else {
						tmp3 = false;
					}
					if(tmp3) {
						var s1 = hitTriScalar.s0 + hitTriScalar.sx * x5 + hitTriScalar.sy * y5;
						var t1 = hitTriScalar.t0 + hitTriScalar.tx * x5 + hitTriScalar.ty * y5;
						tmp2 = s1 <= 0 || t1 <= 0 ? false : s1 + t1 < hitTriScalar.A;
					} else {
						tmp2 = false;
					}
					if(tmp2) {
						++hits;
						averageX += x1;
						averageY += y1;
						fractionTotal += 0.2;
					}
					var x6 = px1 + x2;
					var y6 = py1 + y2;
					var tmp4;
					var tmp5;
					var this6 = hitTriScalar.xIter3;
					if(x6 > this6.start - 1 && x6 < this6.max + 1) {
						var this7 = hitTriScalar.yIter3;
						tmp5 = y6 > this7.start - 1 && y6 < this7.max + 1;
					} else {
						tmp5 = false;
					}
					if(tmp5) {
						var s2 = hitTriScalar.s0 + hitTriScalar.sx * x6 + hitTriScalar.sy * y6;
						var t2 = hitTriScalar.t0 + hitTriScalar.tx * x6 + hitTriScalar.ty * y6;
						tmp4 = s2 <= 0 || t2 <= 0 ? false : s2 + t2 < hitTriScalar.A;
					} else {
						tmp4 = false;
					}
					if(tmp4) {
						++hits;
						averageX += x2;
						averageY += y2;
						fractionTotal += 0.2;
					}
					var x7 = px1 + x3;
					var y7 = py1 + y3;
					var tmp6;
					var tmp7;
					var this8 = hitTriScalar.xIter3;
					if(x7 > this8.start - 1 && x7 < this8.max + 1) {
						var this9 = hitTriScalar.yIter3;
						tmp7 = y7 > this9.start - 1 && y7 < this9.max + 1;
					} else {
						tmp7 = false;
					}
					if(tmp7) {
						var s3 = hitTriScalar.s0 + hitTriScalar.sx * x7 + hitTriScalar.sy * y7;
						var t3 = hitTriScalar.t0 + hitTriScalar.tx * x7 + hitTriScalar.ty * y7;
						tmp6 = s3 <= 0 || t3 <= 0 ? false : s3 + t3 < hitTriScalar.A;
					} else {
						tmp6 = false;
					}
					if(tmp6) {
						++hits;
						averageX += x3;
						averageY += y3;
						fractionTotal += 0.2;
					}
					var x8 = px1 + x4;
					var y8 = py1 + y4;
					var tmp8;
					var tmp9;
					var this10 = hitTriScalar.xIter3;
					if(x8 > this10.start - 1 && x8 < this10.max + 1) {
						var this11 = hitTriScalar.yIter3;
						tmp9 = y8 > this11.start - 1 && y8 < this11.max + 1;
					} else {
						tmp9 = false;
					}
					if(tmp9) {
						var s4 = hitTriScalar.s0 + hitTriScalar.sx * x8 + hitTriScalar.sy * y8;
						var t4 = hitTriScalar.t0 + hitTriScalar.tx * x8 + hitTriScalar.ty * y8;
						tmp8 = s4 <= 0 || t4 <= 0 ? false : s4 + t4 < hitTriScalar.A;
					} else {
						tmp8 = false;
					}
					if(tmp8) {
						++hits;
						averageX += x4;
						averageY += y4;
						fractionTotal += 0.2;
					}
					if(hits != 0) {
						averageX = px1 + averageX / hits;
						averageY = py1 + averageY / hits;
					} else {
						averageX = px1;
						averageY = py1;
					}
					var fractionTotal1 = fractionTotal;
					var sampleData_fractionTotal = fractionTotal1;
					var sampleData_averageX = averageX;
					var sampleData_averageY = averageY;
					var sampleData_notHit = fractionTotal1 == 0.;
					var aScale = sampleData_fractionTotal;
					if(!(aScale > 0.9)) {
						aScale = aScale * 0.8 + 0.2;
					}
					a = 0;
					r = 0;
					g = 0;
					b = 0;
					if(isSoft) {
						if(!sampleData_notHit) {
							var pcx1 = sampleData_averageX - barycentric_cx;
							var pcy1 = sampleData_averageY - barycentric_cy;
							var dot311 = pcx1 * barycentric_bcx + pcy1 * barycentric_bcy;
							var dot321 = pcx1 * barycentric_acx + pcy1 * barycentric_acy;
							var ratioA1 = (barycentric_dot22 * dot311 - barycentric_dot12 * dot321) * barycentric_denom1;
							var ratioB1 = (barycentric_dot11 * dot321 - barycentric_dot12 * dot311) * barycentric_denom1;
							var ratioC1 = 1.0 - ratioB1 - ratioA1;
							var ratiosAvg_ratioA = ratioA1;
							var ratiosAvg_ratioB = ratioB1;
							var ratiosAvg_ratioC = ratioC1;
							var ratioA_ = ratiosAvg_ratioA;
							var ratioB_ = ratiosAvg_ratioB;
							var ratioC_ = ratiosAvg_ratioC;
							var i = aA * ratioA_ + aB * ratioB_ + aC * ratioC_ | 0;
							if(i > 255) {
								i = 255;
							}
							if(i < 0) {
								i = 0;
							}
							var this12 = i;
							a = this12;
							var i1 = rA * ratioA_ + rB * ratioB_ + rC * ratioC_ | 0;
							if(i1 > 255) {
								i1 = 255;
							}
							if(i1 < 0) {
								i1 = 0;
							}
							var this13 = i1;
							r = this13;
							var i2 = gA * ratioA_ + gB * ratioB_ + gC * ratioC_ | 0;
							if(i2 > 255) {
								i2 = 255;
							}
							if(i2 < 0) {
								i2 = 0;
							}
							var this14 = i2;
							g = this14;
							var i3 = bA * ratioA_ + bB * ratioB_ + bC * ratioC_ | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this15 = i3;
							b = this15;
							var a1;
							if(aScale > 0.9) {
								a1 = a;
							} else {
								var i4 = a * aScale | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this16 = i4;
								a1 = this16;
							}
							var location = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
							if(pixelImage.transparent && a1 < 254) {
								var this17 = pixelImage.image.get(location);
								var this18 = this17;
								var old = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs = a1 << 24 | r << 16 | g << 8 | b;
								var this19 = old >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old >> 16 & 255;
								var r1 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old >> 8 & 255;
								var g1 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old & 255;
								var b1 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs >> 24 & 255;
								var a2 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs >> 16 & 255;
								var r2 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs >> 8 & 255;
								var g2 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs & 255;
								var b2 = this26 == 0 ? 0. : this26 / 255;
								var a3 = a11 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								pixelImage.image.set(location,pixelImage.isLittle ? a1 << 24 | b << 16 | g << 8 | r : a1 << 24 | r << 16 | g << 8 | b);
							}
						}
					} else {
						var ratioA2 = ratios_ratioA;
						var ratioB2 = ratios_ratioB;
						var ratioC2 = ratios_ratioC;
						var hitTotal = sampleData_fractionTotal;
						if(!sampleData_notHit) {
							var x01 = -0.0739127852035666;
							var y01 = 0.703233176253404202;
							var x11 = -0.353553390593273564;
							var y11 = 0.61237243569579447;
							var x21 = -0.572061402817684139;
							var y21 = 0.415626937777453465;
							var x31 = -0.691654801480225401;
							var y31 = 0.147015766465198733;
							var x41 = -0.691654801480225512;
							var y41 = -0.147015766465198261;
							var averageX1 = 0.;
							var averageY1 = 0.;
							var hits1 = 0;
							var fractionTotal2 = 0.;
							var x9 = px1 + x01;
							var y9 = py1 + y01;
							var tmp10;
							var tmp11;
							var this27 = scaled.xIter3;
							if(x9 > this27.start - 1 && x9 < this27.max + 1) {
								var this28 = scaled.yIter3;
								tmp11 = y9 > this28.start - 1 && y9 < this28.max + 1;
							} else {
								tmp11 = false;
							}
							if(tmp11) {
								var s5 = scaled.s0 + scaled.sx * x9 + scaled.sy * y9;
								var t5 = scaled.t0 + scaled.tx * x9 + scaled.ty * y9;
								tmp10 = s5 <= 0 || t5 <= 0 ? false : s5 + t5 < scaled.A;
							} else {
								tmp10 = false;
							}
							if(tmp10) {
								++hits1;
								averageX1 += x01;
								averageY1 += y01;
								fractionTotal2 += 0.2;
							}
							var x10 = px1 + x11;
							var y10 = py1 + y11;
							var tmp12;
							var tmp13;
							var this29 = scaled.xIter3;
							if(x10 > this29.start - 1 && x10 < this29.max + 1) {
								var this30 = scaled.yIter3;
								tmp13 = y10 > this30.start - 1 && y10 < this30.max + 1;
							} else {
								tmp13 = false;
							}
							if(tmp13) {
								var s6 = scaled.s0 + scaled.sx * x10 + scaled.sy * y10;
								var t6 = scaled.t0 + scaled.tx * x10 + scaled.ty * y10;
								tmp12 = s6 <= 0 || t6 <= 0 ? false : s6 + t6 < scaled.A;
							} else {
								tmp12 = false;
							}
							if(tmp12) {
								++hits1;
								averageX1 += x11;
								averageY1 += y11;
								fractionTotal2 += 0.2;
							}
							var x12 = px1 + x21;
							var y12 = py1 + y21;
							var tmp14;
							var tmp15;
							var this31 = scaled.xIter3;
							if(x12 > this31.start - 1 && x12 < this31.max + 1) {
								var this32 = scaled.yIter3;
								tmp15 = y12 > this32.start - 1 && y12 < this32.max + 1;
							} else {
								tmp15 = false;
							}
							if(tmp15) {
								var s7 = scaled.s0 + scaled.sx * x12 + scaled.sy * y12;
								var t7 = scaled.t0 + scaled.tx * x12 + scaled.ty * y12;
								tmp14 = s7 <= 0 || t7 <= 0 ? false : s7 + t7 < scaled.A;
							} else {
								tmp14 = false;
							}
							if(tmp14) {
								++hits1;
								averageX1 += x21;
								averageY1 += y21;
								fractionTotal2 += 0.2;
							}
							var x13 = px1 + x31;
							var y13 = py1 + y31;
							var tmp16;
							var tmp17;
							var this33 = scaled.xIter3;
							if(x13 > this33.start - 1 && x13 < this33.max + 1) {
								var this34 = scaled.yIter3;
								tmp17 = y13 > this34.start - 1 && y13 < this34.max + 1;
							} else {
								tmp17 = false;
							}
							if(tmp17) {
								var s8 = scaled.s0 + scaled.sx * x13 + scaled.sy * y13;
								var t8 = scaled.t0 + scaled.tx * x13 + scaled.ty * y13;
								tmp16 = s8 <= 0 || t8 <= 0 ? false : s8 + t8 < scaled.A;
							} else {
								tmp16 = false;
							}
							if(tmp16) {
								++hits1;
								averageX1 += x31;
								averageY1 += y31;
								fractionTotal2 += 0.2;
							}
							var x14 = px1 + x41;
							var y14 = py1 + y41;
							var tmp18;
							var tmp19;
							var this35 = scaled.xIter3;
							if(x14 > this35.start - 1 && x14 < this35.max + 1) {
								var this36 = scaled.yIter3;
								tmp19 = y14 > this36.start - 1 && y14 < this36.max + 1;
							} else {
								tmp19 = false;
							}
							if(tmp19) {
								var s9 = scaled.s0 + scaled.sx * x14 + scaled.sy * y14;
								var t9 = scaled.t0 + scaled.tx * x14 + scaled.ty * y14;
								tmp18 = s9 <= 0 || t9 <= 0 ? false : s9 + t9 < scaled.A;
							} else {
								tmp18 = false;
							}
							if(tmp18) {
								++hits1;
								averageX1 += x41;
								averageY1 += y41;
								fractionTotal2 += 0.2;
							}
							if(hits1 != 0) {
								averageX1 = px1 + averageX1 / hits1;
								averageY1 = py1 + averageY1 / hits1;
							} else {
								averageX1 = px1;
								averageY1 = py1;
							}
							var fractionTotal3 = fractionTotal2;
							var sampleScaled_fractionTotal = fractionTotal3;
							var sampleScaled_averageX = averageX1;
							var sampleScaled_averageY = averageY1;
							var sampleScaled_notHit = fractionTotal3 == 0.;
							var scaledTotal = sampleScaled_fractionTotal;
							if(scaledTotal > hitTotal || hitTotal == 1.) {
								var pcx2 = sampleData_averageX - barycentric_cx;
								var pcy2 = sampleData_averageY - barycentric_cy;
								var dot312 = pcx2 * barycentric_bcx + pcy2 * barycentric_bcy;
								var dot322 = pcx2 * barycentric_acx + pcy2 * barycentric_acy;
								var ratioA3 = (barycentric_dot22 * dot312 - barycentric_dot12 * dot322) * barycentric_denom1;
								var ratioB3 = (barycentric_dot11 * dot322 - barycentric_dot12 * dot312) * barycentric_denom1;
								var ratioC3 = 1.0 - ratioB3 - ratioA3;
								var ratiosAvg_ratioA1 = ratioA3;
								var ratiosAvg_ratioB1 = ratioB3;
								var ratiosAvg_ratioC1 = ratioC3;
								var ratioA_1 = ratiosAvg_ratioA1;
								var ratioB_1 = ratiosAvg_ratioB1;
								var ratioC_1 = ratiosAvg_ratioC1;
								var i5 = aA * ratioA_1 + aB * ratioB_1 + aC * ratioC_1 | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this37 = i5;
								a = this37;
								var i6 = rA * ratioA_1 + rB * ratioB_1 + rC * ratioC_1 | 0;
								if(i6 > 255) {
									i6 = 255;
								}
								if(i6 < 0) {
									i6 = 0;
								}
								var this38 = i6;
								r = this38;
								var i7 = gA * ratioA_1 + gB * ratioB_1 + gC * ratioC_1 | 0;
								if(i7 > 255) {
									i7 = 255;
								}
								if(i7 < 0) {
									i7 = 0;
								}
								var this39 = i7;
								g = this39;
								var i8 = bA * ratioA_1 + bB * ratioB_1 + bC * ratioC_1 | 0;
								if(i8 > 255) {
									i8 = 255;
								}
								if(i8 < 0) {
									i8 = 0;
								}
								var this40 = i8;
								b = this40;
								var location1 = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
								if(pixelImage.transparent && a < 254) {
									var this41 = pixelImage.image.get(location1);
									var this42 = this41;
									var old1 = pi_$xy_Endian_isLittleEndian ? (this42 >> 24 & 255) << 24 | (this42 & 255) << 16 | (this42 >> 8 & 255) << 8 | this42 >> 16 & 255 : this42;
									var rhs1 = a << 24 | r << 16 | g << 8 | b;
									var this43 = old1 >> 24 & 255;
									var a12 = this43 == 0 ? 0. : this43 / 255;
									var this44 = old1 >> 16 & 255;
									var r11 = this44 == 0 ? 0. : this44 / 255;
									var this45 = old1 >> 8 & 255;
									var g11 = this45 == 0 ? 0. : this45 / 255;
									var this46 = old1 & 255;
									var b11 = this46 == 0 ? 0. : this46 / 255;
									var this47 = rhs1 >> 24 & 255;
									var a21 = this47 == 0 ? 0. : this47 / 255;
									var this48 = rhs1 >> 16 & 255;
									var r21 = this48 == 0 ? 0. : this48 / 255;
									var this49 = rhs1 >> 8 & 255;
									var g21 = this49 == 0 ? 0. : this49 / 255;
									var this50 = rhs1 & 255;
									var b21 = this50 == 0 ? 0. : this50 / 255;
									var a31 = a12 * (1 - a21);
									var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a5 = 255 * (a31 + a21) | 0;
									var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
									pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
								} else {
									pixelImage.image.set(location1,pixelImage.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
								}
							} else {
								var pcx3 = sampleData_averageX - barycentric_cx;
								var pcy3 = sampleData_averageY - barycentric_cy;
								var dot313 = pcx3 * barycentric_bcx + pcy3 * barycentric_bcy;
								var dot323 = pcx3 * barycentric_acx + pcy3 * barycentric_acy;
								var ratioA4 = (barycentric_dot22 * dot313 - barycentric_dot12 * dot323) * barycentric_denom1;
								var ratioB4 = (barycentric_dot11 * dot323 - barycentric_dot12 * dot313) * barycentric_denom1;
								var ratioC4 = 1.0 - ratioB4 - ratioA4;
								var ratiosAvg_ratioA2 = ratioA4;
								var ratiosAvg_ratioB2 = ratioB4;
								var ratiosAvg_ratioC2 = ratioC4;
								var ratioA_2 = ratiosAvg_ratioA2;
								var ratioB_2 = ratiosAvg_ratioB2;
								var ratioC_2 = ratiosAvg_ratioC2;
								var i9 = aA * ratioA_2 + aB * ratioB_2 + aC * ratioC_2 | 0;
								if(i9 > 255) {
									i9 = 255;
								}
								if(i9 < 0) {
									i9 = 0;
								}
								var this51 = i9;
								a = this51;
								var i10 = rA * ratioA_2 + rB * ratioB_2 + rC * ratioC_2 | 0;
								if(i10 > 255) {
									i10 = 255;
								}
								if(i10 < 0) {
									i10 = 0;
								}
								var this52 = i10;
								r = this52;
								var i11 = gA * ratioA_2 + gB * ratioB_2 + gC * ratioC_2 | 0;
								if(i11 > 255) {
									i11 = 255;
								}
								if(i11 < 0) {
									i11 = 0;
								}
								var this53 = i11;
								g = this53;
								var i12 = bA * ratioA_2 + bB * ratioB_2 + bC * ratioC_2 | 0;
								if(i12 > 255) {
									i12 = 255;
								}
								if(i12 < 0) {
									i12 = 0;
								}
								var this54 = i12;
								b = this54;
								var a6;
								if(aScale > 0.9) {
									a6 = a;
								} else {
									var i13 = a * aScale | 0;
									if(i13 > 255) {
										i13 = 255;
									}
									if(i13 < 0) {
										i13 = 0;
									}
									var this55 = i13;
									a6 = this55;
								}
								var location2 = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
								if(pixelImage.transparent && a6 < 254) {
									var this56 = pixelImage.image.get(location2);
									var this57 = this56;
									var old2 = pi_$xy_Endian_isLittleEndian ? (this57 >> 24 & 255) << 24 | (this57 & 255) << 16 | (this57 >> 8 & 255) << 8 | this57 >> 16 & 255 : this57;
									var rhs2 = a6 << 24 | r << 16 | g << 8 | b;
									var this58 = old2 >> 24 & 255;
									var a13 = this58 == 0 ? 0. : this58 / 255;
									var this59 = old2 >> 16 & 255;
									var r12 = this59 == 0 ? 0. : this59 / 255;
									var this60 = old2 >> 8 & 255;
									var g12 = this60 == 0 ? 0. : this60 / 255;
									var this61 = old2 & 255;
									var b12 = this61 == 0 ? 0. : this61 / 255;
									var this62 = rhs2 >> 24 & 255;
									var a22 = this62 == 0 ? 0. : this62 / 255;
									var this63 = rhs2 >> 16 & 255;
									var r22 = this63 == 0 ? 0. : this63 / 255;
									var this64 = rhs2 >> 8 & 255;
									var g22 = this64 == 0 ? 0. : this64 / 255;
									var this65 = rhs2 & 255;
									var b22 = this65 == 0 ? 0. : this65 / 255;
									var a32 = a13 * (1 - a22);
									var r5 = 255 * (r12 * a32 + r22 * a22) | 0;
									var g5 = 255 * (g12 * a32 + g22 * a22) | 0;
									var b5 = 255 * (b12 * a32 + b22 * a22) | 0;
									var a7 = 255 * (a32 + a22) | 0;
									var blended2 = a7 << 24 | r5 << 16 | g5 << 8 | b5;
									pixelImage.image.set(location2,pi_$xy_Endian_isLittleEndian ? (blended2 >> 24 & 255) << 24 | (blended2 & 255) << 16 | (blended2 >> 8 & 255) << 8 | blended2 >> 16 & 255 : blended2);
								} else {
									pixelImage.image.set(location2,pixelImage.isLittle ? a6 << 24 | b << 16 | g << 8 | r : a6 << 24 | r << 16 | g << 8 | b);
								}
							}
						}
					}
				}
			}
			if(hasHit2 == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
			}
			var preCalculated = hasHit;
			if(preCalculated == null) {
				preCalculated = true;
			}
			new pi_$xy_algo_HitQuad(quadPoints_ax,quadPoints_ay,quadPoints_bx,quadPoints_by,quadPoints_cx,quadPoints_cy,quadPoints_dx,quadPoints_dy,preCalculated);
		} else {
			var this1 = pixelImage;
			var colorA = this.cornerColors[0];
			var colorB = this.cornerColors[1];
			var colorC = this.cornerColors[2];
			var colorD = this.cornerColors[3];
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var hasHit = false;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var this2 = this1;
				var r_x = ax - 6. | 0;
				var r_y = ay - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = colorA;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = colorA >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = colorA >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = colorA >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = colorA & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = bx - 6. | 0;
				var r_y = by - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = colorB;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = colorB >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = colorB >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = colorB >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = colorB & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = cx - 6. | 0;
				var r_y = cy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = colorC;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = colorC >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = colorC >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = colorC >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = colorC & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = dx - 6. | 0;
				var r_y = dy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = colorD;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = colorD >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = colorD >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = colorD >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = colorD & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var aA = colorB >> 24 & 255;
			var rA = colorB >> 16 & 255;
			var gA = colorB >> 8 & 255;
			var bA = colorB & 255;
			var aB = colorA >> 24 & 255;
			var rB = colorA >> 16 & 255;
			var gB = colorA >> 8 & 255;
			var bB = colorA & 255;
			var aC = colorD >> 24 & 255;
			var rC = colorD >> 16 & 255;
			var gC = colorD >> 8 & 255;
			var bC = colorD & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = aA * ratioA + aB * ratioB + aC * ratioC | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						var a = this2;
						var i1 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						var r = this3;
						var i2 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						var g = this4;
						var i3 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
						if(i3 > 255) {
							i3 = 255;
						}
						if(i3 < 0) {
							i3 = 0;
						}
						var this5 = i3;
						var b = this5;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this6 = this1.image.get(location);
							var this7 = this6;
							var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this8 = old >> 24 & 255;
							var a1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = old >> 16 & 255;
							var r1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = old >> 8 & 255;
							var g1 = this10 == 0 ? 0. : this10 / 255;
							var this11 = old & 255;
							var b1 = this11 == 0 ? 0. : this11 / 255;
							var this12 = rhs >> 24 & 255;
							var a2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = rhs >> 16 & 255;
							var r2 = this13 == 0 ? 0. : this13 / 255;
							var this14 = rhs >> 8 & 255;
							var g2 = this14 == 0 ? 0. : this14 / 255;
							var this15 = rhs & 255;
							var b2 = this15 == 0 ? 0. : this15 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
			}
			var aA = colorC >> 24 & 255;
			var rA = colorC >> 16 & 255;
			var gA = colorC >> 8 & 255;
			var bA = colorC & 255;
			var aB = colorB >> 24 & 255;
			var rB = colorB >> 16 & 255;
			var gB = colorB >> 8 & 255;
			var bB = colorB & 255;
			var aC = colorD >> 24 & 255;
			var rC = colorD >> 16 & 255;
			var gC = colorD >> 8 & 255;
			var bC = colorD & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = aA * ratioA + aB * ratioB + aC * ratioC | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						var a = this2;
						var i1 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						var r = this3;
						var i2 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						var g = this4;
						var i3 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
						if(i3 > 255) {
							i3 = 255;
						}
						if(i3 < 0) {
							i3 = 0;
						}
						var this5 = i3;
						var b = this5;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this6 = this1.image.get(location);
							var this7 = this6;
							var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this8 = old >> 24 & 255;
							var a1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = old >> 16 & 255;
							var r1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = old >> 8 & 255;
							var g1 = this10 == 0 ? 0. : this10 / 255;
							var this11 = old & 255;
							var b1 = this11 == 0 ? 0. : this11 / 255;
							var this12 = rhs >> 24 & 255;
							var a2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = rhs >> 16 & 255;
							var r2 = this13 == 0 ? 0. : this13 / 255;
							var this14 = rhs >> 8 & 255;
							var g2 = this14 == 0 ? 0. : this14 / 255;
							var this15 = rhs & 255;
							var b2 = this15 == 0 ? 0. : this15 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
					}
				}
			}
			var v_yIter3;
			var v_xIter3;
			var v_ty;
			var v_tx;
			var v_t0;
			var v_sy;
			var v_sx;
			var v_s0;
			var v_A;
			var ax1 = bx;
			var ay1 = by;
			var preCalculated = true;
			if(preCalculated == null) {
				preCalculated = true;
			}
			var v_undoImage = null;
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var adjustWinding = ax1 * by1 - bx1 * ay1 + (bx1 * cy1 - cx1 * by1) + (cx1 * ay1 - ax1 * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var v_ax = ax1;
			var v_ay = ay1;
			var v_bx = bx1;
			var v_by = by1;
			var v_cx = cx1;
			var v_cy = cy1;
			var v_preCalculated = preCalculated;
			if(preCalculated) {
				v_s0 = v_ay * v_cx - v_ax * v_cy;
				v_sx = v_cy - v_ay;
				v_sy = v_ax - v_cx;
				v_t0 = v_ax * v_by - v_ay * v_bx;
				v_tx = v_ay - v_by;
				v_ty = v_bx - v_ax;
				v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
				var a = v_ax;
				var b = v_bx;
				var c = v_cx;
				if(a > b) {
					if(a > c) {
						var ii_min = b > c ? Math.floor(c) : Math.floor(b);
						var ii_max = Math.ceil(a);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						v_xIter3 = this1;
					} else {
						var ii_min = Math.floor(b);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						v_xIter3 = this1;
					}
				} else if(b > c) {
					var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
					var ii_max = Math.ceil(b);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					v_xIter3 = this1;
				} else {
					var ii_min = Math.floor(a);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					v_xIter3 = this1;
				}
				var a = v_ay;
				var b = v_by;
				var c = v_cy;
				if(a > b) {
					if(a > c) {
						var ii_min = b > c ? Math.floor(c) : Math.floor(b);
						var ii_max = Math.ceil(a);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						v_yIter3 = this1;
					} else {
						var ii_min = Math.floor(b);
						var ii_max = Math.ceil(c);
						var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						v_yIter3 = this1;
					}
				} else if(b > c) {
					var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
					var ii_max = Math.ceil(b);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					v_yIter3 = this1;
				} else {
					var ii_min = Math.floor(a);
					var ii_max = Math.ceil(c);
					var this1 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					v_yIter3 = this1;
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		}
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_LineGradient
});
var pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH) {
	if(deltaH == null) {
		deltaH = 0.;
	}
	if(delta == null) {
		delta = 1.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.delta = delta;
	this.deltaH = deltaH;
};
pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$.__name__ = "pi_xy.triangleGML.triGML.shape.contour.LineGridShape_";
pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$.__super__ = pi_$xy_triangleGML_triGML_BasicShape;
pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$.prototype = $extend(pi_$xy_triangleGML_triGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "delta":
			this.delta = parseFloat(value);
			break;
		case "deltaH":
			this.deltaH = parseFloat(value);
			break;
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$
});
var pi_$xy_triangleGML_LineGridShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH) {
	pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH);
};
pi_$xy_triangleGML_LineGridShape.__name__ = "pi_xy.triangleGML.LineGridShape";
pi_$xy_triangleGML_LineGridShape.__super__ = pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$;
pi_$xy_triangleGML_LineGridShape.prototype = $extend(pi_$xy_triangleGML_triGML_shape_contour_LineGridShape_$.prototype,{
	render: function(pixelImage) {
		if(this.rotation != 0. || this.skewX != 0. || this.skewY != 0. || this.scaleX != 1. || this.scaleY != 1.) {
			var width = Math.ceil(this.width);
			var height = Math.ceil(this.height);
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var temp = this1;
			temp.transparent = false;
			if(this.deltaH != 0.) {
				var this1 = temp;
				var w = this.width;
				var h = this.height;
				var deltaW = this.delta;
				var deltaH = this.deltaH;
				var thick = this.strokeWidth;
				var color = this.strokeColor;
				var h_ = Math.floor(h / deltaH) * deltaH;
				var w_ = Math.floor(w / deltaW) * deltaW;
				var _g = 0;
				var _g1 = Math.floor(w / deltaW) + 1;
				while(_g < _g1) {
					var i = _g++;
					var r_x = i * deltaW - thick / 2 | 0;
					var r_y = 0;
					var r_w = thick | 0;
					var r_h = h_ | 0;
					var xmax = r_x + r_w + 1;
					var ymax = r_y + r_h + 1;
					var ii_min = r_x;
					var ii_max = xmax;
					var xRange__start = ii_min;
					var xRange__max = ii_max;
					var ii_min1 = r_y;
					var ii_max1 = ymax;
					var yRange__start = ii_min1;
					var yRange__max = ii_max1;
					var range_x = xRange__start;
					var range_y = yRange__start - 1;
					var range_xReset = range_x;
					var range_yReset = range_y;
					var range_xMax = xRange__max - 2;
					var range_yMax = yRange__max - 2;
					var _this_min = 0;
					var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
					while(_this_min < _this_max) {
						var i1 = _this_min++;
						if(range_y > range_yMax) {
							range_y = range_yReset;
							++range_x;
						}
						++range_y;
						var i2 = i1;
						var x = range_x;
						var y = range_y;
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
					}
				}
				var _g = 0;
				var _g1 = Math.floor(h / deltaH) + 1;
				while(_g < _g1) {
					var i = _g++;
					var r_x = 0;
					var r_y = i * deltaH - thick / 2 | 0;
					var r_w = w_ | 0;
					var r_h = thick | 0;
					var xmax = r_x + r_w + 1;
					var ymax = r_y + r_h + 1;
					var ii_min = r_x;
					var ii_max = xmax;
					var xRange__start = ii_min;
					var xRange__max = ii_max;
					var ii_min1 = r_y;
					var ii_max1 = ymax;
					var yRange__start = ii_min1;
					var yRange__max = ii_max1;
					var range_x = xRange__start;
					var range_y = yRange__start - 1;
					var range_xReset = range_x;
					var range_yReset = range_y;
					var range_xMax = xRange__max - 2;
					var range_yMax = yRange__max - 2;
					var _this_min = 0;
					var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
					while(_this_min < _this_max) {
						var i1 = _this_min++;
						if(range_y > range_yMax) {
							range_y = range_yReset;
							++range_x;
						}
						++range_y;
						var i2 = i1;
						var x = range_x;
						var y = range_y;
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
					}
				}
			} else {
				var this1 = temp;
				var w = this.width;
				var h = this.height;
				var delta = this.delta;
				var thick = this.strokeWidth;
				var color = this.strokeColor;
				var h_ = Math.floor(h / delta) * delta;
				var w_ = Math.floor(w / delta) * delta;
				var _g = 0;
				var _g1 = Math.floor(w / delta) + 1;
				while(_g < _g1) {
					var i = _g++;
					var r_x = i * delta - thick / 2 | 0;
					var r_y = 0;
					var r_w = thick | 0;
					var r_h = h_ | 0;
					var xmax = r_x + r_w + 1;
					var ymax = r_y + r_h + 1;
					var ii_min = r_x;
					var ii_max = xmax;
					var xRange__start = ii_min;
					var xRange__max = ii_max;
					var ii_min1 = r_y;
					var ii_max1 = ymax;
					var yRange__start = ii_min1;
					var yRange__max = ii_max1;
					var range_x = xRange__start;
					var range_y = yRange__start - 1;
					var range_xReset = range_x;
					var range_yReset = range_y;
					var range_xMax = xRange__max - 2;
					var range_yMax = yRange__max - 2;
					var _this_min = 0;
					var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
					while(_this_min < _this_max) {
						var i1 = _this_min++;
						if(range_y > range_yMax) {
							range_y = range_yReset;
							++range_x;
						}
						++range_y;
						var i2 = i1;
						var x = range_x;
						var y = range_y;
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
					}
				}
				var _g = 0;
				var _g1 = Math.floor(h / delta) + 1;
				while(_g < _g1) {
					var i = _g++;
					var r_x = 0;
					var r_y = i * delta - thick / 2 | 0;
					var r_w = w_ | 0;
					var r_h = thick | 0;
					var xmax = r_x + r_w + 1;
					var ymax = r_y + r_h + 1;
					var ii_min = r_x;
					var ii_max = xmax;
					var xRange__start = ii_min;
					var xRange__max = ii_max;
					var ii_min1 = r_y;
					var ii_max1 = ymax;
					var yRange__start = ii_min1;
					var yRange__max = ii_max1;
					var range_x = xRange__start;
					var range_y = yRange__start - 1;
					var range_xReset = range_x;
					var range_yReset = range_y;
					var range_xMax = xRange__max - 2;
					var range_yMax = yRange__max - 2;
					var _this_min = 0;
					var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
					while(_this_min < _this_max) {
						var i1 = _this_min++;
						if(range_y > range_yMax) {
							range_y = range_yReset;
							++range_x;
						}
						++range_y;
						var i2 = i1;
						var x = range_x;
						var y = range_y;
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
					}
				}
			}
			var win_x = 0;
			var win_y = 0;
			var win_width = temp.width;
			var win_height = temp.height;
			var width = Math.ceil(this.width);
			var height = Math.ceil(this.height);
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var temp2 = this1;
			temp2.transparent = true;
			var this1 = temp2;
			var wid = temp.width;
			var hi = temp.height;
			var theta = this.rotation;
			var centreX = this.transformCentreX;
			var centreY = this.transformCentreY;
			var skewX = this.skewX;
			var skewY = this.skewY;
			var scaleX = this.scaleX;
			var scaleY = this.scaleY;
			if(scaleY == null) {
				scaleY = 1.;
			}
			if(scaleX == null) {
				scaleX = 1.;
			}
			if(skewY == null) {
				skewY = 0.;
			}
			if(skewX == null) {
				skewX = 0.;
			}
			if(centreY == null) {
				centreY = 0.;
			}
			if(centreX == null) {
				centreX = 0.;
			}
			if(theta == null) {
				theta = 0.;
			}
			var ax = 0;
			var ay = 0;
			if(theta != 0.) {
				centreX = wid / 2 + centreX;
				centreY = hi / 2 + centreY;
				ax -= centreX;
				ay -= centreY;
			}
			var bx = ax + wid;
			var by = ay;
			var cx = bx;
			var cy = ay + hi;
			var dx = ax;
			var dy = cy;
			if(skewX != 0.) {
				ax += skewX;
				bx += skewX;
				cx -= skewX;
				dx -= skewX;
			}
			if(skewY != 0.) {
				ay -= skewY;
				dy -= skewY;
				by += skewY;
				cy += skewY;
			}
			if(scaleX != 1) {
				ax *= scaleX;
				bx *= scaleX;
				cx *= scaleX;
				dx *= scaleX;
			}
			if(scaleY != 1.) {
				ay *= scaleY;
				bx *= scaleY;
				cx *= scaleY;
				dx *= scaleY;
			}
			if(theta != 0) {
				var sin = Math.sin(theta);
				var cos = Math.cos(theta);
				var temp1 = ax;
				ax = temp1 * cos - ay * sin;
				ay = ay * cos + temp1 * sin;
				var temp1 = bx;
				bx = temp1 * cos - by * sin;
				by = by * cos + temp1 * sin;
				var temp1 = cx;
				cx = temp1 * cos - cy * sin;
				cy = cy * cos + temp1 * sin;
				var temp1 = dx;
				dx = temp1 * cos - dy * sin;
				dy = dy * cos + temp1 * sin;
				ax += centreX;
				ay += centreY;
				bx += centreX;
				by += centreY;
				cx += centreX;
				cy += centreY;
				dx += centreX;
				dy += centreY;
			}
			var hasHit = true;
			if(hasHit == null) {
				hasHit = true;
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var au = 0.;
			var av = 0.;
			var bu = 1.;
			var bv = 0.;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var temp1 = au;
			au = bu;
			bu = temp1;
			temp1 = av;
			av = bv;
			bv = temp1;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var u = au * ratioA + bu * ratioB + 0. * ratioC;
						var v = av * ratioA + bv * ratioB + ratioC;
						var x = u * win_width + win_x | 0;
						var y = v * win_height + win_y | 0;
						var c = temp.image.get(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						var this2 = col;
						var c1 = this2;
						if((c1 >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = col >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = col >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = col >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = col & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
						}
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
			}
			var au = 1.;
			var av = 0.;
			var bu = 1.;
			var bv = 1.;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var temp1 = au;
			au = bu;
			bu = temp1;
			temp1 = av;
			av = bv;
			bv = temp1;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var u = au * ratioA + bu * ratioB + 0. * ratioC;
						var v = av * ratioA + bv * ratioB + ratioC;
						var x = u * win_width + win_x | 0;
						var y = v * win_height + win_y | 0;
						var c = temp.image.get(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						var this2 = col;
						var c1 = this2;
						if((c1 >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = col >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = col >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = col >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = col & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
						}
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(bx,by,cx,cy,dx,dy,true);
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp2.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp2.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp2.image.get(temp2.useVirtualPos ? (dy - temp2.virtualY) * temp2.width + dx - temp2.virtualX | 0 : dy * temp2.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp2.useMask && temp2.mask != null) {
						var this1 = temp2.mask;
						var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
							var this11 = pixelImage.image.get(location);
							var this12 = this11;
							var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			temp = null;
			temp2 = null;
		} else if(this.deltaH != 0.) {
			var this1 = pixelImage;
			var x = this.left + this.offX;
			var y = this.top + this.offY;
			var w = this.width;
			var h = this.height;
			var deltaW = this.delta;
			var deltaH = this.deltaH;
			var thick = this.strokeWidth;
			var color = this.strokeColor;
			var h_ = Math.floor(h / deltaH) * deltaH;
			var w_ = Math.floor(w / deltaW) * deltaW;
			var _g = 0;
			var _g1 = Math.floor(w / deltaW) + 1;
			while(_g < _g1) {
				var i = _g++;
				var r_x = x + i * deltaW - thick / 2 | 0;
				var r_y = y | 0;
				var r_w = thick | 0;
				var r_h = h_ | 0;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min1 = r_y;
				var ii_max1 = ymax;
				var yRange__start = ii_min1;
				var yRange__max = ii_max1;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i1 = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i2 = i1;
					var x1 = range_x;
					var y1 = range_y;
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var _g = 0;
			var _g1 = Math.floor(h / deltaH) + 1;
			while(_g < _g1) {
				var i = _g++;
				var r_x = x | 0;
				var r_y = y + i * deltaH - thick / 2 | 0;
				var r_w = w_ | 0;
				var r_h = thick | 0;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min1 = r_y;
				var ii_max1 = ymax;
				var yRange__start = ii_min1;
				var yRange__max = ii_max1;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i1 = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i2 = i1;
					var x1 = range_x;
					var y1 = range_y;
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		} else {
			var this1 = pixelImage;
			var x = this.left + this.offX;
			var y = this.top + this.offY;
			var w = this.width;
			var h = this.height;
			var delta = this.delta;
			var thick = this.strokeWidth;
			var color = this.strokeColor;
			var h_ = Math.floor(h / delta) * delta;
			var w_ = Math.floor(w / delta) * delta;
			var _g = 0;
			var _g1 = Math.floor(w / delta) + 1;
			while(_g < _g1) {
				var i = _g++;
				var r_x = x + i * delta - thick / 2 | 0;
				var r_y = y | 0;
				var r_w = thick | 0;
				var r_h = h_ | 0;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min1 = r_y;
				var ii_max1 = ymax;
				var yRange__start = ii_min1;
				var yRange__max = ii_max1;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i1 = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i2 = i1;
					var x1 = range_x;
					var y1 = range_y;
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var _g = 0;
			var _g1 = Math.floor(h / delta) + 1;
			while(_g < _g1) {
				var i = _g++;
				var r_x = x | 0;
				var r_y = y + i * delta - thick / 2 | 0;
				var r_w = w_ | 0;
				var r_h = thick | 0;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min1 = r_y;
				var ii_max1 = ymax;
				var yRange__start = ii_min1;
				var yRange__max = ii_max1;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i1 = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i2 = i1;
					var x1 = range_x;
					var y1 = range_y;
					var this2 = color;
					var c = this2;
					if((c >> 24 & 255) < 254 && this1.transparent) {
						var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
						var this3 = this1.image.get(location);
						var this4 = this3;
						var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
						var this6 = this5 >> 24 & 255;
						var a1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this5 >> 16 & 255;
						var r1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this5 >> 8 & 255;
						var g1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this5 & 255;
						var b1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 24 & 255;
						var a2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 16 & 255;
						var r2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color >> 8 & 255;
						var g2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = color & 255;
						var b2 = this13 == 0 ? 0. : this13 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this1.image.set(this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_LineGridShape
});
var pi_$xy_triangleGML_triGML_shape_contour_LineShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft) {
	if(edgeSoft == null) {
		edgeSoft = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.edgeSoft = edgeSoft;
};
pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.__name__ = "pi_xy.triangleGML.triGML.shape.contour.LineShape_";
pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.__super__ = pi_$xy_triangleGML_triGML_BasicShape;
pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.prototype = $extend(pi_$xy_triangleGML_triGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_contour_LineShape_$
});
var pi_$xy_triangleGML_LineShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft) {
	pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft);
};
pi_$xy_triangleGML_LineShape.__name__ = "pi_xy.triangleGML.LineShape";
pi_$xy_triangleGML_LineShape.__super__ = pi_$xy_triangleGML_triGML_shape_contour_LineShape_$;
pi_$xy_triangleGML_LineShape.prototype = $extend(pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.prototype,{
	setParameter: function(name,value) {
		if(name == "luxury") {
			this.luxury = StringTools.trim(value).toLowerCase() == "true";
			haxe_Log.trace("setting luxury " + value,{ fileName : "src/pi_xy/triangleGML/LineShape.hx", lineNumber : 16, className : "pi_xy.triangleGML.LineShape", methodName : "setParameter"});
		} else {
			pi_$xy_triangleGML_triGML_shape_contour_LineShape_$.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var px = this.x1 + this.offX;
		var qx = this.x2 + this.offX;
		var py = this.y1 + this.offY;
		var qy = this.y2 + this.offY;
		if(this.strokeWidth < 1.) {
			var alpha = (((this.strokeColor | 0) >> 24 & 255) / 255 - 0.000000000000001) * 0.75;
			var x0 = px;
			var y0 = py;
			var x1 = qx;
			var y1 = qy;
			var color = this.strokeColor;
			var brightRange = alpha;
			if(brightRange == null) {
				brightRange = 0.25;
			}
			var a = color >> 24 & 255;
			var r = color >> 16 & 255;
			var g = color >> 8 & 255;
			var b = color & 255;
			var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
			var temp = 0.;
			if(steep) {
				temp = y0;
				y0 = x0;
				x0 = temp;
				temp = y1;
				y1 = x1;
				x1 = temp;
			}
			if(x0 > x1) {
				temp = x1;
				x1 = x0;
				x0 = temp;
				temp = y1;
				y1 = y0;
				y0 = temp;
			}
			var dx = x1 - x0;
			var dy = y1 - y0;
			var gradient = dx == 0.0 ? 1. : dy / dx;
			var xend = Math.floor(x0) + 0.5;
			var yend = y0 + gradient * (xend - x0);
			var v = x0 + 0.5;
			var xgap = 1 - v + Math.floor(v);
			var xpxl1 = xend | 0;
			var ypxl1 = Math.floor(yend);
			var a0 = 0;
			var range = brightRange;
			var solid = 1 - range;
			if(steep) {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (xpxl1 - pixelImage.virtualY) * pixelImage.width + ypxl1 - pixelImage.virtualX | 0 : xpxl1 * pixelImage.width + ypxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var x = ypxl1 + 1;
				var location = pixelImage.useVirtualPos ? (xpxl1 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : xpxl1 * pixelImage.width + x | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			} else {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (ypxl1 - pixelImage.virtualY) * pixelImage.width + xpxl1 - pixelImage.virtualX | 0 : ypxl1 * pixelImage.width + xpxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var y = ypxl1 + 1;
				var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + xpxl1 - pixelImage.virtualX | 0 : y * pixelImage.width + xpxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			}
			var intery = yend + gradient;
			var xend = Math.floor(x1) + 0.5;
			var yend = y1 + gradient * (xend - x1);
			var v = x1 + 0.5;
			var xgap = v - Math.floor(v);
			var xpxl2 = xend | 0;
			var ypxl2 = Math.floor(yend);
			if(steep) {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (xpxl2 - pixelImage.virtualY) * pixelImage.width + ypxl2 - pixelImage.virtualX | 0 : xpxl2 * pixelImage.width + ypxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var x = ypxl2 + 1;
				var location = pixelImage.useVirtualPos ? (xpxl2 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : xpxl2 * pixelImage.width + x | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			} else {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (ypxl2 - pixelImage.virtualY) * pixelImage.width + xpxl2 - pixelImage.virtualX | 0 : ypxl2 * pixelImage.width + xpxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var y = ypxl2 + 1;
				var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + xpxl2 - pixelImage.virtualX | 0 : y * pixelImage.width + xpxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			}
			var startX = xpxl1 + 1;
			var endX = xpxl2 + 1;
			if(steep) {
				var _g = startX;
				var _g1 = endX;
				while(_g < _g1) {
					var x = _g++;
					var i = a * solid + range * a * (1 - intery + Math.floor(intery)) | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					a0 = this1;
					var x1 = Math.floor(intery);
					var location = pixelImage.useVirtualPos ? (x - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : x * pixelImage.width + x1 | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this2 = pixelImage.image.get(location);
						var this3 = this2;
						var old = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var rhs = a0 << 24 | r << 16 | g << 8 | b;
						var this4 = old >> 24 & 255;
						var a1 = this4 == 0 ? 0. : this4 / 255;
						var this5 = old >> 16 & 255;
						var r1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = old >> 8 & 255;
						var g1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = old & 255;
						var b1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = rhs >> 24 & 255;
						var a2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = rhs >> 16 & 255;
						var r2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = rhs >> 8 & 255;
						var g2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs & 255;
						var b2 = this11 == 0 ? 0. : this11 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					var i1 = a * solid + range * a * (intery - Math.floor(intery)) | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this12 = i1;
					a0 = this12;
					var x2 = Math.floor(intery) + 1;
					var location1 = pixelImage.useVirtualPos ? (x - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : x * pixelImage.width + x2 | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this13 = pixelImage.image.get(location1);
						var this14 = this13;
						var old1 = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
						var rhs1 = a0 << 24 | r << 16 | g << 8 | b;
						var this15 = old1 >> 24 & 255;
						var a11 = this15 == 0 ? 0. : this15 / 255;
						var this16 = old1 >> 16 & 255;
						var r11 = this16 == 0 ? 0. : this16 / 255;
						var this17 = old1 >> 8 & 255;
						var g11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = old1 & 255;
						var b11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = rhs1 >> 24 & 255;
						var a21 = this19 == 0 ? 0. : this19 / 255;
						var this20 = rhs1 >> 16 & 255;
						var r21 = this20 == 0 ? 0. : this20 / 255;
						var this21 = rhs1 >> 8 & 255;
						var g21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = rhs1 & 255;
						var b21 = this22 == 0 ? 0. : this22 / 255;
						var a31 = a11 * (1 - a21);
						var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
					} else {
						pixelImage.image.set(location1,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					intery += gradient;
				}
			} else {
				var _g = startX;
				var _g1 = endX;
				while(_g < _g1) {
					var x = _g++;
					var i = a * solid + range * a * (1 - intery + Math.floor(intery)) | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					a0 = this1;
					var y = Math.floor(intery);
					var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this2 = pixelImage.image.get(location);
						var this3 = this2;
						var old = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var rhs = a0 << 24 | r << 16 | g << 8 | b;
						var this4 = old >> 24 & 255;
						var a1 = this4 == 0 ? 0. : this4 / 255;
						var this5 = old >> 16 & 255;
						var r1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = old >> 8 & 255;
						var g1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = old & 255;
						var b1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = rhs >> 24 & 255;
						var a2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = rhs >> 16 & 255;
						var r2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = rhs >> 8 & 255;
						var g2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs & 255;
						var b2 = this11 == 0 ? 0. : this11 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					var i1 = a * solid + range * a * (intery - Math.floor(intery)) | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this12 = i1;
					a0 = this12;
					var y1 = Math.floor(intery) + 1;
					var location1 = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y1 * pixelImage.width + x | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this13 = pixelImage.image.get(location1);
						var this14 = this13;
						var old1 = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
						var rhs1 = a0 << 24 | r << 16 | g << 8 | b;
						var this15 = old1 >> 24 & 255;
						var a11 = this15 == 0 ? 0. : this15 / 255;
						var this16 = old1 >> 16 & 255;
						var r11 = this16 == 0 ? 0. : this16 / 255;
						var this17 = old1 >> 8 & 255;
						var g11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = old1 & 255;
						var b11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = rhs1 >> 24 & 255;
						var a21 = this19 == 0 ? 0. : this19 / 255;
						var this20 = rhs1 >> 16 & 255;
						var r21 = this20 == 0 ? 0. : this20 / 255;
						var this21 = rhs1 >> 8 & 255;
						var g21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = rhs1 & 255;
						var b21 = this22 == 0 ? 0. : this22 / 255;
						var a31 = a11 * (1 - a21);
						var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
					} else {
						pixelImage.image.set(location1,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					intery += gradient;
				}
			}
			var x0 = px;
			var y0 = px;
			var x1 = qx;
			var y1 = qy;
			var color = this.strokeColor;
			var brightRange = alpha;
			if(brightRange == null) {
				brightRange = 0.25;
			}
			var a = color >> 24 & 255;
			var r = color >> 16 & 255;
			var g = color >> 8 & 255;
			var b = color & 255;
			var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
			var temp = 0.;
			if(steep) {
				temp = y0;
				y0 = x0;
				x0 = temp;
				temp = y1;
				y1 = x1;
				x1 = temp;
			}
			if(x0 > x1) {
				temp = x1;
				x1 = x0;
				x0 = temp;
				temp = y1;
				y1 = y0;
				y0 = temp;
			}
			var dx = x1 - x0;
			var dy = y1 - y0;
			var gradient = dx == 0.0 ? 1. : dy / dx;
			var xend = Math.floor(x0) + 0.5;
			var yend = y0 + gradient * (xend - x0);
			var v = x0 + 0.5;
			var xgap = 1 - v + Math.floor(v);
			var xpxl1 = xend | 0;
			var ypxl1 = Math.floor(yend);
			var a0 = 0;
			var range = brightRange;
			var solid = 1 - range;
			if(steep) {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (xpxl1 - pixelImage.virtualY) * pixelImage.width + ypxl1 - pixelImage.virtualX | 0 : xpxl1 * pixelImage.width + ypxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var x = ypxl1 + 1;
				var location = pixelImage.useVirtualPos ? (xpxl1 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : xpxl1 * pixelImage.width + x | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			} else {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (ypxl1 - pixelImage.virtualY) * pixelImage.width + xpxl1 - pixelImage.virtualX | 0 : ypxl1 * pixelImage.width + xpxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var y = ypxl1 + 1;
				var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + xpxl1 - pixelImage.virtualX | 0 : y * pixelImage.width + xpxl1 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			}
			var intery = yend + gradient;
			var xend = Math.floor(x1) + 0.5;
			var yend = y1 + gradient * (xend - x1);
			var v = x1 + 0.5;
			var xgap = v - Math.floor(v);
			var xpxl2 = xend | 0;
			var ypxl2 = Math.floor(yend);
			if(steep) {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (xpxl2 - pixelImage.virtualY) * pixelImage.width + ypxl2 - pixelImage.virtualX | 0 : xpxl2 * pixelImage.width + ypxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var x = ypxl2 + 1;
				var location = pixelImage.useVirtualPos ? (xpxl2 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : xpxl2 * pixelImage.width + x | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			} else {
				var i = a * solid + range * a * ((1 - yend + Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var location = pixelImage.useVirtualPos ? (ypxl2 - pixelImage.virtualY) * pixelImage.width + xpxl2 - pixelImage.virtualX | 0 : ypxl2 * pixelImage.width + xpxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
				var i = a * solid + range * a * ((yend - Math.floor(yend)) * xgap) | 0;
				if(i > 255) {
					i = 255;
				}
				if(i < 0) {
					i = 0;
				}
				var this1 = i;
				a0 = this1;
				var y = ypxl2 + 1;
				var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + xpxl2 - pixelImage.virtualX | 0 : y * pixelImage.width + xpxl2 | 0;
				if(pixelImage.transparent && a0 < 254) {
					var this1 = pixelImage.image.get(location);
					var this2 = this1;
					var old = pi_$xy_Endian_isLittleEndian ? (this2 >> 24 & 255) << 24 | (this2 & 255) << 16 | (this2 >> 8 & 255) << 8 | this2 >> 16 & 255 : this2;
					var rhs = a0 << 24 | r << 16 | g << 8 | b;
					var this1 = old >> 24 & 255;
					var a1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 16 & 255;
					var r1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old >> 8 & 255;
					var g1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = old & 255;
					var b1 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 24 & 255;
					var a2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 16 & 255;
					var r2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs >> 8 & 255;
					var g2 = this1 == 0 ? 0. : this1 / 255;
					var this1 = rhs & 255;
					var b2 = this1 == 0 ? 0. : this1 / 255;
					var a3 = a1 * (1 - a2);
					var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
					var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
					var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
					var a1 = 255 * (a3 + a2) | 0;
					var blended = a1 << 24 | r3 << 16 | g3 << 8 | b3;
					pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
				}
			}
			var startX = xpxl1 + 1;
			var endX = xpxl2 + 1;
			if(steep) {
				var _g = startX;
				var _g1 = endX;
				while(_g < _g1) {
					var x = _g++;
					var i = a * solid + range * a * (1 - intery + Math.floor(intery)) | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					a0 = this1;
					var x1 = Math.floor(intery);
					var location = pixelImage.useVirtualPos ? (x - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : x * pixelImage.width + x1 | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this2 = pixelImage.image.get(location);
						var this3 = this2;
						var old = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var rhs = a0 << 24 | r << 16 | g << 8 | b;
						var this4 = old >> 24 & 255;
						var a1 = this4 == 0 ? 0. : this4 / 255;
						var this5 = old >> 16 & 255;
						var r1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = old >> 8 & 255;
						var g1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = old & 255;
						var b1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = rhs >> 24 & 255;
						var a2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = rhs >> 16 & 255;
						var r2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = rhs >> 8 & 255;
						var g2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs & 255;
						var b2 = this11 == 0 ? 0. : this11 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					var i1 = a * solid + range * a * (intery - Math.floor(intery)) | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this12 = i1;
					a0 = this12;
					var x2 = Math.floor(intery) + 1;
					var location1 = pixelImage.useVirtualPos ? (x - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : x * pixelImage.width + x2 | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this13 = pixelImage.image.get(location1);
						var this14 = this13;
						var old1 = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
						var rhs1 = a0 << 24 | r << 16 | g << 8 | b;
						var this15 = old1 >> 24 & 255;
						var a11 = this15 == 0 ? 0. : this15 / 255;
						var this16 = old1 >> 16 & 255;
						var r11 = this16 == 0 ? 0. : this16 / 255;
						var this17 = old1 >> 8 & 255;
						var g11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = old1 & 255;
						var b11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = rhs1 >> 24 & 255;
						var a21 = this19 == 0 ? 0. : this19 / 255;
						var this20 = rhs1 >> 16 & 255;
						var r21 = this20 == 0 ? 0. : this20 / 255;
						var this21 = rhs1 >> 8 & 255;
						var g21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = rhs1 & 255;
						var b21 = this22 == 0 ? 0. : this22 / 255;
						var a31 = a11 * (1 - a21);
						var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
					} else {
						pixelImage.image.set(location1,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					intery += gradient;
				}
			} else {
				var _g = startX;
				var _g1 = endX;
				while(_g < _g1) {
					var x = _g++;
					var i = a * solid + range * a * (1 - intery + Math.floor(intery)) | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					a0 = this1;
					var y = Math.floor(intery);
					var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this2 = pixelImage.image.get(location);
						var this3 = this2;
						var old = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var rhs = a0 << 24 | r << 16 | g << 8 | b;
						var this4 = old >> 24 & 255;
						var a1 = this4 == 0 ? 0. : this4 / 255;
						var this5 = old >> 16 & 255;
						var r1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = old >> 8 & 255;
						var g1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = old & 255;
						var b1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = rhs >> 24 & 255;
						var a2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = rhs >> 16 & 255;
						var r2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = rhs >> 8 & 255;
						var g2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs & 255;
						var b2 = this11 == 0 ? 0. : this11 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pixelImage.image.set(location,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					var i1 = a * solid + range * a * (intery - Math.floor(intery)) | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this12 = i1;
					a0 = this12;
					var y1 = Math.floor(intery) + 1;
					var location1 = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y1 * pixelImage.width + x | 0;
					if(pixelImage.transparent && a0 < 254) {
						var this13 = pixelImage.image.get(location1);
						var this14 = this13;
						var old1 = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
						var rhs1 = a0 << 24 | r << 16 | g << 8 | b;
						var this15 = old1 >> 24 & 255;
						var a11 = this15 == 0 ? 0. : this15 / 255;
						var this16 = old1 >> 16 & 255;
						var r11 = this16 == 0 ? 0. : this16 / 255;
						var this17 = old1 >> 8 & 255;
						var g11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = old1 & 255;
						var b11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = rhs1 >> 24 & 255;
						var a21 = this19 == 0 ? 0. : this19 / 255;
						var this20 = rhs1 >> 16 & 255;
						var r21 = this20 == 0 ? 0. : this20 / 255;
						var this21 = rhs1 >> 8 & 255;
						var g21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = rhs1 & 255;
						var b21 = this22 == 0 ? 0. : this22 / 255;
						var a31 = a11 * (1 - a21);
						var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
					} else {
						pixelImage.image.set(location1,pixelImage.isLittle ? a0 << 24 | b << 16 | g << 8 | r : a0 << 24 | r << 16 | g << 8 | b);
					}
					intery += gradient;
				}
			}
		} else if(this.edgeSoft == 0.) {
			var this1 = pixelImage;
			var color = this.strokeColor;
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var this2 = this1;
				var r_x = ax - 6. | 0;
				var r_y = ay - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -65536;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = bx - 6. | 0;
				var r_y = by - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16711936;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = cx - 6. | 0;
				var r_y = cy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16776961;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = dx - 6. | 0;
				var r_y = dy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -1048336;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 240;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		} else if(this.luxury) {
			var this1 = pixelImage;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			if(soft == null) {
				soft = 40;
			}
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var soft1 = soft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft1 == null) {
				soft1 = 40.;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var this2 = this1;
				var r_x = ax - 6. | 0;
				var r_y = ay - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -65536;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = bx - 6. | 0;
				var r_y = by - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16711936;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = cx - 6. | 0;
				var r_y = cy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16776961;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = dx - 6. | 0;
				var r_y = dy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -1048336;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 240;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var soft = soft1;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = softBC1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - cx;
			var bcy = by - cy;
			var acx = ax - cx;
			var acy = ay - cy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > cx) {
					var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > cy) {
					var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - cx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - cy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softCD1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - ax;
			var bcy = cy - ay;
			var acx = dx - ax;
			var acy = dy - ay;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(dx > cx) {
				if(dx > ax) {
					var ii_min = cx > ax ? Math.floor(ax) : Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > ax) {
				var ii_min = dx > ax ? Math.floor(ax) : Math.ceil(dx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(dx);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(dy > cy) {
				if(dy > ay) {
					var ii_min = cy > ay ? Math.floor(ay) : Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > ay) {
				var ii_min = dy > ay ? Math.floor(ay) : Math.ceil(dy);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(dy);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - ax;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - ay;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(dx,dy,cx,cy,ax,ay,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py1 - this1.virtualY) * this1.width + px1 - this1.virtualX | 0 : py1 * this1.width + px1 | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		} else {
			haxe_Log.trace("luxury!!",{ fileName : "src/pi_xy/triangleGML/LineShape.hx", lineNumber : 39, className : "pi_xy.triangleGML.LineShape", methodName : "render"});
			var this1 = pixelImage;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			if(soft == null) {
				soft = 40;
			}
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var soft1 = soft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft1 == null) {
				soft1 = 40.;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var this2 = this1;
				var r_x = ax - 6. | 0;
				var r_y = ay - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -65536;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = bx - 6. | 0;
				var r_y = by - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16711936;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 0;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = cx - 6. | 0;
				var r_y = cy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -16776961;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
				var this2 = this1;
				var r_x = dx - 6. | 0;
				var r_y = dy - 6. | 0;
				var r_w = 12;
				var r_h = 12;
				var xmax = r_x + r_w + 1;
				var ymax = r_y + r_h + 1;
				var ii_min = r_x;
				var ii_max = xmax;
				var xRange__start = ii_min;
				var xRange__max = ii_max;
				var ii_min = r_y;
				var ii_max = ymax;
				var yRange__start = ii_min;
				var yRange__max = ii_max;
				var range_x = xRange__start;
				var range_y = yRange__start - 1;
				var range_xReset = range_x;
				var range_yReset = range_y;
				var range_xMax = xRange__max - 2;
				var range_yMax = yRange__max - 2;
				var _this_min = 0;
				var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
				while(_this_min < _this_max) {
					var i = _this_min++;
					if(range_y > range_yMax) {
						range_y = range_yReset;
						++range_x;
					}
					++range_y;
					var i1 = i;
					var x = range_x;
					var y = range_y;
					var this3 = -1048336;
					var c = this3;
					if((c >> 24 & 255) < 254 && this2.transparent) {
						var location = this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0;
						var this4 = this2.image.get(location);
						var this5 = this4;
						var this6 = pi_$xy_Endian_isLittleEndian ? (this5 >> 24 & 255) << 24 | (this5 & 255) << 16 | (this5 >> 8 & 255) << 8 | this5 >> 16 & 255 : this5;
						var this7 = this6 >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this6 >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = this6 >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this6 & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = 0;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = 240;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this2.image.set(this2.useVirtualPos ? (y - this2.virtualY) * this2.width + x - this2.virtualX | 0 : y * this2.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			var soft = soft1;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this2 = i;
									a = this2;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this3 = i1;
									a = this3;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this4 = i2;
								a = this4;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this5 = i3;
								a = this5;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this6 = i4;
								a = this6;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this7 = i5;
								a = this7;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this8 = i6;
							a = this8;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this9 = i7;
							a = this9;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this10 = i8;
						r = this10;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this11 = i9;
						g = this11;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this12 = i10;
						b = this12;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this13 = this1.image.get(location);
							var this14 = this13;
							var old = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this15 = old >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = old & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = rhs & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this2 = i;
									a = this2;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this3 = i1;
									a = this3;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this4 = i2;
								a = this4;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this5 = i3;
								a = this5;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this6 = i4;
								a = this6;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this7 = i5;
								a = this7;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this8 = i6;
							a = this8;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this9 = i7;
							a = this9;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this10 = i8;
						r = this10;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this11 = i9;
						g = this11;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this12 = i10;
						b = this12;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this13 = this1.image.get(location);
							var this14 = this13;
							var old = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this15 = old >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = old & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = rhs & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pi_$xy_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		}
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_LineShape
});
var pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded) {
	if(rounded == null) {
		rounded = false;
	}
	if(pictureHeight == null) {
		pictureHeight = 0.;
	}
	if(pictureWidth == null) {
		pictureWidth = 0.;
	}
	if(pictureY == null) {
		pictureY = 0.;
	}
	if(pictureX == null) {
		pictureX = 0.;
	}
	if(newTall == null) {
		newTall = 3.;
	}
	if(newFat == null) {
		newFat = 3.;
	}
	if(newTop == null) {
		newTop = 0.5;
	}
	if(newLeft == null) {
		newLeft = 0.5;
	}
	if(newHi == null) {
		newHi = 4.;
	}
	if(newWid == null) {
		newWid = 4.;
	}
	if(initTall == null) {
		initTall = 2.;
	}
	if(initFat == null) {
		initFat = 2.;
	}
	if(initTop == null) {
		initTop = 1.;
	}
	if(initLeft == null) {
		initLeft = 1.;
	}
	if(initHi == null) {
		initHi = 4.;
	}
	if(initWid == null) {
		initWid = 4.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.initWid = initWid;
	this.initHi = initHi;
	this.initLeft = initLeft;
	this.initTop = initTop;
	this.initFat = initFat;
	this.initTall = initTall;
	this.newWid = newWid;
	this.newHi = newHi;
	this.newLeft = newLeft;
	this.newTop = newTop;
	this.newFat = newFat;
	this.newTall = newTall;
	this.imageTexture = imageTexture;
	this.pictureX = pictureX;
	this.pictureY = pictureY;
	this.pictureWidth = pictureWidth;
	this.pictureHeight = pictureHeight;
	this.rounded = rounded;
};
pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$.__name__ = "pi_xy.triangleGML.triGML.shape.picture.NineSlicePicture_";
pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$.__super__ = pi_$xy_triangleGML_triGML_FillForm;
pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$.prototype = $extend(pi_$xy_triangleGML_triGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "initFat":
			this.initFat = parseFloat(value);
			break;
		case "initHi":
			this.initHi = parseFloat(value);
			break;
		case "initLeft":
			this.initLeft = parseFloat(value);
			break;
		case "initTall":
			this.initTall = parseFloat(value);
			break;
		case "initTop":
			this.initTop = parseFloat(value);
			break;
		case "initWid":
			this.initWid = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "newFat":
			this.newFat = parseFloat(value);
			break;
		case "newHi":
			this.newHi = parseFloat(value);
			break;
		case "newLeft":
			this.newLeft = parseFloat(value);
			break;
		case "newTall":
			this.newTall = parseFloat(value);
			break;
		case "newTop":
			this.newTop = parseFloat(value);
			break;
		case "newWid":
			this.newWid = parseFloat(value);
			break;
		case "pictureHeight":
			this.pictureHeight = parseFloat(value);
			break;
		case "pictureWidth":
			this.pictureWidth = parseFloat(value);
			break;
		case "pictureX":
			this.pictureX = parseFloat(value);
			break;
		case "pictureY":
			this.pictureY = parseFloat(value);
			break;
		case "rounded":
			this.rounded = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$
});
var pi_$xy_triangleGML_NineSlicePicture = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded) {
	pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded);
};
pi_$xy_triangleGML_NineSlicePicture.__name__ = "pi_xy.triangleGML.NineSlicePicture";
pi_$xy_triangleGML_NineSlicePicture.__super__ = pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$;
pi_$xy_triangleGML_NineSlicePicture.prototype = $extend(pi_$xy_triangleGML_triGML_shape_picture_NineSlicePicture_$.prototype,{
	render: function(pixelImage) {
		if(this.imageTexture != null) {
			var win_x = 0;
			var win_y = 0;
			var win_width = this.imageTexture.width;
			var win_height = this.imageTexture.height;
			win_x = this.pictureX;
			win_y = this.pictureY;
			if(this.pictureWidth != 0.) {
				win_width = this.pictureWidth;
			}
			if(this.pictureHeight != 0.) {
				win_height = this.pictureHeight;
			}
			if(this.rounded != true) {
				var this1 = pixelImage;
				var texture = this.imageTexture;
				var x = this.left;
				var y = this.top;
				var wid = this.initWid;
				var hi = this.initHi;
				var left = this.initLeft;
				var top = this.initTop;
				var fat = this.initFat;
				var tall = this.initTall;
				var widNew = this.newWid;
				var hiNew = this.newHi;
				var leftNew = this.newLeft;
				var topNew = this.newTop;
				var fatNew = this.newFat;
				var tallNew = this.newTall;
				var width = wid | 0;
				var height = hi | 0;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var tmp;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y1 = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x1 = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					tmp = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					tmp = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					tmp = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					tmp = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					tmp = b;
					break;
				}
				this2.image = tmp;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				var temp = this2;
				temp.transparent = false;
				var hasHit = false;
				if(hasHit == null) {
					hasHit = false;
				}
				var ax = 0;
				var ay = 0;
				var bx = ax + widNew;
				var by = 0;
				var cx = bx;
				var cy = ay + hiNew;
				var dx = 0;
				var dy = cx;
				var rightW = widNew - leftNew - fatNew;
				var bottomH = hiNew - topNew - tallNew;
				var leftX = leftNew;
				var topY = topNew;
				var rightX = leftNew + fatNew;
				var bottomY = topNew + tallNew;
				var au = 0.;
				var av = 0.;
				var bu = 0.;
				var cv = 0.;
				var sw = 1 / (wid + 1);
				var sh = 1 / (hi + 1);
				bu = left * sw;
				cv = top * sh;
				var au1 = 0.;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0.;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = 0 - topY;
				var acx = 0;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(0,0,leftX,0,0,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = topY - topY;
				var acx = leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,0,leftX,topY,0,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(0,0,leftX,0,leftX,topY,0,topY,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var au1 = au;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0.;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = 0 - topY;
				var acx = leftX - leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,0,rightX,0,leftX,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = topY - topY;
				var acx = rightX - leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,0,rightX,topY,leftX,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(leftX,0,rightX,0,rightX,topY,leftX,topY,true);
				}
				au = bu;
				bu = 1.;
				var bx1 = widNew;
				var cx1 = widNew;
				var au1 = au;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = 0 - topY;
				var acx = rightX - rightX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,0,bx1,0,rightX,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = topY - topY;
				var acx = bx1 - rightX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(bx1,0,cx1,topY,rightX,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(rightX,0,bx1,0,cx1,topY,rightX,topY,true);
				}
				av = top * sh;
				bu = left * sw;
				cv = (top + tall) * sh;
				var ay1 = topY - 1;
				var by1 = topY - 1;
				var cy1 = bottomY + 1;
				var au1 = 0.;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = by1 - bottomY;
				var acx = 0;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(0,ay1,leftX,by1,0,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = cy1 - bottomY;
				var acx = leftX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,by1,leftX,cy1,0,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(0,ay1,leftX,by1,leftX,cy1,0,bottomY,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var ay1 = topY - 1;
				var by1 = topY - 1;
				var cy1 = bottomY + 1;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = by1 - bottomY;
				var acx = leftX - leftX;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,ay1,rightX,by1,leftX,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = cy1 - bottomY;
				var acx = rightX - leftX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,by1,rightX,cy1,leftX,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(leftX,ay1,rightX,by1,rightX,cy1,leftX,bottomY,true);
				}
				au = bu;
				bu = 1.;
				var ay1 = topY - 1;
				var bx1 = widNew;
				var by1 = topY - 1;
				var cx1 = widNew;
				var cy1 = bottomY + 1;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = by1 - bottomY;
				var acx = rightX - rightX;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,ay1,bx1,by1,rightX,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = cy1 - bottomY;
				var acx = bx1 - rightX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(bx1,by1,cx1,cy1,rightX,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(rightX,ay1,bx1,by1,cx1,cy1,rightX,bottomY,true);
				}
				av = (top + tall) * sh;
				bu = left * sw;
				cv = 1.;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = 0.;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = bottomY - dy1;
				var acx = 0;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(0,bottomY,leftX,bottomY,0,dy1,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = cy1 - dy1;
				var acx = leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,bottomY,leftX,cy1,0,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(0,bottomY,leftX,bottomY,leftX,cy1,0,dy1,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = bottomY - dy1;
				var acx = leftX - leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(leftX,bottomY,rightX,bottomY,leftX,dy1,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = cy1 - dy1;
				var acx = rightX - leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,bottomY,rightX,cy1,leftX,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(leftX,bottomY,rightX,bottomY,rightX,cy1,leftX,dy1,true);
				}
				au = bu;
				bu = 1.;
				var bx1 = widNew;
				var cx1 = widNew;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au = au1;
				var av = av1;
				var bu = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au;
				au = bu;
				bu = temp1;
				temp1 = av;
				av = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = bottomY - dy1;
				var acx = rightX - rightX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au * ratioA + bu * ratioB + du * ratioC;
							var v = av * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(rightX,bottomY,bx1,bottomY,rightX,dy1,true);
				}
				var au = bu1;
				var av = bv;
				var bu = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au;
				au = bu;
				bu = temp1;
				temp1 = av;
				av = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = cy1 - dy1;
				var acx = bx1 - rightX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this2;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this2;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au * ratioA + bu * ratioB + du * ratioC;
							var v = av * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image.get(texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this2 = col;
							var c1 = this2;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this3 = temp.image.get(location);
								var this4 = this3;
								var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = col & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								temp.image.set(temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pi_$xy_algo_HitTri(bx1,bottomY,cx1,cy1,rightX,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pi_$xy_algo_HitQuad(rightX,bottomY,bx1,bottomY,cx1,cy1,rightX,dy1,true);
				}
				var hit;
				if(hasHit == true) {
					var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hit = v;
				} else {
					hit = null;
				}
				var x1 = x | 0;
				var y1 = y | 0;
				var _g = 0;
				var _g1 = temp.height;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = 0;
					var _g3 = temp.width;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this2 = temp.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x2 = x1 + dx;
							var y2 = y1 + dy;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && this1.transparent) {
								var location = this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0;
								var this12 = this1.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
				temp = null;
				if(hit != null) {
					hit.ax += x;
					hit.ay += y;
					hit.bx += x;
					hit.by += y;
					hit.cx += x;
					hit.cy += y;
					hit.dx += x;
					hit.dy += y;
				}
			} else {
				throw haxe_Exception.thrown("not yet implemented");
			}
		}
		return pixelImage;
	}
	,setImage: function(name,value) {
		if(name.toLowerCase() == "imagetexture") {
			if(value == null) {
				throw haxe_Exception.thrown("failed to find image resource" + name);
			}
			this.imageTexture = value;
		}
		return value;
	}
	,__class__: pi_$xy_triangleGML_NineSlicePicture
});
var pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$ = function(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY) {
	if(dY == null) {
		dY = 1.;
	}
	if(dX == null) {
		dX = 0.;
	}
	if(cY == null) {
		cY = 1.;
	}
	if(cX == null) {
		cX = 1.;
	}
	if(bY == null) {
		bY = 0.;
	}
	if(bX == null) {
		bX = 1.;
	}
	if(aY == null) {
		aY = 0.;
	}
	if(aX == null) {
		aX = 0.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_BasicShape.call(this,opacity,visibility,strokeColor,0.,null);
	this.aX = aX;
	this.aY = aY;
	this.bX = bX;
	this.bY = bY;
	this.cX = cX;
	this.cY = cY;
	this.dX = dX;
	this.dY = dY;
};
pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.__name__ = "pi_xy.triangleGML.triGML.shape.contour.QuadShape_";
pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.__super__ = pi_$xy_triangleGML_triGML_BasicShape;
pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.prototype = $extend(pi_$xy_triangleGML_triGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "aX":
			this.aX = parseFloat(value);
			break;
		case "aY":
			this.aY = parseFloat(value);
			break;
		case "bX":
			this.bX = parseFloat(value);
			break;
		case "bY":
			this.bY = parseFloat(value);
			break;
		case "cX":
			this.cX = parseFloat(value);
			break;
		case "cY":
			this.cY = parseFloat(value);
			break;
		case "dX":
			this.dX = parseFloat(value);
			break;
		case "dY":
			this.dY = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$
});
var pi_$xy_triangleGML_QuadShape = function(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY) {
	pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.call(this,opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY);
};
pi_$xy_triangleGML_QuadShape.__name__ = "pi_xy.triangleGML.QuadShape";
pi_$xy_triangleGML_QuadShape.__super__ = pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$;
pi_$xy_triangleGML_QuadShape.prototype = $extend(pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.prototype,{
	setParameter: function(name,value) {
		if(name == "luxury") {
			this.luxury = StringTools.trim(value).toLowerCase() == "true";
		} else {
			pi_$xy_triangleGML_triGML_shape_contour_QuadShape_$.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var tmp;
		if(this.edgeSoft == 0.) {
			var this1 = pixelImage;
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var hasHit = true;
			if(hasHit == null) {
				hasHit = false;
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			if(hasUndo) {
				var width = xIter3.max - xIter3.start + 1;
				var height = yIter3.max - yIter3.start + 1;
				var imageType = null;
				var this2 = new pi_$xy_ImageStruct();
				if(imageType == null) {
					imageType = pi_$xy_ImageStruct.defaultType;
				}
				var imageType1 = imageType;
				if(imageType1 == null) {
					imageType1 = 2;
				}
				var undoImage1;
				switch(imageType1) {
				case 0:
					var byt = new iterMagic_BytesImg();
					var b = byt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
					var len = b.length;
					var w = 0;
					var _g = 0;
					var _g1 = b.height;
					while(_g < _g1) {
						var y = _g++;
						var _g2 = 0;
						var _g3 = b.width;
						while(_g2 < _g3) {
							var x = _g2++;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
							b.data.b[w++] = 0;
						}
					}
					undoImage1 = b;
					break;
				case 1:
					var arrI = new iterMagic_ArrIntImg();
					var a = arrI;
					a.width = width;
					a.height = height;
					a.data = [];
					a.length = width * height | 0;
					var _g = 0;
					var _g1 = a.length;
					while(_g < _g1) {
						var i = _g++;
						a.data[i] = 0;
					}
					undoImage1 = a;
					break;
				case 2:
					var u32a = new iterMagic_U32ArrImg();
					var b = u32a;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					var this3 = new Uint32Array(b.length);
					b.data = this3;
					var _g = 0;
					var _g1 = b.length;
					while(_g < _g1) {
						var i = _g++;
						b.data[i] = 0;
					}
					undoImage1 = b;
					break;
				case 3:
					var vec = new iterMagic_VecIntImg();
					var v = vec;
					v.width = width;
					v.height = height;
					v.length = width * height | 0;
					var this3 = new Array(v.length);
					v.data = this3;
					var _g = 0;
					var _g1 = v.length;
					while(_g < _g1) {
						var i = _g++;
						v.data[i] = 0;
					}
					undoImage1 = v;
					break;
				case 4:
					var sInt = new iterMagic_StackIntImg();
					var b = sInt;
					b.width = width;
					b.height = height;
					b.length = width * height | 0;
					b.data = new haxe_ds_GenericStack();
					var len = b.length;
					var d = b.data;
					if(d.head == null) {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							d.head = new haxe_ds_GenericCell(0,d.head);
						}
					} else {
						var _g = 0;
						var _g1 = len;
						while(_g < _g1) {
							var i = _g++;
							var l = b.data.head;
							var prev = null;
							var _g2 = 0;
							var _g3 = i;
							while(_g2 < _g3) {
								var i1 = _g2++;
								prev = l;
								l = l.next;
							}
							if(prev == null) {
								b.data.head = new haxe_ds_GenericCell(0,l.next);
								l = null;
							} else {
								prev.next = new haxe_ds_GenericCell(0,l.next);
								l = null;
							}
						}
					}
					undoImage1 = b;
					break;
				}
				this2.image = undoImage1;
				this2.width = width;
				this2.height = height;
				this2.imageType = imageType;
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
						var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(this1.useMask && this1.mask != null) {
							var this2 = this1.mask;
							var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this3;
							var this4 = col;
							var this5 = this4;
							if(maskPixel == 0) {
								var this6 = this5;
								col = this6;
							} else {
								var this7 = maskPixel >> 24 & 255;
								var m0 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 16 & 255;
								var m1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel >> 8 & 255;
								var m2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = maskPixel & 255;
								var m3 = this10 == 0 ? 0. : this10 / 255;
								var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this5 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this11 = col;
							var c2 = this11;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this12 = undoImage.image.get(location);
								var this13 = this12;
								var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
								var this15 = this14 >> 24 & 255;
								var a1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this14 >> 16 & 255;
								var r1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this14 >> 8 & 255;
								var g1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = this14 & 255;
								var b1 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 24 & 255;
								var a2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 16 & 255;
								var r2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col >> 8 & 255;
								var g2 = this21 == 0 ? 0. : this21 / 255;
								var this22 = col & 255;
								var b2 = this22 == 0 ? 0. : this22 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this2 = color;
						var c = this2;
						if((c >> 24 & 255) < 254 && this1.transparent) {
							var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
							var this3 = this1.image.get(location);
							var this4 = this3;
							var this5 = pi_$xy_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
							var this6 = this5 >> 24 & 255;
							var a1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this5 >> 16 & 255;
							var r1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this5 >> 8 & 255;
							var g1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = this5 & 255;
							var b1 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 24 & 255;
							var a2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 16 & 255;
							var r2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color >> 8 & 255;
							var g2 = this12 == 0 ? 0. : this12 / 255;
							var this13 = color & 255;
							var b2 = this13 == 0 ? 0. : this13 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pi_$xy_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		} else if(this.luxury) {
			var this1 = pixelImage;
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft1 = soft;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft1 == null) {
				soft1 = 40;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = softBC1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - cx;
			var bcy = by - cy;
			var acx = ax - cx;
			var acy = ay - cy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > cx) {
					var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > cy) {
					var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - cx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - cy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,cx,cy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softCD1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - ax;
			var bcy = cy - ay;
			var acx = dx - ax;
			var acy = dy - ay;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(dx > cx) {
				if(dx > ax) {
					var ii_min = cx > ax ? Math.floor(ax) : Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > ax) {
				var ii_min = dx > ax ? Math.floor(ax) : Math.ceil(dx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(dx);
				var ii_max = Math.ceil(ax);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(dy > cy) {
				if(dy > ay) {
					var ii_min = cy > ay ? Math.floor(ay) : Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > ay) {
				var ii_min = dy > ay ? Math.floor(ay) : Math.ceil(dy);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(dy);
				var ii_max = Math.ceil(ay);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - ax;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - ay;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(dx,dy,cx,cy,ax,ay,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this2 = i;
						r = this2;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this3 = i1;
						g = this3;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this4 = i2;
						b = this4;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this5 = i3;
							a = this5;
							var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this6 = this1.image.get(location);
								var this7 = this6;
								var old = pi_$xy_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this8 = old >> 24 & 255;
								var a1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 16 & 255;
								var r1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old >> 8 & 255;
								var g1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = old & 255;
								var b1 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 24 & 255;
								var a2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 16 & 255;
								var r2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs >> 8 & 255;
								var g2 = this14 == 0 ? 0. : this14 / 255;
								var this15 = rhs & 255;
								var b2 = this15 == 0 ? 0. : this15 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
							} else {
								this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this16 = i4;
							a = this16;
							var location1 = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
							if(this1.transparent && a < 254) {
								var this17 = this1.image.get(location1);
								var this18 = this17;
								var old1 = pi_$xy_Endian_isLittleEndian ? (this18 >> 24 & 255) << 24 | (this18 & 255) << 16 | (this18 >> 8 & 255) << 8 | this18 >> 16 & 255 : this18;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this19 = old1 >> 24 & 255;
								var a11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 16 & 255;
								var r11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 >> 8 & 255;
								var g11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = old1 & 255;
								var b11 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 24 & 255;
								var a21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 16 & 255;
								var r21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 >> 8 & 255;
								var g21 = this25 == 0 ? 0. : this25 / 255;
								var this26 = rhs1 & 255;
								var b21 = this26 == 0 ? 0. : this26 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								this1.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this1.image.set(location1,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		} else {
			var this1 = pixelImage;
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft1 = soft;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft1 == null) {
				soft1 = 40;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this2 = i;
									a = this2;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this3 = i1;
									a = this3;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this4 = i2;
								a = this4;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this5 = i3;
								a = this5;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this6 = i4;
								a = this6;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this7 = i5;
								a = this7;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this8 = i6;
							a = this8;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this9 = i7;
							a = this9;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this10 = i8;
						r = this10;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this11 = i9;
						g = this11;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this12 = i10;
						b = this12;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this13 = this1.image.get(location);
							var this14 = this13;
							var old = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this15 = old >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = old & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = rhs & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this2;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this2;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this2;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this2 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this2;
			}
			var undoImage = null;
			var width = xIter3.max - xIter3.start + 1;
			var height = yIter3.max - yIter3.start + 1;
			var imageType = null;
			var this2 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var undoImage1;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				undoImage1 = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				undoImage1 = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this3 = new Uint32Array(b.length);
				b.data = this3;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				undoImage1 = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this3 = new Array(v.length);
				v.data = this3;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				undoImage1 = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				undoImage1 = b;
				break;
			}
			this2.image = undoImage1;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = this1.image.get(this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						var this2 = this1.mask;
						var c1 = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
						var this3 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this3;
						var this4 = col;
						var this5 = this4;
						if(maskPixel == 0) {
							var this6 = this5;
							col = this6;
						} else {
							var this7 = maskPixel >> 24 & 255;
							var m0 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 16 & 255;
							var m1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel >> 8 & 255;
							var m2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = maskPixel & 255;
							var m3 = this10 == 0 ? 0. : this10 / 255;
							var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this5 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this11 = col;
						var c2 = this11;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this12 = undoImage.image.get(location);
							var this13 = this12;
							var this14 = pi_$xy_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var this15 = this14 >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this14 >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this14 >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = this14 & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = col & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							undoImage.image.set(undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this2 = i;
									a = this2;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this3 = i1;
									a = this3;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this4 = i2;
								a = this4;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this5 = i3;
								a = this5;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this6 = i4;
								a = this6;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this7 = i5;
								a = this7;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this8 = i6;
							a = this8;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this9 = i7;
							a = this9;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this10 = i8;
						r = this10;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this11 = i9;
						g = this11;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this12 = i10;
						b = this12;
						var location = this1.useVirtualPos ? (py - this1.virtualY) * this1.width + px - this1.virtualX | 0 : py * this1.width + px | 0;
						if(this1.transparent && a < 254) {
							var this13 = this1.image.get(location);
							var this14 = this13;
							var old = pi_$xy_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this15 = old >> 24 & 255;
							var a1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 16 & 255;
							var r1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old >> 8 & 255;
							var g1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = old & 255;
							var b1 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 24 & 255;
							var a2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 16 & 255;
							var r2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs >> 8 & 255;
							var g2 = this21 == 0 ? 0. : this21 / 255;
							var this22 = rhs & 255;
							var b2 = this22 == 0 ? 0. : this22 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							this1.image.set(location,this1.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b);
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pi_$xy_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit == true) {
				var v = new pi_$xy_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		}
		this.hitObj = tmp;
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_QuadShape
});
var pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded) {
	if(rounded == null) {
		rounded = false;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pi_$xy_triangleGML_triGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.rounded = rounded;
};
pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$.__name__ = "pi_xy.triangleGML.triGML.shape.form.RectangleForm_";
pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$.__super__ = pi_$xy_triangleGML_triGML_FillForm;
pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$.prototype = $extend(pi_$xy_triangleGML_triGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "rounded":
			this.rounded = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pi_$xy_triangleGML_triGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$
});
var pi_$xy_triangleGML_RectangleForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded) {
	pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded);
};
pi_$xy_triangleGML_RectangleForm.__name__ = "pi_xy.triangleGML.RectangleForm";
pi_$xy_triangleGML_RectangleForm.__super__ = pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$;
pi_$xy_triangleGML_RectangleForm.prototype = $extend(pi_$xy_triangleGML_triGML_shape_form_RectangleForm_$.prototype,{
	render: function(pixelImage) {
		if(this.rounded == false) {
			var width = Math.ceil(this.width);
			var height = Math.ceil(this.height);
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var temp = this1;
			temp.transparent = false;
			var color = this.strokeColor;
			var r_x = 0;
			var r_y = 0;
			var r_w = this.width | 0;
			var r_h = this.height | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var color = this.fill;
			var r_x = this.strokeWidth | 0;
			var r_y = this.strokeWidth | 0;
			var r_w = this.width - 2 * this.strokeWidth | 0;
			var r_h = this.height - 2 * this.strokeWidth | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
							var this11 = pixelImage.image.get(location);
							var this12 = this11;
							var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			temp = null;
		} else {
			var width = Math.ceil(this.width);
			var height = Math.ceil(this.height);
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var temp = this1;
			temp.transparent = false;
			var wid = this.width;
			var hi = this.height;
			var color = this.strokeColor;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = dx + fat;
			var lowerY = dy + tall;
			var this1 = temp;
			var cx = dx;
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy1 = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy1 - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy1 * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y1 = dy1 - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = dx | 0;
			var r_y = 0;
			var r_w = fat | 0;
			var r_h = dy | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy1 = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy1 - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy1 * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y1 = dy1 - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(farX,cy,bx,by,cx,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = 0;
			var r_y = dy | 0;
			var r_w = wid | 0;
			var r_h = tall | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var cx = dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,lowerY,bx,by,cx1,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = dx | 0;
			var r_y = lowerY | 0;
			var r_w = fat | 0;
			var r_h = bottomRadius | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(farX,lowerY,bx,by,cx,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = this.strokeWidth;
			var y = this.strokeWidth;
			var wid = this.width - 2 * this.strokeWidth;
			var hi = this.height - 2 * this.strokeWidth;
			var color = this.fill;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = x + dx + fat;
			var lowerY = y + dy + tall;
			var this1 = temp;
			var cx = x + dx;
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y1 = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x1 = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy1 = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy1 - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy1 * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x2 = dx1 - rectLeft;
								var y2 = dy1 - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y2 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y2 * undoImage.width + x2 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y2 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y2 * undoImage.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x3 = _g_min++;
					sxx = sx * x3;
					txx = tx * x3;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y3 = _g_min1++;
						s = s0 + sxx + sy * y3;
						t = t0 + txx + ty * y3;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y3 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y3 * this2.width + x3 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y3 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y3 * this2.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = x + dx | 0;
			var r_y = y | 0;
			var r_w = fat | 0;
			var r_h = dy | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x1 = range_x;
				var y1 = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y1 = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x1 = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy1 = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy1 - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy1 * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy1 - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy1 * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x2 = dx1 - rectLeft;
								var y2 = dy1 - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y2 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y2 * undoImage.width + x2 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y2 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y2 * undoImage.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x3 = _g_min++;
					sxx = sx * x3;
					txx = tx * x3;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y3 = _g_min1++;
						s = s0 + sxx + sy * y3;
						t = t0 + txx + ty * y3;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y3 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y3 * this2.width + x3 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y3 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y3 * this2.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(farX,cy,bx,by,cx,cy1,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = x | 0;
			var r_y = y + dy | 0;
			var r_w = wid | 0;
			var r_h = tall | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x1 = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y * temp.width + x1 | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y * temp.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var cx = x + dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x1 = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx1 = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx1 - this2.virtualX | 0 : dy * this2.width + dx1 | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx1 - this14.virtualX | 0 : dy * this14.width + dx1 | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x2 = dx1 - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y1 * undoImage.width + x2 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x2 - undoImage.virtualX | 0 : y1 * undoImage.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x3 = _g_min++;
					sxx = sx * x3;
					txx = tx * x3;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y2 * this2.width + x3 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x3 - this2.virtualX | 0 : y2 * this2.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(cx,lowerY,bx,by,cx1,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var r_x = x + dx | 0;
			var r_y = lowerY | 0;
			var r_w = fat | 0;
			var r_h = bottomRadius | 0;
			var xmax = r_x + r_w + 1;
			var ymax = r_y + r_h + 1;
			var ii_min = r_x;
			var ii_max = xmax;
			var xRange__start = ii_min;
			var xRange__max = ii_max;
			var ii_min = r_y;
			var ii_max = ymax;
			var yRange__start = ii_min;
			var yRange__max = ii_max;
			var range_x = xRange__start;
			var range_y = yRange__start - 1;
			var range_xReset = range_x;
			var range_yReset = range_y;
			var range_xMax = xRange__max - 2;
			var range_yMax = yRange__max - 2;
			var _this_min = 0;
			var _this_max = (xRange__max - xRange__start) * (yRange__max - yRange__start) | 0;
			while(_this_min < _this_max) {
				var i = _this_min++;
				if(range_y > range_yMax) {
					range_y = range_yReset;
					++range_x;
				}
				++range_y;
				var i1 = i;
				var x = range_x;
				var y = range_y;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
					var this2 = temp.image.get(location);
					var this3 = this2;
					var this4 = pi_$xy_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					temp.image.set(temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
			var this1 = temp;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var this2 = this1;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this3 = new pi_$xy_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this3;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this4 = new pi_$xy_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this4;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this5 = new pi_$xy_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this5;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this6 = new pi_$xy_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this6;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this7 = new pi_$xy_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this7;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this8 = new pi_$xy_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this8;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this9 = new pi_$xy_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this9;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this10 = new pi_$xy_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this10;
				}
				var undoImage = null;
				if(hasUndo1) {
					var width = xIter3.max - xIter3.start + 1;
					var height = yIter3.max - yIter3.start + 1;
					var imageType = null;
					var this11 = new pi_$xy_ImageStruct();
					if(imageType == null) {
						imageType = pi_$xy_ImageStruct.defaultType;
					}
					var imageType1 = imageType;
					if(imageType1 == null) {
						imageType1 = 2;
					}
					var undoImage1;
					switch(imageType1) {
					case 0:
						var byt = new iterMagic_BytesImg();
						var b = byt;
						b.width = width;
						b.height = height;
						b.length = width * height | 0;
						b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
						var len = b.length;
						var w = 0;
						var _g2 = 0;
						var _g3 = b.height;
						while(_g2 < _g3) {
							var y = _g2++;
							var _g4 = 0;
							var _g5 = b.width;
							while(_g4 < _g5) {
								var x = _g4++;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
								b.data.b[w++] = 0;
							}
						}
						undoImage1 = b;
						break;
					case 1:
						var arrI = new iterMagic_ArrIntImg();
						var a = arrI;
						a.width = width;
						a.height = height;
						a.data = [];
						a.length = width * height | 0;
						var _g6 = 0;
						var _g7 = a.length;
						while(_g6 < _g7) {
							var i1 = _g6++;
							a.data[i1] = 0;
						}
						undoImage1 = a;
						break;
					case 2:
						var u32a = new iterMagic_U32ArrImg();
						var b1 = u32a;
						b1.width = width;
						b1.height = height;
						b1.length = width * height | 0;
						var this12 = new Uint32Array(b1.length);
						b1.data = this12;
						var _g8 = 0;
						var _g9 = b1.length;
						while(_g8 < _g9) {
							var i2 = _g8++;
							b1.data[i2] = 0;
						}
						undoImage1 = b1;
						break;
					case 3:
						var vec = new iterMagic_VecIntImg();
						var v = vec;
						v.width = width;
						v.height = height;
						v.length = width * height | 0;
						var this13 = new Array(v.length);
						v.data = this13;
						var _g10 = 0;
						var _g11 = v.length;
						while(_g10 < _g11) {
							var i3 = _g10++;
							v.data[i3] = 0;
						}
						undoImage1 = v;
						break;
					case 4:
						var sInt = new iterMagic_StackIntImg();
						var b2 = sInt;
						b2.width = width;
						b2.height = height;
						b2.length = width * height | 0;
						b2.data = new haxe_ds_GenericStack();
						var len1 = b2.length;
						var d = b2.data;
						if(d.head == null) {
							var _g12 = 0;
							var _g13 = len1;
							while(_g12 < _g13) {
								var i4 = _g12++;
								d.head = new haxe_ds_GenericCell(0,d.head);
							}
						} else {
							var _g14 = 0;
							var _g15 = len1;
							while(_g14 < _g15) {
								var i5 = _g14++;
								var l = b2.data.head;
								var prev = null;
								var _g16 = 0;
								var _g17 = i5;
								while(_g16 < _g17) {
									var i6 = _g16++;
									prev = l;
									l = l.next;
								}
								if(prev == null) {
									b2.data.head = new haxe_ds_GenericCell(0,l.next);
									l = null;
								} else {
									prev.next = new haxe_ds_GenericCell(0,l.next);
									l = null;
								}
							}
						}
						undoImage1 = b2;
						break;
					}
					this11.image = undoImage1;
					this11.width = width;
					this11.height = height;
					this11.imageType = imageType;
					undoImage = this11;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g18 = rectTop;
					var _g19 = yIter3.max;
					while(_g18 < _g19) {
						var dy = _g18++;
						var _g20 = rectLeft;
						var _g21 = rectRight;
						while(_g20 < _g21) {
							var dx = _g20++;
							var c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
							var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(this2.useMask && this2.mask != null) {
								var this14 = this2.mask;
								var c1 = this14.image.get(this14.useVirtualPos ? (dy - this14.virtualY) * this14.width + dx - this14.virtualX | 0 : dy * this14.width + dx | 0);
								var this15 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this15;
								var this16 = col;
								var this17 = this16;
								if(maskPixel == 0) {
									var this18 = this17;
									col = this18;
								} else {
									var this19 = maskPixel >> 24 & 255;
									var m0 = this19 == 0 ? 0. : this19 / 255;
									var this20 = maskPixel >> 16 & 255;
									var m1 = this20 == 0 ? 0. : this20 / 255;
									var this21 = maskPixel >> 8 & 255;
									var m2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = maskPixel & 255;
									var m3 = this22 == 0 ? 0. : this22 / 255;
									var ch0 = (1. - m0) * (this17 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this17 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this17 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this17 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx - rectLeft;
								var y1 = dy - rectTop;
								var this23 = col;
								var c2 = this23;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this24 = undoImage.image.get(location);
									var this25 = this24;
									var this26 = pi_$xy_Endian_isLittleEndian ? (this25 >> 24 & 255) << 24 | (this25 & 255) << 16 | (this25 >> 8 & 255) << 8 | this25 >> 16 & 255 : this25;
									var this27 = this26 >> 24 & 255;
									var a1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = this26 >> 16 & 255;
									var r1 = this28 == 0 ? 0. : this28 / 255;
									var this29 = this26 >> 8 & 255;
									var g1 = this29 == 0 ? 0. : this29 / 255;
									var this30 = this26 & 255;
									var b11 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col >> 24 & 255;
									var a2 = this31 == 0 ? 0. : this31 / 255;
									var this32 = col >> 16 & 255;
									var r2 = this32 == 0 ? 0. : this32 / 255;
									var this33 = col >> 8 & 255;
									var g2 = this33 == 0 ? 0. : this33 / 255;
									var this34 = col & 255;
									var b21 = this34 == 0 ? 0. : this34 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b11 * a3 + b21 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r << 16 | g << 8 | b3;
									undoImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
								} else {
									undoImage.image.set(undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this35 = color;
							var c3 = this35;
							if((c3 >> 24 & 255) < 254 && this2.transparent) {
								var location1 = this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0;
								var this36 = this2.image.get(location1);
								var this37 = this36;
								var this38 = pi_$xy_Endian_isLittleEndian ? (this37 >> 24 & 255) << 24 | (this37 & 255) << 16 | (this37 >> 8 & 255) << 8 | this37 >> 16 & 255 : this37;
								var this39 = this38 >> 24 & 255;
								var a11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = this38 >> 16 & 255;
								var r11 = this40 == 0 ? 0. : this40 / 255;
								var this41 = this38 >> 8 & 255;
								var g11 = this41 == 0 ? 0. : this41 / 255;
								var this42 = this38 & 255;
								var b12 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color >> 24 & 255;
								var a21 = this43 == 0 ? 0. : this43 / 255;
								var this44 = color >> 16 & 255;
								var r21 = this44 == 0 ? 0. : this44 / 255;
								var this45 = color >> 8 & 255;
								var g21 = this45 == 0 ? 0. : this45 / 255;
								var this46 = color & 255;
								var b22 = this46 == 0 ? 0. : this46 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b12 * a31 + b22 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b4;
								this2.image.set(location1,pi_$xy_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1);
							} else {
								this2.image.set(this2.useVirtualPos ? (y2 - this2.virtualY) * this2.width + x2 - this2.virtualX | 0 : y2 * this2.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v1 = new pi_$xy_algo_HitTri(farX,lowerY,bx,by,cx,cy,true);
					if(hasUndo1) {
						v1.undoImage = undoImage;
						v1.undoX = xIter3.start;
						v1.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image.get(temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0);
					var col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
						var this2 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
							var this11 = pixelImage.image.get(location);
							var this12 = this11;
							var this13 = pi_$xy_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelImage.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							pixelImage.image.set(pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2);
						}
					}
				}
			}
			temp = null;
		}
		return pixelImage;
	}
	,__class__: pi_$xy_triangleGML_RectangleForm
});
var pi_$xy_triangleGML_ShapeAtt = function(shape,att) {
	this.shape = shape;
	this.att = att;
};
pi_$xy_triangleGML_ShapeAtt.__name__ = "pi_xy.triangleGML.ShapeAtt";
pi_$xy_triangleGML_ShapeAtt.prototype = {
	__class__: pi_$xy_triangleGML_ShapeAtt
};
var pi_$xy_triangleGML_triGML_TriGML = function(drawTool,xml,x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.imageResource = new haxe_ds_StringMap();
	this.drawTool = drawTool;
	if(xml != null) {
		this.xml = xml;
		this.offX = x;
		this.offY = y;
		this.process();
	}
};
pi_$xy_triangleGML_triGML_TriGML.__name__ = "pi_xy.triangleGML.triGML.TriGML";
pi_$xy_triangleGML_triGML_TriGML.prototype = {
	addShape: function(str,x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.xml = Xml.parse("<node>" + str + "</node>").firstElement();
		this.offX = x;
		this.offY = y;
		this.process();
		return this;
	}
	,process: function() {
		var e = this.xml.elements();
		while(e.hasNext()) {
			var e1 = e.next();
			this.processShape(e1);
		}
	}
	,processShape: function(x) {
		if(x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		var name = x.nodeName;
		var s = this.getTriangleGML(name);
		var att = x.attributes();
		while(att.hasNext()) {
			var att1 = att.next();
			this.processAttribute(att1,x.get(att1),s);
		}
		if(this.offX != 0. || this.offY != 0.) {
			s.translate(this.offX,this.offY);
		}
		if(this.shapes == null) {
			this.shapes = [];
		}
		this.shapes.push(s);
	}
	,processAttribute: function(att,value,shape) {
		haxe_Log.trace(att + " " + value,{ fileName : "src/pi_xy/triangleGML/triGML/TriGML.hx", lineNumber : 60, className : "pi_xy.triangleGML.triGML.TriGML", methodName : "processAttribute"});
		if(HxOverrides.substr(att,0,"image".length) == "image") {
			shape.setImage(att,this.imageResource.h[value.toLowerCase()]);
		} else {
			shape.setParameter(att,value);
		}
	}
	,render: function() {
		var _g = 0;
		var _g1 = this.shapes.length;
		while(_g < _g1) {
			var i = _g++;
			this.shapes[i].render(this.drawTool);
		}
	}
	,__class__: pi_$xy_triangleGML_triGML_TriGML
};
var pi_$xy_triangleGML_TriangleGML = function(drawTool,xml,x,y) {
	this.shapes_att = [];
	this.promises = [];
	pi_$xy_triangleGML_triGML_TriGML.call(this,drawTool,xml,x,y);
};
pi_$xy_triangleGML_TriangleGML.__name__ = "pi_xy.triangleGML.TriangleGML";
pi_$xy_triangleGML_TriangleGML.load = function(url) {
	return new Promise(function(resolve,reject) {
		var image = new Image();
		image.onload = function() {
			var resolve1 = resolve;
			var canvas = window.document.createElement("canvas");
			canvas.width = image.width;
			canvas.height = image.height;
			canvas.getContext("2d",null).drawImage(image,0,0,image.width,image.height);
			var width = image.width;
			var height = image.height;
			var imageType = null;
			var this1 = new pi_$xy_ImageStruct();
			if(imageType == null) {
				imageType = pi_$xy_ImageStruct.defaultType;
			}
			var imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			var tmp;
			switch(imageType1) {
			case 0:
				var byt = new iterMagic_BytesImg();
				var b = byt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				var len = b.length;
				var w = 0;
				var _g = 0;
				var _g1 = b.height;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = b.width;
					while(_g2 < _g3) {
						var x = _g2++;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				var arrI = new iterMagic_ArrIntImg();
				var a = arrI;
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				var _g = 0;
				var _g1 = a.length;
				while(_g < _g1) {
					var i = _g++;
					a.data[i] = 0;
				}
				tmp = a;
				break;
			case 2:
				var u32a = new iterMagic_U32ArrImg();
				var b = u32a;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				var this2 = new Uint32Array(b.length);
				b.data = this2;
				var _g = 0;
				var _g1 = b.length;
				while(_g < _g1) {
					var i = _g++;
					b.data[i] = 0;
				}
				tmp = b;
				break;
			case 3:
				var vec = new iterMagic_VecIntImg();
				var v = vec;
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				var this2 = new Array(v.length);
				v.data = this2;
				var _g = 0;
				var _g1 = v.length;
				while(_g < _g1) {
					var i = _g++;
					v.data[i] = 0;
				}
				tmp = v;
				break;
			case 4:
				var sInt = new iterMagic_StackIntImg();
				var b = sInt;
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_ds_GenericStack();
				var len = b.length;
				var d = b.data;
				if(d.head == null) {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var l = b.data.head;
						var prev = null;
						var _g2 = 0;
						var _g3 = i;
						while(_g2 < _g3) {
							var i1 = _g2++;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			var pixelImage = this1;
			pixelImage.transparent = false;
			var this1 = pixelImage;
			var ctx = canvas.getContext("2d",null);
			var here = this1;
			var base = this1;
			var imageData = base.useVirtualPos ? ctx.getImageData(base.virtualX,base.virtualY,here.width,here.height) : ctx.getImageData(0,0,here.width,here.height);
			var data = imageData.data;
			var temp = new Uint32Array(data.buffer);
			var _g = 0;
			var _g1 = here.image.length;
			while(_g < _g1) {
				var i = _g++;
				here.image.set(i,temp[i]);
			}
			canvas = null;
			resolve1(pixelImage);
		};
		image.src = url;
	});
};
pi_$xy_triangleGML_TriangleGML.__super__ = pi_$xy_triangleGML_triGML_TriGML;
pi_$xy_triangleGML_TriangleGML.prototype = $extend(pi_$xy_triangleGML_triGML_TriGML.prototype,{
	processAttribute: function(att,value,shape) {
		if(HxOverrides.substr(att,0,"src".length) == "src") {
			this.promises.push(pi_$xy_triangleGML_TriangleGML.load(value));
			this.shapes_att.push(new pi_$xy_triangleGML_ShapeAtt(shape,att.toLowerCase()));
		} else {
			pi_$xy_triangleGML_triGML_TriGML.prototype.processAttribute.call(this,att,value,shape);
		}
	}
	,renderPromise: function() {
		var here = this;
		if(this.promises.length == 0) {
			return Promise.all([Promise.resolve()]).then(function(_) {
				here.render();
				here = null;
				return here;
			});
		} else {
			return Promise.all(this.promises).then(function(pixelimages) {
				var _g = 0;
				var _g1 = pixelimages.length;
				while(_g < _g1) {
					var i = _g++;
					var shapeAt = here.shapes_att[i];
					var pixelImage = pixelimages[i];
					shapeAt.shape.setImage(shapeAt.att,pixelImage);
				}
				here.render();
				here = null;
				return here;
			});
		}
	}
	,getTriangleGML: function(nodeName) {
		var s;
		switch(nodeName) {
		case "ArcForm":
			s = new pi_$xy_triangleGML_ArcForm();
			break;
		case "ArrowShape":
			s = new pi_$xy_triangleGML_ArrowShape();
			break;
		case "CircleForm":
			s = new pi_$xy_triangleGML_CircleForm();
			break;
		case "EllipseForm":
			s = new pi_$xy_triangleGML_EllipseForm();
			break;
		case "LineGradient":
			s = new pi_$xy_triangleGML_LineGradient();
			break;
		case "LineGridShape":
			s = new pi_$xy_triangleGML_LineGridShape();
			break;
		case "LineShape":
			s = new pi_$xy_triangleGML_LineShape();
			break;
		case "NineSlicePicture":
			s = new pi_$xy_triangleGML_NineSlicePicture();
			break;
		case "QuadShape":
			s = new pi_$xy_triangleGML_QuadShape();
			break;
		case "RectangleForm":
			s = new pi_$xy_triangleGML_RectangleForm();
			break;
		default:
			throw haxe_Exception.thrown("shape unfound " + nodeName);
		}
		return s;
	}
	,__class__: pi_$xy_triangleGML_TriangleGML
});
var pi_$xy_triangleGML_triGML_hitTest_IhitObj = function() { };
pi_$xy_triangleGML_triGML_hitTest_IhitObj.__name__ = "pi_xy.triangleGML.triGML.hitTest.IhitObj";
pi_$xy_triangleGML_triGML_hitTest_IhitObj.__isInterface__ = true;
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false});
String.__name__ = "String";
Array.__name__ = "Array";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
var pi_$xy_Endian_isLittleEndian = (function($this) {
	var $r;
	var a8 = new Uint8Array(4);
	var a32 = new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
pi_$xy_ImageStruct.defaultType = 2;
pi_$xy_application_Arcs_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
