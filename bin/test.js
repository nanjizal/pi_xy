// Generated by Haxe 4.3.0-rc.1+
(function ($global) { "use strict";
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
IntIterator.__name__ = true;
IntIterator.prototype = {
	hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var htmlHelper_canvas_CanvasSetup = function() {
	this.divertTrace = new htmlHelper_tools_DivertTrace();
	var e = null;
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	var canvas = this1;
	canvas.width = 1024;
	canvas.height = 768;
	var dom = canvas;
	var style = dom.style;
	style.background = "black";
	window.document.body.appendChild(canvas);
	var this1 = new htmlHelper_canvas_CanvasPlus(canvas.getContext("2d",null),10,10);
	this.surface = this1;
	var factor = 4.;
	this.overSampleCanvas(canvas,this.surface.me,factor);
};
htmlHelper_canvas_CanvasSetup.__name__ = true;
htmlHelper_canvas_CanvasSetup.prototype = {
	overSampleCanvas: function(canvas,ctx,factor) {
		var width = canvas.width;
		var height = canvas.height;
		canvas.width = 0 | (width * factor | 0);
		canvas.height = 0 | (height * factor | 0);
		canvas.style.width = width + "px";
		canvas.style.height = height + "px";
		ctx.scale(factor,factor);
	}
};
var htmlHelper_canvas_CanvasPlus = function(me,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.me = me;
};
htmlHelper_canvas_CanvasPlus.__name__ = true;
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = true;
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var pixelimage_DemoUse = function() {
	this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
	haxe_Log.trace("Pixelimage example on Canvas",{ fileName : "src/pixelimage/DemoUse.hx", lineNumber : 11, className : "pixelimage.DemoUse", methodName : "new"});
	var g = this.canvasSetup.surface;
	var this1 = new Uint32Array(786432);
	var this2 = new pixelimage_ImageStruct(1024,768,this1);
	var p = this2;
	var this1 = new Uint32Array(12582912);
	var this2 = new pixelimage_ImageStruct(4096,3072,this1);
	var this1 = this2;
	var p = this1;
	p.transparent = true;
	pixelimage_Pixelimage.setRelativePosition(p,0,0);
	var a_0 = 871366848;
	var a_1 = -1712324416;
	var a_2 = -1427111744;
	var a_3 = -856686400;
	var a_4 = -286261056;
	var gap = 200;
	var ax = 100 + 0 * gap;
	var bx = 300 + 0 * gap;
	var by = 1200;
	var cx = 500 + 0 * gap;
	var cy = 1000;
	var color = a_0;
	var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var s0 = 900 * cx - ax * cy;
	var sx = cy - 900;
	var sy = ax - cx;
	var t0 = ax * by - 900 * bx;
	var tx = 900 - by;
	var ty = bx - ax;
	var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var ii = 900 > by ? 900 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(900)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(900 > cy ? Math.floor(cy) : Math.ceil(900),Math.ceil(by)) : new IntIterator(Math.floor(900),Math.ceil(cy));
	var this1 = new pixelimage_IntIterStart(ii.min,ii.max);
	var yIter3 = this1;
	var foundY = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
	while(_g.min < _g.max) {
		var x = _g.min++;
		sxx = sx * x;
		txx = tx * x;
		foundY = false;
		var _g_min = yIter3.start;
		var _g_max = yIter3.max;
		while(_g_min < _g_max) {
			var y = _g_min++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(foundY) {
					break;
				}
			} else if(s + t < A) {
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && p.transparent) {
					var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
					var a = color >> 24 & 255;
					var r;
					var b;
					if(p.isLittle) {
						r = color & 255;
						b = color >> 16 & 255;
					} else {
						r = color >> 16 & 255;
						b = color & 255;
					}
					var g1 = color >> 8 & 255;
					var a1 = a;
					var r1 = r;
					var g2 = g1;
					var b1 = b;
					var oldColor = p.image[location];
					var aOld = oldColor >>> 24 & 255;
					var rOld;
					var bOld;
					if(p.isLittle) {
						rOld = oldColor & 255;
						bOld = oldColor >>> 16 & 255;
					} else {
						rOld = oldColor >>> 16 & 255;
						bOld = oldColor & 255;
					}
					var gOld = oldColor >>> 8 & 255;
					var a11 = aOld == 0 ? 0. : aOld / 255;
					var r11 = rOld == 0 ? 0. : rOld / 255;
					var g11 = gOld == 0 ? 0. : gOld / 255;
					var b11 = bOld == 0 ? 0. : bOld / 255;
					var a2 = a1 == 0 ? 0. : a1 / 255;
					var r2 = r1 == 0 ? 0. : r1 / 255;
					var g21 = g2 == 0 ? 0. : g2 / 255;
					var b2 = b1 == 0 ? 0. : b1 / 255;
					var a3 = a11 * (1 - a2);
					r1 = 255 * (r11 * a3 + r2 * a2) | 0;
					g2 = 255 * (g11 * a3 + g21 * a2) | 0;
					b1 = 255 * (b11 * a3 + b2 * a2) | 0;
					a1 = 255 * (a3 + a2) | 0;
					p.image[location] = p.isLittle ? a1 << 24 | b1 << 16 | g2 << 8 | r1 : a1 << 24 | r1 << 16 | g2 << 8 | b1;
				} else {
					p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				foundY = true;
			} else if(foundY) {
				break;
			}
		}
	}
	var ax = 100 + gap;
	var bx = 300 + gap;
	var by = 1200;
	var cx = 500 + gap;
	var cy = 1000;
	var color = a_1;
	var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var s0 = 900 * cx - ax * cy;
	var sx = cy - 900;
	var sy = ax - cx;
	var t0 = ax * by - 900 * bx;
	var tx = 900 - by;
	var ty = bx - ax;
	var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var ii = 900 > by ? 900 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(900)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(900 > cy ? Math.floor(cy) : Math.ceil(900),Math.ceil(by)) : new IntIterator(Math.floor(900),Math.ceil(cy));
	var this1 = new pixelimage_IntIterStart(ii.min,ii.max);
	var yIter3 = this1;
	var foundY = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
	while(_g.min < _g.max) {
		var x = _g.min++;
		sxx = sx * x;
		txx = tx * x;
		foundY = false;
		var _g_min = yIter3.start;
		var _g_max = yIter3.max;
		while(_g_min < _g_max) {
			var y = _g_min++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(foundY) {
					break;
				}
			} else if(s + t < A) {
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && p.transparent) {
					var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
					var a = color >> 24 & 255;
					var r;
					var b;
					if(p.isLittle) {
						r = color & 255;
						b = color >> 16 & 255;
					} else {
						r = color >> 16 & 255;
						b = color & 255;
					}
					var g1 = color >> 8 & 255;
					var a1 = a;
					var r1 = r;
					var g2 = g1;
					var b1 = b;
					var oldColor = p.image[location];
					var aOld = oldColor >>> 24 & 255;
					var rOld;
					var bOld;
					if(p.isLittle) {
						rOld = oldColor & 255;
						bOld = oldColor >>> 16 & 255;
					} else {
						rOld = oldColor >>> 16 & 255;
						bOld = oldColor & 255;
					}
					var gOld = oldColor >>> 8 & 255;
					var a11 = aOld == 0 ? 0. : aOld / 255;
					var r11 = rOld == 0 ? 0. : rOld / 255;
					var g11 = gOld == 0 ? 0. : gOld / 255;
					var b11 = bOld == 0 ? 0. : bOld / 255;
					var a2 = a1 == 0 ? 0. : a1 / 255;
					var r2 = r1 == 0 ? 0. : r1 / 255;
					var g21 = g2 == 0 ? 0. : g2 / 255;
					var b2 = b1 == 0 ? 0. : b1 / 255;
					var a3 = a11 * (1 - a2);
					r1 = 255 * (r11 * a3 + r2 * a2) | 0;
					g2 = 255 * (g11 * a3 + g21 * a2) | 0;
					b1 = 255 * (b11 * a3 + b2 * a2) | 0;
					a1 = 255 * (a3 + a2) | 0;
					p.image[location] = p.isLittle ? a1 << 24 | b1 << 16 | g2 << 8 | r1 : a1 << 24 | r1 << 16 | g2 << 8 | b1;
				} else {
					p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				foundY = true;
			} else if(foundY) {
				break;
			}
		}
	}
	var ax = 100 + 2 * gap;
	var bx = 300 + 2 * gap;
	var by = 1200;
	var cx = 500 + 2 * gap;
	var cy = 1000;
	var color = a_2;
	var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var s0 = 900 * cx - ax * cy;
	var sx = cy - 900;
	var sy = ax - cx;
	var t0 = ax * by - 900 * bx;
	var tx = 900 - by;
	var ty = bx - ax;
	var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var ii = 900 > by ? 900 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(900)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(900 > cy ? Math.floor(cy) : Math.ceil(900),Math.ceil(by)) : new IntIterator(Math.floor(900),Math.ceil(cy));
	var this1 = new pixelimage_IntIterStart(ii.min,ii.max);
	var yIter3 = this1;
	var foundY = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
	while(_g.min < _g.max) {
		var x = _g.min++;
		sxx = sx * x;
		txx = tx * x;
		foundY = false;
		var _g_min = yIter3.start;
		var _g_max = yIter3.max;
		while(_g_min < _g_max) {
			var y = _g_min++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(foundY) {
					break;
				}
			} else if(s + t < A) {
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && p.transparent) {
					var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
					var a = color >> 24 & 255;
					var r;
					var b;
					if(p.isLittle) {
						r = color & 255;
						b = color >> 16 & 255;
					} else {
						r = color >> 16 & 255;
						b = color & 255;
					}
					var g1 = color >> 8 & 255;
					var a1 = a;
					var r1 = r;
					var g2 = g1;
					var b1 = b;
					var oldColor = p.image[location];
					var aOld = oldColor >>> 24 & 255;
					var rOld;
					var bOld;
					if(p.isLittle) {
						rOld = oldColor & 255;
						bOld = oldColor >>> 16 & 255;
					} else {
						rOld = oldColor >>> 16 & 255;
						bOld = oldColor & 255;
					}
					var gOld = oldColor >>> 8 & 255;
					var a11 = aOld == 0 ? 0. : aOld / 255;
					var r11 = rOld == 0 ? 0. : rOld / 255;
					var g11 = gOld == 0 ? 0. : gOld / 255;
					var b11 = bOld == 0 ? 0. : bOld / 255;
					var a2 = a1 == 0 ? 0. : a1 / 255;
					var r2 = r1 == 0 ? 0. : r1 / 255;
					var g21 = g2 == 0 ? 0. : g2 / 255;
					var b2 = b1 == 0 ? 0. : b1 / 255;
					var a3 = a11 * (1 - a2);
					r1 = 255 * (r11 * a3 + r2 * a2) | 0;
					g2 = 255 * (g11 * a3 + g21 * a2) | 0;
					b1 = 255 * (b11 * a3 + b2 * a2) | 0;
					a1 = 255 * (a3 + a2) | 0;
					p.image[location] = p.isLittle ? a1 << 24 | b1 << 16 | g2 << 8 | r1 : a1 << 24 | r1 << 16 | g2 << 8 | b1;
				} else {
					p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				foundY = true;
			} else if(foundY) {
				break;
			}
		}
	}
	var ax = 100 + 3 * gap;
	var bx = 300 + 3 * gap;
	var by = 1200;
	var cx = 500 + 3 * gap;
	var cy = 1000;
	var color = a_3;
	var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var s0 = 900 * cx - ax * cy;
	var sx = cy - 900;
	var sy = ax - cx;
	var t0 = ax * by - 900 * bx;
	var tx = 900 - by;
	var ty = bx - ax;
	var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var ii = 900 > by ? 900 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(900)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(900 > cy ? Math.floor(cy) : Math.ceil(900),Math.ceil(by)) : new IntIterator(Math.floor(900),Math.ceil(cy));
	var this1 = new pixelimage_IntIterStart(ii.min,ii.max);
	var yIter3 = this1;
	var foundY = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
	while(_g.min < _g.max) {
		var x = _g.min++;
		sxx = sx * x;
		txx = tx * x;
		foundY = false;
		var _g_min = yIter3.start;
		var _g_max = yIter3.max;
		while(_g_min < _g_max) {
			var y = _g_min++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(foundY) {
					break;
				}
			} else if(s + t < A) {
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && p.transparent) {
					var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
					var a = color >> 24 & 255;
					var r;
					var b;
					if(p.isLittle) {
						r = color & 255;
						b = color >> 16 & 255;
					} else {
						r = color >> 16 & 255;
						b = color & 255;
					}
					var g1 = color >> 8 & 255;
					var a1 = a;
					var r1 = r;
					var g2 = g1;
					var b1 = b;
					var oldColor = p.image[location];
					var aOld = oldColor >>> 24 & 255;
					var rOld;
					var bOld;
					if(p.isLittle) {
						rOld = oldColor & 255;
						bOld = oldColor >>> 16 & 255;
					} else {
						rOld = oldColor >>> 16 & 255;
						bOld = oldColor & 255;
					}
					var gOld = oldColor >>> 8 & 255;
					var a11 = aOld == 0 ? 0. : aOld / 255;
					var r11 = rOld == 0 ? 0. : rOld / 255;
					var g11 = gOld == 0 ? 0. : gOld / 255;
					var b11 = bOld == 0 ? 0. : bOld / 255;
					var a2 = a1 == 0 ? 0. : a1 / 255;
					var r2 = r1 == 0 ? 0. : r1 / 255;
					var g21 = g2 == 0 ? 0. : g2 / 255;
					var b2 = b1 == 0 ? 0. : b1 / 255;
					var a3 = a11 * (1 - a2);
					r1 = 255 * (r11 * a3 + r2 * a2) | 0;
					g2 = 255 * (g11 * a3 + g21 * a2) | 0;
					b1 = 255 * (b11 * a3 + b2 * a2) | 0;
					a1 = 255 * (a3 + a2) | 0;
					p.image[location] = p.isLittle ? a1 << 24 | b1 << 16 | g2 << 8 | r1 : a1 << 24 | r1 << 16 | g2 << 8 | b1;
				} else {
					p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				foundY = true;
			} else if(foundY) {
				break;
			}
		}
	}
	var ax = 100 + 4 * gap;
	var bx = 300 + 4 * gap;
	var by = 1200;
	var cx = 500 + 4 * gap;
	var cy = 1000;
	var color = a_4;
	var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var s0 = 900 * cx - ax * cy;
	var sx = cy - 900;
	var sy = ax - cx;
	var t0 = ax * by - 900 * bx;
	var tx = 900 - by;
	var ty = bx - ax;
	var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var ii = 900 > by ? 900 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(900)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(900 > cy ? Math.floor(cy) : Math.ceil(900),Math.ceil(by)) : new IntIterator(Math.floor(900),Math.ceil(cy));
	var this1 = new pixelimage_IntIterStart(ii.min,ii.max);
	var yIter3 = this1;
	var foundY = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
	while(_g.min < _g.max) {
		var x = _g.min++;
		sxx = sx * x;
		txx = tx * x;
		foundY = false;
		var _g_min = yIter3.start;
		var _g_max = yIter3.max;
		while(_g_min < _g_max) {
			var y = _g_min++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(foundY) {
					break;
				}
			} else if(s + t < A) {
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && p.transparent) {
					var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
					var a = color >> 24 & 255;
					var r;
					var b;
					if(p.isLittle) {
						r = color & 255;
						b = color >> 16 & 255;
					} else {
						r = color >> 16 & 255;
						b = color & 255;
					}
					var g1 = color >> 8 & 255;
					var a1 = a;
					var r1 = r;
					var g2 = g1;
					var b1 = b;
					var oldColor = p.image[location];
					var aOld = oldColor >>> 24 & 255;
					var rOld;
					var bOld;
					if(p.isLittle) {
						rOld = oldColor & 255;
						bOld = oldColor >>> 16 & 255;
					} else {
						rOld = oldColor >>> 16 & 255;
						bOld = oldColor & 255;
					}
					var gOld = oldColor >>> 8 & 255;
					var a11 = aOld == 0 ? 0. : aOld / 255;
					var r11 = rOld == 0 ? 0. : rOld / 255;
					var g11 = gOld == 0 ? 0. : gOld / 255;
					var b11 = bOld == 0 ? 0. : bOld / 255;
					var a2 = a1 == 0 ? 0. : a1 / 255;
					var r2 = r1 == 0 ? 0. : r1 / 255;
					var g21 = g2 == 0 ? 0. : g2 / 255;
					var b2 = b1 == 0 ? 0. : b1 / 255;
					var a3 = a11 * (1 - a2);
					r1 = 255 * (r11 * a3 + r2 * a2) | 0;
					g2 = 255 * (g11 * a3 + g21 * a2) | 0;
					b1 = 255 * (b11 * a3 + b2 * a2) | 0;
					a1 = 255 * (a3 + a2) | 0;
					p.image[location] = p.isLittle ? a1 << 24 | b1 << 16 | g2 << 8 | r1 : a1 << 24 | r1 << 16 | g2 << 8 | b1;
				} else {
					p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				foundY = true;
			} else if(foundY) {
				break;
			}
		}
	}
	var ctx = g.me;
	var dataimg = p.image;
	var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
	var imageData = new ImageData(data,p.width,p.height);
	if(p.useVirtualPos) {
		ctx.putImageData(imageData,0 - p.virtualX,0 - p.virtualY);
	} else {
		ctx.putImageData(imageData,0,0);
	}
};
pixelimage_DemoUse.__name__ = true;
function pixelimage_DemoUse_main() {
	new pixelimage_DemoUse();
}
var pixelimage_ImageStruct = function(width,height,image) {
	this.useVirtualPos = false;
	this.virtualY = 0;
	this.virtualX = 0;
	this.transparent = false;
	this.width = width;
	this.height = height;
	this.image = image;
	this.isLittle = pixelimage_Endian_isLittleEndian;
	this.transparent = false;
};
pixelimage_ImageStruct.__name__ = true;
var pixelimage_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
pixelimage_IntIterStart.__name__ = true;
var pixelimage_Pixelimage = {};
pixelimage_Pixelimage.setRelativePosition = function(this1,x,y,update) {
	if(update == null) {
		update = false;
	}
	this1.useVirtualPos = true;
	if(x < 0) {
		x = 0;
	}
	if(y < 0) {
		y = 0;
	}
	this1.virtualX = x;
	this1.virtualY = y;
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
var pixelimage_Endian_isLittleEndian = (function($this) {
	var $r;
	var a8 = new Uint8Array(4);
	var a32 = new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
pixelimage_DemoUse_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
