// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__TransformImage_TransformImage_Impl_
#include <pi_xy/imageAbstracts/_TransformImage/TransformImage_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__SpinImage_SpinImage_Fields_
#include <pi_xy/transformation/_SpinImage/SpinImage_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_15_spinClock90,"pi_xy.transformation._SpinImage.SpinImage_Fields_","spinClock90",0x77ed2b5f,"pi_xy.transformation._SpinImage.SpinImage_Fields_.spinClock90","pi_xy/transformation/SpinImage.hx",15,0x8d020b03)
HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_52_spinAntiClock90,"pi_xy.transformation._SpinImage.SpinImage_Fields_","spinAntiClock90",0xc20680dd,"pi_xy.transformation._SpinImage.SpinImage_Fields_.spinAntiClock90","pi_xy/transformation/SpinImage.hx",52,0x8d020b03)
HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_90_spin180,"pi_xy.transformation._SpinImage.SpinImage_Fields_","spin180",0xe71fe2c3,"pi_xy.transformation._SpinImage.SpinImage_Fields_.spin180","pi_xy/transformation/SpinImage.hx",90,0x8d020b03)
HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_127_rotatingClockwiseDegrees,"pi_xy.transformation._SpinImage.SpinImage_Fields_","rotatingClockwiseDegrees",0x80b060f1,"pi_xy.transformation._SpinImage.SpinImage_Fields_.rotatingClockwiseDegrees","pi_xy/transformation/SpinImage.hx",127,0x8d020b03)
HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_148_rotatingClockwiseRadians,"pi_xy.transformation._SpinImage.SpinImage_Fields_","rotatingClockwiseRadians",0x6d45c3bc,"pi_xy.transformation._SpinImage.SpinImage_Fields_.rotatingClockwiseRadians","pi_xy/transformation/SpinImage.hx",148,0x8d020b03)
HX_LOCAL_STACK_FRAME(_hx_pos_a4487198a0754673_169_rotating,"pi_xy.transformation._SpinImage.SpinImage_Fields_","rotating",0x0824bcfc,"pi_xy.transformation._SpinImage.SpinImage_Fields_.rotating","pi_xy/transformation/SpinImage.hx",169,0x8d020b03)
namespace pi_xy{
namespace transformation{
namespace _SpinImage{

void SpinImage_Fields__obj::__construct() { }

Dynamic SpinImage_Fields__obj::__CreateEmpty() { return new SpinImage_Fields__obj; }

void *SpinImage_Fields__obj::_hx_vtable = 0;

Dynamic SpinImage_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< SpinImage_Fields__obj > _hx_result = new SpinImage_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SpinImage_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7b8b0c96;
}

 ::pi_xy::ImageStruct SpinImage_Fields__obj::spinClock90( ::pi_xy::ImageStruct thisImage,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_15_spinClock90)
HXLINE(  16)		Float r_x = x;
HXDLIN(  16)		Float r_y = y;
HXDLIN(  16)		Float r_w = w;
HXDLIN(  16)		Float r_h = h;
HXDLIN(  16)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  16)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  16)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  16)		int ii_max = xmax;
HXDLIN(  16)		int xRange__start = ii_min;
HXDLIN(  16)		int xRange__max = ii_max;
HXDLIN(  16)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  16)		int ii_max1 = ymax;
HXDLIN(  16)		int yRange__start = ii_min1;
HXDLIN(  16)		int yRange__max = ii_max1;
HXDLIN(  16)		int range_x = xRange__start;
HXDLIN(  16)		int range_y = (yRange__start - 1);
HXDLIN(  16)		int range_xReset = range_x;
HXDLIN(  16)		int range_yReset = range_y;
HXDLIN(  16)		int range_xMax = (xRange__max - 2);
HXDLIN(  16)		int range_yMax = (yRange__max - 2);
HXDLIN(  16)		int _this_min = 0;
HXDLIN(  16)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXLINE(  17)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  17)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  17)		 ::Dynamic imageType = null();
HXDLIN(  17)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  17)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  17)		::Dynamic _hx_tmp;
HXDLIN(  17)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  17)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  17)				{
HXLINE(  17)					b->width = width;
HXDLIN(  17)					b->height = height;
HXDLIN(  17)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  17)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  17)					{
HXLINE(  17)						int len = b->length;
HXDLIN(  17)						int w1 = 0;
HXDLIN(  17)						{
HXLINE(  17)							int _g = 0;
HXDLIN(  17)							int _g1 = b->height;
HXDLIN(  17)							while((_g < _g1)){
HXLINE(  17)								_g = (_g + 1);
HXDLIN(  17)								int y1 = (_g - 1);
HXDLIN(  17)								{
HXLINE(  17)									int _g2 = 0;
HXDLIN(  17)									int _g3 = b->width;
HXDLIN(  17)									while((_g2 < _g3)){
HXLINE(  17)										_g2 = (_g2 + 1);
HXDLIN(  17)										int x1 = (_g2 - 1);
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  17)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  17)				{
HXLINE(  17)					a->width = width;
HXDLIN(  17)					a->height = height;
HXDLIN(  17)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  17)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  17)					{
HXLINE(  17)						int _g4 = 0;
HXDLIN(  17)						int _g5 = a->length;
HXDLIN(  17)						while((_g4 < _g5)){
HXLINE(  17)							_g4 = (_g4 + 1);
HXDLIN(  17)							int i = (_g4 - 1);
HXDLIN(  17)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  17)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  17)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  17)				{
HXLINE(  17)					b1->width = width;
HXDLIN(  17)					b1->height = height;
HXDLIN(  17)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  17)					int size = (b1->length * 4);
HXDLIN(  17)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  17)					{
HXLINE(  17)						int _g6 = 0;
HXDLIN(  17)						int _g7 = b1->length;
HXDLIN(  17)						while((_g6 < _g7)){
HXLINE(  17)							_g6 = (_g6 + 1);
HXDLIN(  17)							int i1 = (_g6 - 1);
HXDLIN(  17)							{
HXLINE(  17)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  17)								bool _hx_tmp1;
HXDLIN(  17)								if ((i1 >= 0)) {
HXLINE(  17)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  17)									_hx_tmp1 = false;
            								}
HXDLIN(  17)								if (_hx_tmp1) {
HXLINE(  17)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  17)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  17)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  17)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  17)				{
HXLINE(  17)					v->width = width;
HXDLIN(  17)					v->height = height;
HXDLIN(  17)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  17)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  17)					{
HXLINE(  17)						int _g8 = 0;
HXDLIN(  17)						int _g9 = v->length;
HXDLIN(  17)						while((_g8 < _g9)){
HXLINE(  17)							_g8 = (_g8 + 1);
HXDLIN(  17)							int i2 = (_g8 - 1);
HXDLIN(  17)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  17)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  17)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  17)				{
HXLINE(  17)					b2->width = width;
HXDLIN(  17)					b2->height = height;
HXDLIN(  17)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  17)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  17)					{
HXLINE(  17)						int len1 = b2->length;
HXDLIN(  17)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  17)						if (::hx::IsNull( d->head )) {
HXLINE(  17)							int _g10 = 0;
HXDLIN(  17)							int _g11 = len1;
HXDLIN(  17)							while((_g10 < _g11)){
HXLINE(  17)								_g10 = (_g10 + 1);
HXDLIN(  17)								int i3 = (_g10 - 1);
HXDLIN(  17)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  17)							int _g12 = 0;
HXDLIN(  17)							int _g13 = len1;
HXDLIN(  17)							while((_g12 < _g13)){
HXLINE(  17)								_g12 = (_g12 + 1);
HXDLIN(  17)								int i4 = (_g12 - 1);
HXDLIN(  17)								{
HXLINE(  17)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  17)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  17)									{
HXLINE(  17)										int _g14 = 0;
HXDLIN(  17)										int _g15 = i4;
HXDLIN(  17)										while((_g14 < _g15)){
HXLINE(  17)											_g14 = (_g14 + 1);
HXDLIN(  17)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  17)									if (::hx::IsNull( prev )) {
HXLINE(  17)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  17)										l = null();
            									}
            									else {
HXLINE(  17)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  17)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  17)		this1->image = _hx_tmp;
HXDLIN(  17)		this1->width = width;
HXDLIN(  17)		this1->height = height;
HXDLIN(  17)		this1->imageType = ( (int)(imageType) );
HXDLIN(  17)		 ::pi_xy::ImageStruct nextImage = this1;
HXLINE(  18)		nextImage->transparent = transparent;
HXLINE(  19)		while((_this_min < _this_max)){
HXLINE(  19)			_this_min = (_this_min + 1);
HXDLIN(  19)			int i6 = (_this_min - 1);
HXDLIN(  19)			if ((range_y > range_yMax)) {
HXLINE(  19)				range_y = range_yReset;
HXDLIN(  19)				range_x = (range_x + 1);
            			}
HXDLIN(  19)			range_y = (range_y + 1);
HXDLIN(  19)			int i7 = i6;
HXLINE(  21)			{
HXLINE(  21)				int x2 = (range_yMax - range_y);
HXDLIN(  21)				int y2 = range_x;
HXDLIN(  21)				int x3 = range_x;
HXDLIN(  21)				int y3 = range_y;
HXDLIN(  21)				::Dynamic this3 = thisImage->image;
HXDLIN(  21)				int index;
HXDLIN(  21)				if (thisImage->useVirtualPos) {
HXLINE(  21)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x3) - thisImage->virtualX));
            				}
            				else {
HXLINE(  21)					index = ::Std_obj::_hx_int(( (Float)(((y3 * thisImage->width) + x3)) ));
            				}
HXDLIN(  21)				int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  21)				int color;
HXDLIN(  21)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  21)					color = c;
            				}
HXDLIN(  21)				int c1 = color;
HXDLIN(  21)				bool _hx_tmp2;
HXDLIN(  21)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  21)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXLINE(  21)					_hx_tmp2 = false;
            				}
HXDLIN(  21)				if (_hx_tmp2) {
HXLINE(  21)					int location;
HXDLIN(  21)					if (nextImage->useVirtualPos) {
HXLINE(  21)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  21)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  21)					int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  21)					int this5;
HXDLIN(  21)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)						this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            					}
            					else {
HXLINE(  21)						this5 = this4;
            					}
HXDLIN(  21)					Float a1;
HXDLIN(  21)					int this6 = ((this5 >> 24) & 255);
HXDLIN(  21)					if ((this6 == 0)) {
HXLINE(  21)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float r1;
HXDLIN(  21)					int this7 = ((this5 >> 16) & 255);
HXDLIN(  21)					if ((this7 == 0)) {
HXLINE(  21)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float g1;
HXDLIN(  21)					int this8 = ((this5 >> 8) & 255);
HXDLIN(  21)					if ((this8 == 0)) {
HXLINE(  21)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float b11;
HXDLIN(  21)					int this9 = (this5 & 255);
HXDLIN(  21)					if ((this9 == 0)) {
HXLINE(  21)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float a2;
HXDLIN(  21)					int this10 = ((color >> 24) & 255);
HXDLIN(  21)					if ((this10 == 0)) {
HXLINE(  21)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float r2;
HXDLIN(  21)					int this11 = ((color >> 16) & 255);
HXDLIN(  21)					if ((this11 == 0)) {
HXLINE(  21)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float g2;
HXDLIN(  21)					int this12 = ((color >> 8) & 255);
HXDLIN(  21)					if ((this12 == 0)) {
HXLINE(  21)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float b21;
HXDLIN(  21)					int this13 = (color & 255);
HXDLIN(  21)					if ((this13 == 0)) {
HXLINE(  21)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  21)						b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  21)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  21)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  21)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  21)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  21)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  21)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  21)					{
HXLINE(  21)						int _hx_tmp3;
HXDLIN(  21)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  21)							_hx_tmp3 = blended;
            						}
HXDLIN(  21)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  21)					::Dynamic this14 = nextImage->image;
HXDLIN(  21)					int index1;
HXDLIN(  21)					if (nextImage->useVirtualPos) {
HXLINE(  21)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  21)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  21)					int _hx_tmp4;
HXDLIN(  21)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  21)						_hx_tmp4 = c1;
            					}
HXDLIN(  21)					::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp4);
            				}
            			}
            		}
HXLINE(  43)		bool _hx_tmp5;
HXDLIN(  43)		if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  43)			_hx_tmp5 = includeMask;
            		}
            		else {
HXLINE(  43)			_hx_tmp5 = false;
            		}
HXDLIN(  43)		if (_hx_tmp5) {
HXLINE(  44)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(thisImage->mask,x,y,w,h,thisImage->mask->transparent,includeMask);
HXDLIN(  44)			nextImage->useMask = true;
HXDLIN(  44)			nextImage->mask = v1;
            		}
HXLINE(  46)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(SpinImage_Fields__obj,spinClock90,return )

 ::pi_xy::ImageStruct SpinImage_Fields__obj::spinAntiClock90( ::pi_xy::ImageStruct thisImage,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_52_spinAntiClock90)
HXLINE(  53)		Float r_x = x;
HXDLIN(  53)		Float r_y = y;
HXDLIN(  53)		Float r_w = w;
HXDLIN(  53)		Float r_h = h;
HXDLIN(  53)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  53)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  53)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  53)		int ii_max = xmax;
HXDLIN(  53)		int xRange__start = ii_min;
HXDLIN(  53)		int xRange__max = ii_max;
HXDLIN(  53)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  53)		int ii_max1 = ymax;
HXDLIN(  53)		int yRange__start = ii_min1;
HXDLIN(  53)		int yRange__max = ii_max1;
HXDLIN(  53)		int range_x = xRange__start;
HXDLIN(  53)		int range_y = (yRange__start - 1);
HXDLIN(  53)		int range_xReset = range_x;
HXDLIN(  53)		int range_yReset = range_y;
HXDLIN(  53)		int range_xMax = (xRange__max - 2);
HXDLIN(  53)		int range_yMax = (yRange__max - 2);
HXDLIN(  53)		int _this_min = 0;
HXDLIN(  53)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXLINE(  54)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  54)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  54)		 ::Dynamic imageType = null();
HXDLIN(  54)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  54)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  54)		::Dynamic _hx_tmp;
HXDLIN(  54)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  54)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  54)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  54)				{
HXLINE(  54)					b->width = width;
HXDLIN(  54)					b->height = height;
HXDLIN(  54)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  54)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  54)					{
HXLINE(  54)						int len = b->length;
HXDLIN(  54)						int w1 = 0;
HXDLIN(  54)						{
HXLINE(  54)							int _g = 0;
HXDLIN(  54)							int _g1 = b->height;
HXDLIN(  54)							while((_g < _g1)){
HXLINE(  54)								_g = (_g + 1);
HXDLIN(  54)								int y1 = (_g - 1);
HXDLIN(  54)								{
HXLINE(  54)									int _g2 = 0;
HXDLIN(  54)									int _g3 = b->width;
HXDLIN(  54)									while((_g2 < _g3)){
HXLINE(  54)										_g2 = (_g2 + 1);
HXDLIN(  54)										int x1 = (_g2 - 1);
HXDLIN(  54)										{
HXLINE(  54)											w1 = (w1 + 1);
HXDLIN(  54)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  54)										{
HXLINE(  54)											w1 = (w1 + 1);
HXDLIN(  54)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  54)										{
HXLINE(  54)											w1 = (w1 + 1);
HXDLIN(  54)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  54)										{
HXLINE(  54)											w1 = (w1 + 1);
HXDLIN(  54)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  54)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  54)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  54)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  54)				{
HXLINE(  54)					a->width = width;
HXDLIN(  54)					a->height = height;
HXDLIN(  54)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  54)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  54)					{
HXLINE(  54)						int _g4 = 0;
HXDLIN(  54)						int _g5 = a->length;
HXDLIN(  54)						while((_g4 < _g5)){
HXLINE(  54)							_g4 = (_g4 + 1);
HXDLIN(  54)							int i = (_g4 - 1);
HXDLIN(  54)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  54)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  54)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  54)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  54)				{
HXLINE(  54)					b1->width = width;
HXDLIN(  54)					b1->height = height;
HXDLIN(  54)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  54)					int size = (b1->length * 4);
HXDLIN(  54)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  54)					{
HXLINE(  54)						int _g6 = 0;
HXDLIN(  54)						int _g7 = b1->length;
HXDLIN(  54)						while((_g6 < _g7)){
HXLINE(  54)							_g6 = (_g6 + 1);
HXDLIN(  54)							int i1 = (_g6 - 1);
HXDLIN(  54)							{
HXLINE(  54)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  54)								bool _hx_tmp1;
HXDLIN(  54)								if ((i1 >= 0)) {
HXLINE(  54)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  54)									_hx_tmp1 = false;
            								}
HXDLIN(  54)								if (_hx_tmp1) {
HXLINE(  54)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  54)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  54)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  54)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  54)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  54)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  54)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  54)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  54)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  54)				{
HXLINE(  54)					v->width = width;
HXDLIN(  54)					v->height = height;
HXDLIN(  54)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  54)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  54)					{
HXLINE(  54)						int _g8 = 0;
HXDLIN(  54)						int _g9 = v->length;
HXDLIN(  54)						while((_g8 < _g9)){
HXLINE(  54)							_g8 = (_g8 + 1);
HXDLIN(  54)							int i2 = (_g8 - 1);
HXDLIN(  54)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  54)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  54)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  54)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  54)				{
HXLINE(  54)					b2->width = width;
HXDLIN(  54)					b2->height = height;
HXDLIN(  54)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  54)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  54)					{
HXLINE(  54)						int len1 = b2->length;
HXDLIN(  54)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  54)						if (::hx::IsNull( d->head )) {
HXLINE(  54)							int _g10 = 0;
HXDLIN(  54)							int _g11 = len1;
HXDLIN(  54)							while((_g10 < _g11)){
HXLINE(  54)								_g10 = (_g10 + 1);
HXDLIN(  54)								int i3 = (_g10 - 1);
HXDLIN(  54)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  54)							int _g12 = 0;
HXDLIN(  54)							int _g13 = len1;
HXDLIN(  54)							while((_g12 < _g13)){
HXLINE(  54)								_g12 = (_g12 + 1);
HXDLIN(  54)								int i4 = (_g12 - 1);
HXDLIN(  54)								{
HXLINE(  54)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  54)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  54)									{
HXLINE(  54)										int _g14 = 0;
HXDLIN(  54)										int _g15 = i4;
HXDLIN(  54)										while((_g14 < _g15)){
HXLINE(  54)											_g14 = (_g14 + 1);
HXDLIN(  54)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  54)									if (::hx::IsNull( prev )) {
HXLINE(  54)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  54)										l = null();
            									}
            									else {
HXLINE(  54)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  54)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  54)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  54)		this1->image = _hx_tmp;
HXDLIN(  54)		this1->width = width;
HXDLIN(  54)		this1->height = height;
HXDLIN(  54)		this1->imageType = ( (int)(imageType) );
HXDLIN(  54)		 ::pi_xy::ImageStruct nextImage = this1;
HXLINE(  55)		nextImage->transparent = transparent;
HXLINE(  56)		while((_this_min < _this_max)){
HXLINE(  56)			_this_min = (_this_min + 1);
HXDLIN(  56)			int i6 = (_this_min - 1);
HXDLIN(  56)			if ((range_y > range_yMax)) {
HXLINE(  56)				range_y = range_yReset;
HXDLIN(  56)				range_x = (range_x + 1);
            			}
HXDLIN(  56)			range_y = (range_y + 1);
HXDLIN(  56)			int i7 = i6;
HXLINE(  58)			{
HXLINE(  58)				int x2 = range_y;
HXDLIN(  58)				int y2 = (range_xMax - range_x);
HXDLIN(  58)				int x3 = range_y;
HXDLIN(  58)				int y3 = range_x;
HXDLIN(  58)				::Dynamic this3 = thisImage->image;
HXDLIN(  58)				int index;
HXDLIN(  58)				if (thisImage->useVirtualPos) {
HXLINE(  58)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x3) - thisImage->virtualX));
            				}
            				else {
HXLINE(  58)					index = ::Std_obj::_hx_int(( (Float)(((y3 * thisImage->width) + x3)) ));
            				}
HXDLIN(  58)				int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  58)				int color;
HXDLIN(  58)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  58)					color = c;
            				}
HXDLIN(  58)				int c1 = color;
HXDLIN(  58)				bool _hx_tmp2;
HXDLIN(  58)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  58)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXLINE(  58)					_hx_tmp2 = false;
            				}
HXDLIN(  58)				if (_hx_tmp2) {
HXLINE(  58)					int location;
HXDLIN(  58)					if (nextImage->useVirtualPos) {
HXLINE(  58)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  58)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  58)					int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  58)					int this5;
HXDLIN(  58)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)						this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            					}
            					else {
HXLINE(  58)						this5 = this4;
            					}
HXDLIN(  58)					Float a1;
HXDLIN(  58)					int this6 = ((this5 >> 24) & 255);
HXDLIN(  58)					if ((this6 == 0)) {
HXLINE(  58)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float r1;
HXDLIN(  58)					int this7 = ((this5 >> 16) & 255);
HXDLIN(  58)					if ((this7 == 0)) {
HXLINE(  58)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float g1;
HXDLIN(  58)					int this8 = ((this5 >> 8) & 255);
HXDLIN(  58)					if ((this8 == 0)) {
HXLINE(  58)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float b11;
HXDLIN(  58)					int this9 = (this5 & 255);
HXDLIN(  58)					if ((this9 == 0)) {
HXLINE(  58)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float a2;
HXDLIN(  58)					int this10 = ((color >> 24) & 255);
HXDLIN(  58)					if ((this10 == 0)) {
HXLINE(  58)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float r2;
HXDLIN(  58)					int this11 = ((color >> 16) & 255);
HXDLIN(  58)					if ((this11 == 0)) {
HXLINE(  58)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float g2;
HXDLIN(  58)					int this12 = ((color >> 8) & 255);
HXDLIN(  58)					if ((this12 == 0)) {
HXLINE(  58)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float b21;
HXDLIN(  58)					int this13 = (color & 255);
HXDLIN(  58)					if ((this13 == 0)) {
HXLINE(  58)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  58)						b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  58)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  58)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  58)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  58)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  58)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  58)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  58)					{
HXLINE(  58)						int _hx_tmp3;
HXDLIN(  58)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  58)							_hx_tmp3 = blended;
            						}
HXDLIN(  58)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  58)					::Dynamic this14 = nextImage->image;
HXDLIN(  58)					int index1;
HXDLIN(  58)					if (nextImage->useVirtualPos) {
HXLINE(  58)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  58)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  58)					int _hx_tmp4;
HXDLIN(  58)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  58)						_hx_tmp4 = c1;
            					}
HXDLIN(  58)					::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp4);
            				}
            			}
            		}
HXLINE(  80)		bool _hx_tmp5;
HXDLIN(  80)		if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  80)			_hx_tmp5 = includeMask;
            		}
            		else {
HXLINE(  80)			_hx_tmp5 = false;
            		}
HXDLIN(  80)		if (_hx_tmp5) {
HXLINE(  81)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(thisImage->mask,x,y,w,h,thisImage->mask->transparent,includeMask);
HXDLIN(  81)			nextImage->useMask = true;
HXDLIN(  81)			nextImage->mask = v1;
            		}
HXLINE(  83)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(SpinImage_Fields__obj,spinAntiClock90,return )

 ::pi_xy::ImageStruct SpinImage_Fields__obj::spin180( ::pi_xy::ImageStruct thisImage,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_90_spin180)
HXLINE(  91)		Float r_x = x;
HXDLIN(  91)		Float r_y = y;
HXDLIN(  91)		Float r_w = w;
HXDLIN(  91)		Float r_h = h;
HXDLIN(  91)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  91)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  91)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  91)		int ii_max = xmax;
HXDLIN(  91)		int xRange__start = ii_min;
HXDLIN(  91)		int xRange__max = ii_max;
HXDLIN(  91)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  91)		int ii_max1 = ymax;
HXDLIN(  91)		int yRange__start = ii_min1;
HXDLIN(  91)		int yRange__max = ii_max1;
HXDLIN(  91)		int range_x = xRange__start;
HXDLIN(  91)		int range_y = (yRange__start - 1);
HXDLIN(  91)		int range_xReset = range_x;
HXDLIN(  91)		int range_yReset = range_y;
HXDLIN(  91)		int range_xMax = (xRange__max - 2);
HXDLIN(  91)		int range_yMax = (yRange__max - 2);
HXDLIN(  91)		int _this_min = 0;
HXDLIN(  91)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXLINE(  92)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  92)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  92)		 ::Dynamic imageType = null();
HXDLIN(  92)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  92)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  92)		::Dynamic _hx_tmp;
HXDLIN(  92)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  92)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  92)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  92)				{
HXLINE(  92)					b->width = width;
HXDLIN(  92)					b->height = height;
HXDLIN(  92)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  92)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  92)					{
HXLINE(  92)						int len = b->length;
HXDLIN(  92)						int w1 = 0;
HXDLIN(  92)						{
HXLINE(  92)							int _g = 0;
HXDLIN(  92)							int _g1 = b->height;
HXDLIN(  92)							while((_g < _g1)){
HXLINE(  92)								_g = (_g + 1);
HXDLIN(  92)								int y1 = (_g - 1);
HXDLIN(  92)								{
HXLINE(  92)									int _g2 = 0;
HXDLIN(  92)									int _g3 = b->width;
HXDLIN(  92)									while((_g2 < _g3)){
HXLINE(  92)										_g2 = (_g2 + 1);
HXDLIN(  92)										int x1 = (_g2 - 1);
HXDLIN(  92)										{
HXLINE(  92)											w1 = (w1 + 1);
HXDLIN(  92)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  92)										{
HXLINE(  92)											w1 = (w1 + 1);
HXDLIN(  92)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  92)										{
HXLINE(  92)											w1 = (w1 + 1);
HXDLIN(  92)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  92)										{
HXLINE(  92)											w1 = (w1 + 1);
HXDLIN(  92)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  92)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  92)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  92)				{
HXLINE(  92)					a->width = width;
HXDLIN(  92)					a->height = height;
HXDLIN(  92)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  92)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  92)					{
HXLINE(  92)						int _g4 = 0;
HXDLIN(  92)						int _g5 = a->length;
HXDLIN(  92)						while((_g4 < _g5)){
HXLINE(  92)							_g4 = (_g4 + 1);
HXDLIN(  92)							int i = (_g4 - 1);
HXDLIN(  92)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  92)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  92)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  92)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  92)				{
HXLINE(  92)					b1->width = width;
HXDLIN(  92)					b1->height = height;
HXDLIN(  92)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  92)					int size = (b1->length * 4);
HXDLIN(  92)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  92)					{
HXLINE(  92)						int _g6 = 0;
HXDLIN(  92)						int _g7 = b1->length;
HXDLIN(  92)						while((_g6 < _g7)){
HXLINE(  92)							_g6 = (_g6 + 1);
HXDLIN(  92)							int i1 = (_g6 - 1);
HXDLIN(  92)							{
HXLINE(  92)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  92)								bool _hx_tmp1;
HXDLIN(  92)								if ((i1 >= 0)) {
HXLINE(  92)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  92)									_hx_tmp1 = false;
            								}
HXDLIN(  92)								if (_hx_tmp1) {
HXLINE(  92)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  92)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  92)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  92)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  92)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  92)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  92)				{
HXLINE(  92)					v->width = width;
HXDLIN(  92)					v->height = height;
HXDLIN(  92)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  92)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  92)					{
HXLINE(  92)						int _g8 = 0;
HXDLIN(  92)						int _g9 = v->length;
HXDLIN(  92)						while((_g8 < _g9)){
HXLINE(  92)							_g8 = (_g8 + 1);
HXDLIN(  92)							int i2 = (_g8 - 1);
HXDLIN(  92)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  92)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  92)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  92)				{
HXLINE(  92)					b2->width = width;
HXDLIN(  92)					b2->height = height;
HXDLIN(  92)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  92)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  92)					{
HXLINE(  92)						int len1 = b2->length;
HXDLIN(  92)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  92)						if (::hx::IsNull( d->head )) {
HXLINE(  92)							int _g10 = 0;
HXDLIN(  92)							int _g11 = len1;
HXDLIN(  92)							while((_g10 < _g11)){
HXLINE(  92)								_g10 = (_g10 + 1);
HXDLIN(  92)								int i3 = (_g10 - 1);
HXDLIN(  92)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  92)							int _g12 = 0;
HXDLIN(  92)							int _g13 = len1;
HXDLIN(  92)							while((_g12 < _g13)){
HXLINE(  92)								_g12 = (_g12 + 1);
HXDLIN(  92)								int i4 = (_g12 - 1);
HXDLIN(  92)								{
HXLINE(  92)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  92)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  92)									{
HXLINE(  92)										int _g14 = 0;
HXDLIN(  92)										int _g15 = i4;
HXDLIN(  92)										while((_g14 < _g15)){
HXLINE(  92)											_g14 = (_g14 + 1);
HXDLIN(  92)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  92)									if (::hx::IsNull( prev )) {
HXLINE(  92)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  92)										l = null();
            									}
            									else {
HXLINE(  92)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  92)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  92)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  92)		this1->image = _hx_tmp;
HXDLIN(  92)		this1->width = width;
HXDLIN(  92)		this1->height = height;
HXDLIN(  92)		this1->imageType = ( (int)(imageType) );
HXDLIN(  92)		 ::pi_xy::ImageStruct nextImage = this1;
HXLINE(  93)		nextImage->transparent = transparent;
HXLINE(  94)		while((_this_min < _this_max)){
HXLINE(  94)			_this_min = (_this_min + 1);
HXDLIN(  94)			int i6 = (_this_min - 1);
HXDLIN(  94)			if ((range_y > range_yMax)) {
HXLINE(  94)				range_y = range_yReset;
HXDLIN(  94)				range_x = (range_x + 1);
            			}
HXDLIN(  94)			range_y = (range_y + 1);
HXDLIN(  94)			int i7 = i6;
HXLINE(  96)			{
HXLINE(  96)				int x2 = (range_xMax - range_x);
HXDLIN(  96)				int y2 = (range_yMax - range_y);
HXDLIN(  96)				int x3 = range_x;
HXDLIN(  96)				int y3 = range_y;
HXDLIN(  96)				::Dynamic this3 = thisImage->image;
HXDLIN(  96)				int index;
HXDLIN(  96)				if (thisImage->useVirtualPos) {
HXLINE(  96)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x3) - thisImage->virtualX));
            				}
            				else {
HXLINE(  96)					index = ::Std_obj::_hx_int(( (Float)(((y3 * thisImage->width) + x3)) ));
            				}
HXDLIN(  96)				int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  96)				int color;
HXDLIN(  96)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  96)					color = c;
            				}
HXDLIN(  96)				int c1 = color;
HXDLIN(  96)				bool _hx_tmp2;
HXDLIN(  96)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  96)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXLINE(  96)					_hx_tmp2 = false;
            				}
HXDLIN(  96)				if (_hx_tmp2) {
HXLINE(  96)					int location;
HXDLIN(  96)					if (nextImage->useVirtualPos) {
HXLINE(  96)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  96)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  96)					int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  96)					int this5;
HXDLIN(  96)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)						this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            					}
            					else {
HXLINE(  96)						this5 = this4;
            					}
HXDLIN(  96)					Float a1;
HXDLIN(  96)					int this6 = ((this5 >> 24) & 255);
HXDLIN(  96)					if ((this6 == 0)) {
HXLINE(  96)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float r1;
HXDLIN(  96)					int this7 = ((this5 >> 16) & 255);
HXDLIN(  96)					if ((this7 == 0)) {
HXLINE(  96)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float g1;
HXDLIN(  96)					int this8 = ((this5 >> 8) & 255);
HXDLIN(  96)					if ((this8 == 0)) {
HXLINE(  96)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float b11;
HXDLIN(  96)					int this9 = (this5 & 255);
HXDLIN(  96)					if ((this9 == 0)) {
HXLINE(  96)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float a2;
HXDLIN(  96)					int this10 = ((color >> 24) & 255);
HXDLIN(  96)					if ((this10 == 0)) {
HXLINE(  96)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float r2;
HXDLIN(  96)					int this11 = ((color >> 16) & 255);
HXDLIN(  96)					if ((this11 == 0)) {
HXLINE(  96)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float g2;
HXDLIN(  96)					int this12 = ((color >> 8) & 255);
HXDLIN(  96)					if ((this12 == 0)) {
HXLINE(  96)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float b21;
HXDLIN(  96)					int this13 = (color & 255);
HXDLIN(  96)					if ((this13 == 0)) {
HXLINE(  96)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  96)						b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  96)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  96)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  96)					{
HXLINE(  96)						int _hx_tmp3;
HXDLIN(  96)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  96)							_hx_tmp3 = blended;
            						}
HXDLIN(  96)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  96)					::Dynamic this14 = nextImage->image;
HXDLIN(  96)					int index1;
HXDLIN(  96)					if (nextImage->useVirtualPos) {
HXLINE(  96)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  96)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  96)					int _hx_tmp4;
HXDLIN(  96)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  96)						_hx_tmp4 = c1;
            					}
HXDLIN(  96)					::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp4);
            				}
            			}
            		}
HXLINE( 118)		bool _hx_tmp5;
HXDLIN( 118)		if (::hx::IsNotNull( thisImage->mask )) {
HXLINE( 118)			_hx_tmp5 = includeMask;
            		}
            		else {
HXLINE( 118)			_hx_tmp5 = false;
            		}
HXDLIN( 118)		if (_hx_tmp5) {
HXLINE( 119)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(thisImage->mask,x,y,w,h,thisImage->mask->transparent,includeMask);
HXDLIN( 119)			nextImage->useMask = true;
HXDLIN( 119)			nextImage->mask = v1;
            		}
HXLINE( 121)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(SpinImage_Fields__obj,spin180,return )

 ::pi_xy::ImageStruct SpinImage_Fields__obj::rotatingClockwiseDegrees( ::pi_xy::ImageStruct thisImage,Float angle,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_127_rotatingClockwiseDegrees)
HXLINE( 128)		while((angle >= 360)){
HXLINE( 129)			angle = (angle - ( (Float)(360) ));
            		}
HXLINE( 131)		while((angle <= -360)){
HXLINE( 132)			angle = (angle + 360);
            		}
HXLINE( 134)		bool _hx_tmp;
HXDLIN( 134)		if ((angle != ((Float)90.))) {
HXLINE( 134)			_hx_tmp = (angle == -270);
            		}
            		else {
HXLINE( 134)			_hx_tmp = true;
            		}
HXDLIN( 134)		if (_hx_tmp) {
HXLINE( 135)			Float w = ( (Float)(thisImage->width) );
HXDLIN( 135)			Float h = ( (Float)(thisImage->height) );
HXDLIN( 135)			 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN( 135)			Float r_x = ( (Float)(0) );
HXDLIN( 135)			Float r_y = ( (Float)(0) );
HXDLIN( 135)			Float r_w = w;
HXDLIN( 135)			Float r_h = h;
HXDLIN( 135)			int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN( 135)			int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN( 135)			int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN( 135)			int ii_max = xmax;
HXDLIN( 135)			int xRange__start = ii_min;
HXDLIN( 135)			int xRange__max = ii_max;
HXDLIN( 135)			int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN( 135)			int ii_max1 = ymax;
HXDLIN( 135)			int yRange__start = ii_min1;
HXDLIN( 135)			int yRange__max = ii_max1;
HXDLIN( 135)			int range_x = xRange__start;
HXDLIN( 135)			int range_y = (yRange__start - 1);
HXDLIN( 135)			int range_xReset = range_x;
HXDLIN( 135)			int range_yReset = range_y;
HXDLIN( 135)			int range_xMax = (xRange__max - 2);
HXDLIN( 135)			int range_yMax = (yRange__max - 2);
HXDLIN( 135)			int _this_min = 0;
HXDLIN( 135)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 135)			int width = ::Std_obj::_hx_int(w);
HXDLIN( 135)			int height = ::Std_obj::_hx_int(h);
HXDLIN( 135)			 ::Dynamic imageType = null();
HXDLIN( 135)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 135)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 135)			::Dynamic _hx_tmp1;
HXDLIN( 135)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 135)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 135)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 135)					{
HXLINE( 135)						b->width = width;
HXDLIN( 135)						b->height = height;
HXDLIN( 135)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 135)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 135)						{
HXLINE( 135)							int len = b->length;
HXDLIN( 135)							int w1 = 0;
HXDLIN( 135)							{
HXLINE( 135)								int _g = 0;
HXDLIN( 135)								int _g1 = b->height;
HXDLIN( 135)								while((_g < _g1)){
HXLINE( 135)									_g = (_g + 1);
HXDLIN( 135)									int y = (_g - 1);
HXDLIN( 135)									{
HXLINE( 135)										int _g2 = 0;
HXDLIN( 135)										int _g3 = b->width;
HXDLIN( 135)										while((_g2 < _g3)){
HXLINE( 135)											_g2 = (_g2 + 1);
HXDLIN( 135)											int x = (_g2 - 1);
HXDLIN( 135)											{
HXLINE( 135)												w1 = (w1 + 1);
HXDLIN( 135)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 135)											{
HXLINE( 135)												w1 = (w1 + 1);
HXDLIN( 135)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 135)											{
HXLINE( 135)												w1 = (w1 + 1);
HXDLIN( 135)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 135)											{
HXLINE( 135)												w1 = (w1 + 1);
HXDLIN( 135)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 135)					_hx_tmp1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 135)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 135)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 135)					{
HXLINE( 135)						a->width = width;
HXDLIN( 135)						a->height = height;
HXDLIN( 135)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 135)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 135)						{
HXLINE( 135)							int _g4 = 0;
HXDLIN( 135)							int _g5 = a->length;
HXDLIN( 135)							while((_g4 < _g5)){
HXLINE( 135)								_g4 = (_g4 + 1);
HXDLIN( 135)								int i = (_g4 - 1);
HXDLIN( 135)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 135)					_hx_tmp1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 135)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 135)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 135)					{
HXLINE( 135)						b1->width = width;
HXDLIN( 135)						b1->height = height;
HXDLIN( 135)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 135)						int size = (b1->length * 4);
HXDLIN( 135)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 135)						{
HXLINE( 135)							int _g6 = 0;
HXDLIN( 135)							int _g7 = b1->length;
HXDLIN( 135)							while((_g6 < _g7)){
HXLINE( 135)								_g6 = (_g6 + 1);
HXDLIN( 135)								int i1 = (_g6 - 1);
HXDLIN( 135)								{
HXLINE( 135)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 135)									bool _hx_tmp2;
HXDLIN( 135)									if ((i1 >= 0)) {
HXLINE( 135)										_hx_tmp2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 135)										_hx_tmp2 = false;
            									}
HXDLIN( 135)									if (_hx_tmp2) {
HXLINE( 135)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 135)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 135)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 135)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 135)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 135)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 135)					_hx_tmp1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 135)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 135)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 135)					{
HXLINE( 135)						v->width = width;
HXDLIN( 135)						v->height = height;
HXDLIN( 135)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 135)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 135)						{
HXLINE( 135)							int _g8 = 0;
HXDLIN( 135)							int _g9 = v->length;
HXDLIN( 135)							while((_g8 < _g9)){
HXLINE( 135)								_g8 = (_g8 + 1);
HXDLIN( 135)								int i2 = (_g8 - 1);
HXDLIN( 135)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 135)					_hx_tmp1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 135)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 135)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 135)					{
HXLINE( 135)						b2->width = width;
HXDLIN( 135)						b2->height = height;
HXDLIN( 135)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 135)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 135)						{
HXLINE( 135)							int len1 = b2->length;
HXDLIN( 135)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 135)							if (::hx::IsNull( d->head )) {
HXLINE( 135)								int _g10 = 0;
HXDLIN( 135)								int _g11 = len1;
HXDLIN( 135)								while((_g10 < _g11)){
HXLINE( 135)									_g10 = (_g10 + 1);
HXDLIN( 135)									int i3 = (_g10 - 1);
HXDLIN( 135)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 135)								int _g12 = 0;
HXDLIN( 135)								int _g13 = len1;
HXDLIN( 135)								while((_g12 < _g13)){
HXLINE( 135)									_g12 = (_g12 + 1);
HXDLIN( 135)									int i4 = (_g12 - 1);
HXDLIN( 135)									{
HXLINE( 135)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 135)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 135)										{
HXLINE( 135)											int _g14 = 0;
HXDLIN( 135)											int _g15 = i4;
HXDLIN( 135)											while((_g14 < _g15)){
HXLINE( 135)												_g14 = (_g14 + 1);
HXDLIN( 135)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 135)										if (::hx::IsNull( prev )) {
HXLINE( 135)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 135)											l = null();
            										}
            										else {
HXLINE( 135)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 135)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 135)					_hx_tmp1 = b2;
            				}
            				break;
            			}
HXDLIN( 135)			this1->image = _hx_tmp1;
HXDLIN( 135)			this1->width = width;
HXDLIN( 135)			this1->height = height;
HXDLIN( 135)			this1->imageType = ( (int)(imageType) );
HXDLIN( 135)			 ::pi_xy::ImageStruct nextImage = this1;
HXDLIN( 135)			nextImage->transparent = transparent;
HXDLIN( 135)			while((_this_min < _this_max)){
HXLINE( 135)				_this_min = (_this_min + 1);
HXDLIN( 135)				int i6 = (_this_min - 1);
HXDLIN( 135)				if ((range_y > range_yMax)) {
HXLINE(  19)					range_y = range_yReset;
HXLINE( 135)					range_x = (range_x + 1);
            				}
HXDLIN( 135)				range_y = (range_y + 1);
HXDLIN( 135)				int i7 = i6;
HXDLIN( 135)				{
HXLINE( 135)					int x1 = (range_yMax - range_y);
HXDLIN( 135)					int y1 = range_x;
HXDLIN( 135)					int x2 = range_x;
HXDLIN( 135)					int y2 = range_y;
HXDLIN( 135)					::Dynamic this3 = thisImage1->image;
HXDLIN( 135)					int index;
HXDLIN( 135)					if (thisImage1->useVirtualPos) {
HXLINE( 135)						index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x2) - thisImage1->virtualX));
            					}
            					else {
HXLINE( 135)						index = ::Std_obj::_hx_int(( (Float)(((y2 * thisImage1->width) + x2)) ));
            					}
HXDLIN( 135)					int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 135)					int color;
HXDLIN( 135)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 135)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 135)						color = c;
            					}
HXDLIN( 135)					int c1 = color;
HXDLIN( 135)					bool _hx_tmp3;
HXDLIN( 135)					if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 135)						_hx_tmp3 = nextImage->transparent;
            					}
            					else {
HXLINE( 135)						_hx_tmp3 = false;
            					}
HXDLIN( 135)					if (_hx_tmp3) {
HXLINE( 135)						int location;
HXDLIN( 135)						if (nextImage->useVirtualPos) {
HXLINE( 135)							location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXLINE( 135)							location = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN( 135)						int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN( 135)						int this5;
HXDLIN( 135)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 135)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE( 135)							this5 = this4;
            						}
HXDLIN( 135)						Float a1;
HXDLIN( 135)						int this6 = ((this5 >> 24) & 255);
HXDLIN( 135)						if ((this6 == 0)) {
HXLINE( 135)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float r1;
HXDLIN( 135)						int this7 = ((this5 >> 16) & 255);
HXDLIN( 135)						if ((this7 == 0)) {
HXLINE( 135)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float g1;
HXDLIN( 135)						int this8 = ((this5 >> 8) & 255);
HXDLIN( 135)						if ((this8 == 0)) {
HXLINE( 135)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float b11;
HXDLIN( 135)						int this9 = (this5 & 255);
HXDLIN( 135)						if ((this9 == 0)) {
HXLINE( 135)							b11 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float a2;
HXDLIN( 135)						int this10 = ((color >> 24) & 255);
HXDLIN( 135)						if ((this10 == 0)) {
HXLINE( 135)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float r2;
HXDLIN( 135)						int this11 = ((color >> 16) & 255);
HXDLIN( 135)						if ((this11 == 0)) {
HXLINE( 135)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float g2;
HXDLIN( 135)						int this12 = ((color >> 8) & 255);
HXDLIN( 135)						if ((this12 == 0)) {
HXLINE( 135)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float b21;
HXDLIN( 135)						int this13 = (color & 255);
HXDLIN( 135)						if ((this13 == 0)) {
HXLINE( 135)							b21 = ((Float)0.);
            						}
            						else {
HXLINE( 135)							b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN( 135)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 135)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 135)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 135)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 135)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 135)						int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 135)						{
HXLINE( 135)							int _hx_tmp4;
HXDLIN( 135)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 135)								_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 135)								_hx_tmp4 = blended;
            							}
HXDLIN( 135)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp4);
            						}
            					}
            					else {
HXLINE( 135)						::Dynamic this14 = nextImage->image;
HXDLIN( 135)						int index1;
HXDLIN( 135)						if (nextImage->useVirtualPos) {
HXLINE( 135)							index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXLINE( 135)							index1 = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN( 135)						int _hx_tmp5;
HXDLIN( 135)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 135)							_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE( 135)							_hx_tmp5 = c1;
            						}
HXDLIN( 135)						::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp5);
            					}
            				}
            			}
HXDLIN( 135)			bool _hx_tmp6;
HXDLIN( 135)			if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE( 135)				_hx_tmp6 = includeMask;
            			}
            			else {
HXLINE( 135)				_hx_tmp6 = false;
            			}
HXDLIN( 135)			if (_hx_tmp6) {
HXLINE( 135)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(thisImage1->mask,( (Float)(0) ),( (Float)(0) ),w,h,thisImage1->mask->transparent,includeMask);
HXDLIN( 135)				nextImage->useMask = true;
HXDLIN( 135)				nextImage->mask = v1;
            			}
HXDLIN( 135)			return nextImage;
            		}
            		else {
HXLINE( 136)			bool _hx_tmp7;
HXDLIN( 136)			if ((angle != -90)) {
HXLINE( 136)				_hx_tmp7 = (angle == 270);
            			}
            			else {
HXLINE( 136)				_hx_tmp7 = true;
            			}
HXDLIN( 136)			if (_hx_tmp7) {
HXLINE( 137)				Float w2 = ( (Float)(thisImage->width) );
HXDLIN( 137)				Float h1 = ( (Float)(thisImage->height) );
HXDLIN( 137)				 ::pi_xy::ImageStruct thisImage2 = thisImage;
HXDLIN( 137)				Float r_x1 = ( (Float)(0) );
HXDLIN( 137)				Float r_y1 = ( (Float)(0) );
HXDLIN( 137)				Float r_w1 = w2;
HXDLIN( 137)				Float r_h1 = h1;
HXDLIN( 137)				int xmax1 = ::Std_obj::_hx_int(((r_x1 + r_w1) + 1));
HXDLIN( 137)				int ymax1 = ::Std_obj::_hx_int(((r_y1 + r_h1) + 1));
HXDLIN( 137)				int ii_min2 = ::Std_obj::_hx_int(r_x1);
HXDLIN( 137)				int ii_max2 = xmax1;
HXDLIN( 137)				int xRange__start1 = ii_min2;
HXDLIN( 137)				int xRange__max1 = ii_max2;
HXDLIN( 137)				int ii_min3 = ::Std_obj::_hx_int(r_y1);
HXDLIN( 137)				int ii_max3 = ymax1;
HXDLIN( 137)				int yRange__start1 = ii_min3;
HXDLIN( 137)				int yRange__max1 = ii_max3;
HXDLIN( 137)				int range_x1 = xRange__start1;
HXDLIN( 137)				int range_y1 = (yRange__start1 - 1);
HXDLIN( 137)				int range_xReset1 = range_x1;
HXDLIN( 137)				int range_yReset1 = range_y1;
HXDLIN( 137)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 137)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 137)				int _this_min1 = 0;
HXDLIN( 137)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 137)				int width1 = ::Std_obj::_hx_int(w2);
HXDLIN( 137)				int height1 = ::Std_obj::_hx_int(h1);
HXDLIN( 137)				 ::Dynamic imageType1 = null();
HXDLIN( 137)				 ::pi_xy::ImageStruct this15 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 137)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 137)				::Dynamic _hx_tmp8;
HXDLIN( 137)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 137)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 137)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN( 137)						{
HXLINE( 137)							b4->width = width1;
HXDLIN( 137)							b4->height = height1;
HXDLIN( 137)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 137)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN( 137)							{
HXLINE( 137)								int len2 = b4->length;
HXDLIN( 137)								int w3 = 0;
HXDLIN( 137)								{
HXLINE( 137)									int _g16 = 0;
HXDLIN( 137)									int _g17 = b4->height;
HXDLIN( 137)									while((_g16 < _g17)){
HXLINE( 137)										_g16 = (_g16 + 1);
HXDLIN( 137)										int y3 = (_g16 - 1);
HXDLIN( 137)										{
HXLINE( 137)											int _g18 = 0;
HXDLIN( 137)											int _g19 = b4->width;
HXDLIN( 137)											while((_g18 < _g19)){
HXLINE( 137)												_g18 = (_g18 + 1);
HXDLIN( 137)												int x3 = (_g18 - 1);
HXDLIN( 137)												{
HXLINE( 137)													w3 = (w3 + 1);
HXDLIN( 137)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 137)												{
HXLINE( 137)													w3 = (w3 + 1);
HXDLIN( 137)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 137)												{
HXLINE( 137)													w3 = (w3 + 1);
HXDLIN( 137)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 137)												{
HXLINE( 137)													w3 = (w3 + 1);
HXDLIN( 137)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 137)						_hx_tmp8 = b4;
            					}
            					break;
            					case (int)1: {
HXLINE( 137)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 137)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN( 137)						{
HXLINE( 137)							a5->width = width1;
HXDLIN( 137)							a5->height = height1;
HXDLIN( 137)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN( 137)							a5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 137)							{
HXLINE( 137)								int _g20 = 0;
HXDLIN( 137)								int _g21 = a5->length;
HXDLIN( 137)								while((_g20 < _g21)){
HXLINE( 137)									_g20 = (_g20 + 1);
HXDLIN( 137)									int i8 = (_g20 - 1);
HXDLIN( 137)									a5->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 137)						_hx_tmp8 = a5;
            					}
            					break;
            					case (int)2: {
HXLINE( 137)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 137)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN( 137)						{
HXLINE( 137)							b5->width = width1;
HXDLIN( 137)							b5->height = height1;
HXDLIN( 137)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 137)							int size1 = (b5->length * 4);
HXDLIN( 137)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 137)							{
HXLINE( 137)								int _g22 = 0;
HXDLIN( 137)								int _g23 = b5->length;
HXDLIN( 137)								while((_g22 < _g23)){
HXLINE( 137)									_g22 = (_g22 + 1);
HXDLIN( 137)									int i9 = (_g22 - 1);
HXDLIN( 137)									{
HXLINE( 137)										 ::haxe::io::ArrayBufferViewImpl this16 = b5->data;
HXDLIN( 137)										bool _hx_tmp9;
HXDLIN( 137)										if ((i9 >= 0)) {
HXLINE( 137)											_hx_tmp9 = (i9 < (this16->byteLength >> 2));
            										}
            										else {
HXLINE( 137)											_hx_tmp9 = false;
            										}
HXDLIN( 137)										if (_hx_tmp9) {
HXLINE( 137)											 ::haxe::io::Bytes _this1 = this16->bytes;
HXDLIN( 137)											int pos1 = ((i9 << 2) + this16->byteOffset);
HXDLIN( 137)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 137)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 137)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 137)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 137)						_hx_tmp8 = b5;
            					}
            					break;
            					case (int)3: {
HXLINE( 137)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 137)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 137)						{
HXLINE( 137)							v2->width = width1;
HXDLIN( 137)							v2->height = height1;
HXDLIN( 137)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 137)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 137)							{
HXLINE( 137)								int _g24 = 0;
HXDLIN( 137)								int _g25 = v2->length;
HXDLIN( 137)								while((_g24 < _g25)){
HXLINE( 137)									_g24 = (_g24 + 1);
HXDLIN( 137)									int i10 = (_g24 - 1);
HXDLIN( 137)									v2->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 137)						_hx_tmp8 = v2;
            					}
            					break;
            					case (int)4: {
HXLINE( 137)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 137)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN( 137)						{
HXLINE( 137)							b6->width = width1;
HXDLIN( 137)							b6->height = height1;
HXDLIN( 137)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 137)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 137)							{
HXLINE( 137)								int len3 = b6->length;
HXDLIN( 137)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN( 137)								if (::hx::IsNull( d1->head )) {
HXLINE( 137)									int _g26 = 0;
HXDLIN( 137)									int _g27 = len3;
HXDLIN( 137)									while((_g26 < _g27)){
HXLINE( 137)										_g26 = (_g26 + 1);
HXDLIN( 137)										int i11 = (_g26 - 1);
HXDLIN( 137)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 137)									int _g28 = 0;
HXDLIN( 137)									int _g29 = len3;
HXDLIN( 137)									while((_g28 < _g29)){
HXLINE( 137)										_g28 = (_g28 + 1);
HXDLIN( 137)										int i12 = (_g28 - 1);
HXDLIN( 137)										{
HXLINE( 137)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN( 137)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 137)											{
HXLINE( 137)												int _g30 = 0;
HXDLIN( 137)												int _g31 = i12;
HXDLIN( 137)												while((_g30 < _g31)){
HXLINE( 137)													_g30 = (_g30 + 1);
HXDLIN( 137)													int i13 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 137)											if (::hx::IsNull( prev1 )) {
HXLINE( 137)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 137)												l1 = null();
            											}
            											else {
HXLINE( 137)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 137)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 137)						_hx_tmp8 = b6;
            					}
            					break;
            				}
HXDLIN( 137)				this15->image = _hx_tmp8;
HXDLIN( 137)				this15->width = width1;
HXDLIN( 137)				this15->height = height1;
HXDLIN( 137)				this15->imageType = ( (int)(imageType1) );
HXDLIN( 137)				 ::pi_xy::ImageStruct nextImage1 = this15;
HXDLIN( 137)				nextImage1->transparent = transparent;
HXDLIN( 137)				while((_this_min1 < _this_max1)){
HXLINE( 137)					_this_min1 = (_this_min1 + 1);
HXDLIN( 137)					int i14 = (_this_min1 - 1);
HXDLIN( 137)					if ((range_y1 > range_yMax1)) {
HXLINE(  56)						range_y1 = range_yReset1;
HXLINE( 137)						range_x1 = (range_x1 + 1);
            					}
HXDLIN( 137)					range_y1 = (range_y1 + 1);
HXDLIN( 137)					int i15 = i14;
HXDLIN( 137)					{
HXLINE( 137)						int x4 = range_y1;
HXDLIN( 137)						int y4 = (range_xMax1 - range_x1);
HXDLIN( 137)						int x5 = range_y1;
HXDLIN( 137)						int y5 = range_x1;
HXDLIN( 137)						::Dynamic this17 = thisImage2->image;
HXDLIN( 137)						int index2;
HXDLIN( 137)						if (thisImage2->useVirtualPos) {
HXLINE( 137)							index2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - thisImage2->virtualY) * ( (Float)(thisImage2->width) )) + x5) - thisImage2->virtualX));
            						}
            						else {
HXLINE( 137)							index2 = ::Std_obj::_hx_int(( (Float)(((y5 * thisImage2->width) + x5)) ));
            						}
HXDLIN( 137)						int c2 = ::iterMagic::Iimg_obj::get(this17,index2);
HXDLIN( 137)						int color1;
HXDLIN( 137)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 137)							color1 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            						}
            						else {
HXLINE( 137)							color1 = c2;
            						}
HXDLIN( 137)						int c3 = color1;
HXDLIN( 137)						bool _hx_tmp10;
HXDLIN( 137)						if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 137)							_hx_tmp10 = nextImage1->transparent;
            						}
            						else {
HXLINE( 137)							_hx_tmp10 = false;
            						}
HXDLIN( 137)						if (_hx_tmp10) {
HXLINE( 137)							int location1;
HXDLIN( 137)							if (nextImage1->useVirtualPos) {
HXLINE( 137)								location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXLINE( 137)								location1 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN( 137)							int this18 = ::iterMagic::Iimg_obj::get(nextImage1->image,location1);
HXDLIN( 137)							int this19;
HXDLIN( 137)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 137)								this19 = ((((((this18 >> 24) & 255) << 24) | ((this18 & 255) << 16)) | (((this18 >> 8) & 255) << 8)) | ((this18 >> 16) & 255));
            							}
            							else {
HXLINE( 137)								this19 = this18;
            							}
HXDLIN( 137)							Float a11;
HXDLIN( 137)							int this20 = ((this19 >> 24) & 255);
HXDLIN( 137)							if ((this20 == 0)) {
HXLINE( 137)								a11 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								a11 = (( (Float)(this20) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float r11;
HXDLIN( 137)							int this21 = ((this19 >> 16) & 255);
HXDLIN( 137)							if ((this21 == 0)) {
HXLINE( 137)								r11 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								r11 = (( (Float)(this21) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float g11;
HXDLIN( 137)							int this22 = ((this19 >> 8) & 255);
HXDLIN( 137)							if ((this22 == 0)) {
HXLINE( 137)								g11 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								g11 = (( (Float)(this22) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float b12;
HXDLIN( 137)							int this23 = (this19 & 255);
HXDLIN( 137)							if ((this23 == 0)) {
HXLINE( 137)								b12 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								b12 = (( (Float)(this23) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float a21;
HXDLIN( 137)							int this24 = ((color1 >> 24) & 255);
HXDLIN( 137)							if ((this24 == 0)) {
HXLINE( 137)								a21 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								a21 = (( (Float)(this24) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float r21;
HXDLIN( 137)							int this25 = ((color1 >> 16) & 255);
HXDLIN( 137)							if ((this25 == 0)) {
HXLINE( 137)								r21 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								r21 = (( (Float)(this25) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float g21;
HXDLIN( 137)							int this26 = ((color1 >> 8) & 255);
HXDLIN( 137)							if ((this26 == 0)) {
HXLINE( 137)								g21 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								g21 = (( (Float)(this26) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float b22;
HXDLIN( 137)							int this27 = (color1 & 255);
HXDLIN( 137)							if ((this27 == 0)) {
HXLINE( 137)								b22 = ((Float)0.);
            							}
            							else {
HXLINE( 137)								b22 = (( (Float)(this27) ) / ( (Float)(255) ));
            							}
HXDLIN( 137)							Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 137)							int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 137)							int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 137)							int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 137)							int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 137)							int blended1 = ((((a6 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 137)							{
HXLINE( 137)								int _hx_tmp11;
HXDLIN( 137)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 137)									_hx_tmp11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            								}
            								else {
HXLINE( 137)									_hx_tmp11 = blended1;
            								}
HXDLIN( 137)								::iterMagic::Iimg_obj::set(nextImage1->image,location1,_hx_tmp11);
            							}
            						}
            						else {
HXLINE( 137)							::Dynamic this28 = nextImage1->image;
HXDLIN( 137)							int index3;
HXDLIN( 137)							if (nextImage1->useVirtualPos) {
HXLINE( 137)								index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXLINE( 137)								index3 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN( 137)							int _hx_tmp12;
HXDLIN( 137)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 137)								_hx_tmp12 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 137)								_hx_tmp12 = c3;
            							}
HXDLIN( 137)							::iterMagic::Iimg_obj::set(this28,index3,_hx_tmp12);
            						}
            					}
            				}
HXDLIN( 137)				bool _hx_tmp13;
HXDLIN( 137)				if (::hx::IsNotNull( thisImage2->mask )) {
HXLINE( 137)					_hx_tmp13 = includeMask;
            				}
            				else {
HXLINE( 137)					_hx_tmp13 = false;
            				}
HXDLIN( 137)				if (_hx_tmp13) {
HXLINE( 137)					 ::pi_xy::ImageStruct v3 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(thisImage2->mask,( (Float)(0) ),( (Float)(0) ),w2,h1,thisImage2->mask->transparent,includeMask);
HXDLIN( 137)					nextImage1->useMask = true;
HXDLIN( 137)					nextImage1->mask = v3;
            				}
HXDLIN( 137)				return nextImage1;
            			}
            			else {
HXLINE( 138)				bool _hx_tmp14;
HXDLIN( 138)				if ((angle != 180)) {
HXLINE( 138)					_hx_tmp14 = (angle == -180);
            				}
            				else {
HXLINE( 138)					_hx_tmp14 = true;
            				}
HXDLIN( 138)				if (_hx_tmp14) {
HXLINE( 139)					Float w4 = ( (Float)(thisImage->width) );
HXDLIN( 139)					Float h2 = ( (Float)(thisImage->height) );
HXDLIN( 139)					 ::pi_xy::ImageStruct thisImage3 = thisImage;
HXDLIN( 139)					Float r_x2 = ( (Float)(0) );
HXDLIN( 139)					Float r_y2 = ( (Float)(0) );
HXDLIN( 139)					Float r_w2 = w4;
HXDLIN( 139)					Float r_h2 = h2;
HXDLIN( 139)					int xmax2 = ::Std_obj::_hx_int(((r_x2 + r_w2) + 1));
HXDLIN( 139)					int ymax2 = ::Std_obj::_hx_int(((r_y2 + r_h2) + 1));
HXDLIN( 139)					int ii_min4 = ::Std_obj::_hx_int(r_x2);
HXDLIN( 139)					int ii_max4 = xmax2;
HXDLIN( 139)					int xRange__start2 = ii_min4;
HXDLIN( 139)					int xRange__max2 = ii_max4;
HXDLIN( 139)					int ii_min5 = ::Std_obj::_hx_int(r_y2);
HXDLIN( 139)					int ii_max5 = ymax2;
HXDLIN( 139)					int yRange__start2 = ii_min5;
HXDLIN( 139)					int yRange__max2 = ii_max5;
HXDLIN( 139)					int range_x2 = xRange__start2;
HXDLIN( 139)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 139)					int range_xReset2 = range_x2;
HXDLIN( 139)					int range_yReset2 = range_y2;
HXDLIN( 139)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 139)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 139)					int _this_min2 = 0;
HXDLIN( 139)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 139)					int width2 = ::Std_obj::_hx_int(w4);
HXDLIN( 139)					int height2 = ::Std_obj::_hx_int(h2);
HXDLIN( 139)					 ::Dynamic imageType2 = null();
HXDLIN( 139)					 ::pi_xy::ImageStruct this29 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 139)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 139)					::Dynamic _hx_tmp15;
HXDLIN( 139)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE( 139)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 139)							 ::iterMagic::BytesImg b8 = byt2;
HXDLIN( 139)							{
HXLINE( 139)								b8->width = width2;
HXDLIN( 139)								b8->height = height2;
HXDLIN( 139)								b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 139)								b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN( 139)								{
HXLINE( 139)									int len4 = b8->length;
HXDLIN( 139)									int w5 = 0;
HXDLIN( 139)									{
HXLINE( 139)										int _g32 = 0;
HXDLIN( 139)										int _g33 = b8->height;
HXDLIN( 139)										while((_g32 < _g33)){
HXLINE( 139)											_g32 = (_g32 + 1);
HXDLIN( 139)											int y6 = (_g32 - 1);
HXDLIN( 139)											{
HXLINE( 139)												int _g34 = 0;
HXDLIN( 139)												int _g35 = b8->width;
HXDLIN( 139)												while((_g34 < _g35)){
HXLINE( 139)													_g34 = (_g34 + 1);
HXDLIN( 139)													int x6 = (_g34 - 1);
HXDLIN( 139)													{
HXLINE( 139)														w5 = (w5 + 1);
HXDLIN( 139)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 139)													{
HXLINE( 139)														w5 = (w5 + 1);
HXDLIN( 139)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 139)													{
HXLINE( 139)														w5 = (w5 + 1);
HXDLIN( 139)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 139)													{
HXLINE( 139)														w5 = (w5 + 1);
HXDLIN( 139)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 139)							_hx_tmp15 = b8;
            						}
            						break;
            						case (int)1: {
HXLINE( 139)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)							 ::iterMagic::ArrIntImg a7 = arrI2;
HXDLIN( 139)							{
HXLINE( 139)								a7->width = width2;
HXDLIN( 139)								a7->height = height2;
HXDLIN( 139)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 139)								a7->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 139)								{
HXLINE( 139)									int _g36 = 0;
HXDLIN( 139)									int _g37 = a7->length;
HXDLIN( 139)									while((_g36 < _g37)){
HXLINE( 139)										_g36 = (_g36 + 1);
HXDLIN( 139)										int i16 = (_g36 - 1);
HXDLIN( 139)										a7->data[i16] = 0;
            									}
            								}
            							}
HXDLIN( 139)							_hx_tmp15 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE( 139)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 139)							 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN( 139)							{
HXLINE( 139)								b9->width = width2;
HXDLIN( 139)								b9->height = height2;
HXDLIN( 139)								b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 139)								int size2 = (b9->length * 4);
HXDLIN( 139)								b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 139)								{
HXLINE( 139)									int _g38 = 0;
HXDLIN( 139)									int _g39 = b9->length;
HXDLIN( 139)									while((_g38 < _g39)){
HXLINE( 139)										_g38 = (_g38 + 1);
HXDLIN( 139)										int i17 = (_g38 - 1);
HXDLIN( 139)										{
HXLINE( 139)											 ::haxe::io::ArrayBufferViewImpl this30 = b9->data;
HXDLIN( 139)											bool _hx_tmp16;
HXDLIN( 139)											if ((i17 >= 0)) {
HXLINE( 139)												_hx_tmp16 = (i17 < (this30->byteLength >> 2));
            											}
            											else {
HXLINE( 139)												_hx_tmp16 = false;
            											}
HXDLIN( 139)											if (_hx_tmp16) {
HXLINE( 139)												 ::haxe::io::Bytes _this2 = this30->bytes;
HXDLIN( 139)												int pos2 = ((i17 << 2) + this30->byteOffset);
HXDLIN( 139)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 139)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 139)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 139)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 139)							_hx_tmp15 = b9;
            						}
            						break;
            						case (int)3: {
HXLINE( 139)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 139)							{
HXLINE( 139)								v4->width = width2;
HXDLIN( 139)								v4->height = height2;
HXDLIN( 139)								v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 139)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 139)								{
HXLINE( 139)									int _g40 = 0;
HXDLIN( 139)									int _g41 = v4->length;
HXDLIN( 139)									while((_g40 < _g41)){
HXLINE( 139)										_g40 = (_g40 + 1);
HXDLIN( 139)										int i18 = (_g40 - 1);
HXDLIN( 139)										v4->data->__unsafe_set(i18,0);
            									}
            								}
            							}
HXDLIN( 139)							_hx_tmp15 = v4;
            						}
            						break;
            						case (int)4: {
HXLINE( 139)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 139)							 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN( 139)							{
HXLINE( 139)								b10->width = width2;
HXDLIN( 139)								b10->height = height2;
HXDLIN( 139)								b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 139)								b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 139)								{
HXLINE( 139)									int len5 = b10->length;
HXDLIN( 139)									 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN( 139)									if (::hx::IsNull( d2->head )) {
HXLINE( 139)										int _g42 = 0;
HXDLIN( 139)										int _g43 = len5;
HXDLIN( 139)										while((_g42 < _g43)){
HXLINE( 139)											_g42 = (_g42 + 1);
HXDLIN( 139)											int i19 = (_g42 - 1);
HXDLIN( 139)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE( 139)										int _g44 = 0;
HXDLIN( 139)										int _g45 = len5;
HXDLIN( 139)										while((_g44 < _g45)){
HXLINE( 139)											_g44 = (_g44 + 1);
HXDLIN( 139)											int i20 = (_g44 - 1);
HXDLIN( 139)											{
HXLINE( 139)												 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN( 139)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 139)												{
HXLINE( 139)													int _g46 = 0;
HXDLIN( 139)													int _g47 = i20;
HXDLIN( 139)													while((_g46 < _g47)){
HXLINE( 139)														_g46 = (_g46 + 1);
HXDLIN( 139)														int i21 = (_g46 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 139)												if (::hx::IsNull( prev2 )) {
HXLINE( 139)													b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 139)													l2 = null();
            												}
            												else {
HXLINE( 139)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 139)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 139)							_hx_tmp15 = b10;
            						}
            						break;
            					}
HXDLIN( 139)					this29->image = _hx_tmp15;
HXDLIN( 139)					this29->width = width2;
HXDLIN( 139)					this29->height = height2;
HXDLIN( 139)					this29->imageType = ( (int)(imageType2) );
HXDLIN( 139)					 ::pi_xy::ImageStruct nextImage2 = this29;
HXDLIN( 139)					nextImage2->transparent = transparent;
HXDLIN( 139)					while((_this_min2 < _this_max2)){
HXLINE( 139)						_this_min2 = (_this_min2 + 1);
HXDLIN( 139)						int i22 = (_this_min2 - 1);
HXDLIN( 139)						if ((range_y2 > range_yMax2)) {
HXLINE(  94)							range_y2 = range_yReset2;
HXLINE( 139)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 139)						range_y2 = (range_y2 + 1);
HXDLIN( 139)						int i23 = i22;
HXDLIN( 139)						{
HXLINE( 139)							int x7 = (range_xMax2 - range_x2);
HXDLIN( 139)							int y7 = (range_yMax2 - range_y2);
HXDLIN( 139)							int x8 = range_x2;
HXDLIN( 139)							int y8 = range_y2;
HXDLIN( 139)							::Dynamic this31 = thisImage3->image;
HXDLIN( 139)							int index4;
HXDLIN( 139)							if (thisImage3->useVirtualPos) {
HXLINE( 139)								index4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - thisImage3->virtualY) * ( (Float)(thisImage3->width) )) + x8) - thisImage3->virtualX));
            							}
            							else {
HXLINE( 139)								index4 = ::Std_obj::_hx_int(( (Float)(((y8 * thisImage3->width) + x8)) ));
            							}
HXDLIN( 139)							int c4 = ::iterMagic::Iimg_obj::get(this31,index4);
HXDLIN( 139)							int color2;
HXDLIN( 139)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)								color2 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            							}
            							else {
HXLINE( 139)								color2 = c4;
            							}
HXDLIN( 139)							int c5 = color2;
HXDLIN( 139)							bool _hx_tmp17;
HXDLIN( 139)							if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 139)								_hx_tmp17 = nextImage2->transparent;
            							}
            							else {
HXLINE( 139)								_hx_tmp17 = false;
            							}
HXDLIN( 139)							if (_hx_tmp17) {
HXLINE( 139)								int location2;
HXDLIN( 139)								if (nextImage2->useVirtualPos) {
HXLINE( 139)									location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXLINE( 139)									location2 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN( 139)								int this32 = ::iterMagic::Iimg_obj::get(nextImage2->image,location2);
HXDLIN( 139)								int this33;
HXDLIN( 139)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)									this33 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            								}
            								else {
HXLINE( 139)									this33 = this32;
            								}
HXDLIN( 139)								Float a12;
HXDLIN( 139)								int this34 = ((this33 >> 24) & 255);
HXDLIN( 139)								if ((this34 == 0)) {
HXLINE( 139)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									a12 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float r12;
HXDLIN( 139)								int this35 = ((this33 >> 16) & 255);
HXDLIN( 139)								if ((this35 == 0)) {
HXLINE( 139)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									r12 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float g12;
HXDLIN( 139)								int this36 = ((this33 >> 8) & 255);
HXDLIN( 139)								if ((this36 == 0)) {
HXLINE( 139)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									g12 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float b13;
HXDLIN( 139)								int this37 = (this33 & 255);
HXDLIN( 139)								if ((this37 == 0)) {
HXLINE( 139)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									b13 = (( (Float)(this37) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float a22;
HXDLIN( 139)								int this38 = ((color2 >> 24) & 255);
HXDLIN( 139)								if ((this38 == 0)) {
HXLINE( 139)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									a22 = (( (Float)(this38) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float r22;
HXDLIN( 139)								int this39 = ((color2 >> 16) & 255);
HXDLIN( 139)								if ((this39 == 0)) {
HXLINE( 139)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									r22 = (( (Float)(this39) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float g22;
HXDLIN( 139)								int this40 = ((color2 >> 8) & 255);
HXDLIN( 139)								if ((this40 == 0)) {
HXLINE( 139)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									g22 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float b23;
HXDLIN( 139)								int this41 = (color2 & 255);
HXDLIN( 139)								if ((this41 == 0)) {
HXLINE( 139)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 139)									b23 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 139)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 139)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 139)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 139)								int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 139)								int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 139)								int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN( 139)								{
HXLINE( 139)									int _hx_tmp18;
HXDLIN( 139)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										_hx_tmp18 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 139)										_hx_tmp18 = blended2;
            									}
HXDLIN( 139)									::iterMagic::Iimg_obj::set(nextImage2->image,location2,_hx_tmp18);
            								}
            							}
            							else {
HXLINE( 139)								::Dynamic this42 = nextImage2->image;
HXDLIN( 139)								int index5;
HXDLIN( 139)								if (nextImage2->useVirtualPos) {
HXLINE( 139)									index5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXLINE( 139)									index5 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN( 139)								int _hx_tmp19;
HXDLIN( 139)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)									_hx_tmp19 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 139)									_hx_tmp19 = c5;
            								}
HXDLIN( 139)								::iterMagic::Iimg_obj::set(this42,index5,_hx_tmp19);
            							}
            						}
            					}
HXDLIN( 139)					bool _hx_tmp20;
HXDLIN( 139)					if (::hx::IsNotNull( thisImage3->mask )) {
HXLINE( 139)						_hx_tmp20 = includeMask;
            					}
            					else {
HXLINE( 139)						_hx_tmp20 = false;
            					}
HXDLIN( 139)					if (_hx_tmp20) {
HXLINE( 139)						 ::pi_xy::ImageStruct v5 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(thisImage3->mask,( (Float)(0) ),( (Float)(0) ),w4,h2,thisImage3->mask->transparent,includeMask);
HXDLIN( 139)						nextImage2->useMask = true;
HXDLIN( 139)						nextImage2->mask = v5;
            					}
HXDLIN( 139)					return nextImage2;
            				}
            				else {
HXLINE( 141)					 ::pi_xy::ImageStruct this43 = thisImage;
HXDLIN( 141)					Float theta = ((angle * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN( 141)					Float centreX1 = centreX;
HXDLIN( 141)					Float centreY1 = centreY;
HXDLIN( 141)					Float ax = ((Float)0.);
HXDLIN( 141)					Float ay = ((Float)0.);
HXDLIN( 141)					if ((centreX1 != ((Float)0.))) {
HXLINE( 173)						centreX1 = ((( (Float)(this43->width) ) / ( (Float)(2) )) + centreX1);
HXLINE( 141)						ax = (ax - centreX1);
            					}
HXDLIN( 141)					if ((centreY1 != ((Float)0.))) {
HXLINE( 177)						centreY1 = ((( (Float)(this43->height) ) / ( (Float)(2) )) + centreY1);
HXLINE( 141)						ay = (ay - centreY1);
            					}
HXDLIN( 141)					Float bx = (ax + this43->width);
HXDLIN( 141)					Float by = ay;
HXDLIN( 141)					Float cx = bx;
HXDLIN( 141)					Float cy = (ay + this43->height);
HXDLIN( 141)					Float dx = ax;
HXDLIN( 141)					Float dy = cy;
HXDLIN( 141)					Float sin = ::Math_obj::sin(theta);
HXDLIN( 141)					Float cos = ::Math_obj::cos(theta);
HXDLIN( 141)					Float temp = ax;
HXLINE( 189)					ax = ((temp * cos) - (ay * sin));
HXLINE( 190)					ay = ((ay * cos) + (temp * sin));
HXLINE( 141)					Float temp1 = bx;
HXLINE( 192)					bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)					by = ((by * cos) + (temp1 * sin));
HXLINE( 141)					Float temp2 = cx;
HXLINE( 195)					cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)					cy = ((cy * cos) + (temp2 * sin));
HXLINE( 141)					Float temp3 = dx;
HXLINE( 198)					dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)					dy = ((dy * cos) + (temp3 * sin));
HXLINE( 141)					if ((centreX1 != ((Float)0.))) {
HXLINE( 141)						ax = (ax + centreX1);
HXDLIN( 141)						bx = (bx + centreX1);
HXDLIN( 141)						cx = (cx + centreX1);
HXDLIN( 141)						dx = (dx + centreX1);
            					}
HXDLIN( 141)					if ((centreY1 != ((Float)0.))) {
HXLINE( 141)						ay = (ay + centreY1);
HXDLIN( 141)						by = (by + centreY1);
HXDLIN( 141)						cy = (cy + centreY1);
HXDLIN( 141)						dy = (dy + centreY1);
            					}
HXDLIN( 141)					int min = ::Math_obj::floor(ax);
HXDLIN( 141)					int max = ::Math_obj::ceil(ax);
HXDLIN( 141)					if ((bx < min)) {
HXLINE(  31)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 141)						if ((bx > max)) {
HXLINE(  33)							max = ::Math_obj::ceil(bx);
            						}
            					}
HXLINE( 141)					if ((cx < min)) {
HXLINE(  36)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 141)						if ((cx > max)) {
HXLINE(  38)							max = ::Math_obj::ceil(cx);
            						}
            					}
HXLINE( 141)					if ((dx < min)) {
HXLINE(  41)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 141)						if ((dx > max)) {
HXLINE(  43)							max = ::Math_obj::ceil(dx);
            						}
            					}
HXLINE( 141)					int ii_min6 = min;
HXDLIN( 141)					int ii_max6 = max;
HXDLIN( 141)					 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
HXDLIN( 141)					int min1 = ::Math_obj::floor(ay);
HXDLIN( 141)					int max1 = ::Math_obj::ceil(ay);
HXDLIN( 141)					if ((by < min1)) {
HXLINE(  31)						min1 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 141)						if ((by > max1)) {
HXLINE(  33)							max1 = ::Math_obj::ceil(by);
            						}
            					}
HXLINE( 141)					if ((cy < min1)) {
HXLINE(  36)						min1 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 141)						if ((cy > max1)) {
HXLINE(  38)							max1 = ::Math_obj::ceil(cy);
            						}
            					}
HXLINE( 141)					if ((dy < min1)) {
HXLINE(  41)						min1 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 141)						if ((dy > max1)) {
HXLINE(  43)							max1 = ::Math_obj::ceil(dy);
            						}
            					}
HXLINE( 141)					int ii_min7 = min1;
HXDLIN( 141)					int ii_max7 = max1;
HXDLIN( 141)					 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
HXDLIN( 141)					int minX = boundX->start;
HXDLIN( 141)					int wid = ((boundX->max - boundX->start) + 1);
HXDLIN( 141)					int minY = boundY->start;
HXDLIN( 141)					int hi = ((boundY->max - boundY->start) + 1);
HXDLIN( 141)					 ::Dynamic imageType3 = null();
HXDLIN( 141)					 ::pi_xy::ImageStruct this44 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 141)					::Dynamic _hx_tmp21;
HXDLIN( 141)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 141)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)							 ::iterMagic::BytesImg b15 = byt3;
HXDLIN( 141)							{
HXLINE( 141)								b15->width = wid;
HXDLIN( 141)								b15->height = hi;
HXDLIN( 141)								b15->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 141)								b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN( 141)								{
HXLINE( 141)									int len6 = b15->length;
HXDLIN( 141)									int w6 = 0;
HXDLIN( 141)									{
HXLINE( 141)										int _g48 = 0;
HXDLIN( 141)										int _g49 = b15->height;
HXDLIN( 141)										while((_g48 < _g49)){
HXLINE( 141)											_g48 = (_g48 + 1);
HXDLIN( 141)											int y9 = (_g48 - 1);
HXDLIN( 141)											{
HXLINE( 141)												int _g50 = 0;
HXDLIN( 141)												int _g51 = b15->width;
HXDLIN( 141)												while((_g50 < _g51)){
HXLINE( 141)													_g50 = (_g50 + 1);
HXDLIN( 141)													int x9 = (_g50 - 1);
HXDLIN( 141)													{
HXLINE( 141)														w6 = (w6 + 1);
HXDLIN( 141)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 141)													{
HXLINE( 141)														w6 = (w6 + 1);
HXDLIN( 141)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 141)													{
HXLINE( 141)														w6 = (w6 + 1);
HXDLIN( 141)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 141)													{
HXLINE( 141)														w6 = (w6 + 1);
HXDLIN( 141)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							_hx_tmp21 = b15;
            						}
            						break;
            						case (int)1: {
HXLINE( 141)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)							 ::iterMagic::ArrIntImg a9 = arrI3;
HXDLIN( 141)							{
HXLINE( 141)								a9->width = wid;
HXDLIN( 141)								a9->height = hi;
HXDLIN( 141)								a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)								a9->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 141)								{
HXLINE( 141)									int _g52 = 0;
HXDLIN( 141)									int _g53 = a9->length;
HXDLIN( 141)									while((_g52 < _g53)){
HXLINE( 141)										_g52 = (_g52 + 1);
HXDLIN( 141)										int i24 = (_g52 - 1);
HXDLIN( 141)										a9->data[i24] = 0;
            									}
            								}
            							}
HXDLIN( 141)							_hx_tmp21 = a9;
            						}
            						break;
            						case (int)2: {
HXLINE( 141)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)							 ::iterMagic::U32ArrImg b16 = u32a3;
HXDLIN( 141)							{
HXLINE( 141)								b16->width = wid;
HXDLIN( 141)								b16->height = hi;
HXDLIN( 141)								b16->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 141)								int size3 = (b16->length * 4);
HXDLIN( 141)								b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 141)								{
HXLINE( 141)									int _g54 = 0;
HXDLIN( 141)									int _g55 = b16->length;
HXDLIN( 141)									while((_g54 < _g55)){
HXLINE( 141)										_g54 = (_g54 + 1);
HXDLIN( 141)										int i25 = (_g54 - 1);
HXDLIN( 141)										{
HXLINE( 141)											 ::haxe::io::ArrayBufferViewImpl this45 = b16->data;
HXDLIN( 141)											bool _hx_tmp22;
HXDLIN( 141)											if ((i25 >= 0)) {
HXLINE( 141)												_hx_tmp22 = (i25 < (this45->byteLength >> 2));
            											}
            											else {
HXLINE( 141)												_hx_tmp22 = false;
            											}
HXDLIN( 141)											if (_hx_tmp22) {
HXLINE( 141)												 ::haxe::io::Bytes _this3 = this45->bytes;
HXDLIN( 141)												int pos3 = ((i25 << 2) + this45->byteOffset);
HXDLIN( 141)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 141)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							_hx_tmp21 = b16;
            						}
            						break;
            						case (int)3: {
HXLINE( 141)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)							 ::iterMagic::VecIntImg v6 = vec3;
HXDLIN( 141)							{
HXLINE( 141)								v6->width = wid;
HXDLIN( 141)								v6->height = hi;
HXDLIN( 141)								v6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 141)								v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 141)								{
HXLINE( 141)									int _g56 = 0;
HXDLIN( 141)									int _g57 = v6->length;
HXDLIN( 141)									while((_g56 < _g57)){
HXLINE( 141)										_g56 = (_g56 + 1);
HXDLIN( 141)										int i26 = (_g56 - 1);
HXDLIN( 141)										v6->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN( 141)							_hx_tmp21 = v6;
            						}
            						break;
            						case (int)4: {
HXLINE( 141)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)							 ::iterMagic::StackIntImg b17 = sInt3;
HXDLIN( 141)							{
HXLINE( 141)								b17->width = wid;
HXDLIN( 141)								b17->height = hi;
HXDLIN( 141)								b17->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 141)								b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)								{
HXLINE( 141)									int len7 = b17->length;
HXDLIN( 141)									 ::haxe::ds::GenericStack_Int d3 = b17->data;
HXDLIN( 141)									if (::hx::IsNull( d3->head )) {
HXLINE( 141)										int _g58 = 0;
HXDLIN( 141)										int _g59 = len7;
HXDLIN( 141)										while((_g58 < _g59)){
HXLINE( 141)											_g58 = (_g58 + 1);
HXDLIN( 141)											int i27 = (_g58 - 1);
HXDLIN( 141)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 141)										int _g60 = 0;
HXDLIN( 141)										int _g61 = len7;
HXDLIN( 141)										while((_g60 < _g61)){
HXLINE( 141)											_g60 = (_g60 + 1);
HXDLIN( 141)											int i28 = (_g60 - 1);
HXDLIN( 141)											{
HXLINE( 141)												 ::haxe::ds::GenericCell_Int l3 = b17->data->head;
HXDLIN( 141)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 141)												{
HXLINE( 141)													int _g62 = 0;
HXDLIN( 141)													int _g63 = i28;
HXDLIN( 141)													while((_g62 < _g63)){
HXLINE( 141)														_g62 = (_g62 + 1);
HXDLIN( 141)														int i29 = (_g62 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 141)												if (::hx::IsNull( prev3 )) {
HXLINE( 141)													b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 141)													l3 = null();
            												}
            												else {
HXLINE( 141)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 141)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							_hx_tmp21 = b17;
            						}
            						break;
            					}
HXDLIN( 141)					this44->image = _hx_tmp21;
HXDLIN( 141)					this44->width = wid;
HXDLIN( 141)					this44->height = hi;
HXDLIN( 141)					this44->imageType = ( (int)(imageType3) );
HXDLIN( 141)					 ::pi_xy::ImageStruct nextImage3 = this44;
HXDLIN( 141)					nextImage3->transparent = true;
HXDLIN( 141)					if ((minX < ((Float)0.))) {
HXLINE( 141)						ax = (ax - ( (Float)(minX) ));
HXDLIN( 141)						bx = (bx - ( (Float)(minX) ));
HXDLIN( 141)						cx = (cx - ( (Float)(minX) ));
HXDLIN( 141)						dx = (dx - ( (Float)(minX) ));
            					}
HXDLIN( 141)					if ((minY < ((Float)0.))) {
HXLINE( 141)						ay = (ay - ( (Float)(minY) ));
HXDLIN( 141)						by = (by - ( (Float)(minY) ));
HXDLIN( 141)						cy = (cy - ( (Float)(minY) ));
HXDLIN( 141)						dy = (dy - ( (Float)(minY) ));
            					}
HXDLIN( 141)					{
HXLINE( 141)						 ::pi_xy::ImageStruct this46 = nextImage3;
HXDLIN( 141)						Float win_x = ( (Float)(0) );
HXDLIN( 141)						Float win_y = ( (Float)(0) );
HXDLIN( 141)						Float win_width = ( (Float)(this43->width) );
HXDLIN( 141)						Float win_height = ( (Float)(this43->height) );
HXDLIN( 141)						{
HXLINE( 141)							Float bu = ((Float)1.);
HXDLIN( 141)							Float bv = ((Float)0.);
HXDLIN( 141)							Float cu = ((Float)1.);
HXDLIN( 141)							Float cv = ((Float)1.);
HXDLIN( 141)							Float du = ((Float)0.);
HXDLIN( 141)							Float dv = ((Float)1.);
HXDLIN( 141)							Float au = ((Float)0.);
HXDLIN( 141)							Float av = ((Float)0.);
HXDLIN( 141)							Float bu1 = bu;
HXDLIN( 141)							Float bv1 = bv;
HXDLIN( 141)							bool hasUndo = false;
HXDLIN( 141)							Float temp4 = au;
HXLINE( 422)							au = bu1;
HXLINE( 423)							bu1 = temp4;
HXLINE( 424)							temp4 = av;
HXLINE( 425)							av = bv1;
HXLINE( 426)							bv1 = temp4;
HXLINE( 141)							Float bcx = (bx - dx);
HXDLIN( 141)							Float bcy = (by - dy);
HXDLIN( 141)							Float acx = (ax - dx);
HXDLIN( 141)							Float acy = (ay - dy);
HXDLIN( 141)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 141)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 141)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 141)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 141)							if ((ax > bx)) {
HXLINE( 141)								if ((ax > dx)) {
HXLINE( 141)									int min2;
HXDLIN( 141)									if ((bx > dx)) {
HXLINE( 141)										min2 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 141)										min2 = ::Math_obj::floor(bx);
            									}
HXDLIN( 141)									int ii_min8 = min2;
HXDLIN( 141)									int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 141)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE( 141)									int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 141)									int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 141)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE( 141)								if ((bx > dx)) {
HXLINE( 141)									int min3;
HXDLIN( 141)									if ((ax > dx)) {
HXLINE( 141)										min3 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 141)										min3 = ::Math_obj::ceil(ax);
            									}
HXDLIN( 141)									int ii_min10 = min3;
HXDLIN( 141)									int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 141)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE( 141)									int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 141)									int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 141)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 141)							if ((ay > by)) {
HXLINE( 141)								if ((ay > dy)) {
HXLINE( 141)									int min4;
HXDLIN( 141)									if ((by > dy)) {
HXLINE( 141)										min4 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 141)										min4 = ::Math_obj::floor(by);
            									}
HXDLIN( 141)									int ii_min12 = min4;
HXDLIN( 141)									int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 141)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE( 141)									int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 141)									int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 141)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE( 141)								if ((by > dy)) {
HXLINE( 141)									int min5;
HXDLIN( 141)									if ((ay > dy)) {
HXLINE( 141)										min5 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 141)										min5 = ::Math_obj::ceil(ay);
            									}
HXDLIN( 141)									int ii_min14 = min5;
HXDLIN( 141)									int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 141)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE( 141)									int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 141)									int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 141)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 141)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 141)							if (hasUndo) {
HXLINE( 141)								int width3 = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 141)								int height3 = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 141)								 ::Dynamic imageType4 = null();
HXDLIN( 141)								 ::pi_xy::ImageStruct this47 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)								if (::hx::IsNull( imageType4 )) {
HXLINE(  54)									imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 141)								::Dynamic undoImage1;
HXDLIN( 141)								switch((int)(( (int)(imageType4) ))){
            									case (int)0: {
HXLINE( 141)										 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::BytesImg b18 = byt4;
HXDLIN( 141)										{
HXLINE( 141)											b18->width = width3;
HXDLIN( 141)											b18->height = height3;
HXDLIN( 141)											b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 141)											b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 141)											{
HXLINE( 141)												int len8 = b18->length;
HXDLIN( 141)												int w7 = 0;
HXDLIN( 141)												{
HXLINE( 141)													int _g64 = 0;
HXDLIN( 141)													int _g65 = b18->height;
HXDLIN( 141)													while((_g64 < _g65)){
HXLINE( 141)														_g64 = (_g64 + 1);
HXDLIN( 141)														int y10 = (_g64 - 1);
HXDLIN( 141)														{
HXLINE( 141)															int _g66 = 0;
HXDLIN( 141)															int _g67 = b18->width;
HXDLIN( 141)															while((_g66 < _g67)){
HXLINE( 141)																_g66 = (_g66 + 1);
HXDLIN( 141)																int x10 = (_g66 - 1);
HXDLIN( 141)																{
HXLINE( 141)																	w7 = (w7 + 1);
HXDLIN( 141)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w7 = (w7 + 1);
HXDLIN( 141)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w7 = (w7 + 1);
HXDLIN( 141)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w7 = (w7 + 1);
HXDLIN( 141)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage1 = b18;
            									}
            									break;
            									case (int)1: {
HXLINE( 141)										 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::ArrIntImg a10 = arrI4;
HXDLIN( 141)										{
HXLINE( 141)											a10->width = width3;
HXDLIN( 141)											a10->height = height3;
HXDLIN( 141)											a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)											a10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 141)											{
HXLINE( 141)												int _g68 = 0;
HXDLIN( 141)												int _g69 = a10->length;
HXDLIN( 141)												while((_g68 < _g69)){
HXLINE( 141)													_g68 = (_g68 + 1);
HXDLIN( 141)													int i30 = (_g68 - 1);
HXDLIN( 141)													a10->data[i30] = 0;
            												}
            											}
            										}
HXDLIN( 141)										undoImage1 = a10;
            									}
            									break;
            									case (int)2: {
HXLINE( 141)										 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::U32ArrImg b19 = u32a4;
HXDLIN( 141)										{
HXLINE( 141)											b19->width = width3;
HXDLIN( 141)											b19->height = height3;
HXDLIN( 141)											b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 141)											int size4 = (b19->length * 4);
HXDLIN( 141)											b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 141)											{
HXLINE( 141)												int _g70 = 0;
HXDLIN( 141)												int _g71 = b19->length;
HXDLIN( 141)												while((_g70 < _g71)){
HXLINE( 141)													_g70 = (_g70 + 1);
HXDLIN( 141)													int i31 = (_g70 - 1);
HXDLIN( 141)													{
HXLINE( 141)														 ::haxe::io::ArrayBufferViewImpl this48 = b19->data;
HXDLIN( 141)														bool undoImage2;
HXDLIN( 141)														if ((i31 >= 0)) {
HXLINE( 141)															undoImage2 = (i31 < (this48->byteLength >> 2));
            														}
            														else {
HXLINE( 141)															undoImage2 = false;
            														}
HXDLIN( 141)														if (undoImage2) {
HXLINE( 141)															 ::haxe::io::Bytes _this4 = this48->bytes;
HXDLIN( 141)															int pos4 = ((i31 << 2) + this48->byteOffset);
HXDLIN( 141)															_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 141)															_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)															_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)															_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage1 = b19;
            									}
            									break;
            									case (int)3: {
HXLINE( 141)										 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::VecIntImg v7 = vec4;
HXDLIN( 141)										{
HXLINE( 141)											v7->width = width3;
HXDLIN( 141)											v7->height = height3;
HXDLIN( 141)											v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 141)											v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 141)											{
HXLINE( 141)												int _g72 = 0;
HXDLIN( 141)												int _g73 = v7->length;
HXDLIN( 141)												while((_g72 < _g73)){
HXLINE( 141)													_g72 = (_g72 + 1);
HXDLIN( 141)													int i32 = (_g72 - 1);
HXDLIN( 141)													v7->data->__unsafe_set(i32,0);
            												}
            											}
            										}
HXDLIN( 141)										undoImage1 = v7;
            									}
            									break;
            									case (int)4: {
HXLINE( 141)										 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::StackIntImg b20 = sInt4;
HXDLIN( 141)										{
HXLINE( 141)											b20->width = width3;
HXDLIN( 141)											b20->height = height3;
HXDLIN( 141)											b20->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 141)											b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)											{
HXLINE( 141)												int len9 = b20->length;
HXDLIN( 141)												 ::haxe::ds::GenericStack_Int d4 = b20->data;
HXDLIN( 141)												if (::hx::IsNull( d4->head )) {
HXLINE( 141)													int _g74 = 0;
HXDLIN( 141)													int _g75 = len9;
HXDLIN( 141)													while((_g74 < _g75)){
HXLINE( 141)														_g74 = (_g74 + 1);
HXDLIN( 141)														int i33 = (_g74 - 1);
HXDLIN( 141)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXLINE( 141)													int _g76 = 0;
HXDLIN( 141)													int _g77 = len9;
HXDLIN( 141)													while((_g76 < _g77)){
HXLINE( 141)														_g76 = (_g76 + 1);
HXDLIN( 141)														int i34 = (_g76 - 1);
HXDLIN( 141)														{
HXLINE( 141)															 ::haxe::ds::GenericCell_Int l4 = b20->data->head;
HXDLIN( 141)															 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 141)															{
HXLINE( 141)																int _g78 = 0;
HXDLIN( 141)																int _g79 = i34;
HXDLIN( 141)																while((_g78 < _g79)){
HXLINE( 141)																	_g78 = (_g78 + 1);
HXDLIN( 141)																	int i35 = (_g78 - 1);
HXLINE( 345)																	prev4 = l4;
HXLINE( 346)																	l4 = l4->next;
            																}
            															}
HXLINE( 141)															if (::hx::IsNull( prev4 )) {
HXLINE( 141)																b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 141)																l4 = null();
            															}
            															else {
HXLINE( 141)																prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 141)																l4 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage1 = b20;
            									}
            									break;
            								}
HXDLIN( 141)								this47->image = undoImage1;
HXDLIN( 141)								this47->width = width3;
HXDLIN( 141)								this47->height = height3;
HXDLIN( 141)								this47->imageType = ( (int)(imageType4) );
HXDLIN( 141)								undoImage = this47;
HXDLIN( 141)								{
HXLINE( 141)									int rectLeft = xIter3->start;
HXDLIN( 141)									int rectTop = yIter3->start;
HXDLIN( 141)									int rectRight = xIter3->max;
HXDLIN( 141)									bool forceClear = false;
HXDLIN( 141)									{
HXLINE( 141)										int _g80 = rectTop;
HXDLIN( 141)										int _g81 = yIter3->max;
HXDLIN( 141)										while((_g80 < _g81)){
HXLINE( 141)											_g80 = (_g80 + 1);
HXDLIN( 141)											int dy1 = (_g80 - 1);
HXDLIN( 141)											{
HXLINE( 141)												int _g82 = rectLeft;
HXDLIN( 141)												int _g83 = rectRight;
HXDLIN( 141)												while((_g82 < _g83)){
HXLINE( 141)													_g82 = (_g82 + 1);
HXDLIN( 141)													int dx1 = (_g82 - 1);
HXDLIN( 141)													::Dynamic this49 = this46->image;
HXDLIN( 141)													int index6;
HXDLIN( 141)													if (this46->useVirtualPos) {
HXLINE( 141)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this46->virtualY) * ( (Float)(this46->width) )) + dx1) - this46->virtualX));
            													}
            													else {
HXLINE( 141)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this46->width) + dx1)) ));
            													}
HXDLIN( 141)													int c6 = ::iterMagic::Iimg_obj::get(this49,index6);
HXDLIN( 141)													int col;
HXDLIN( 141)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)														col = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE( 141)														col = c6;
            													}
HXDLIN( 141)													bool _hx_tmp23;
HXDLIN( 141)													if (this46->useMask) {
HXLINE( 141)														_hx_tmp23 = ::hx::IsNotNull( this46->mask );
            													}
            													else {
HXLINE( 141)														_hx_tmp23 = false;
            													}
HXDLIN( 141)													if (_hx_tmp23) {
HXLINE( 141)														 ::pi_xy::ImageStruct this50 = this46->mask;
HXDLIN( 141)														::Dynamic this51 = this50->image;
HXDLIN( 141)														int index7;
HXDLIN( 141)														if (this50->useVirtualPos) {
HXLINE( 141)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this50->virtualY) * ( (Float)(this50->width) )) + dx1) - this50->virtualX));
            														}
            														else {
HXLINE( 141)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this50->width) + dx1)) ));
            														}
HXDLIN( 141)														int c7 = ::iterMagic::Iimg_obj::get(this51,index7);
HXDLIN( 141)														int v8;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															v8 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															v8 = c7;
            														}
HXDLIN( 141)														int maskPixel = v8;
HXDLIN( 141)														int this52 = col;
HXDLIN( 141)														if ((maskPixel == 0)) {
HXLINE( 141)															col = this52;
            														}
            														else {
HXLINE( 141)															Float m0;
HXDLIN( 141)															int this53 = ((maskPixel >> 24) & 255);
HXDLIN( 141)															if ((this53 == 0)) {
HXLINE( 141)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m0 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m1;
HXDLIN( 141)															int this54 = ((maskPixel >> 16) & 255);
HXDLIN( 141)															if ((this54 == 0)) {
HXLINE( 141)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m1 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m2;
HXDLIN( 141)															int this55 = ((maskPixel >> 8) & 255);
HXDLIN( 141)															if ((this55 == 0)) {
HXLINE( 141)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m2 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m3;
HXDLIN( 141)															int this56 = (maskPixel & 255);
HXDLIN( 141)															if ((this56 == 0)) {
HXLINE( 141)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m3 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this52 >> 24) & 255)) )));
HXDLIN( 141)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this52 >> 16) & 255)) )));
HXDLIN( 141)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this52 >> 8) & 255)) )));
HXDLIN( 141)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this52 & 255)) )));
HXDLIN( 141)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 141)													if ((col != 0)) {
HXLINE( 141)														int x11 = (dx1 - rectLeft);
HXDLIN( 141)														int y11 = (dy1 - rectTop);
HXDLIN( 141)														int c8 = col;
HXDLIN( 141)														bool _hx_tmp24;
HXDLIN( 141)														if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 141)															_hx_tmp24 = undoImage->transparent;
            														}
            														else {
HXLINE( 141)															_hx_tmp24 = false;
            														}
HXDLIN( 141)														if (_hx_tmp24) {
HXLINE( 141)															int location3;
HXDLIN( 141)															if (undoImage->useVirtualPos) {
HXLINE( 141)																location3 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXLINE( 141)																location3 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN( 141)															int this57 = ::iterMagic::Iimg_obj::get(undoImage->image,location3);
HXDLIN( 141)															int this58;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																this58 = this57;
            															}
HXDLIN( 141)															Float a13;
HXDLIN( 141)															int this59 = ((this58 >> 24) & 255);
HXDLIN( 141)															if ((this59 == 0)) {
HXLINE( 141)																a13 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r13;
HXDLIN( 141)															int this60 = ((this58 >> 16) & 255);
HXDLIN( 141)															if ((this60 == 0)) {
HXLINE( 141)																r13 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g13;
HXDLIN( 141)															int this61 = ((this58 >> 8) & 255);
HXDLIN( 141)															if ((this61 == 0)) {
HXLINE( 141)																g13 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b110;
HXDLIN( 141)															int this62 = (this58 & 255);
HXDLIN( 141)															if ((this62 == 0)) {
HXLINE( 141)																b110 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b110 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a23;
HXDLIN( 141)															int this63 = ((col >> 24) & 255);
HXDLIN( 141)															if ((this63 == 0)) {
HXLINE( 141)																a23 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r23;
HXDLIN( 141)															int this64 = ((col >> 16) & 255);
HXDLIN( 141)															if ((this64 == 0)) {
HXLINE( 141)																r23 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g23;
HXDLIN( 141)															int this65 = ((col >> 8) & 255);
HXDLIN( 141)															if ((this65 == 0)) {
HXLINE( 141)																g23 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b24;
HXDLIN( 141)															int this66 = (col & 255);
HXDLIN( 141)															if ((this66 == 0)) {
HXLINE( 141)																b24 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 141)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 141)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 141)															int b25 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN( 141)															int a14 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 141)															int blended3 = ((((a14 << 24) | (r5 << 16)) | (g5 << 8)) | b25);
HXDLIN( 141)															{
HXLINE( 141)																int _hx_tmp25;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp25 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp25 = blended3;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(undoImage->image,location3,_hx_tmp25);
            															}
            														}
            														else {
HXLINE( 141)															::Dynamic this67 = undoImage->image;
HXDLIN( 141)															int index8;
HXDLIN( 141)															if (undoImage->useVirtualPos) {
HXLINE( 141)																index8 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXLINE( 141)																index8 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN( 141)															int _hx_tmp26;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp26 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp26 = c8;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this67,index8,_hx_tmp26);
            														}
            													}
            													else {
HXLINE( 141)														if (forceClear) {
HXLINE( 141)															::Dynamic this68 = undoImage->image;
HXDLIN( 141)															int x12 = (dx1 - rectLeft);
HXDLIN( 141)															int y12 = (dy1 - rectTop);
HXDLIN( 141)															int index9;
HXDLIN( 141)															if (undoImage->useVirtualPos) {
HXLINE( 141)																index9 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x12) - undoImage->virtualX));
            															}
            															else {
HXLINE( 141)																index9 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage->width) + x12)) ));
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this68,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							{
HXLINE( 141)								int _g_min = xIter3->start;
HXDLIN( 141)								int _g_max = xIter3->max;
HXDLIN( 141)								while((_g_min < _g_max)){
HXLINE( 141)									_g_min = (_g_min + 1);
HXDLIN( 141)									int px = (_g_min - 1);
HXDLIN( 141)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 141)									{
HXLINE( 141)										int _g_min1 = yIter3->start;
HXDLIN( 141)										int _g_max1 = yIter3->max;
HXDLIN( 141)										while((_g_min1 < _g_max1)){
HXLINE( 141)											_g_min1 = (_g_min1 + 1);
HXDLIN( 141)											int py = (_g_min1 - 1);
HXDLIN( 141)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 141)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 141)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 141)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 141)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 141)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 141)											bool _hx_tmp27;
HXDLIN( 141)											bool _hx_tmp28;
HXDLIN( 141)											if ((ratioA >= 0)) {
HXLINE( 141)												_hx_tmp28 = (ratioB >= 0);
            											}
            											else {
HXLINE( 141)												_hx_tmp28 = false;
            											}
HXDLIN( 141)											if (_hx_tmp28) {
HXLINE( 141)												_hx_tmp27 = (ratioC >= 0);
            											}
            											else {
HXLINE( 141)												_hx_tmp27 = false;
            											}
HXDLIN( 141)											if (_hx_tmp27) {
HXLINE( 141)												Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN( 141)												Float v9 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN( 141)												int x13 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN( 141)												int y13 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN( 141)												::Dynamic this69 = this43->image;
HXDLIN( 141)												int index10;
HXDLIN( 141)												if (this43->useVirtualPos) {
HXLINE( 141)													index10 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this43->virtualY) * ( (Float)(this43->width) )) + x13) - this43->virtualX));
            												}
            												else {
HXLINE( 141)													index10 = ::Std_obj::_hx_int(( (Float)(((y13 * this43->width) + x13)) ));
            												}
HXDLIN( 141)												int c9 = ::iterMagic::Iimg_obj::get(this69,index10);
HXDLIN( 141)												int col1;
HXDLIN( 141)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)													col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 141)													col1 = c9;
            												}
HXDLIN( 141)												{
HXLINE( 141)													int c10 = col1;
HXDLIN( 141)													bool _hx_tmp29;
HXDLIN( 141)													if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 141)														_hx_tmp29 = this46->transparent;
            													}
            													else {
HXLINE( 141)														_hx_tmp29 = false;
            													}
HXDLIN( 141)													if (_hx_tmp29) {
HXLINE( 141)														int location4;
HXDLIN( 141)														if (this46->useVirtualPos) {
HXLINE( 141)															location4 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this46->virtualY) * ( (Float)(this46->width) )) + px) - this46->virtualX));
            														}
            														else {
HXLINE( 141)															location4 = ::Std_obj::_hx_int(( (Float)(((py * this46->width) + px)) ));
            														}
HXDLIN( 141)														int this70 = ::iterMagic::Iimg_obj::get(this46->image,location4);
HXDLIN( 141)														int this71;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															this71 = ((((((this70 >> 24) & 255) << 24) | ((this70 & 255) << 16)) | (((this70 >> 8) & 255) << 8)) | ((this70 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															this71 = this70;
            														}
HXDLIN( 141)														Float a15;
HXDLIN( 141)														int this72 = ((this71 >> 24) & 255);
HXDLIN( 141)														if ((this72 == 0)) {
HXLINE( 141)															a15 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float r14;
HXDLIN( 141)														int this73 = ((this71 >> 16) & 255);
HXDLIN( 141)														if ((this73 == 0)) {
HXLINE( 141)															r14 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															r14 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float g14;
HXDLIN( 141)														int this74 = ((this71 >> 8) & 255);
HXDLIN( 141)														if ((this74 == 0)) {
HXLINE( 141)															g14 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															g14 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float b111;
HXDLIN( 141)														int this75 = (this71 & 255);
HXDLIN( 141)														if ((this75 == 0)) {
HXLINE( 141)															b111 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															b111 = (( (Float)(this75) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float a24;
HXDLIN( 141)														int this76 = ((col1 >> 24) & 255);
HXDLIN( 141)														if ((this76 == 0)) {
HXLINE( 141)															a24 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															a24 = (( (Float)(this76) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float r24;
HXDLIN( 141)														int this77 = ((col1 >> 16) & 255);
HXDLIN( 141)														if ((this77 == 0)) {
HXLINE( 141)															r24 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															r24 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float g24;
HXDLIN( 141)														int this78 = ((col1 >> 8) & 255);
HXDLIN( 141)														if ((this78 == 0)) {
HXLINE( 141)															g24 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															g24 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float b26;
HXDLIN( 141)														int this79 = (col1 & 255);
HXDLIN( 141)														if ((this79 == 0)) {
HXLINE( 141)															b26 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															b26 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 141)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 141)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 141)														int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b26 * a24))));
HXDLIN( 141)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 141)														int blended4 = ((((a16 << 24) | (r6 << 16)) | (g6 << 8)) | b27);
HXDLIN( 141)														{
HXLINE( 141)															int _hx_tmp30;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp30 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp30 = blended4;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this46->image,location4,_hx_tmp30);
            														}
            													}
            													else {
HXLINE( 141)														::Dynamic this80 = this46->image;
HXDLIN( 141)														int index11;
HXDLIN( 141)														if (this46->useVirtualPos) {
HXLINE( 141)															index11 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this46->virtualY) * ( (Float)(this46->width) )) + px) - this46->virtualX));
            														}
            														else {
HXLINE( 141)															index11 = ::Std_obj::_hx_int(( (Float)(((py * this46->width) + px)) ));
            														}
HXDLIN( 141)														int _hx_tmp31;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															_hx_tmp31 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															_hx_tmp31 = c10;
            														}
HXDLIN( 141)														::iterMagic::Iimg_obj::set(this80,index11,_hx_tmp31);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 141)							int v_undoY;
HXDLIN( 141)							int v_undoX;
HXDLIN( 141)							Float v_ty;
HXDLIN( 141)							Float v_tx;
HXDLIN( 141)							Float v_t0;
HXDLIN( 141)							Float v_sy;
HXDLIN( 141)							Float v_sx;
HXDLIN( 141)							Float v_s0;
HXDLIN( 141)							Float v_A;
HXDLIN( 141)							Float ax1 = ax;
HXDLIN( 141)							Float ay1 = ay;
HXDLIN( 141)							 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 141)							Float bx1 = bx;
HXDLIN( 141)							Float by1 = by;
HXDLIN( 141)							Float cx1 = dx;
HXDLIN( 141)							Float cy1 = dy;
HXDLIN( 141)							bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN( 141)							if (!(adjustWinding)) {
HXLINE( 141)								Float bx_ = bx1;
HXDLIN( 141)								Float by_ = by1;
HXLINE(  24)								bx1 = cx1;
HXLINE(  25)								by1 = cy1;
HXLINE(  26)								cx1 = bx_;
HXLINE(  27)								cy1 = by_;
            							}
HXLINE( 141)							Float v_ax = ax1;
HXDLIN( 141)							Float v_ay = ay1;
HXDLIN( 141)							Float v_bx = bx1;
HXDLIN( 141)							Float v_by = by1;
HXDLIN( 141)							Float v_cx = cx1;
HXDLIN( 141)							Float v_cy = cy1;
HXDLIN( 141)							bool v_preCalculated = true;
HXDLIN( 141)							{
HXLINE( 141)								v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 141)								v_sx = (v_cy - v_ay);
HXDLIN( 141)								v_sy = (v_ax - v_cx);
HXDLIN( 141)								v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 141)								v_tx = (v_ay - v_by);
HXDLIN( 141)								v_ty = (v_bx - v_ax);
HXDLIN( 141)								v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 141)								Float a17 = v_ax;
HXDLIN( 141)								Float b28 = v_bx;
HXDLIN( 141)								Float c11 = v_cx;
HXDLIN( 141)								if ((a17 > b28)) {
HXLINE( 141)									if ((a17 > c11)) {
HXLINE( 141)										int min6;
HXDLIN( 141)										if ((b28 > c11)) {
HXLINE( 141)											min6 = ::Math_obj::floor(c11);
            										}
            										else {
HXLINE( 141)											min6 = ::Math_obj::floor(b28);
            										}
HXDLIN( 141)										int ii_min16 = min6;
HXDLIN( 141)										int ii_max16 = ::Math_obj::ceil(a17);
HXDLIN( 141)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXLINE( 141)										int ii_min17 = ::Math_obj::floor(b28);
HXDLIN( 141)										int ii_max17 = ::Math_obj::ceil(c11);
HXDLIN( 141)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
            								else {
HXLINE( 141)									if ((b28 > c11)) {
HXLINE( 141)										int min7;
HXDLIN( 141)										if ((a17 > c11)) {
HXLINE( 141)											min7 = ::Math_obj::floor(c11);
            										}
            										else {
HXLINE( 141)											min7 = ::Math_obj::ceil(a17);
            										}
HXDLIN( 141)										int ii_min18 = min7;
HXDLIN( 141)										int ii_max18 = ::Math_obj::ceil(b28);
HXDLIN( 141)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            									}
            									else {
HXLINE( 141)										int ii_min19 = ::Math_obj::floor(a17);
HXDLIN( 141)										int ii_max19 = ::Math_obj::ceil(c11);
HXDLIN( 141)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            									}
            								}
HXDLIN( 141)								Float a18 = v_ay;
HXDLIN( 141)								Float b29 = v_by;
HXDLIN( 141)								Float c12 = v_cy;
HXDLIN( 141)								if ((a18 > b29)) {
HXLINE( 141)									if ((a18 > c12)) {
HXLINE( 141)										int min8;
HXDLIN( 141)										if ((b29 > c12)) {
HXLINE( 141)											min8 = ::Math_obj::floor(c12);
            										}
            										else {
HXLINE( 141)											min8 = ::Math_obj::floor(b29);
            										}
HXDLIN( 141)										int ii_min20 = min8;
HXDLIN( 141)										int ii_max20 = ::Math_obj::ceil(a18);
HXDLIN( 141)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            									}
            									else {
HXLINE( 141)										int ii_min21 = ::Math_obj::floor(b29);
HXDLIN( 141)										int ii_max21 = ::Math_obj::ceil(c12);
HXDLIN( 141)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            									}
            								}
            								else {
HXLINE( 141)									if ((b29 > c12)) {
HXLINE( 141)										int min9;
HXDLIN( 141)										if ((a18 > c12)) {
HXLINE( 141)											min9 = ::Math_obj::floor(c12);
            										}
            										else {
HXLINE( 141)											min9 = ::Math_obj::ceil(a18);
            										}
HXDLIN( 141)										int ii_min22 = min9;
HXDLIN( 141)										int ii_max22 = ::Math_obj::ceil(b29);
HXDLIN( 141)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            									}
            									else {
HXLINE( 141)										int ii_min23 = ::Math_obj::floor(a18);
HXDLIN( 141)										int ii_max23 = ::Math_obj::ceil(c12);
HXDLIN( 141)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            									}
            								}
            							}
HXDLIN( 141)							if (hasUndo) {
HXLINE( 141)								v_undoImage = undoImage;
HXDLIN( 141)								v_undoX = xIter3->start;
HXDLIN( 141)								v_undoY = yIter3->start;
            							}
HXDLIN( 141)							Float au1 = bu;
HXDLIN( 141)							Float av1 = bv;
HXDLIN( 141)							Float bu2 = cu;
HXDLIN( 141)							Float bv2 = cv;
HXDLIN( 141)							bool hasUndo1 = false;
HXDLIN( 141)							Float temp5 = au1;
HXLINE( 422)							au1 = bu2;
HXLINE( 423)							bu2 = temp5;
HXLINE( 424)							temp5 = av1;
HXLINE( 425)							av1 = bv2;
HXLINE( 426)							bv2 = temp5;
HXLINE( 141)							Float bcx1 = (cx - dx);
HXDLIN( 141)							Float bcy1 = (cy - dy);
HXDLIN( 141)							Float acx1 = (bx - dx);
HXDLIN( 141)							Float acy1 = (by - dy);
HXDLIN( 141)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 141)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 141)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 141)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 141)							if ((bx > cx)) {
HXLINE( 141)								if ((bx > dx)) {
HXLINE( 141)									int min10;
HXDLIN( 141)									if ((cx > dx)) {
HXLINE( 141)										min10 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 141)										min10 = ::Math_obj::floor(cx);
            									}
HXDLIN( 141)									int ii_min24 = min10;
HXDLIN( 141)									int ii_max24 = ::Math_obj::ceil(bx);
HXDLIN( 141)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            								else {
HXLINE( 141)									int ii_min25 = ::Math_obj::floor(cx);
HXDLIN( 141)									int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN( 141)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            							}
            							else {
HXLINE( 141)								if ((cx > dx)) {
HXLINE( 141)									int min11;
HXDLIN( 141)									if ((bx > dx)) {
HXLINE( 141)										min11 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 141)										min11 = ::Math_obj::ceil(bx);
            									}
HXDLIN( 141)									int ii_min26 = min11;
HXDLIN( 141)									int ii_max26 = ::Math_obj::ceil(cx);
HXDLIN( 141)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            								else {
HXLINE( 141)									int ii_min27 = ::Math_obj::floor(bx);
HXDLIN( 141)									int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN( 141)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            							}
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 141)							if ((by > cy)) {
HXLINE( 141)								if ((by > dy)) {
HXLINE( 141)									int min12;
HXDLIN( 141)									if ((cy > dy)) {
HXLINE( 141)										min12 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 141)										min12 = ::Math_obj::floor(cy);
            									}
HXDLIN( 141)									int ii_min28 = min12;
HXDLIN( 141)									int ii_max28 = ::Math_obj::ceil(by);
HXDLIN( 141)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            								else {
HXLINE( 141)									int ii_min29 = ::Math_obj::floor(cy);
HXDLIN( 141)									int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN( 141)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            								}
            							}
            							else {
HXLINE( 141)								if ((cy > dy)) {
HXLINE( 141)									int min13;
HXDLIN( 141)									if ((by > dy)) {
HXLINE( 141)										min13 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 141)										min13 = ::Math_obj::ceil(by);
            									}
HXDLIN( 141)									int ii_min30 = min13;
HXDLIN( 141)									int ii_max30 = ::Math_obj::ceil(cy);
HXDLIN( 141)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            								}
            								else {
HXLINE( 141)									int ii_min31 = ::Math_obj::floor(by);
HXDLIN( 141)									int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN( 141)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            								}
            							}
HXDLIN( 141)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 141)							if (hasUndo1) {
HXLINE( 141)								int width4 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 141)								int height4 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 141)								 ::Dynamic imageType5 = null();
HXDLIN( 141)								 ::pi_xy::ImageStruct this81 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)								if (::hx::IsNull( imageType5 )) {
HXLINE(  54)									imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 141)								::Dynamic undoImage4;
HXDLIN( 141)								switch((int)(( (int)(imageType5) ))){
            									case (int)0: {
HXLINE( 141)										 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::BytesImg b30 = byt5;
HXDLIN( 141)										{
HXLINE( 141)											b30->width = width4;
HXDLIN( 141)											b30->height = height4;
HXDLIN( 141)											b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 141)											b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN( 141)											{
HXLINE( 141)												int len10 = b30->length;
HXDLIN( 141)												int w8 = 0;
HXDLIN( 141)												{
HXLINE( 141)													int _g84 = 0;
HXDLIN( 141)													int _g85 = b30->height;
HXDLIN( 141)													while((_g84 < _g85)){
HXLINE( 141)														_g84 = (_g84 + 1);
HXDLIN( 141)														int y14 = (_g84 - 1);
HXDLIN( 141)														{
HXLINE( 141)															int _g86 = 0;
HXDLIN( 141)															int _g87 = b30->width;
HXDLIN( 141)															while((_g86 < _g87)){
HXLINE( 141)																_g86 = (_g86 + 1);
HXDLIN( 141)																int x14 = (_g86 - 1);
HXDLIN( 141)																{
HXLINE( 141)																	w8 = (w8 + 1);
HXDLIN( 141)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w8 = (w8 + 1);
HXDLIN( 141)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w8 = (w8 + 1);
HXDLIN( 141)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 141)																{
HXLINE( 141)																	w8 = (w8 + 1);
HXDLIN( 141)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage4 = b30;
            									}
            									break;
            									case (int)1: {
HXLINE( 141)										 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::ArrIntImg a19 = arrI5;
HXDLIN( 141)										{
HXLINE( 141)											a19->width = width4;
HXDLIN( 141)											a19->height = height4;
HXDLIN( 141)											a19->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)											a19->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 141)											{
HXLINE( 141)												int _g88 = 0;
HXDLIN( 141)												int _g89 = a19->length;
HXDLIN( 141)												while((_g88 < _g89)){
HXLINE( 141)													_g88 = (_g88 + 1);
HXDLIN( 141)													int i36 = (_g88 - 1);
HXDLIN( 141)													a19->data[i36] = 0;
            												}
            											}
            										}
HXDLIN( 141)										undoImage4 = a19;
            									}
            									break;
            									case (int)2: {
HXLINE( 141)										 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::U32ArrImg b31 = u32a5;
HXDLIN( 141)										{
HXLINE( 141)											b31->width = width4;
HXDLIN( 141)											b31->height = height4;
HXDLIN( 141)											b31->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 141)											int size5 = (b31->length * 4);
HXDLIN( 141)											b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 141)											{
HXLINE( 141)												int _g90 = 0;
HXDLIN( 141)												int _g91 = b31->length;
HXDLIN( 141)												while((_g90 < _g91)){
HXLINE( 141)													_g90 = (_g90 + 1);
HXDLIN( 141)													int i37 = (_g90 - 1);
HXDLIN( 141)													{
HXLINE( 141)														 ::haxe::io::ArrayBufferViewImpl this82 = b31->data;
HXDLIN( 141)														bool undoImage5;
HXDLIN( 141)														if ((i37 >= 0)) {
HXLINE( 141)															undoImage5 = (i37 < (this82->byteLength >> 2));
            														}
            														else {
HXLINE( 141)															undoImage5 = false;
            														}
HXDLIN( 141)														if (undoImage5) {
HXLINE( 141)															 ::haxe::io::Bytes _this5 = this82->bytes;
HXDLIN( 141)															int pos5 = ((i37 << 2) + this82->byteOffset);
HXDLIN( 141)															_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 141)															_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)															_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)															_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage4 = b31;
            									}
            									break;
            									case (int)3: {
HXLINE( 141)										 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::VecIntImg v10 = vec5;
HXDLIN( 141)										{
HXLINE( 141)											v10->width = width4;
HXDLIN( 141)											v10->height = height4;
HXDLIN( 141)											v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 141)											v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 141)											{
HXLINE( 141)												int _g92 = 0;
HXDLIN( 141)												int _g93 = v10->length;
HXDLIN( 141)												while((_g92 < _g93)){
HXLINE( 141)													_g92 = (_g92 + 1);
HXDLIN( 141)													int i38 = (_g92 - 1);
HXDLIN( 141)													v10->data->__unsafe_set(i38,0);
            												}
            											}
            										}
HXDLIN( 141)										undoImage4 = v10;
            									}
            									break;
            									case (int)4: {
HXLINE( 141)										 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)										 ::iterMagic::StackIntImg b32 = sInt5;
HXDLIN( 141)										{
HXLINE( 141)											b32->width = width4;
HXDLIN( 141)											b32->height = height4;
HXDLIN( 141)											b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 141)											b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)											{
HXLINE( 141)												int len11 = b32->length;
HXDLIN( 141)												 ::haxe::ds::GenericStack_Int d5 = b32->data;
HXDLIN( 141)												if (::hx::IsNull( d5->head )) {
HXLINE( 141)													int _g94 = 0;
HXDLIN( 141)													int _g95 = len11;
HXDLIN( 141)													while((_g94 < _g95)){
HXLINE( 141)														_g94 = (_g94 + 1);
HXDLIN( 141)														int i39 = (_g94 - 1);
HXDLIN( 141)														d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            													}
            												}
            												else {
HXLINE( 141)													int _g96 = 0;
HXDLIN( 141)													int _g97 = len11;
HXDLIN( 141)													while((_g96 < _g97)){
HXLINE( 141)														_g96 = (_g96 + 1);
HXDLIN( 141)														int i40 = (_g96 - 1);
HXDLIN( 141)														{
HXLINE( 141)															 ::haxe::ds::GenericCell_Int l5 = b32->data->head;
HXDLIN( 141)															 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 141)															{
HXLINE( 141)																int _g98 = 0;
HXDLIN( 141)																int _g99 = i40;
HXDLIN( 141)																while((_g98 < _g99)){
HXLINE( 141)																	_g98 = (_g98 + 1);
HXDLIN( 141)																	int i41 = (_g98 - 1);
HXLINE( 345)																	prev5 = l5;
HXLINE( 346)																	l5 = l5->next;
            																}
            															}
HXLINE( 141)															if (::hx::IsNull( prev5 )) {
HXLINE( 141)																b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 141)																l5 = null();
            															}
            															else {
HXLINE( 141)																prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 141)																l5 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 141)										undoImage4 = b32;
            									}
            									break;
            								}
HXDLIN( 141)								this81->image = undoImage4;
HXDLIN( 141)								this81->width = width4;
HXDLIN( 141)								this81->height = height4;
HXDLIN( 141)								this81->imageType = ( (int)(imageType5) );
HXDLIN( 141)								undoImage3 = this81;
HXDLIN( 141)								{
HXLINE( 141)									int rectLeft1 = xIter31->start;
HXDLIN( 141)									int rectTop1 = yIter31->start;
HXDLIN( 141)									int rectRight1 = xIter31->max;
HXDLIN( 141)									bool forceClear1 = false;
HXDLIN( 141)									{
HXLINE( 141)										int _g100 = rectTop1;
HXDLIN( 141)										int _g101 = yIter31->max;
HXDLIN( 141)										while((_g100 < _g101)){
HXLINE( 141)											_g100 = (_g100 + 1);
HXDLIN( 141)											int dy2 = (_g100 - 1);
HXDLIN( 141)											{
HXLINE( 141)												int _g102 = rectLeft1;
HXDLIN( 141)												int _g103 = rectRight1;
HXDLIN( 141)												while((_g102 < _g103)){
HXLINE( 141)													_g102 = (_g102 + 1);
HXDLIN( 141)													int dx2 = (_g102 - 1);
HXDLIN( 141)													::Dynamic this83 = this46->image;
HXDLIN( 141)													int index12;
HXDLIN( 141)													if (this46->useVirtualPos) {
HXLINE( 141)														index12 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this46->virtualY) * ( (Float)(this46->width) )) + dx2) - this46->virtualX));
            													}
            													else {
HXLINE( 141)														index12 = ::Std_obj::_hx_int(( (Float)(((dy2 * this46->width) + dx2)) ));
            													}
HXDLIN( 141)													int c13 = ::iterMagic::Iimg_obj::get(this83,index12);
HXDLIN( 141)													int col2;
HXDLIN( 141)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)														col2 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE( 141)														col2 = c13;
            													}
HXDLIN( 141)													bool _hx_tmp32;
HXDLIN( 141)													if (this46->useMask) {
HXLINE( 141)														_hx_tmp32 = ::hx::IsNotNull( this46->mask );
            													}
            													else {
HXLINE( 141)														_hx_tmp32 = false;
            													}
HXDLIN( 141)													if (_hx_tmp32) {
HXLINE( 141)														 ::pi_xy::ImageStruct this84 = this46->mask;
HXDLIN( 141)														::Dynamic this85 = this84->image;
HXDLIN( 141)														int index13;
HXDLIN( 141)														if (this84->useVirtualPos) {
HXLINE( 141)															index13 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this84->virtualY) * ( (Float)(this84->width) )) + dx2) - this84->virtualX));
            														}
            														else {
HXLINE( 141)															index13 = ::Std_obj::_hx_int(( (Float)(((dy2 * this84->width) + dx2)) ));
            														}
HXDLIN( 141)														int c14 = ::iterMagic::Iimg_obj::get(this85,index13);
HXDLIN( 141)														int v11;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															v11 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															v11 = c14;
            														}
HXDLIN( 141)														int maskPixel1 = v11;
HXDLIN( 141)														int this86 = col2;
HXDLIN( 141)														if ((maskPixel1 == 0)) {
HXLINE( 141)															col2 = this86;
            														}
            														else {
HXLINE( 141)															Float m01;
HXDLIN( 141)															int this87 = ((maskPixel1 >> 24) & 255);
HXDLIN( 141)															if ((this87 == 0)) {
HXLINE( 141)																m01 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m01 = (( (Float)(this87) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m11;
HXDLIN( 141)															int this88 = ((maskPixel1 >> 16) & 255);
HXDLIN( 141)															if ((this88 == 0)) {
HXLINE( 141)																m11 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m11 = (( (Float)(this88) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m21;
HXDLIN( 141)															int this89 = ((maskPixel1 >> 8) & 255);
HXDLIN( 141)															if ((this89 == 0)) {
HXLINE( 141)																m21 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m21 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float m31;
HXDLIN( 141)															int this90 = (maskPixel1 & 255);
HXDLIN( 141)															if ((this90 == 0)) {
HXLINE( 141)																m31 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																m31 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this86 >> 24) & 255)) )));
HXDLIN( 141)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this86 >> 16) & 255)) )));
HXDLIN( 141)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this86 >> 8) & 255)) )));
HXDLIN( 141)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this86 & 255)) )));
HXDLIN( 141)															col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 141)													if ((col2 != 0)) {
HXLINE( 141)														int x15 = (dx2 - rectLeft1);
HXDLIN( 141)														int y15 = (dy2 - rectTop1);
HXDLIN( 141)														int c15 = col2;
HXDLIN( 141)														bool _hx_tmp33;
HXDLIN( 141)														if ((((c15 >> 24) & 255) < 254)) {
HXLINE( 141)															_hx_tmp33 = undoImage3->transparent;
            														}
            														else {
HXLINE( 141)															_hx_tmp33 = false;
            														}
HXDLIN( 141)														if (_hx_tmp33) {
HXLINE( 141)															int location5;
HXDLIN( 141)															if (undoImage3->useVirtualPos) {
HXLINE( 141)																location5 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 141)																location5 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN( 141)															int this91 = ::iterMagic::Iimg_obj::get(undoImage3->image,location5);
HXDLIN( 141)															int this92;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																this92 = this91;
            															}
HXDLIN( 141)															Float a110;
HXDLIN( 141)															int this93 = ((this92 >> 24) & 255);
HXDLIN( 141)															if ((this93 == 0)) {
HXLINE( 141)																a110 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a110 = (( (Float)(this93) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r15;
HXDLIN( 141)															int this94 = ((this92 >> 16) & 255);
HXDLIN( 141)															if ((this94 == 0)) {
HXLINE( 141)																r15 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r15 = (( (Float)(this94) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g15;
HXDLIN( 141)															int this95 = ((this92 >> 8) & 255);
HXDLIN( 141)															if ((this95 == 0)) {
HXLINE( 141)																g15 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g15 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b112;
HXDLIN( 141)															int this96 = (this92 & 255);
HXDLIN( 141)															if ((this96 == 0)) {
HXLINE( 141)																b112 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b112 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a25;
HXDLIN( 141)															int this97 = ((col2 >> 24) & 255);
HXDLIN( 141)															if ((this97 == 0)) {
HXLINE( 141)																a25 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a25 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r25;
HXDLIN( 141)															int this98 = ((col2 >> 16) & 255);
HXDLIN( 141)															if ((this98 == 0)) {
HXLINE( 141)																r25 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r25 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g25;
HXDLIN( 141)															int this99 = ((col2 >> 8) & 255);
HXDLIN( 141)															if ((this99 == 0)) {
HXLINE( 141)																g25 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g25 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b210;
HXDLIN( 141)															int this100 = (col2 & 255);
HXDLIN( 141)															if ((this100 == 0)) {
HXLINE( 141)																b210 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b210 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 141)															int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 141)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 141)															int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a35) + (b210 * a25))));
HXDLIN( 141)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 141)															int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b33);
HXDLIN( 141)															{
HXLINE( 141)																int _hx_tmp34;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp34 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp34 = blended5;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(undoImage3->image,location5,_hx_tmp34);
            															}
            														}
            														else {
HXLINE( 141)															::Dynamic this101 = undoImage3->image;
HXDLIN( 141)															int index14;
HXDLIN( 141)															if (undoImage3->useVirtualPos) {
HXLINE( 141)																index14 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 141)																index14 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN( 141)															int _hx_tmp35;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp35 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp35 = c15;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this101,index14,_hx_tmp35);
            														}
            													}
            													else {
HXLINE( 141)														if (forceClear1) {
HXLINE( 141)															::Dynamic this102 = undoImage3->image;
HXDLIN( 141)															int x16 = (dx2 - rectLeft1);
HXDLIN( 141)															int y16 = (dy2 - rectTop1);
HXDLIN( 141)															int index15;
HXDLIN( 141)															if (undoImage3->useVirtualPos) {
HXLINE( 141)																index15 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x16) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 141)																index15 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage3->width) + x16)) ));
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this102,index15,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							{
HXLINE( 141)								int _g_min2 = xIter31->start;
HXDLIN( 141)								int _g_max2 = xIter31->max;
HXDLIN( 141)								while((_g_min2 < _g_max2)){
HXLINE( 141)									_g_min2 = (_g_min2 + 1);
HXDLIN( 141)									int px1 = (_g_min2 - 1);
HXDLIN( 141)									Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN( 141)									{
HXLINE( 141)										int _g_min3 = yIter31->start;
HXDLIN( 141)										int _g_max3 = yIter31->max;
HXDLIN( 141)										while((_g_min3 < _g_max3)){
HXLINE( 141)											_g_min3 = (_g_min3 + 1);
HXDLIN( 141)											int py1 = (_g_min3 - 1);
HXDLIN( 141)											Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN( 141)											Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 141)											Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 141)											Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 141)											Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 141)											Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 141)											bool _hx_tmp36;
HXDLIN( 141)											bool _hx_tmp37;
HXDLIN( 141)											if ((ratioA1 >= 0)) {
HXLINE( 141)												_hx_tmp37 = (ratioB1 >= 0);
            											}
            											else {
HXLINE( 141)												_hx_tmp37 = false;
            											}
HXDLIN( 141)											if (_hx_tmp37) {
HXLINE( 141)												_hx_tmp36 = (ratioC1 >= 0);
            											}
            											else {
HXLINE( 141)												_hx_tmp36 = false;
            											}
HXDLIN( 141)											if (_hx_tmp36) {
HXLINE( 141)												Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN( 141)												Float v12 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN( 141)												int x17 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN( 141)												int y17 = ::Std_obj::_hx_int(((v12 * win_height) + win_y));
HXDLIN( 141)												::Dynamic this103 = this43->image;
HXDLIN( 141)												int index16;
HXDLIN( 141)												if (this43->useVirtualPos) {
HXLINE( 141)													index16 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this43->virtualY) * ( (Float)(this43->width) )) + x17) - this43->virtualX));
            												}
            												else {
HXLINE( 141)													index16 = ::Std_obj::_hx_int(( (Float)(((y17 * this43->width) + x17)) ));
            												}
HXDLIN( 141)												int c16 = ::iterMagic::Iimg_obj::get(this103,index16);
HXDLIN( 141)												int col3;
HXDLIN( 141)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)													col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXLINE( 141)													col3 = c16;
            												}
HXDLIN( 141)												{
HXLINE( 141)													int c17 = col3;
HXDLIN( 141)													bool _hx_tmp38;
HXDLIN( 141)													if ((((c17 >> 24) & 255) < 254)) {
HXLINE( 141)														_hx_tmp38 = this46->transparent;
            													}
            													else {
HXLINE( 141)														_hx_tmp38 = false;
            													}
HXDLIN( 141)													if (_hx_tmp38) {
HXLINE( 141)														int location6;
HXDLIN( 141)														if (this46->useVirtualPos) {
HXLINE( 141)															location6 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this46->virtualY) * ( (Float)(this46->width) )) + px1) - this46->virtualX));
            														}
            														else {
HXLINE( 141)															location6 = ::Std_obj::_hx_int(( (Float)(((py1 * this46->width) + px1)) ));
            														}
HXDLIN( 141)														int this104 = ::iterMagic::Iimg_obj::get(this46->image,location6);
HXDLIN( 141)														int this105;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															this105 = ((((((this104 >> 24) & 255) << 24) | ((this104 & 255) << 16)) | (((this104 >> 8) & 255) << 8)) | ((this104 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															this105 = this104;
            														}
HXDLIN( 141)														Float a111;
HXDLIN( 141)														int this106 = ((this105 >> 24) & 255);
HXDLIN( 141)														if ((this106 == 0)) {
HXLINE( 141)															a111 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															a111 = (( (Float)(this106) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float r16;
HXDLIN( 141)														int this107 = ((this105 >> 16) & 255);
HXDLIN( 141)														if ((this107 == 0)) {
HXLINE( 141)															r16 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															r16 = (( (Float)(this107) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float g16;
HXDLIN( 141)														int this108 = ((this105 >> 8) & 255);
HXDLIN( 141)														if ((this108 == 0)) {
HXLINE( 141)															g16 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															g16 = (( (Float)(this108) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float b113;
HXDLIN( 141)														int this109 = (this105 & 255);
HXDLIN( 141)														if ((this109 == 0)) {
HXLINE( 141)															b113 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															b113 = (( (Float)(this109) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float a26;
HXDLIN( 141)														int this110 = ((col3 >> 24) & 255);
HXDLIN( 141)														if ((this110 == 0)) {
HXLINE( 141)															a26 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															a26 = (( (Float)(this110) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float r26;
HXDLIN( 141)														int this111 = ((col3 >> 16) & 255);
HXDLIN( 141)														if ((this111 == 0)) {
HXLINE( 141)															r26 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															r26 = (( (Float)(this111) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float g26;
HXDLIN( 141)														int this112 = ((col3 >> 8) & 255);
HXDLIN( 141)														if ((this112 == 0)) {
HXLINE( 141)															g26 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															g26 = (( (Float)(this112) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float b211;
HXDLIN( 141)														int this113 = (col3 & 255);
HXDLIN( 141)														if ((this113 == 0)) {
HXLINE( 141)															b211 = ((Float)0.);
            														}
            														else {
HXLINE( 141)															b211 = (( (Float)(this113) ) / ( (Float)(255) ));
            														}
HXDLIN( 141)														Float a36 = (a111 * (( (Float)(1) ) - a26));
HXDLIN( 141)														int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 141)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 141)														int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a36) + (b211 * a26))));
HXDLIN( 141)														int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 141)														int blended6 = ((((a27 << 24) | (r8 << 16)) | (g8 << 8)) | b34);
HXDLIN( 141)														{
HXLINE( 141)															int _hx_tmp39;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp39 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp39 = blended6;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this46->image,location6,_hx_tmp39);
            														}
            													}
            													else {
HXLINE( 141)														::Dynamic this114 = this46->image;
HXDLIN( 141)														int index17;
HXDLIN( 141)														if (this46->useVirtualPos) {
HXLINE( 141)															index17 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this46->virtualY) * ( (Float)(this46->width) )) + px1) - this46->virtualX));
            														}
            														else {
HXLINE( 141)															index17 = ::Std_obj::_hx_int(( (Float)(((py1 * this46->width) + px1)) ));
            														}
HXDLIN( 141)														int _hx_tmp40;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															_hx_tmp40 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															_hx_tmp40 = c17;
            														}
HXDLIN( 141)														::iterMagic::Iimg_obj::set(this114,index17,_hx_tmp40);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 141)							 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 141)							int v_undoY1;
HXDLIN( 141)							int v_undoX1;
HXDLIN( 141)							Float v_ty1;
HXDLIN( 141)							Float v_tx1;
HXDLIN( 141)							Float v_t01;
HXDLIN( 141)							Float v_sy1;
HXDLIN( 141)							Float v_sx1;
HXDLIN( 141)							Float v_s01;
HXDLIN( 141)							Float v_A1;
HXDLIN( 141)							Float ax2 = bx;
HXDLIN( 141)							Float ay2 = by;
HXDLIN( 141)							 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 141)							Float bx2 = cx;
HXDLIN( 141)							Float by2 = cy;
HXDLIN( 141)							Float cx2 = dx;
HXDLIN( 141)							Float cy2 = dy;
HXDLIN( 141)							bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN( 141)							if (!(adjustWinding1)) {
HXLINE( 141)								Float bx_1 = bx2;
HXDLIN( 141)								Float by_1 = by2;
HXLINE(  24)								bx2 = cx2;
HXLINE(  25)								by2 = cy2;
HXLINE(  26)								cx2 = bx_1;
HXLINE(  27)								cy2 = by_1;
            							}
HXLINE( 141)							Float v_ax1 = ax2;
HXDLIN( 141)							Float v_ay1 = ay2;
HXDLIN( 141)							Float v_bx1 = bx2;
HXDLIN( 141)							Float v_by1 = by2;
HXDLIN( 141)							Float v_cx1 = cx2;
HXDLIN( 141)							Float v_cy1 = cy2;
HXDLIN( 141)							bool v_preCalculated1 = true;
HXDLIN( 141)							{
HXLINE( 141)								v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 141)								v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 141)								v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 141)								v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 141)								v_tx1 = (v_ay1 - v_by1);
HXDLIN( 141)								v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 141)								v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 141)								Float a28 = v_ax1;
HXDLIN( 141)								Float b35 = v_bx1;
HXDLIN( 141)								Float c18 = v_cx1;
HXDLIN( 141)								if ((a28 > b35)) {
HXLINE( 141)									if ((a28 > c18)) {
HXLINE( 141)										int min14;
HXDLIN( 141)										if ((b35 > c18)) {
HXLINE( 141)											min14 = ::Math_obj::floor(c18);
            										}
            										else {
HXLINE( 141)											min14 = ::Math_obj::floor(b35);
            										}
HXDLIN( 141)										int ii_min32 = min14;
HXDLIN( 141)										int ii_max32 = ::Math_obj::ceil(a28);
HXDLIN( 141)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            									}
            									else {
HXLINE( 141)										int ii_min33 = ::Math_obj::floor(b35);
HXDLIN( 141)										int ii_max33 = ::Math_obj::ceil(c18);
HXDLIN( 141)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            									}
            								}
            								else {
HXLINE( 141)									if ((b35 > c18)) {
HXLINE( 141)										int min15;
HXDLIN( 141)										if ((a28 > c18)) {
HXLINE( 141)											min15 = ::Math_obj::floor(c18);
            										}
            										else {
HXLINE( 141)											min15 = ::Math_obj::ceil(a28);
            										}
HXDLIN( 141)										int ii_min34 = min15;
HXDLIN( 141)										int ii_max34 = ::Math_obj::ceil(b35);
HXDLIN( 141)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            									}
            									else {
HXLINE( 141)										int ii_min35 = ::Math_obj::floor(a28);
HXDLIN( 141)										int ii_max35 = ::Math_obj::ceil(c18);
HXDLIN( 141)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            									}
            								}
HXDLIN( 141)								Float a29 = v_ay1;
HXDLIN( 141)								Float b36 = v_by1;
HXDLIN( 141)								Float c19 = v_cy1;
HXDLIN( 141)								if ((a29 > b36)) {
HXLINE( 141)									if ((a29 > c19)) {
HXLINE( 141)										int min16;
HXDLIN( 141)										if ((b36 > c19)) {
HXLINE( 141)											min16 = ::Math_obj::floor(c19);
            										}
            										else {
HXLINE( 141)											min16 = ::Math_obj::floor(b36);
            										}
HXDLIN( 141)										int ii_min36 = min16;
HXDLIN( 141)										int ii_max36 = ::Math_obj::ceil(a29);
HXDLIN( 141)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            									}
            									else {
HXLINE( 141)										int ii_min37 = ::Math_obj::floor(b36);
HXDLIN( 141)										int ii_max37 = ::Math_obj::ceil(c19);
HXDLIN( 141)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            									}
            								}
            								else {
HXLINE( 141)									if ((b36 > c19)) {
HXLINE( 141)										int min17;
HXDLIN( 141)										if ((a29 > c19)) {
HXLINE( 141)											min17 = ::Math_obj::floor(c19);
            										}
            										else {
HXLINE( 141)											min17 = ::Math_obj::ceil(a29);
            										}
HXDLIN( 141)										int ii_min38 = min17;
HXDLIN( 141)										int ii_max38 = ::Math_obj::ceil(b36);
HXDLIN( 141)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            									}
            									else {
HXLINE( 141)										int ii_min39 = ::Math_obj::floor(a29);
HXDLIN( 141)										int ii_max39 = ::Math_obj::ceil(c19);
HXDLIN( 141)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            									}
            								}
            							}
HXDLIN( 141)							if (hasUndo1) {
HXLINE( 141)								v_undoImage1 = undoImage3;
HXDLIN( 141)								v_undoX1 = xIter31->start;
HXDLIN( 141)								v_undoY1 = yIter31->start;
            							}
            						}
            					}
HXDLIN( 141)					bool _hx_tmp41;
HXDLIN( 141)					if (::hx::IsNotNull( nextImage3->mask )) {
HXLINE( 141)						_hx_tmp41 = includeMask;
            					}
            					else {
HXLINE( 141)						_hx_tmp41 = false;
            					}
HXDLIN( 141)					if (_hx_tmp41) {
HXLINE( 141)						 ::pi_xy::ImageStruct this115 = this43->mask;
HXDLIN( 141)						bool transparent1 = this43->mask->transparent;
HXDLIN( 141)						Float centreX2 = centreX1;
HXDLIN( 141)						Float centreY2 = centreY1;
HXDLIN( 141)						Float ax3 = ((Float)0.);
HXDLIN( 141)						Float ay3 = ((Float)0.);
HXDLIN( 141)						if ((centreX2 != ((Float)0.))) {
HXLINE( 173)							centreX2 = ((( (Float)(this115->width) ) / ( (Float)(2) )) + centreX2);
HXLINE( 141)							ax3 = (ax3 - centreX2);
            						}
HXDLIN( 141)						if ((centreY2 != ((Float)0.))) {
HXLINE( 177)							centreY2 = ((( (Float)(this115->height) ) / ( (Float)(2) )) + centreY2);
HXLINE( 141)							ay3 = (ay3 - centreY2);
            						}
HXDLIN( 141)						Float bx3 = (ax3 + this115->width);
HXDLIN( 141)						Float by3 = ay3;
HXDLIN( 141)						Float cx3 = bx3;
HXDLIN( 141)						Float cy3 = (ay3 + this115->height);
HXDLIN( 141)						Float dx3 = ax3;
HXDLIN( 141)						Float dy3 = cy3;
HXDLIN( 141)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 141)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 141)						Float temp6 = ax3;
HXLINE( 189)						ax3 = ((temp6 * cos1) - (ay3 * sin1));
HXLINE( 190)						ay3 = ((ay3 * cos1) + (temp6 * sin1));
HXLINE( 141)						Float temp7 = bx3;
HXLINE( 192)						bx3 = ((temp7 * cos1) - (by3 * sin1));
HXLINE( 193)						by3 = ((by3 * cos1) + (temp7 * sin1));
HXLINE( 141)						Float temp8 = cx3;
HXLINE( 195)						cx3 = ((temp8 * cos1) - (cy3 * sin1));
HXLINE( 196)						cy3 = ((cy3 * cos1) + (temp8 * sin1));
HXLINE( 141)						Float temp9 = dx3;
HXLINE( 198)						dx3 = ((temp9 * cos1) - (dy3 * sin1));
HXLINE( 199)						dy3 = ((dy3 * cos1) + (temp9 * sin1));
HXLINE( 141)						if ((centreX2 != ((Float)0.))) {
HXLINE( 141)							ax3 = (ax3 + centreX2);
HXDLIN( 141)							bx3 = (bx3 + centreX2);
HXDLIN( 141)							cx3 = (cx3 + centreX2);
HXDLIN( 141)							dx3 = (dx3 + centreX2);
            						}
HXDLIN( 141)						if ((centreY2 != ((Float)0.))) {
HXLINE( 141)							ay3 = (ay3 + centreY2);
HXDLIN( 141)							by3 = (by3 + centreY2);
HXDLIN( 141)							cy3 = (cy3 + centreY2);
HXDLIN( 141)							dy3 = (dy3 + centreY2);
            						}
HXDLIN( 141)						int min18 = ::Math_obj::floor(ax3);
HXDLIN( 141)						int max2 = ::Math_obj::ceil(ax3);
HXDLIN( 141)						if ((bx3 < min18)) {
HXLINE(  31)							min18 = ::Math_obj::floor(bx3);
            						}
            						else {
HXLINE( 141)							if ((bx3 > max2)) {
HXLINE(  33)								max2 = ::Math_obj::ceil(bx3);
            							}
            						}
HXLINE( 141)						if ((cx3 < min18)) {
HXLINE(  36)							min18 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 141)							if ((cx3 > max2)) {
HXLINE(  38)								max2 = ::Math_obj::ceil(cx3);
            							}
            						}
HXLINE( 141)						if ((dx3 < min18)) {
HXLINE(  41)							min18 = ::Math_obj::floor(dx3);
            						}
            						else {
HXLINE( 141)							if ((dx3 > max2)) {
HXLINE(  43)								max2 = ::Math_obj::ceil(dx3);
            							}
            						}
HXLINE( 141)						int ii_min40 = min18;
HXDLIN( 141)						int ii_max40 = max2;
HXDLIN( 141)						 ::pi_xy::iter::IntIterStart boundX1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
HXDLIN( 141)						int min19 = ::Math_obj::floor(ay3);
HXDLIN( 141)						int max3 = ::Math_obj::ceil(ay3);
HXDLIN( 141)						if ((by3 < min19)) {
HXLINE(  31)							min19 = ::Math_obj::floor(by3);
            						}
            						else {
HXLINE( 141)							if ((by3 > max3)) {
HXLINE(  33)								max3 = ::Math_obj::ceil(by3);
            							}
            						}
HXLINE( 141)						if ((cy3 < min19)) {
HXLINE(  36)							min19 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 141)							if ((cy3 > max3)) {
HXLINE(  38)								max3 = ::Math_obj::ceil(cy3);
            							}
            						}
HXLINE( 141)						if ((dy3 < min19)) {
HXLINE(  41)							min19 = ::Math_obj::floor(dy3);
            						}
            						else {
HXLINE( 141)							if ((dy3 > max3)) {
HXLINE(  43)								max3 = ::Math_obj::ceil(dy3);
            							}
            						}
HXLINE( 141)						int ii_min41 = min19;
HXDLIN( 141)						int ii_max41 = max3;
HXDLIN( 141)						 ::pi_xy::iter::IntIterStart boundY1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
HXDLIN( 141)						int minX1 = boundX1->start;
HXDLIN( 141)						int wid1 = ((boundX1->max - boundX1->start) + 1);
HXDLIN( 141)						int minY1 = boundY1->start;
HXDLIN( 141)						int hi1 = ((boundY1->max - boundY1->start) + 1);
HXDLIN( 141)						 ::Dynamic imageType6 = null();
HXDLIN( 141)						 ::pi_xy::ImageStruct this116 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 141)						::Dynamic _hx_tmp42;
HXDLIN( 141)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXLINE( 141)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)								 ::iterMagic::BytesImg b37 = byt6;
HXDLIN( 141)								{
HXLINE( 141)									b37->width = wid1;
HXDLIN( 141)									b37->height = hi1;
HXDLIN( 141)									b37->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 141)									b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN( 141)									{
HXLINE( 141)										int len12 = b37->length;
HXDLIN( 141)										int w9 = 0;
HXDLIN( 141)										{
HXLINE( 141)											int _g104 = 0;
HXDLIN( 141)											int _g105 = b37->height;
HXDLIN( 141)											while((_g104 < _g105)){
HXLINE( 141)												_g104 = (_g104 + 1);
HXDLIN( 141)												int y18 = (_g104 - 1);
HXDLIN( 141)												{
HXLINE( 141)													int _g106 = 0;
HXDLIN( 141)													int _g107 = b37->width;
HXDLIN( 141)													while((_g106 < _g107)){
HXLINE( 141)														_g106 = (_g106 + 1);
HXDLIN( 141)														int x18 = (_g106 - 1);
HXDLIN( 141)														{
HXLINE( 141)															w9 = (w9 + 1);
HXDLIN( 141)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 141)														{
HXLINE( 141)															w9 = (w9 + 1);
HXDLIN( 141)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 141)														{
HXLINE( 141)															w9 = (w9 + 1);
HXDLIN( 141)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 141)														{
HXLINE( 141)															w9 = (w9 + 1);
HXDLIN( 141)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								_hx_tmp42 = b37;
            							}
            							break;
            							case (int)1: {
HXLINE( 141)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)								 ::iterMagic::ArrIntImg a30 = arrI6;
HXDLIN( 141)								{
HXLINE( 141)									a30->width = wid1;
HXDLIN( 141)									a30->height = hi1;
HXDLIN( 141)									a30->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)									a30->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 141)									{
HXLINE( 141)										int _g108 = 0;
HXDLIN( 141)										int _g109 = a30->length;
HXDLIN( 141)										while((_g108 < _g109)){
HXLINE( 141)											_g108 = (_g108 + 1);
HXDLIN( 141)											int i42 = (_g108 - 1);
HXDLIN( 141)											a30->data[i42] = 0;
            										}
            									}
            								}
HXDLIN( 141)								_hx_tmp42 = a30;
            							}
            							break;
            							case (int)2: {
HXLINE( 141)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)								 ::iterMagic::U32ArrImg b38 = u32a6;
HXDLIN( 141)								{
HXLINE( 141)									b38->width = wid1;
HXDLIN( 141)									b38->height = hi1;
HXDLIN( 141)									b38->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 141)									int size6 = (b38->length * 4);
HXDLIN( 141)									b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 141)									{
HXLINE( 141)										int _g110 = 0;
HXDLIN( 141)										int _g111 = b38->length;
HXDLIN( 141)										while((_g110 < _g111)){
HXLINE( 141)											_g110 = (_g110 + 1);
HXDLIN( 141)											int i43 = (_g110 - 1);
HXDLIN( 141)											{
HXLINE( 141)												 ::haxe::io::ArrayBufferViewImpl this117 = b38->data;
HXDLIN( 141)												bool _hx_tmp43;
HXDLIN( 141)												if ((i43 >= 0)) {
HXLINE( 141)													_hx_tmp43 = (i43 < (this117->byteLength >> 2));
            												}
            												else {
HXLINE( 141)													_hx_tmp43 = false;
            												}
HXDLIN( 141)												if (_hx_tmp43) {
HXLINE( 141)													 ::haxe::io::Bytes _this6 = this117->bytes;
HXDLIN( 141)													int pos6 = ((i43 << 2) + this117->byteOffset);
HXDLIN( 141)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 141)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								_hx_tmp42 = b38;
            							}
            							break;
            							case (int)3: {
HXLINE( 141)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)								 ::iterMagic::VecIntImg v13 = vec6;
HXDLIN( 141)								{
HXLINE( 141)									v13->width = wid1;
HXDLIN( 141)									v13->height = hi1;
HXDLIN( 141)									v13->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 141)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 141)									{
HXLINE( 141)										int _g112 = 0;
HXDLIN( 141)										int _g113 = v13->length;
HXDLIN( 141)										while((_g112 < _g113)){
HXLINE( 141)											_g112 = (_g112 + 1);
HXDLIN( 141)											int i44 = (_g112 - 1);
HXDLIN( 141)											v13->data->__unsafe_set(i44,0);
            										}
            									}
            								}
HXDLIN( 141)								_hx_tmp42 = v13;
            							}
            							break;
            							case (int)4: {
HXLINE( 141)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)								 ::iterMagic::StackIntImg b39 = sInt6;
HXDLIN( 141)								{
HXLINE( 141)									b39->width = wid1;
HXDLIN( 141)									b39->height = hi1;
HXDLIN( 141)									b39->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 141)									b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)									{
HXLINE( 141)										int len13 = b39->length;
HXDLIN( 141)										 ::haxe::ds::GenericStack_Int d6 = b39->data;
HXDLIN( 141)										if (::hx::IsNull( d6->head )) {
HXLINE( 141)											int _g114 = 0;
HXDLIN( 141)											int _g115 = len13;
HXDLIN( 141)											while((_g114 < _g115)){
HXLINE( 141)												_g114 = (_g114 + 1);
HXDLIN( 141)												int i45 = (_g114 - 1);
HXDLIN( 141)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXLINE( 141)											int _g116 = 0;
HXDLIN( 141)											int _g117 = len13;
HXDLIN( 141)											while((_g116 < _g117)){
HXLINE( 141)												_g116 = (_g116 + 1);
HXDLIN( 141)												int i46 = (_g116 - 1);
HXDLIN( 141)												{
HXLINE( 141)													 ::haxe::ds::GenericCell_Int l6 = b39->data->head;
HXDLIN( 141)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 141)													{
HXLINE( 141)														int _g118 = 0;
HXDLIN( 141)														int _g119 = i46;
HXDLIN( 141)														while((_g118 < _g119)){
HXLINE( 141)															_g118 = (_g118 + 1);
HXDLIN( 141)															int i47 = (_g118 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE( 141)													if (::hx::IsNull( prev6 )) {
HXLINE( 141)														b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 141)														l6 = null();
            													}
            													else {
HXLINE( 141)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 141)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								_hx_tmp42 = b39;
            							}
            							break;
            						}
HXDLIN( 141)						this116->image = _hx_tmp42;
HXDLIN( 141)						this116->width = wid1;
HXDLIN( 141)						this116->height = hi1;
HXDLIN( 141)						this116->imageType = ( (int)(imageType6) );
HXDLIN( 141)						 ::pi_xy::ImageStruct nextImage4 = this116;
HXDLIN( 141)						nextImage4->transparent = true;
HXDLIN( 141)						if ((minX1 < ((Float)0.))) {
HXLINE( 141)							ax3 = (ax3 - ( (Float)(minX1) ));
HXDLIN( 141)							bx3 = (bx3 - ( (Float)(minX1) ));
HXDLIN( 141)							cx3 = (cx3 - ( (Float)(minX1) ));
HXDLIN( 141)							dx3 = (dx3 - ( (Float)(minX1) ));
            						}
HXDLIN( 141)						if ((minY1 < ((Float)0.))) {
HXLINE( 141)							ay3 = (ay3 - ( (Float)(minY1) ));
HXDLIN( 141)							by3 = (by3 - ( (Float)(minY1) ));
HXDLIN( 141)							cy3 = (cy3 - ( (Float)(minY1) ));
HXDLIN( 141)							dy3 = (dy3 - ( (Float)(minY1) ));
            						}
HXDLIN( 141)						{
HXLINE( 141)							 ::pi_xy::ImageStruct this118 = nextImage4;
HXDLIN( 141)							Float win_x1 = ( (Float)(0) );
HXDLIN( 141)							Float win_y1 = ( (Float)(0) );
HXDLIN( 141)							Float win_width1 = ( (Float)(this115->width) );
HXDLIN( 141)							Float win_height1 = ( (Float)(this115->height) );
HXDLIN( 141)							{
HXLINE( 141)								Float bu3 = ((Float)1.);
HXDLIN( 141)								Float bv3 = ((Float)0.);
HXDLIN( 141)								Float cu1 = ((Float)1.);
HXDLIN( 141)								Float cv1 = ((Float)1.);
HXDLIN( 141)								Float du1 = ((Float)0.);
HXDLIN( 141)								Float dv1 = ((Float)1.);
HXDLIN( 141)								Float au2 = ((Float)0.);
HXDLIN( 141)								Float av2 = ((Float)0.);
HXDLIN( 141)								Float bu4 = bu3;
HXDLIN( 141)								Float bv4 = bv3;
HXDLIN( 141)								bool hasUndo2 = false;
HXDLIN( 141)								Float temp10 = au2;
HXLINE( 422)								au2 = bu4;
HXLINE( 423)								bu4 = temp10;
HXLINE( 424)								temp10 = av2;
HXLINE( 425)								av2 = bv4;
HXLINE( 426)								bv4 = temp10;
HXLINE( 141)								Float bcx2 = (bx3 - dx3);
HXDLIN( 141)								Float bcy2 = (by3 - dy3);
HXDLIN( 141)								Float acx2 = (ax3 - dx3);
HXDLIN( 141)								Float acy2 = (ay3 - dy3);
HXDLIN( 141)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 141)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 141)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 141)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 141)								if ((ax3 > bx3)) {
HXLINE( 141)									if ((ax3 > dx3)) {
HXLINE( 141)										int min20;
HXDLIN( 141)										if ((bx3 > dx3)) {
HXLINE( 141)											min20 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 141)											min20 = ::Math_obj::floor(bx3);
            										}
HXDLIN( 141)										int ii_min42 = min20;
HXDLIN( 141)										int ii_max42 = ::Math_obj::ceil(ax3);
HXDLIN( 141)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            									}
            									else {
HXLINE( 141)										int ii_min43 = ::Math_obj::floor(bx3);
HXDLIN( 141)										int ii_max43 = ::Math_obj::ceil(dx3);
HXDLIN( 141)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            									}
            								}
            								else {
HXLINE( 141)									if ((bx3 > dx3)) {
HXLINE( 141)										int min21;
HXDLIN( 141)										if ((ax3 > dx3)) {
HXLINE( 141)											min21 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 141)											min21 = ::Math_obj::ceil(ax3);
            										}
HXDLIN( 141)										int ii_min44 = min21;
HXDLIN( 141)										int ii_max44 = ::Math_obj::ceil(bx3);
HXDLIN( 141)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            									}
            									else {
HXLINE( 141)										int ii_min45 = ::Math_obj::floor(ax3);
HXDLIN( 141)										int ii_max45 = ::Math_obj::ceil(dx3);
HXDLIN( 141)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            									}
            								}
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 141)								if ((ay3 > by3)) {
HXLINE( 141)									if ((ay3 > dy3)) {
HXLINE( 141)										int min22;
HXDLIN( 141)										if ((by3 > dy3)) {
HXLINE( 141)											min22 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 141)											min22 = ::Math_obj::floor(by3);
            										}
HXDLIN( 141)										int ii_min46 = min22;
HXDLIN( 141)										int ii_max46 = ::Math_obj::ceil(ay3);
HXDLIN( 141)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            									}
            									else {
HXLINE( 141)										int ii_min47 = ::Math_obj::floor(by3);
HXDLIN( 141)										int ii_max47 = ::Math_obj::ceil(dy3);
HXDLIN( 141)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            									}
            								}
            								else {
HXLINE( 141)									if ((by3 > dy3)) {
HXLINE( 141)										int min23;
HXDLIN( 141)										if ((ay3 > dy3)) {
HXLINE( 141)											min23 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 141)											min23 = ::Math_obj::ceil(ay3);
            										}
HXDLIN( 141)										int ii_min48 = min23;
HXDLIN( 141)										int ii_max48 = ::Math_obj::ceil(by3);
HXDLIN( 141)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            									}
            									else {
HXLINE( 141)										int ii_min49 = ::Math_obj::floor(ay3);
HXDLIN( 141)										int ii_max49 = ::Math_obj::ceil(dy3);
HXDLIN( 141)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            									}
            								}
HXDLIN( 141)								 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 141)								if (hasUndo2) {
HXLINE( 141)									int width5 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 141)									int height5 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 141)									 ::Dynamic imageType7 = null();
HXDLIN( 141)									 ::pi_xy::ImageStruct this119 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)									if (::hx::IsNull( imageType7 )) {
HXLINE(  54)										imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 141)									::Dynamic undoImage7;
HXDLIN( 141)									switch((int)(( (int)(imageType7) ))){
            										case (int)0: {
HXLINE( 141)											 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::BytesImg b40 = byt7;
HXDLIN( 141)											{
HXLINE( 141)												b40->width = width5;
HXDLIN( 141)												b40->height = height5;
HXDLIN( 141)												b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 141)												b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN( 141)												{
HXLINE( 141)													int len14 = b40->length;
HXDLIN( 141)													int w10 = 0;
HXDLIN( 141)													{
HXLINE( 141)														int _g120 = 0;
HXDLIN( 141)														int _g121 = b40->height;
HXDLIN( 141)														while((_g120 < _g121)){
HXLINE( 141)															_g120 = (_g120 + 1);
HXDLIN( 141)															int y19 = (_g120 - 1);
HXDLIN( 141)															{
HXLINE( 141)																int _g122 = 0;
HXDLIN( 141)																int _g123 = b40->width;
HXDLIN( 141)																while((_g122 < _g123)){
HXLINE( 141)																	_g122 = (_g122 + 1);
HXDLIN( 141)																	int x19 = (_g122 - 1);
HXDLIN( 141)																	{
HXLINE( 141)																		w10 = (w10 + 1);
HXDLIN( 141)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w10 = (w10 + 1);
HXDLIN( 141)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w10 = (w10 + 1);
HXDLIN( 141)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w10 = (w10 + 1);
HXDLIN( 141)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage7 = b40;
            										}
            										break;
            										case (int)1: {
HXLINE( 141)											 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::ArrIntImg a37 = arrI7;
HXDLIN( 141)											{
HXLINE( 141)												a37->width = width5;
HXDLIN( 141)												a37->height = height5;
HXDLIN( 141)												a37->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)												a37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 141)												{
HXLINE( 141)													int _g124 = 0;
HXDLIN( 141)													int _g125 = a37->length;
HXDLIN( 141)													while((_g124 < _g125)){
HXLINE( 141)														_g124 = (_g124 + 1);
HXDLIN( 141)														int i48 = (_g124 - 1);
HXDLIN( 141)														a37->data[i48] = 0;
            													}
            												}
            											}
HXDLIN( 141)											undoImage7 = a37;
            										}
            										break;
            										case (int)2: {
HXLINE( 141)											 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::U32ArrImg b41 = u32a7;
HXDLIN( 141)											{
HXLINE( 141)												b41->width = width5;
HXDLIN( 141)												b41->height = height5;
HXDLIN( 141)												b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 141)												int size7 = (b41->length * 4);
HXDLIN( 141)												b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 141)												{
HXLINE( 141)													int _g126 = 0;
HXDLIN( 141)													int _g127 = b41->length;
HXDLIN( 141)													while((_g126 < _g127)){
HXLINE( 141)														_g126 = (_g126 + 1);
HXDLIN( 141)														int i49 = (_g126 - 1);
HXDLIN( 141)														{
HXLINE( 141)															 ::haxe::io::ArrayBufferViewImpl this120 = b41->data;
HXDLIN( 141)															bool undoImage8;
HXDLIN( 141)															if ((i49 >= 0)) {
HXLINE( 141)																undoImage8 = (i49 < (this120->byteLength >> 2));
            															}
            															else {
HXLINE( 141)																undoImage8 = false;
            															}
HXDLIN( 141)															if (undoImage8) {
HXLINE( 141)																 ::haxe::io::Bytes _this7 = this120->bytes;
HXDLIN( 141)																int pos7 = ((i49 << 2) + this120->byteOffset);
HXDLIN( 141)																_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 141)																_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)																_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)																_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage7 = b41;
            										}
            										break;
            										case (int)3: {
HXLINE( 141)											 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::VecIntImg v14 = vec7;
HXDLIN( 141)											{
HXLINE( 141)												v14->width = width5;
HXDLIN( 141)												v14->height = height5;
HXDLIN( 141)												v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 141)												v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN( 141)												{
HXLINE( 141)													int _g128 = 0;
HXDLIN( 141)													int _g129 = v14->length;
HXDLIN( 141)													while((_g128 < _g129)){
HXLINE( 141)														_g128 = (_g128 + 1);
HXDLIN( 141)														int i50 = (_g128 - 1);
HXDLIN( 141)														v14->data->__unsafe_set(i50,0);
            													}
            												}
            											}
HXDLIN( 141)											undoImage7 = v14;
            										}
            										break;
            										case (int)4: {
HXLINE( 141)											 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::StackIntImg b42 = sInt7;
HXDLIN( 141)											{
HXLINE( 141)												b42->width = width5;
HXDLIN( 141)												b42->height = height5;
HXDLIN( 141)												b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 141)												b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)												{
HXLINE( 141)													int len15 = b42->length;
HXDLIN( 141)													 ::haxe::ds::GenericStack_Int d7 = b42->data;
HXDLIN( 141)													if (::hx::IsNull( d7->head )) {
HXLINE( 141)														int _g130 = 0;
HXDLIN( 141)														int _g131 = len15;
HXDLIN( 141)														while((_g130 < _g131)){
HXLINE( 141)															_g130 = (_g130 + 1);
HXDLIN( 141)															int i51 = (_g130 - 1);
HXDLIN( 141)															d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            														}
            													}
            													else {
HXLINE( 141)														int _g132 = 0;
HXDLIN( 141)														int _g133 = len15;
HXDLIN( 141)														while((_g132 < _g133)){
HXLINE( 141)															_g132 = (_g132 + 1);
HXDLIN( 141)															int i52 = (_g132 - 1);
HXDLIN( 141)															{
HXLINE( 141)																 ::haxe::ds::GenericCell_Int l7 = b42->data->head;
HXDLIN( 141)																 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 141)																{
HXLINE( 141)																	int _g134 = 0;
HXDLIN( 141)																	int _g135 = i52;
HXDLIN( 141)																	while((_g134 < _g135)){
HXLINE( 141)																		_g134 = (_g134 + 1);
HXDLIN( 141)																		int i53 = (_g134 - 1);
HXLINE( 345)																		prev7 = l7;
HXLINE( 346)																		l7 = l7->next;
            																	}
            																}
HXLINE( 141)																if (::hx::IsNull( prev7 )) {
HXLINE( 141)																	b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 141)																	l7 = null();
            																}
            																else {
HXLINE( 141)																	prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 141)																	l7 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage7 = b42;
            										}
            										break;
            									}
HXDLIN( 141)									this119->image = undoImage7;
HXDLIN( 141)									this119->width = width5;
HXDLIN( 141)									this119->height = height5;
HXDLIN( 141)									this119->imageType = ( (int)(imageType7) );
HXDLIN( 141)									undoImage6 = this119;
HXDLIN( 141)									{
HXLINE( 141)										int rectLeft2 = xIter32->start;
HXDLIN( 141)										int rectTop2 = yIter32->start;
HXDLIN( 141)										int rectRight2 = xIter32->max;
HXDLIN( 141)										bool forceClear2 = false;
HXDLIN( 141)										{
HXLINE( 141)											int _g136 = rectTop2;
HXDLIN( 141)											int _g137 = yIter32->max;
HXDLIN( 141)											while((_g136 < _g137)){
HXLINE( 141)												_g136 = (_g136 + 1);
HXDLIN( 141)												int dy4 = (_g136 - 1);
HXDLIN( 141)												{
HXLINE( 141)													int _g138 = rectLeft2;
HXDLIN( 141)													int _g139 = rectRight2;
HXDLIN( 141)													while((_g138 < _g139)){
HXLINE( 141)														_g138 = (_g138 + 1);
HXDLIN( 141)														int dx4 = (_g138 - 1);
HXDLIN( 141)														::Dynamic this121 = this118->image;
HXDLIN( 141)														int index18;
HXDLIN( 141)														if (this118->useVirtualPos) {
HXLINE( 141)															index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this118->virtualY) * ( (Float)(this118->width) )) + dx4) - this118->virtualX));
            														}
            														else {
HXLINE( 141)															index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this118->width) + dx4)) ));
            														}
HXDLIN( 141)														int c20 = ::iterMagic::Iimg_obj::get(this121,index18);
HXDLIN( 141)														int col4;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															col4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															col4 = c20;
            														}
HXDLIN( 141)														bool _hx_tmp44;
HXDLIN( 141)														if (this118->useMask) {
HXLINE( 141)															_hx_tmp44 = ::hx::IsNotNull( this118->mask );
            														}
            														else {
HXLINE( 141)															_hx_tmp44 = false;
            														}
HXDLIN( 141)														if (_hx_tmp44) {
HXLINE( 141)															 ::pi_xy::ImageStruct this122 = this118->mask;
HXDLIN( 141)															::Dynamic this123 = this122->image;
HXDLIN( 141)															int index19;
HXDLIN( 141)															if (this122->useVirtualPos) {
HXLINE( 141)																index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this122->virtualY) * ( (Float)(this122->width) )) + dx4) - this122->virtualX));
            															}
            															else {
HXLINE( 141)																index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this122->width) + dx4)) ));
            															}
HXDLIN( 141)															int c21 = ::iterMagic::Iimg_obj::get(this123,index19);
HXDLIN( 141)															int v15;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																v15 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																v15 = c21;
            															}
HXDLIN( 141)															int maskPixel2 = v15;
HXDLIN( 141)															int this124 = col4;
HXDLIN( 141)															if ((maskPixel2 == 0)) {
HXLINE( 141)																col4 = this124;
            															}
            															else {
HXLINE( 141)																Float m02;
HXDLIN( 141)																int this125 = ((maskPixel2 >> 24) & 255);
HXDLIN( 141)																if ((this125 == 0)) {
HXLINE( 141)																	m02 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m02 = (( (Float)(this125) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m12;
HXDLIN( 141)																int this126 = ((maskPixel2 >> 16) & 255);
HXDLIN( 141)																if ((this126 == 0)) {
HXLINE( 141)																	m12 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m12 = (( (Float)(this126) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m22;
HXDLIN( 141)																int this127 = ((maskPixel2 >> 8) & 255);
HXDLIN( 141)																if ((this127 == 0)) {
HXLINE( 141)																	m22 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m22 = (( (Float)(this127) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m32;
HXDLIN( 141)																int this128 = (maskPixel2 & 255);
HXDLIN( 141)																if ((this128 == 0)) {
HXLINE( 141)																	m32 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m32 = (( (Float)(this128) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this124 >> 24) & 255)) )));
HXDLIN( 141)																int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this124 >> 16) & 255)) )));
HXDLIN( 141)																int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this124 >> 8) & 255)) )));
HXDLIN( 141)																int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this124 & 255)) )));
HXDLIN( 141)																col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 141)														if ((col4 != 0)) {
HXLINE( 141)															int x20 = (dx4 - rectLeft2);
HXDLIN( 141)															int y20 = (dy4 - rectTop2);
HXDLIN( 141)															int c22 = col4;
HXDLIN( 141)															bool _hx_tmp45;
HXDLIN( 141)															if ((((c22 >> 24) & 255) < 254)) {
HXLINE( 141)																_hx_tmp45 = undoImage6->transparent;
            															}
            															else {
HXLINE( 141)																_hx_tmp45 = false;
            															}
HXDLIN( 141)															if (_hx_tmp45) {
HXLINE( 141)																int location7;
HXDLIN( 141)																if (undoImage6->useVirtualPos) {
HXLINE( 141)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 141)																	location7 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN( 141)																int this129 = ::iterMagic::Iimg_obj::get(undoImage6->image,location7);
HXDLIN( 141)																int this130;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	this130 = ((((((this129 >> 24) & 255) << 24) | ((this129 & 255) << 16)) | (((this129 >> 8) & 255) << 8)) | ((this129 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	this130 = this129;
            																}
HXDLIN( 141)																Float a112;
HXDLIN( 141)																int this131 = ((this130 >> 24) & 255);
HXDLIN( 141)																if ((this131 == 0)) {
HXLINE( 141)																	a112 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	a112 = (( (Float)(this131) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float r17;
HXDLIN( 141)																int this132 = ((this130 >> 16) & 255);
HXDLIN( 141)																if ((this132 == 0)) {
HXLINE( 141)																	r17 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	r17 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float g17;
HXDLIN( 141)																int this133 = ((this130 >> 8) & 255);
HXDLIN( 141)																if ((this133 == 0)) {
HXLINE( 141)																	g17 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	g17 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float b114;
HXDLIN( 141)																int this134 = (this130 & 255);
HXDLIN( 141)																if ((this134 == 0)) {
HXLINE( 141)																	b114 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	b114 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float a210;
HXDLIN( 141)																int this135 = ((col4 >> 24) & 255);
HXDLIN( 141)																if ((this135 == 0)) {
HXLINE( 141)																	a210 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	a210 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float r27;
HXDLIN( 141)																int this136 = ((col4 >> 16) & 255);
HXDLIN( 141)																if ((this136 == 0)) {
HXLINE( 141)																	r27 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	r27 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float g27;
HXDLIN( 141)																int this137 = ((col4 >> 8) & 255);
HXDLIN( 141)																if ((this137 == 0)) {
HXLINE( 141)																	g27 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	g27 = (( (Float)(this137) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float b212;
HXDLIN( 141)																int this138 = (col4 & 255);
HXDLIN( 141)																if ((this138 == 0)) {
HXLINE( 141)																	b212 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	b212 = (( (Float)(this138) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 141)																int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a38) + (r27 * a210))));
HXDLIN( 141)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a38) + (g27 * a210))));
HXDLIN( 141)																int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN( 141)																int a39 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 141)																int blended7 = ((((a39 << 24) | (r9 << 16)) | (g9 << 8)) | b43);
HXDLIN( 141)																{
HXLINE( 141)																	int _hx_tmp46;
HXDLIN( 141)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																		_hx_tmp46 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXLINE( 141)																		_hx_tmp46 = blended7;
            																	}
HXDLIN( 141)																	::iterMagic::Iimg_obj::set(undoImage6->image,location7,_hx_tmp46);
            																}
            															}
            															else {
HXLINE( 141)																::Dynamic this139 = undoImage6->image;
HXDLIN( 141)																int index20;
HXDLIN( 141)																if (undoImage6->useVirtualPos) {
HXLINE( 141)																	index20 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 141)																	index20 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN( 141)																int _hx_tmp47;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp47 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp47 = c22;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this139,index20,_hx_tmp47);
            															}
            														}
            														else {
HXLINE( 141)															if (forceClear2) {
HXLINE( 141)																::Dynamic this140 = undoImage6->image;
HXDLIN( 141)																int x21 = (dx4 - rectLeft2);
HXDLIN( 141)																int y21 = (dy4 - rectTop2);
HXDLIN( 141)																int index21;
HXDLIN( 141)																if (undoImage6->useVirtualPos) {
HXLINE( 141)																	index21 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x21) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 141)																	index21 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage6->width) + x21)) ));
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this140,index21,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								{
HXLINE( 141)									int _g_min4 = xIter32->start;
HXDLIN( 141)									int _g_max4 = xIter32->max;
HXDLIN( 141)									while((_g_min4 < _g_max4)){
HXLINE( 141)										_g_min4 = (_g_min4 + 1);
HXDLIN( 141)										int px2 = (_g_min4 - 1);
HXDLIN( 141)										Float pcx2 = (( (Float)(px2) ) - dx3);
HXDLIN( 141)										{
HXLINE( 141)											int _g_min5 = yIter32->start;
HXDLIN( 141)											int _g_max5 = yIter32->max;
HXDLIN( 141)											while((_g_min5 < _g_max5)){
HXLINE( 141)												_g_min5 = (_g_min5 + 1);
HXDLIN( 141)												int py2 = (_g_min5 - 1);
HXDLIN( 141)												Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN( 141)												Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 141)												Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 141)												Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 141)												Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 141)												Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 141)												bool _hx_tmp48;
HXDLIN( 141)												bool _hx_tmp49;
HXDLIN( 141)												if ((ratioA2 >= 0)) {
HXLINE( 141)													_hx_tmp49 = (ratioB2 >= 0);
            												}
            												else {
HXLINE( 141)													_hx_tmp49 = false;
            												}
HXDLIN( 141)												if (_hx_tmp49) {
HXLINE( 141)													_hx_tmp48 = (ratioC2 >= 0);
            												}
            												else {
HXLINE( 141)													_hx_tmp48 = false;
            												}
HXDLIN( 141)												if (_hx_tmp48) {
HXLINE( 141)													Float u2 = (((au2 * ratioA2) + (bu4 * ratioB2)) + (du1 * ratioC2));
HXDLIN( 141)													Float v16 = (((av2 * ratioA2) + (bv4 * ratioB2)) + (dv1 * ratioC2));
HXDLIN( 141)													int x22 = ::Std_obj::_hx_int(((u2 * win_width1) + win_x1));
HXDLIN( 141)													int y22 = ::Std_obj::_hx_int(((v16 * win_height1) + win_y1));
HXDLIN( 141)													::Dynamic this141 = this115->image;
HXDLIN( 141)													int index22;
HXDLIN( 141)													if (this115->useVirtualPos) {
HXLINE( 141)														index22 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this115->virtualY) * ( (Float)(this115->width) )) + x22) - this115->virtualX));
            													}
            													else {
HXLINE( 141)														index22 = ::Std_obj::_hx_int(( (Float)(((y22 * this115->width) + x22)) ));
            													}
HXDLIN( 141)													int c23 = ::iterMagic::Iimg_obj::get(this141,index22);
HXDLIN( 141)													int col5;
HXDLIN( 141)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)														col5 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXLINE( 141)														col5 = c23;
            													}
HXDLIN( 141)													{
HXLINE( 141)														int c24 = col5;
HXDLIN( 141)														bool _hx_tmp50;
HXDLIN( 141)														if ((((c24 >> 24) & 255) < 254)) {
HXLINE( 141)															_hx_tmp50 = this118->transparent;
            														}
            														else {
HXLINE( 141)															_hx_tmp50 = false;
            														}
HXDLIN( 141)														if (_hx_tmp50) {
HXLINE( 141)															int location8;
HXDLIN( 141)															if (this118->useVirtualPos) {
HXLINE( 141)																location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this118->virtualY) * ( (Float)(this118->width) )) + px2) - this118->virtualX));
            															}
            															else {
HXLINE( 141)																location8 = ::Std_obj::_hx_int(( (Float)(((py2 * this118->width) + px2)) ));
            															}
HXDLIN( 141)															int this142 = ::iterMagic::Iimg_obj::get(this118->image,location8);
HXDLIN( 141)															int this143;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																this143 = ((((((this142 >> 24) & 255) << 24) | ((this142 & 255) << 16)) | (((this142 >> 8) & 255) << 8)) | ((this142 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																this143 = this142;
            															}
HXDLIN( 141)															Float a113;
HXDLIN( 141)															int this144 = ((this143 >> 24) & 255);
HXDLIN( 141)															if ((this144 == 0)) {
HXLINE( 141)																a113 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a113 = (( (Float)(this144) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r18;
HXDLIN( 141)															int this145 = ((this143 >> 16) & 255);
HXDLIN( 141)															if ((this145 == 0)) {
HXLINE( 141)																r18 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r18 = (( (Float)(this145) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g18;
HXDLIN( 141)															int this146 = ((this143 >> 8) & 255);
HXDLIN( 141)															if ((this146 == 0)) {
HXLINE( 141)																g18 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g18 = (( (Float)(this146) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b115;
HXDLIN( 141)															int this147 = (this143 & 255);
HXDLIN( 141)															if ((this147 == 0)) {
HXLINE( 141)																b115 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b115 = (( (Float)(this147) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a211;
HXDLIN( 141)															int this148 = ((col5 >> 24) & 255);
HXDLIN( 141)															if ((this148 == 0)) {
HXLINE( 141)																a211 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a211 = (( (Float)(this148) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r28;
HXDLIN( 141)															int this149 = ((col5 >> 16) & 255);
HXDLIN( 141)															if ((this149 == 0)) {
HXLINE( 141)																r28 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r28 = (( (Float)(this149) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g28;
HXDLIN( 141)															int this150 = ((col5 >> 8) & 255);
HXDLIN( 141)															if ((this150 == 0)) {
HXLINE( 141)																g28 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g28 = (( (Float)(this150) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b213;
HXDLIN( 141)															int this151 = (col5 & 255);
HXDLIN( 141)															if ((this151 == 0)) {
HXLINE( 141)																b213 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b213 = (( (Float)(this151) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 141)															int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a310) + (r28 * a211))));
HXDLIN( 141)															int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN( 141)															int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN( 141)															int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 141)															int blended8 = ((((a40 << 24) | (r10 << 16)) | (g10 << 8)) | b44);
HXDLIN( 141)															{
HXLINE( 141)																int _hx_tmp51;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp51 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp51 = blended8;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this118->image,location8,_hx_tmp51);
            															}
            														}
            														else {
HXLINE( 141)															::Dynamic this152 = this118->image;
HXDLIN( 141)															int index23;
HXDLIN( 141)															if (this118->useVirtualPos) {
HXLINE( 141)																index23 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this118->virtualY) * ( (Float)(this118->width) )) + px2) - this118->virtualX));
            															}
            															else {
HXLINE( 141)																index23 = ::Std_obj::_hx_int(( (Float)(((py2 * this118->width) + px2)) ));
            															}
HXDLIN( 141)															int _hx_tmp52;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp52 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp52 = c24;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this152,index23,_hx_tmp52);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN( 141)								int v_undoY2;
HXDLIN( 141)								int v_undoX2;
HXDLIN( 141)								Float v_ty2;
HXDLIN( 141)								Float v_tx2;
HXDLIN( 141)								Float v_t02;
HXDLIN( 141)								Float v_sy2;
HXDLIN( 141)								Float v_sx2;
HXDLIN( 141)								Float v_s02;
HXDLIN( 141)								Float v_A2;
HXDLIN( 141)								Float ax4 = ax3;
HXDLIN( 141)								Float ay4 = ay3;
HXDLIN( 141)								 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN( 141)								Float bx4 = bx3;
HXDLIN( 141)								Float by4 = by3;
HXDLIN( 141)								Float cx4 = dx3;
HXDLIN( 141)								Float cy4 = dy3;
HXDLIN( 141)								bool adjustWinding2 = (((((ax4 * by4) - (bx4 * ay4)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay4) - (ax4 * cy4))) > 0);
HXDLIN( 141)								if (!(adjustWinding2)) {
HXLINE( 141)									Float bx_2 = bx4;
HXDLIN( 141)									Float by_2 = by4;
HXLINE(  24)									bx4 = cx4;
HXLINE(  25)									by4 = cy4;
HXLINE(  26)									cx4 = bx_2;
HXLINE(  27)									cy4 = by_2;
            								}
HXLINE( 141)								Float v_ax2 = ax4;
HXDLIN( 141)								Float v_ay2 = ay4;
HXDLIN( 141)								Float v_bx2 = bx4;
HXDLIN( 141)								Float v_by2 = by4;
HXDLIN( 141)								Float v_cx2 = cx4;
HXDLIN( 141)								Float v_cy2 = cy4;
HXDLIN( 141)								bool v_preCalculated2 = true;
HXDLIN( 141)								{
HXLINE(  93)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  93)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  93)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  93)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  93)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  93)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  93)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXLINE( 141)									Float a41 = v_ax2;
HXDLIN( 141)									Float b45 = v_bx2;
HXDLIN( 141)									Float c25 = v_cx2;
HXDLIN( 141)									if ((a41 > b45)) {
HXLINE( 141)										if ((a41 > c25)) {
HXLINE( 141)											int min24;
HXDLIN( 141)											if ((b45 > c25)) {
HXLINE( 141)												min24 = ::Math_obj::floor(c25);
            											}
            											else {
HXLINE( 141)												min24 = ::Math_obj::floor(b45);
            											}
HXDLIN( 141)											int ii_min50 = min24;
HXDLIN( 141)											int ii_max50 = ::Math_obj::ceil(a41);
HXDLIN( 141)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            										}
            										else {
HXLINE( 141)											int ii_min51 = ::Math_obj::floor(b45);
HXDLIN( 141)											int ii_max51 = ::Math_obj::ceil(c25);
HXDLIN( 141)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            										}
            									}
            									else {
HXLINE( 141)										if ((b45 > c25)) {
HXLINE( 141)											int min25;
HXDLIN( 141)											if ((a41 > c25)) {
HXLINE( 141)												min25 = ::Math_obj::floor(c25);
            											}
            											else {
HXLINE( 141)												min25 = ::Math_obj::ceil(a41);
            											}
HXDLIN( 141)											int ii_min52 = min25;
HXDLIN( 141)											int ii_max52 = ::Math_obj::ceil(b45);
HXDLIN( 141)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            										}
            										else {
HXLINE( 141)											int ii_min53 = ::Math_obj::floor(a41);
HXDLIN( 141)											int ii_max53 = ::Math_obj::ceil(c25);
HXDLIN( 141)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            										}
            									}
HXDLIN( 141)									Float a42 = v_ay2;
HXDLIN( 141)									Float b46 = v_by2;
HXDLIN( 141)									Float c26 = v_cy2;
HXDLIN( 141)									if ((a42 > b46)) {
HXLINE( 141)										if ((a42 > c26)) {
HXLINE( 141)											int min26;
HXDLIN( 141)											if ((b46 > c26)) {
HXLINE( 141)												min26 = ::Math_obj::floor(c26);
            											}
            											else {
HXLINE( 141)												min26 = ::Math_obj::floor(b46);
            											}
HXDLIN( 141)											int ii_min54 = min26;
HXDLIN( 141)											int ii_max54 = ::Math_obj::ceil(a42);
HXDLIN( 141)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            										}
            										else {
HXLINE( 141)											int ii_min55 = ::Math_obj::floor(b46);
HXDLIN( 141)											int ii_max55 = ::Math_obj::ceil(c26);
HXDLIN( 141)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            										}
            									}
            									else {
HXLINE( 141)										if ((b46 > c26)) {
HXLINE( 141)											int min27;
HXDLIN( 141)											if ((a42 > c26)) {
HXLINE( 141)												min27 = ::Math_obj::floor(c26);
            											}
            											else {
HXLINE( 141)												min27 = ::Math_obj::ceil(a42);
            											}
HXDLIN( 141)											int ii_min56 = min27;
HXDLIN( 141)											int ii_max56 = ::Math_obj::ceil(b46);
HXDLIN( 141)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            										}
            										else {
HXLINE( 141)											int ii_min57 = ::Math_obj::floor(a42);
HXDLIN( 141)											int ii_max57 = ::Math_obj::ceil(c26);
HXDLIN( 141)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            										}
            									}
            								}
HXDLIN( 141)								if (hasUndo2) {
HXLINE(  93)									v_undoImage2 = undoImage6;
HXDLIN(  93)									v_undoX2 = xIter32->start;
HXDLIN(  93)									v_undoY2 = yIter32->start;
            								}
HXLINE( 141)								Float au3 = bu3;
HXDLIN( 141)								Float av3 = bv3;
HXDLIN( 141)								Float bu5 = cu1;
HXDLIN( 141)								Float bv5 = cv1;
HXDLIN( 141)								bool hasUndo3 = false;
HXDLIN( 141)								Float temp11 = au3;
HXLINE( 422)								au3 = bu5;
HXLINE( 423)								bu5 = temp11;
HXLINE( 424)								temp11 = av3;
HXLINE( 425)								av3 = bv5;
HXLINE( 426)								bv5 = temp11;
HXLINE( 141)								Float bcx3 = (cx3 - dx3);
HXDLIN( 141)								Float bcy3 = (cy3 - dy3);
HXDLIN( 141)								Float acx3 = (bx3 - dx3);
HXDLIN( 141)								Float acy3 = (by3 - dy3);
HXDLIN( 141)								Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 141)								Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 141)								Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 141)								Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 141)								if ((bx3 > cx3)) {
HXLINE( 141)									if ((bx3 > dx3)) {
HXLINE( 141)										int min28;
HXDLIN( 141)										if ((cx3 > dx3)) {
HXLINE( 141)											min28 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 141)											min28 = ::Math_obj::floor(cx3);
            										}
HXDLIN( 141)										int ii_min58 = min28;
HXDLIN( 141)										int ii_max58 = ::Math_obj::ceil(bx3);
HXDLIN( 141)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            									}
            									else {
HXLINE( 141)										int ii_min59 = ::Math_obj::floor(cx3);
HXDLIN( 141)										int ii_max59 = ::Math_obj::ceil(dx3);
HXDLIN( 141)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            									}
            								}
            								else {
HXLINE( 141)									if ((cx3 > dx3)) {
HXLINE( 141)										int min29;
HXDLIN( 141)										if ((bx3 > dx3)) {
HXLINE( 141)											min29 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 141)											min29 = ::Math_obj::ceil(bx3);
            										}
HXDLIN( 141)										int ii_min60 = min29;
HXDLIN( 141)										int ii_max60 = ::Math_obj::ceil(cx3);
HXDLIN( 141)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            									}
            									else {
HXLINE( 141)										int ii_min61 = ::Math_obj::floor(bx3);
HXDLIN( 141)										int ii_max61 = ::Math_obj::ceil(dx3);
HXDLIN( 141)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            									}
            								}
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 141)								if ((by3 > cy3)) {
HXLINE( 141)									if ((by3 > dy3)) {
HXLINE( 141)										int min30;
HXDLIN( 141)										if ((cy3 > dy3)) {
HXLINE( 141)											min30 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 141)											min30 = ::Math_obj::floor(cy3);
            										}
HXDLIN( 141)										int ii_min62 = min30;
HXDLIN( 141)										int ii_max62 = ::Math_obj::ceil(by3);
HXDLIN( 141)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            									}
            									else {
HXLINE( 141)										int ii_min63 = ::Math_obj::floor(cy3);
HXDLIN( 141)										int ii_max63 = ::Math_obj::ceil(dy3);
HXDLIN( 141)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            									}
            								}
            								else {
HXLINE( 141)									if ((cy3 > dy3)) {
HXLINE( 141)										int min31;
HXDLIN( 141)										if ((by3 > dy3)) {
HXLINE( 141)											min31 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 141)											min31 = ::Math_obj::ceil(by3);
            										}
HXDLIN( 141)										int ii_min64 = min31;
HXDLIN( 141)										int ii_max64 = ::Math_obj::ceil(cy3);
HXDLIN( 141)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            									}
            									else {
HXLINE( 141)										int ii_min65 = ::Math_obj::floor(by3);
HXDLIN( 141)										int ii_max65 = ::Math_obj::ceil(dy3);
HXDLIN( 141)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            									}
            								}
HXDLIN( 141)								 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 141)								if (hasUndo3) {
HXLINE( 141)									int width6 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 141)									int height6 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 141)									 ::Dynamic imageType8 = null();
HXDLIN( 141)									 ::pi_xy::ImageStruct this153 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 141)									if (::hx::IsNull( imageType8 )) {
HXLINE(  54)										imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 141)									::Dynamic undoImage10;
HXDLIN( 141)									switch((int)(( (int)(imageType8) ))){
            										case (int)0: {
HXLINE( 141)											 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::BytesImg b47 = byt8;
HXDLIN( 141)											{
HXLINE( 141)												b47->width = width6;
HXDLIN( 141)												b47->height = height6;
HXDLIN( 141)												b47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 141)												b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN( 141)												{
HXLINE( 141)													int len16 = b47->length;
HXDLIN( 141)													int w11 = 0;
HXDLIN( 141)													{
HXLINE( 141)														int _g140 = 0;
HXDLIN( 141)														int _g141 = b47->height;
HXDLIN( 141)														while((_g140 < _g141)){
HXLINE( 141)															_g140 = (_g140 + 1);
HXDLIN( 141)															int y23 = (_g140 - 1);
HXDLIN( 141)															{
HXLINE( 141)																int _g142 = 0;
HXDLIN( 141)																int _g143 = b47->width;
HXDLIN( 141)																while((_g142 < _g143)){
HXLINE( 141)																	_g142 = (_g142 + 1);
HXDLIN( 141)																	int x23 = (_g142 - 1);
HXDLIN( 141)																	{
HXLINE( 141)																		w11 = (w11 + 1);
HXDLIN( 141)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w11 = (w11 + 1);
HXDLIN( 141)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w11 = (w11 + 1);
HXDLIN( 141)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 141)																	{
HXLINE( 141)																		w11 = (w11 + 1);
HXDLIN( 141)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage10 = b47;
            										}
            										break;
            										case (int)1: {
HXLINE( 141)											 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::ArrIntImg a43 = arrI8;
HXDLIN( 141)											{
HXLINE( 141)												a43->width = width6;
HXDLIN( 141)												a43->height = height6;
HXDLIN( 141)												a43->data = ::Array_obj< int >::__new(0);
HXDLIN( 141)												a43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 141)												{
HXLINE( 141)													int _g144 = 0;
HXDLIN( 141)													int _g145 = a43->length;
HXDLIN( 141)													while((_g144 < _g145)){
HXLINE( 141)														_g144 = (_g144 + 1);
HXDLIN( 141)														int i54 = (_g144 - 1);
HXDLIN( 141)														a43->data[i54] = 0;
            													}
            												}
            											}
HXDLIN( 141)											undoImage10 = a43;
            										}
            										break;
            										case (int)2: {
HXLINE( 141)											 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::U32ArrImg b48 = u32a8;
HXDLIN( 141)											{
HXLINE( 141)												b48->width = width6;
HXDLIN( 141)												b48->height = height6;
HXDLIN( 141)												b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 141)												int size8 = (b48->length * 4);
HXDLIN( 141)												b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN( 141)												{
HXLINE( 141)													int _g146 = 0;
HXDLIN( 141)													int _g147 = b48->length;
HXDLIN( 141)													while((_g146 < _g147)){
HXLINE( 141)														_g146 = (_g146 + 1);
HXDLIN( 141)														int i55 = (_g146 - 1);
HXDLIN( 141)														{
HXLINE( 141)															 ::haxe::io::ArrayBufferViewImpl this154 = b48->data;
HXDLIN( 141)															bool undoImage11;
HXDLIN( 141)															if ((i55 >= 0)) {
HXLINE( 141)																undoImage11 = (i55 < (this154->byteLength >> 2));
            															}
            															else {
HXLINE( 141)																undoImage11 = false;
            															}
HXDLIN( 141)															if (undoImage11) {
HXLINE( 141)																 ::haxe::io::Bytes _this8 = this154->bytes;
HXDLIN( 141)																int pos8 = ((i55 << 2) + this154->byteOffset);
HXDLIN( 141)																_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN( 141)																_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN( 141)																_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN( 141)																_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage10 = b48;
            										}
            										break;
            										case (int)3: {
HXLINE( 141)											 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::VecIntImg v17 = vec8;
HXDLIN( 141)											{
HXLINE( 141)												v17->width = width6;
HXDLIN( 141)												v17->height = height6;
HXDLIN( 141)												v17->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 141)												v17->data = ::Array_obj< int >::__new(v17->length);
HXDLIN( 141)												{
HXLINE( 141)													int _g148 = 0;
HXDLIN( 141)													int _g149 = v17->length;
HXDLIN( 141)													while((_g148 < _g149)){
HXLINE( 141)														_g148 = (_g148 + 1);
HXDLIN( 141)														int i56 = (_g148 - 1);
HXDLIN( 141)														v17->data->__unsafe_set(i56,0);
            													}
            												}
            											}
HXDLIN( 141)											undoImage10 = v17;
            										}
            										break;
            										case (int)4: {
HXLINE( 141)											 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 141)											 ::iterMagic::StackIntImg b49 = sInt8;
HXDLIN( 141)											{
HXLINE( 141)												b49->width = width6;
HXDLIN( 141)												b49->height = height6;
HXDLIN( 141)												b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 141)												b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 141)												{
HXLINE( 141)													int len17 = b49->length;
HXDLIN( 141)													 ::haxe::ds::GenericStack_Int d8 = b49->data;
HXDLIN( 141)													if (::hx::IsNull( d8->head )) {
HXLINE( 141)														int _g150 = 0;
HXDLIN( 141)														int _g151 = len17;
HXDLIN( 141)														while((_g150 < _g151)){
HXLINE( 141)															_g150 = (_g150 + 1);
HXDLIN( 141)															int i57 = (_g150 - 1);
HXDLIN( 141)															d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            														}
            													}
            													else {
HXLINE( 141)														int _g152 = 0;
HXDLIN( 141)														int _g153 = len17;
HXDLIN( 141)														while((_g152 < _g153)){
HXLINE( 141)															_g152 = (_g152 + 1);
HXDLIN( 141)															int i58 = (_g152 - 1);
HXDLIN( 141)															{
HXLINE( 141)																 ::haxe::ds::GenericCell_Int l8 = b49->data->head;
HXDLIN( 141)																 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN( 141)																{
HXLINE( 141)																	int _g154 = 0;
HXDLIN( 141)																	int _g155 = i58;
HXDLIN( 141)																	while((_g154 < _g155)){
HXLINE( 141)																		_g154 = (_g154 + 1);
HXDLIN( 141)																		int i59 = (_g154 - 1);
HXLINE( 345)																		prev8 = l8;
HXLINE( 346)																		l8 = l8->next;
            																	}
            																}
HXLINE( 141)																if (::hx::IsNull( prev8 )) {
HXLINE( 141)																	b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 141)																	l8 = null();
            																}
            																else {
HXLINE( 141)																	prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 141)																	l8 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 141)											undoImage10 = b49;
            										}
            										break;
            									}
HXDLIN( 141)									this153->image = undoImage10;
HXDLIN( 141)									this153->width = width6;
HXDLIN( 141)									this153->height = height6;
HXDLIN( 141)									this153->imageType = ( (int)(imageType8) );
HXDLIN( 141)									undoImage9 = this153;
HXDLIN( 141)									{
HXLINE( 141)										int rectLeft3 = xIter33->start;
HXDLIN( 141)										int rectTop3 = yIter33->start;
HXDLIN( 141)										int rectRight3 = xIter33->max;
HXDLIN( 141)										bool forceClear3 = false;
HXDLIN( 141)										{
HXLINE( 141)											int _g156 = rectTop3;
HXDLIN( 141)											int _g157 = yIter33->max;
HXDLIN( 141)											while((_g156 < _g157)){
HXLINE( 141)												_g156 = (_g156 + 1);
HXDLIN( 141)												int dy5 = (_g156 - 1);
HXDLIN( 141)												{
HXLINE( 141)													int _g158 = rectLeft3;
HXDLIN( 141)													int _g159 = rectRight3;
HXDLIN( 141)													while((_g158 < _g159)){
HXLINE( 141)														_g158 = (_g158 + 1);
HXDLIN( 141)														int dx5 = (_g158 - 1);
HXDLIN( 141)														::Dynamic this155 = this118->image;
HXDLIN( 141)														int index24;
HXDLIN( 141)														if (this118->useVirtualPos) {
HXLINE( 141)															index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this118->virtualY) * ( (Float)(this118->width) )) + dx5) - this118->virtualX));
            														}
            														else {
HXLINE( 141)															index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * this118->width) + dx5)) ));
            														}
HXDLIN( 141)														int c27 = ::iterMagic::Iimg_obj::get(this155,index24);
HXDLIN( 141)														int col6;
HXDLIN( 141)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)															col6 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            														}
            														else {
HXLINE( 141)															col6 = c27;
            														}
HXDLIN( 141)														bool _hx_tmp53;
HXDLIN( 141)														if (this118->useMask) {
HXLINE( 141)															_hx_tmp53 = ::hx::IsNotNull( this118->mask );
            														}
            														else {
HXLINE( 141)															_hx_tmp53 = false;
            														}
HXDLIN( 141)														if (_hx_tmp53) {
HXLINE( 141)															 ::pi_xy::ImageStruct this156 = this118->mask;
HXDLIN( 141)															::Dynamic this157 = this156->image;
HXDLIN( 141)															int index25;
HXDLIN( 141)															if (this156->useVirtualPos) {
HXLINE( 141)																index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this156->virtualY) * ( (Float)(this156->width) )) + dx5) - this156->virtualX));
            															}
            															else {
HXLINE( 141)																index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this156->width) + dx5)) ));
            															}
HXDLIN( 141)															int c28 = ::iterMagic::Iimg_obj::get(this157,index25);
HXDLIN( 141)															int v18;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																v18 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																v18 = c28;
            															}
HXDLIN( 141)															int maskPixel3 = v18;
HXDLIN( 141)															int this158 = col6;
HXDLIN( 141)															if ((maskPixel3 == 0)) {
HXLINE( 141)																col6 = this158;
            															}
            															else {
HXLINE( 141)																Float m03;
HXDLIN( 141)																int this159 = ((maskPixel3 >> 24) & 255);
HXDLIN( 141)																if ((this159 == 0)) {
HXLINE( 141)																	m03 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m03 = (( (Float)(this159) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m13;
HXDLIN( 141)																int this160 = ((maskPixel3 >> 16) & 255);
HXDLIN( 141)																if ((this160 == 0)) {
HXLINE( 141)																	m13 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m13 = (( (Float)(this160) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m23;
HXDLIN( 141)																int this161 = ((maskPixel3 >> 8) & 255);
HXDLIN( 141)																if ((this161 == 0)) {
HXLINE( 141)																	m23 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m23 = (( (Float)(this161) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float m33;
HXDLIN( 141)																int this162 = (maskPixel3 & 255);
HXDLIN( 141)																if ((this162 == 0)) {
HXLINE( 141)																	m33 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	m33 = (( (Float)(this162) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this158 >> 24) & 255)) )));
HXDLIN( 141)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this158 >> 16) & 255)) )));
HXDLIN( 141)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this158 >> 8) & 255)) )));
HXDLIN( 141)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this158 & 255)) )));
HXDLIN( 141)																col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 141)														if ((col6 != 0)) {
HXLINE( 141)															int x24 = (dx5 - rectLeft3);
HXDLIN( 141)															int y24 = (dy5 - rectTop3);
HXDLIN( 141)															int c29 = col6;
HXDLIN( 141)															bool _hx_tmp54;
HXDLIN( 141)															if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 141)																_hx_tmp54 = undoImage9->transparent;
            															}
            															else {
HXLINE( 141)																_hx_tmp54 = false;
            															}
HXDLIN( 141)															if (_hx_tmp54) {
HXLINE( 141)																int location9;
HXDLIN( 141)																if (undoImage9->useVirtualPos) {
HXLINE( 141)																	location9 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 141)																	location9 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN( 141)																int this163 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN( 141)																int this164;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	this164 = ((((((this163 >> 24) & 255) << 24) | ((this163 & 255) << 16)) | (((this163 >> 8) & 255) << 8)) | ((this163 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	this164 = this163;
            																}
HXDLIN( 141)																Float a114;
HXDLIN( 141)																int this165 = ((this164 >> 24) & 255);
HXDLIN( 141)																if ((this165 == 0)) {
HXLINE( 141)																	a114 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	a114 = (( (Float)(this165) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float r19;
HXDLIN( 141)																int this166 = ((this164 >> 16) & 255);
HXDLIN( 141)																if ((this166 == 0)) {
HXLINE( 141)																	r19 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	r19 = (( (Float)(this166) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float g19;
HXDLIN( 141)																int this167 = ((this164 >> 8) & 255);
HXDLIN( 141)																if ((this167 == 0)) {
HXLINE( 141)																	g19 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	g19 = (( (Float)(this167) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float b116;
HXDLIN( 141)																int this168 = (this164 & 255);
HXDLIN( 141)																if ((this168 == 0)) {
HXLINE( 141)																	b116 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	b116 = (( (Float)(this168) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float a212;
HXDLIN( 141)																int this169 = ((col6 >> 24) & 255);
HXDLIN( 141)																if ((this169 == 0)) {
HXLINE( 141)																	a212 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	a212 = (( (Float)(this169) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float r29;
HXDLIN( 141)																int this170 = ((col6 >> 16) & 255);
HXDLIN( 141)																if ((this170 == 0)) {
HXLINE( 141)																	r29 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	r29 = (( (Float)(this170) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float g29;
HXDLIN( 141)																int this171 = ((col6 >> 8) & 255);
HXDLIN( 141)																if ((this171 == 0)) {
HXLINE( 141)																	g29 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	g29 = (( (Float)(this171) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float b214;
HXDLIN( 141)																int this172 = (col6 & 255);
HXDLIN( 141)																if ((this172 == 0)) {
HXLINE( 141)																	b214 = ((Float)0.);
            																}
            																else {
HXLINE( 141)																	b214 = (( (Float)(this172) ) / ( (Float)(255) ));
            																}
HXDLIN( 141)																Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 141)																int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a311) + (r29 * a212))));
HXDLIN( 141)																int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN( 141)																int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN( 141)																int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 141)																int blended9 = ((((a44 << 24) | (r20 << 16)) | (g20 << 8)) | b50);
HXDLIN( 141)																{
HXLINE( 141)																	int _hx_tmp55;
HXDLIN( 141)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																		_hx_tmp55 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																	}
            																	else {
HXLINE( 141)																		_hx_tmp55 = blended9;
            																	}
HXDLIN( 141)																	::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp55);
            																}
            															}
            															else {
HXLINE( 141)																::Dynamic this173 = undoImage9->image;
HXDLIN( 141)																int index26;
HXDLIN( 141)																if (undoImage9->useVirtualPos) {
HXLINE( 141)																	index26 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 141)																	index26 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN( 141)																int _hx_tmp56;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp56 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp56 = c29;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this173,index26,_hx_tmp56);
            															}
            														}
            														else {
HXLINE( 141)															if (forceClear3) {
HXLINE( 141)																::Dynamic this174 = undoImage9->image;
HXDLIN( 141)																int x25 = (dx5 - rectLeft3);
HXDLIN( 141)																int y25 = (dy5 - rectTop3);
HXDLIN( 141)																int index27;
HXDLIN( 141)																if (undoImage9->useVirtualPos) {
HXLINE( 141)																	index27 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x25) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 141)																	index27 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage9->width) + x25)) ));
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this174,index27,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								{
HXLINE( 141)									int _g_min6 = xIter33->start;
HXDLIN( 141)									int _g_max6 = xIter33->max;
HXDLIN( 141)									while((_g_min6 < _g_max6)){
HXLINE( 141)										_g_min6 = (_g_min6 + 1);
HXDLIN( 141)										int px3 = (_g_min6 - 1);
HXDLIN( 141)										Float pcx3 = (( (Float)(px3) ) - dx3);
HXDLIN( 141)										{
HXLINE( 141)											int _g_min7 = yIter33->start;
HXDLIN( 141)											int _g_max7 = yIter33->max;
HXDLIN( 141)											while((_g_min7 < _g_max7)){
HXLINE( 141)												_g_min7 = (_g_min7 + 1);
HXDLIN( 141)												int py3 = (_g_min7 - 1);
HXDLIN( 141)												Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN( 141)												Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 141)												Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 141)												Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 141)												Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 141)												Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 141)												bool _hx_tmp57;
HXDLIN( 141)												bool _hx_tmp58;
HXDLIN( 141)												if ((ratioA3 >= 0)) {
HXLINE( 141)													_hx_tmp58 = (ratioB3 >= 0);
            												}
            												else {
HXLINE( 141)													_hx_tmp58 = false;
            												}
HXDLIN( 141)												if (_hx_tmp58) {
HXLINE( 141)													_hx_tmp57 = (ratioC3 >= 0);
            												}
            												else {
HXLINE( 141)													_hx_tmp57 = false;
            												}
HXDLIN( 141)												if (_hx_tmp57) {
HXLINE( 141)													Float u3 = (((au3 * ratioA3) + (bu5 * ratioB3)) + (du1 * ratioC3));
HXDLIN( 141)													Float v19 = (((av3 * ratioA3) + (bv5 * ratioB3)) + (dv1 * ratioC3));
HXDLIN( 141)													int x26 = ::Std_obj::_hx_int(((u3 * win_width1) + win_x1));
HXDLIN( 141)													int y26 = ::Std_obj::_hx_int(((v19 * win_height1) + win_y1));
HXDLIN( 141)													::Dynamic this175 = this115->image;
HXDLIN( 141)													int index28;
HXDLIN( 141)													if (this115->useVirtualPos) {
HXLINE( 141)														index28 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this115->virtualY) * ( (Float)(this115->width) )) + x26) - this115->virtualX));
            													}
            													else {
HXLINE( 141)														index28 = ::Std_obj::_hx_int(( (Float)(((y26 * this115->width) + x26)) ));
            													}
HXDLIN( 141)													int c30 = ::iterMagic::Iimg_obj::get(this175,index28);
HXDLIN( 141)													int col7;
HXDLIN( 141)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)														col7 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            													}
            													else {
HXLINE( 141)														col7 = c30;
            													}
HXDLIN( 141)													{
HXLINE( 141)														int c31 = col7;
HXDLIN( 141)														bool _hx_tmp59;
HXDLIN( 141)														if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 141)															_hx_tmp59 = this118->transparent;
            														}
            														else {
HXLINE( 141)															_hx_tmp59 = false;
            														}
HXDLIN( 141)														if (_hx_tmp59) {
HXLINE( 141)															int location10;
HXDLIN( 141)															if (this118->useVirtualPos) {
HXLINE( 141)																location10 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this118->virtualY) * ( (Float)(this118->width) )) + px3) - this118->virtualX));
            															}
            															else {
HXLINE( 141)																location10 = ::Std_obj::_hx_int(( (Float)(((py3 * this118->width) + px3)) ));
            															}
HXDLIN( 141)															int this176 = ::iterMagic::Iimg_obj::get(this118->image,location10);
HXDLIN( 141)															int this177;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																this177 = ((((((this176 >> 24) & 255) << 24) | ((this176 & 255) << 16)) | (((this176 >> 8) & 255) << 8)) | ((this176 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																this177 = this176;
            															}
HXDLIN( 141)															Float a115;
HXDLIN( 141)															int this178 = ((this177 >> 24) & 255);
HXDLIN( 141)															if ((this178 == 0)) {
HXLINE( 141)																a115 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a115 = (( (Float)(this178) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r110;
HXDLIN( 141)															int this179 = ((this177 >> 16) & 255);
HXDLIN( 141)															if ((this179 == 0)) {
HXLINE( 141)																r110 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r110 = (( (Float)(this179) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g110;
HXDLIN( 141)															int this180 = ((this177 >> 8) & 255);
HXDLIN( 141)															if ((this180 == 0)) {
HXLINE( 141)																g110 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g110 = (( (Float)(this180) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b117;
HXDLIN( 141)															int this181 = (this177 & 255);
HXDLIN( 141)															if ((this181 == 0)) {
HXLINE( 141)																b117 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b117 = (( (Float)(this181) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a213;
HXDLIN( 141)															int this182 = ((col7 >> 24) & 255);
HXDLIN( 141)															if ((this182 == 0)) {
HXLINE( 141)																a213 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																a213 = (( (Float)(this182) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float r210;
HXDLIN( 141)															int this183 = ((col7 >> 16) & 255);
HXDLIN( 141)															if ((this183 == 0)) {
HXLINE( 141)																r210 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																r210 = (( (Float)(this183) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float g210;
HXDLIN( 141)															int this184 = ((col7 >> 8) & 255);
HXDLIN( 141)															if ((this184 == 0)) {
HXLINE( 141)																g210 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																g210 = (( (Float)(this184) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float b215;
HXDLIN( 141)															int this185 = (col7 & 255);
HXDLIN( 141)															if ((this185 == 0)) {
HXLINE( 141)																b215 = ((Float)0.);
            															}
            															else {
HXLINE( 141)																b215 = (( (Float)(this185) ) / ( (Float)(255) ));
            															}
HXDLIN( 141)															Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 141)															int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a312) + (r210 * a213))));
HXDLIN( 141)															int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN( 141)															int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN( 141)															int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 141)															int blended10 = ((((a45 << 24) | (r30 << 16)) | (g30 << 8)) | b51);
HXDLIN( 141)															{
HXLINE( 141)																int _hx_tmp60;
HXDLIN( 141)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																	_hx_tmp60 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            																}
            																else {
HXLINE( 141)																	_hx_tmp60 = blended10;
            																}
HXDLIN( 141)																::iterMagic::Iimg_obj::set(this118->image,location10,_hx_tmp60);
            															}
            														}
            														else {
HXLINE( 141)															::Dynamic this186 = this118->image;
HXDLIN( 141)															int index29;
HXDLIN( 141)															if (this118->useVirtualPos) {
HXLINE( 141)																index29 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this118->virtualY) * ( (Float)(this118->width) )) + px3) - this118->virtualX));
            															}
            															else {
HXLINE( 141)																index29 = ::Std_obj::_hx_int(( (Float)(((py3 * this118->width) + px3)) ));
            															}
HXDLIN( 141)															int _hx_tmp61;
HXDLIN( 141)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)																_hx_tmp61 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            															}
            															else {
HXLINE( 141)																_hx_tmp61 = c31;
            															}
HXDLIN( 141)															::iterMagic::Iimg_obj::set(this186,index29,_hx_tmp61);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN( 141)								 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN( 141)								int v_undoY3;
HXDLIN( 141)								int v_undoX3;
HXDLIN( 141)								Float v_ty3;
HXDLIN( 141)								Float v_tx3;
HXDLIN( 141)								Float v_t03;
HXDLIN( 141)								Float v_sy3;
HXDLIN( 141)								Float v_sx3;
HXDLIN( 141)								Float v_s03;
HXDLIN( 141)								Float v_A3;
HXDLIN( 141)								Float ax5 = bx3;
HXDLIN( 141)								Float ay5 = by3;
HXDLIN( 141)								 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN( 141)								Float bx5 = cx3;
HXDLIN( 141)								Float by5 = cy3;
HXDLIN( 141)								Float cx5 = dx3;
HXDLIN( 141)								Float cy5 = dy3;
HXDLIN( 141)								bool adjustWinding3 = (((((ax5 * by5) - (bx5 * ay5)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay5) - (ax5 * cy5))) > 0);
HXDLIN( 141)								if (!(adjustWinding3)) {
HXLINE( 141)									Float bx_3 = bx5;
HXDLIN( 141)									Float by_3 = by5;
HXLINE(  24)									bx5 = cx5;
HXLINE(  25)									by5 = cy5;
HXLINE(  26)									cx5 = bx_3;
HXLINE(  27)									cy5 = by_3;
            								}
HXLINE( 141)								Float v_ax3 = ax5;
HXDLIN( 141)								Float v_ay3 = ay5;
HXDLIN( 141)								Float v_bx3 = bx5;
HXDLIN( 141)								Float v_by3 = by5;
HXDLIN( 141)								Float v_cx3 = cx5;
HXDLIN( 141)								Float v_cy3 = cy5;
HXDLIN( 141)								bool v_preCalculated3 = true;
HXDLIN( 141)								{
HXLINE(  93)									v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN(  93)									v_sx3 = (v_cy3 - v_ay3);
HXDLIN(  93)									v_sy3 = (v_ax3 - v_cx3);
HXDLIN(  93)									v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN(  93)									v_tx3 = (v_ay3 - v_by3);
HXDLIN(  93)									v_ty3 = (v_bx3 - v_ax3);
HXDLIN(  93)									v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXLINE( 141)									Float a46 = v_ax3;
HXDLIN( 141)									Float b52 = v_bx3;
HXDLIN( 141)									Float c32 = v_cx3;
HXDLIN( 141)									if ((a46 > b52)) {
HXLINE( 141)										if ((a46 > c32)) {
HXLINE( 141)											int min32;
HXDLIN( 141)											if ((b52 > c32)) {
HXLINE( 141)												min32 = ::Math_obj::floor(c32);
            											}
            											else {
HXLINE( 141)												min32 = ::Math_obj::floor(b52);
            											}
HXDLIN( 141)											int ii_min66 = min32;
HXDLIN( 141)											int ii_max66 = ::Math_obj::ceil(a46);
HXDLIN( 141)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            										}
            										else {
HXLINE( 141)											int ii_min67 = ::Math_obj::floor(b52);
HXDLIN( 141)											int ii_max67 = ::Math_obj::ceil(c32);
HXDLIN( 141)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            										}
            									}
            									else {
HXLINE( 141)										if ((b52 > c32)) {
HXLINE( 141)											int min33;
HXDLIN( 141)											if ((a46 > c32)) {
HXLINE( 141)												min33 = ::Math_obj::floor(c32);
            											}
            											else {
HXLINE( 141)												min33 = ::Math_obj::ceil(a46);
            											}
HXDLIN( 141)											int ii_min68 = min33;
HXDLIN( 141)											int ii_max68 = ::Math_obj::ceil(b52);
HXDLIN( 141)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            										}
            										else {
HXLINE( 141)											int ii_min69 = ::Math_obj::floor(a46);
HXDLIN( 141)											int ii_max69 = ::Math_obj::ceil(c32);
HXDLIN( 141)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            										}
            									}
HXDLIN( 141)									Float a47 = v_ay3;
HXDLIN( 141)									Float b53 = v_by3;
HXDLIN( 141)									Float c33 = v_cy3;
HXDLIN( 141)									if ((a47 > b53)) {
HXLINE( 141)										if ((a47 > c33)) {
HXLINE( 141)											int min34;
HXDLIN( 141)											if ((b53 > c33)) {
HXLINE( 141)												min34 = ::Math_obj::floor(c33);
            											}
            											else {
HXLINE( 141)												min34 = ::Math_obj::floor(b53);
            											}
HXDLIN( 141)											int ii_min70 = min34;
HXDLIN( 141)											int ii_max70 = ::Math_obj::ceil(a47);
HXDLIN( 141)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            										}
            										else {
HXLINE( 141)											int ii_min71 = ::Math_obj::floor(b53);
HXDLIN( 141)											int ii_max71 = ::Math_obj::ceil(c33);
HXDLIN( 141)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            										}
            									}
            									else {
HXLINE( 141)										if ((b53 > c33)) {
HXLINE( 141)											int min35;
HXDLIN( 141)											if ((a47 > c33)) {
HXLINE( 141)												min35 = ::Math_obj::floor(c33);
            											}
            											else {
HXLINE( 141)												min35 = ::Math_obj::ceil(a47);
            											}
HXDLIN( 141)											int ii_min72 = min35;
HXDLIN( 141)											int ii_max72 = ::Math_obj::ceil(b53);
HXDLIN( 141)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            										}
            										else {
HXLINE( 141)											int ii_min73 = ::Math_obj::floor(a47);
HXDLIN( 141)											int ii_max73 = ::Math_obj::ceil(c33);
HXDLIN( 141)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            										}
            									}
            								}
HXDLIN( 141)								if (hasUndo3) {
HXLINE(  93)									v_undoImage3 = undoImage9;
HXDLIN(  93)									v_undoX3 = xIter33->start;
HXDLIN(  93)									v_undoY3 = yIter33->start;
            								}
            							}
            						}
HXLINE( 141)						bool _hx_tmp62;
HXDLIN( 141)						if (::hx::IsNotNull( nextImage4->mask )) {
HXLINE( 141)							_hx_tmp62 = includeMask;
            						}
            						else {
HXLINE( 141)							_hx_tmp62 = false;
            						}
HXDLIN( 141)						if (_hx_tmp62) {
HXLINE( 141)							 ::pi_xy::ImageStruct v20 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this115->mask,theta,centreX2,centreY2,this115->mask->transparent,includeMask);
HXDLIN( 141)							nextImage4->useMask = true;
HXDLIN( 141)							nextImage4->mask = v20;
            						}
HXDLIN( 141)						 ::pi_xy::ImageStruct v21 = nextImage4;
HXDLIN( 141)						nextImage3->useMask = true;
HXDLIN( 141)						nextImage3->mask = v21;
            					}
HXDLIN( 141)					return nextImage3;
            				}
            			}
            		}
HXLINE( 134)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(SpinImage_Fields__obj,rotatingClockwiseDegrees,return )

 ::pi_xy::ImageStruct SpinImage_Fields__obj::rotatingClockwiseRadians( ::pi_xy::ImageStruct thisImage,Float theta,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_148_rotatingClockwiseRadians)
HXLINE( 149)		while((theta >= (( (Float)(2) ) * ::Math_obj::PI))){
HXLINE( 150)			theta = (theta - (( (Float)(2) ) * ::Math_obj::PI));
            		}
HXLINE( 152)		while((theta <= (( (Float)(-2) ) * ::Math_obj::PI))){
HXLINE( 153)			theta = (theta + (( (Float)(2) ) * ::Math_obj::PI));
            		}
HXLINE( 155)		bool _hx_tmp;
HXDLIN( 155)		if ((theta != (::Math_obj::PI / ( (Float)(2) )))) {
HXLINE( 155)			_hx_tmp = (theta == ((( (Float)(-3) ) * ::Math_obj::PI) / ( (Float)(2) )));
            		}
            		else {
HXLINE( 155)			_hx_tmp = true;
            		}
HXDLIN( 155)		if (_hx_tmp) {
HXLINE( 156)			Float w = ( (Float)(thisImage->width) );
HXDLIN( 156)			Float h = ( (Float)(thisImage->height) );
HXDLIN( 156)			 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN( 156)			Float r_x = ( (Float)(0) );
HXDLIN( 156)			Float r_y = ( (Float)(0) );
HXDLIN( 156)			Float r_w = w;
HXDLIN( 156)			Float r_h = h;
HXDLIN( 156)			int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN( 156)			int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN( 156)			int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN( 156)			int ii_max = xmax;
HXDLIN( 156)			int xRange__start = ii_min;
HXDLIN( 156)			int xRange__max = ii_max;
HXDLIN( 156)			int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN( 156)			int ii_max1 = ymax;
HXDLIN( 156)			int yRange__start = ii_min1;
HXDLIN( 156)			int yRange__max = ii_max1;
HXDLIN( 156)			int range_x = xRange__start;
HXDLIN( 156)			int range_y = (yRange__start - 1);
HXDLIN( 156)			int range_xReset = range_x;
HXDLIN( 156)			int range_yReset = range_y;
HXDLIN( 156)			int range_xMax = (xRange__max - 2);
HXDLIN( 156)			int range_yMax = (yRange__max - 2);
HXDLIN( 156)			int _this_min = 0;
HXDLIN( 156)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 156)			int width = ::Std_obj::_hx_int(w);
HXDLIN( 156)			int height = ::Std_obj::_hx_int(h);
HXDLIN( 156)			 ::Dynamic imageType = null();
HXDLIN( 156)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 156)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 156)			::Dynamic _hx_tmp1;
HXDLIN( 156)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 156)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 156)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 156)					{
HXLINE( 156)						b->width = width;
HXDLIN( 156)						b->height = height;
HXDLIN( 156)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 156)						{
HXLINE( 156)							int len = b->length;
HXDLIN( 156)							int w1 = 0;
HXDLIN( 156)							{
HXLINE( 156)								int _g = 0;
HXDLIN( 156)								int _g1 = b->height;
HXDLIN( 156)								while((_g < _g1)){
HXLINE( 156)									_g = (_g + 1);
HXDLIN( 156)									int y = (_g - 1);
HXDLIN( 156)									{
HXLINE( 156)										int _g2 = 0;
HXDLIN( 156)										int _g3 = b->width;
HXDLIN( 156)										while((_g2 < _g3)){
HXLINE( 156)											_g2 = (_g2 + 1);
HXDLIN( 156)											int x = (_g2 - 1);
HXDLIN( 156)											{
HXLINE( 156)												w1 = (w1 + 1);
HXDLIN( 156)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 156)											{
HXLINE( 156)												w1 = (w1 + 1);
HXDLIN( 156)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 156)											{
HXLINE( 156)												w1 = (w1 + 1);
HXDLIN( 156)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 156)											{
HXLINE( 156)												w1 = (w1 + 1);
HXDLIN( 156)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 156)					_hx_tmp1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 156)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 156)					{
HXLINE( 156)						a->width = width;
HXDLIN( 156)						a->height = height;
HXDLIN( 156)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 156)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)						{
HXLINE( 156)							int _g4 = 0;
HXDLIN( 156)							int _g5 = a->length;
HXDLIN( 156)							while((_g4 < _g5)){
HXLINE( 156)								_g4 = (_g4 + 1);
HXDLIN( 156)								int i = (_g4 - 1);
HXDLIN( 156)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 156)					_hx_tmp1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 156)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 156)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 156)					{
HXLINE( 156)						b1->width = width;
HXDLIN( 156)						b1->height = height;
HXDLIN( 156)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)						int size = (b1->length * 4);
HXDLIN( 156)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 156)						{
HXLINE( 156)							int _g6 = 0;
HXDLIN( 156)							int _g7 = b1->length;
HXDLIN( 156)							while((_g6 < _g7)){
HXLINE( 156)								_g6 = (_g6 + 1);
HXDLIN( 156)								int i1 = (_g6 - 1);
HXDLIN( 156)								{
HXLINE( 156)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 156)									bool _hx_tmp2;
HXDLIN( 156)									if ((i1 >= 0)) {
HXLINE( 156)										_hx_tmp2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 156)										_hx_tmp2 = false;
            									}
HXDLIN( 156)									if (_hx_tmp2) {
HXLINE( 156)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 156)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 156)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 156)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 156)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 156)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 156)					_hx_tmp1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 156)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 156)					{
HXLINE( 156)						v->width = width;
HXDLIN( 156)						v->height = height;
HXDLIN( 156)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 156)						{
HXLINE( 156)							int _g8 = 0;
HXDLIN( 156)							int _g9 = v->length;
HXDLIN( 156)							while((_g8 < _g9)){
HXLINE( 156)								_g8 = (_g8 + 1);
HXDLIN( 156)								int i2 = (_g8 - 1);
HXDLIN( 156)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 156)					_hx_tmp1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 156)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 156)					{
HXLINE( 156)						b2->width = width;
HXDLIN( 156)						b2->height = height;
HXDLIN( 156)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 156)						{
HXLINE( 156)							int len1 = b2->length;
HXDLIN( 156)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 156)							if (::hx::IsNull( d->head )) {
HXLINE( 156)								int _g10 = 0;
HXDLIN( 156)								int _g11 = len1;
HXDLIN( 156)								while((_g10 < _g11)){
HXLINE( 156)									_g10 = (_g10 + 1);
HXDLIN( 156)									int i3 = (_g10 - 1);
HXDLIN( 156)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 156)								int _g12 = 0;
HXDLIN( 156)								int _g13 = len1;
HXDLIN( 156)								while((_g12 < _g13)){
HXLINE( 156)									_g12 = (_g12 + 1);
HXDLIN( 156)									int i4 = (_g12 - 1);
HXDLIN( 156)									{
HXLINE( 156)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 156)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 156)										{
HXLINE( 156)											int _g14 = 0;
HXDLIN( 156)											int _g15 = i4;
HXDLIN( 156)											while((_g14 < _g15)){
HXLINE( 156)												_g14 = (_g14 + 1);
HXDLIN( 156)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 156)										if (::hx::IsNull( prev )) {
HXLINE( 156)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 156)											l = null();
            										}
            										else {
HXLINE( 156)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 156)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 156)					_hx_tmp1 = b2;
            				}
            				break;
            			}
HXDLIN( 156)			this1->image = _hx_tmp1;
HXDLIN( 156)			this1->width = width;
HXDLIN( 156)			this1->height = height;
HXDLIN( 156)			this1->imageType = ( (int)(imageType) );
HXDLIN( 156)			 ::pi_xy::ImageStruct nextImage = this1;
HXDLIN( 156)			nextImage->transparent = transparent;
HXDLIN( 156)			while((_this_min < _this_max)){
HXLINE( 156)				_this_min = (_this_min + 1);
HXDLIN( 156)				int i6 = (_this_min - 1);
HXDLIN( 156)				if ((range_y > range_yMax)) {
HXLINE(  19)					range_y = range_yReset;
HXLINE( 156)					range_x = (range_x + 1);
            				}
HXDLIN( 156)				range_y = (range_y + 1);
HXDLIN( 156)				int i7 = i6;
HXDLIN( 156)				{
HXLINE( 156)					int x1 = (range_yMax - range_y);
HXDLIN( 156)					int y1 = range_x;
HXDLIN( 156)					int x2 = range_x;
HXDLIN( 156)					int y2 = range_y;
HXDLIN( 156)					::Dynamic this3 = thisImage1->image;
HXDLIN( 156)					int index;
HXDLIN( 156)					if (thisImage1->useVirtualPos) {
HXLINE( 156)						index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x2) - thisImage1->virtualX));
            					}
            					else {
HXLINE( 156)						index = ::Std_obj::_hx_int(( (Float)(((y2 * thisImage1->width) + x2)) ));
            					}
HXDLIN( 156)					int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 156)					int color;
HXDLIN( 156)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 156)						color = c;
            					}
HXDLIN( 156)					int c1 = color;
HXDLIN( 156)					bool _hx_tmp3;
HXDLIN( 156)					if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 156)						_hx_tmp3 = nextImage->transparent;
            					}
            					else {
HXLINE( 156)						_hx_tmp3 = false;
            					}
HXDLIN( 156)					if (_hx_tmp3) {
HXLINE( 156)						int location;
HXDLIN( 156)						if (nextImage->useVirtualPos) {
HXLINE( 156)							location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXLINE( 156)							location = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN( 156)						int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN( 156)						int this5;
HXDLIN( 156)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE( 156)							this5 = this4;
            						}
HXDLIN( 156)						Float a1;
HXDLIN( 156)						int this6 = ((this5 >> 24) & 255);
HXDLIN( 156)						if ((this6 == 0)) {
HXLINE( 156)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float r1;
HXDLIN( 156)						int this7 = ((this5 >> 16) & 255);
HXDLIN( 156)						if ((this7 == 0)) {
HXLINE( 156)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float g1;
HXDLIN( 156)						int this8 = ((this5 >> 8) & 255);
HXDLIN( 156)						if ((this8 == 0)) {
HXLINE( 156)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float b11;
HXDLIN( 156)						int this9 = (this5 & 255);
HXDLIN( 156)						if ((this9 == 0)) {
HXLINE( 156)							b11 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float a2;
HXDLIN( 156)						int this10 = ((color >> 24) & 255);
HXDLIN( 156)						if ((this10 == 0)) {
HXLINE( 156)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float r2;
HXDLIN( 156)						int this11 = ((color >> 16) & 255);
HXDLIN( 156)						if ((this11 == 0)) {
HXLINE( 156)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float g2;
HXDLIN( 156)						int this12 = ((color >> 8) & 255);
HXDLIN( 156)						if ((this12 == 0)) {
HXLINE( 156)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float b21;
HXDLIN( 156)						int this13 = (color & 255);
HXDLIN( 156)						if ((this13 == 0)) {
HXLINE( 156)							b21 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 156)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 156)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 156)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 156)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 156)						int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 156)						{
HXLINE( 156)							int _hx_tmp4;
HXDLIN( 156)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)								_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 156)								_hx_tmp4 = blended;
            							}
HXDLIN( 156)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp4);
            						}
            					}
            					else {
HXLINE( 156)						::Dynamic this14 = nextImage->image;
HXDLIN( 156)						int index1;
HXDLIN( 156)						if (nextImage->useVirtualPos) {
HXLINE( 156)							index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXLINE( 156)							index1 = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN( 156)						int _hx_tmp5;
HXDLIN( 156)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)							_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE( 156)							_hx_tmp5 = c1;
            						}
HXDLIN( 156)						::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp5);
            					}
            				}
            			}
HXDLIN( 156)			bool _hx_tmp6;
HXDLIN( 156)			if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE( 156)				_hx_tmp6 = includeMask;
            			}
            			else {
HXLINE( 156)				_hx_tmp6 = false;
            			}
HXDLIN( 156)			if (_hx_tmp6) {
HXLINE( 156)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(thisImage1->mask,( (Float)(0) ),( (Float)(0) ),w,h,thisImage1->mask->transparent,includeMask);
HXDLIN( 156)				nextImage->useMask = true;
HXDLIN( 156)				nextImage->mask = v1;
            			}
HXDLIN( 156)			return nextImage;
            		}
            		else {
HXLINE( 157)			bool _hx_tmp7;
HXDLIN( 157)			if ((theta != (-(::Math_obj::PI) / ( (Float)(2) )))) {
HXLINE( 157)				_hx_tmp7 = (theta == ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) )));
            			}
            			else {
HXLINE( 157)				_hx_tmp7 = true;
            			}
HXDLIN( 157)			if (_hx_tmp7) {
HXLINE( 158)				Float w2 = ( (Float)(thisImage->width) );
HXDLIN( 158)				Float h1 = ( (Float)(thisImage->height) );
HXDLIN( 158)				 ::pi_xy::ImageStruct thisImage2 = thisImage;
HXDLIN( 158)				Float r_x1 = ( (Float)(0) );
HXDLIN( 158)				Float r_y1 = ( (Float)(0) );
HXDLIN( 158)				Float r_w1 = w2;
HXDLIN( 158)				Float r_h1 = h1;
HXDLIN( 158)				int xmax1 = ::Std_obj::_hx_int(((r_x1 + r_w1) + 1));
HXDLIN( 158)				int ymax1 = ::Std_obj::_hx_int(((r_y1 + r_h1) + 1));
HXDLIN( 158)				int ii_min2 = ::Std_obj::_hx_int(r_x1);
HXDLIN( 158)				int ii_max2 = xmax1;
HXDLIN( 158)				int xRange__start1 = ii_min2;
HXDLIN( 158)				int xRange__max1 = ii_max2;
HXDLIN( 158)				int ii_min3 = ::Std_obj::_hx_int(r_y1);
HXDLIN( 158)				int ii_max3 = ymax1;
HXDLIN( 158)				int yRange__start1 = ii_min3;
HXDLIN( 158)				int yRange__max1 = ii_max3;
HXDLIN( 158)				int range_x1 = xRange__start1;
HXDLIN( 158)				int range_y1 = (yRange__start1 - 1);
HXDLIN( 158)				int range_xReset1 = range_x1;
HXDLIN( 158)				int range_yReset1 = range_y1;
HXDLIN( 158)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 158)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 158)				int _this_min1 = 0;
HXDLIN( 158)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 158)				int width1 = ::Std_obj::_hx_int(w2);
HXDLIN( 158)				int height1 = ::Std_obj::_hx_int(h1);
HXDLIN( 158)				 ::Dynamic imageType1 = null();
HXDLIN( 158)				 ::pi_xy::ImageStruct this15 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 158)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 158)				::Dynamic _hx_tmp8;
HXDLIN( 158)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 158)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 158)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN( 158)						{
HXLINE( 158)							b4->width = width1;
HXDLIN( 158)							b4->height = height1;
HXDLIN( 158)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 158)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN( 158)							{
HXLINE( 158)								int len2 = b4->length;
HXDLIN( 158)								int w3 = 0;
HXDLIN( 158)								{
HXLINE( 158)									int _g16 = 0;
HXDLIN( 158)									int _g17 = b4->height;
HXDLIN( 158)									while((_g16 < _g17)){
HXLINE( 158)										_g16 = (_g16 + 1);
HXDLIN( 158)										int y3 = (_g16 - 1);
HXDLIN( 158)										{
HXLINE( 158)											int _g18 = 0;
HXDLIN( 158)											int _g19 = b4->width;
HXDLIN( 158)											while((_g18 < _g19)){
HXLINE( 158)												_g18 = (_g18 + 1);
HXDLIN( 158)												int x3 = (_g18 - 1);
HXDLIN( 158)												{
HXLINE( 158)													w3 = (w3 + 1);
HXDLIN( 158)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 158)												{
HXLINE( 158)													w3 = (w3 + 1);
HXDLIN( 158)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 158)												{
HXLINE( 158)													w3 = (w3 + 1);
HXDLIN( 158)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 158)												{
HXLINE( 158)													w3 = (w3 + 1);
HXDLIN( 158)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 158)						_hx_tmp8 = b4;
            					}
            					break;
            					case (int)1: {
HXLINE( 158)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 158)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN( 158)						{
HXLINE( 158)							a5->width = width1;
HXDLIN( 158)							a5->height = height1;
HXDLIN( 158)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN( 158)							a5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 158)							{
HXLINE( 158)								int _g20 = 0;
HXDLIN( 158)								int _g21 = a5->length;
HXDLIN( 158)								while((_g20 < _g21)){
HXLINE( 158)									_g20 = (_g20 + 1);
HXDLIN( 158)									int i8 = (_g20 - 1);
HXDLIN( 158)									a5->data[i8] = 0;
            								}
            							}
            						}
HXDLIN( 158)						_hx_tmp8 = a5;
            					}
            					break;
            					case (int)2: {
HXLINE( 158)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 158)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN( 158)						{
HXLINE( 158)							b5->width = width1;
HXDLIN( 158)							b5->height = height1;
HXDLIN( 158)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 158)							int size1 = (b5->length * 4);
HXDLIN( 158)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 158)							{
HXLINE( 158)								int _g22 = 0;
HXDLIN( 158)								int _g23 = b5->length;
HXDLIN( 158)								while((_g22 < _g23)){
HXLINE( 158)									_g22 = (_g22 + 1);
HXDLIN( 158)									int i9 = (_g22 - 1);
HXDLIN( 158)									{
HXLINE( 158)										 ::haxe::io::ArrayBufferViewImpl this16 = b5->data;
HXDLIN( 158)										bool _hx_tmp9;
HXDLIN( 158)										if ((i9 >= 0)) {
HXLINE( 158)											_hx_tmp9 = (i9 < (this16->byteLength >> 2));
            										}
            										else {
HXLINE( 158)											_hx_tmp9 = false;
            										}
HXDLIN( 158)										if (_hx_tmp9) {
HXLINE( 158)											 ::haxe::io::Bytes _this1 = this16->bytes;
HXDLIN( 158)											int pos1 = ((i9 << 2) + this16->byteOffset);
HXDLIN( 158)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 158)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 158)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 158)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 158)						_hx_tmp8 = b5;
            					}
            					break;
            					case (int)3: {
HXLINE( 158)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 158)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 158)						{
HXLINE( 158)							v2->width = width1;
HXDLIN( 158)							v2->height = height1;
HXDLIN( 158)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 158)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 158)							{
HXLINE( 158)								int _g24 = 0;
HXDLIN( 158)								int _g25 = v2->length;
HXDLIN( 158)								while((_g24 < _g25)){
HXLINE( 158)									_g24 = (_g24 + 1);
HXDLIN( 158)									int i10 = (_g24 - 1);
HXDLIN( 158)									v2->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN( 158)						_hx_tmp8 = v2;
            					}
            					break;
            					case (int)4: {
HXLINE( 158)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 158)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN( 158)						{
HXLINE( 158)							b6->width = width1;
HXDLIN( 158)							b6->height = height1;
HXDLIN( 158)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 158)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 158)							{
HXLINE( 158)								int len3 = b6->length;
HXDLIN( 158)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN( 158)								if (::hx::IsNull( d1->head )) {
HXLINE( 158)									int _g26 = 0;
HXDLIN( 158)									int _g27 = len3;
HXDLIN( 158)									while((_g26 < _g27)){
HXLINE( 158)										_g26 = (_g26 + 1);
HXDLIN( 158)										int i11 = (_g26 - 1);
HXDLIN( 158)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 158)									int _g28 = 0;
HXDLIN( 158)									int _g29 = len3;
HXDLIN( 158)									while((_g28 < _g29)){
HXLINE( 158)										_g28 = (_g28 + 1);
HXDLIN( 158)										int i12 = (_g28 - 1);
HXDLIN( 158)										{
HXLINE( 158)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN( 158)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 158)											{
HXLINE( 158)												int _g30 = 0;
HXDLIN( 158)												int _g31 = i12;
HXDLIN( 158)												while((_g30 < _g31)){
HXLINE( 158)													_g30 = (_g30 + 1);
HXDLIN( 158)													int i13 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 158)											if (::hx::IsNull( prev1 )) {
HXLINE( 158)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 158)												l1 = null();
            											}
            											else {
HXLINE( 158)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 158)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 158)						_hx_tmp8 = b6;
            					}
            					break;
            				}
HXDLIN( 158)				this15->image = _hx_tmp8;
HXDLIN( 158)				this15->width = width1;
HXDLIN( 158)				this15->height = height1;
HXDLIN( 158)				this15->imageType = ( (int)(imageType1) );
HXDLIN( 158)				 ::pi_xy::ImageStruct nextImage1 = this15;
HXDLIN( 158)				nextImage1->transparent = transparent;
HXDLIN( 158)				while((_this_min1 < _this_max1)){
HXLINE( 158)					_this_min1 = (_this_min1 + 1);
HXDLIN( 158)					int i14 = (_this_min1 - 1);
HXDLIN( 158)					if ((range_y1 > range_yMax1)) {
HXLINE(  56)						range_y1 = range_yReset1;
HXLINE( 158)						range_x1 = (range_x1 + 1);
            					}
HXDLIN( 158)					range_y1 = (range_y1 + 1);
HXDLIN( 158)					int i15 = i14;
HXDLIN( 158)					{
HXLINE( 158)						int x4 = range_y1;
HXDLIN( 158)						int y4 = (range_xMax1 - range_x1);
HXDLIN( 158)						int x5 = range_y1;
HXDLIN( 158)						int y5 = range_x1;
HXDLIN( 158)						::Dynamic this17 = thisImage2->image;
HXDLIN( 158)						int index2;
HXDLIN( 158)						if (thisImage2->useVirtualPos) {
HXLINE( 158)							index2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - thisImage2->virtualY) * ( (Float)(thisImage2->width) )) + x5) - thisImage2->virtualX));
            						}
            						else {
HXLINE( 158)							index2 = ::Std_obj::_hx_int(( (Float)(((y5 * thisImage2->width) + x5)) ));
            						}
HXDLIN( 158)						int c2 = ::iterMagic::Iimg_obj::get(this17,index2);
HXDLIN( 158)						int color1;
HXDLIN( 158)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)							color1 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            						}
            						else {
HXLINE( 158)							color1 = c2;
            						}
HXDLIN( 158)						int c3 = color1;
HXDLIN( 158)						bool _hx_tmp10;
HXDLIN( 158)						if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 158)							_hx_tmp10 = nextImage1->transparent;
            						}
            						else {
HXLINE( 158)							_hx_tmp10 = false;
            						}
HXDLIN( 158)						if (_hx_tmp10) {
HXLINE( 158)							int location1;
HXDLIN( 158)							if (nextImage1->useVirtualPos) {
HXLINE( 158)								location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXLINE( 158)								location1 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN( 158)							int this18 = ::iterMagic::Iimg_obj::get(nextImage1->image,location1);
HXDLIN( 158)							int this19;
HXDLIN( 158)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)								this19 = ((((((this18 >> 24) & 255) << 24) | ((this18 & 255) << 16)) | (((this18 >> 8) & 255) << 8)) | ((this18 >> 16) & 255));
            							}
            							else {
HXLINE( 158)								this19 = this18;
            							}
HXDLIN( 158)							Float a11;
HXDLIN( 158)							int this20 = ((this19 >> 24) & 255);
HXDLIN( 158)							if ((this20 == 0)) {
HXLINE( 158)								a11 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								a11 = (( (Float)(this20) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float r11;
HXDLIN( 158)							int this21 = ((this19 >> 16) & 255);
HXDLIN( 158)							if ((this21 == 0)) {
HXLINE( 158)								r11 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								r11 = (( (Float)(this21) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float g11;
HXDLIN( 158)							int this22 = ((this19 >> 8) & 255);
HXDLIN( 158)							if ((this22 == 0)) {
HXLINE( 158)								g11 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								g11 = (( (Float)(this22) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float b12;
HXDLIN( 158)							int this23 = (this19 & 255);
HXDLIN( 158)							if ((this23 == 0)) {
HXLINE( 158)								b12 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								b12 = (( (Float)(this23) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float a21;
HXDLIN( 158)							int this24 = ((color1 >> 24) & 255);
HXDLIN( 158)							if ((this24 == 0)) {
HXLINE( 158)								a21 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								a21 = (( (Float)(this24) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float r21;
HXDLIN( 158)							int this25 = ((color1 >> 16) & 255);
HXDLIN( 158)							if ((this25 == 0)) {
HXLINE( 158)								r21 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								r21 = (( (Float)(this25) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float g21;
HXDLIN( 158)							int this26 = ((color1 >> 8) & 255);
HXDLIN( 158)							if ((this26 == 0)) {
HXLINE( 158)								g21 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								g21 = (( (Float)(this26) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float b22;
HXDLIN( 158)							int this27 = (color1 & 255);
HXDLIN( 158)							if ((this27 == 0)) {
HXLINE( 158)								b22 = ((Float)0.);
            							}
            							else {
HXLINE( 158)								b22 = (( (Float)(this27) ) / ( (Float)(255) ));
            							}
HXDLIN( 158)							Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 158)							int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 158)							int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 158)							int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 158)							int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 158)							int blended1 = ((((a6 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 158)							{
HXLINE( 158)								int _hx_tmp11;
HXDLIN( 158)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)									_hx_tmp11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            								}
            								else {
HXLINE( 158)									_hx_tmp11 = blended1;
            								}
HXDLIN( 158)								::iterMagic::Iimg_obj::set(nextImage1->image,location1,_hx_tmp11);
            							}
            						}
            						else {
HXLINE( 158)							::Dynamic this28 = nextImage1->image;
HXDLIN( 158)							int index3;
HXDLIN( 158)							if (nextImage1->useVirtualPos) {
HXLINE( 158)								index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXLINE( 158)								index3 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN( 158)							int _hx_tmp12;
HXDLIN( 158)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)								_hx_tmp12 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 158)								_hx_tmp12 = c3;
            							}
HXDLIN( 158)							::iterMagic::Iimg_obj::set(this28,index3,_hx_tmp12);
            						}
            					}
            				}
HXDLIN( 158)				bool _hx_tmp13;
HXDLIN( 158)				if (::hx::IsNotNull( thisImage2->mask )) {
HXLINE( 158)					_hx_tmp13 = includeMask;
            				}
            				else {
HXLINE( 158)					_hx_tmp13 = false;
            				}
HXDLIN( 158)				if (_hx_tmp13) {
HXLINE( 158)					 ::pi_xy::ImageStruct v3 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(thisImage2->mask,( (Float)(0) ),( (Float)(0) ),w2,h1,thisImage2->mask->transparent,includeMask);
HXDLIN( 158)					nextImage1->useMask = true;
HXDLIN( 158)					nextImage1->mask = v3;
            				}
HXDLIN( 158)				return nextImage1;
            			}
            			else {
HXLINE( 159)				bool _hx_tmp14;
HXDLIN( 159)				if ((theta != ::Math_obj::PI)) {
HXLINE( 159)					_hx_tmp14 = (theta == -(::Math_obj::PI));
            				}
            				else {
HXLINE( 159)					_hx_tmp14 = true;
            				}
HXDLIN( 159)				if (_hx_tmp14) {
HXLINE( 160)					Float w4 = ( (Float)(thisImage->width) );
HXDLIN( 160)					Float h2 = ( (Float)(thisImage->height) );
HXDLIN( 160)					 ::pi_xy::ImageStruct thisImage3 = thisImage;
HXDLIN( 160)					Float r_x2 = ( (Float)(0) );
HXDLIN( 160)					Float r_y2 = ( (Float)(0) );
HXDLIN( 160)					Float r_w2 = w4;
HXDLIN( 160)					Float r_h2 = h2;
HXDLIN( 160)					int xmax2 = ::Std_obj::_hx_int(((r_x2 + r_w2) + 1));
HXDLIN( 160)					int ymax2 = ::Std_obj::_hx_int(((r_y2 + r_h2) + 1));
HXDLIN( 160)					int ii_min4 = ::Std_obj::_hx_int(r_x2);
HXDLIN( 160)					int ii_max4 = xmax2;
HXDLIN( 160)					int xRange__start2 = ii_min4;
HXDLIN( 160)					int xRange__max2 = ii_max4;
HXDLIN( 160)					int ii_min5 = ::Std_obj::_hx_int(r_y2);
HXDLIN( 160)					int ii_max5 = ymax2;
HXDLIN( 160)					int yRange__start2 = ii_min5;
HXDLIN( 160)					int yRange__max2 = ii_max5;
HXDLIN( 160)					int range_x2 = xRange__start2;
HXDLIN( 160)					int range_y2 = (yRange__start2 - 1);
HXDLIN( 160)					int range_xReset2 = range_x2;
HXDLIN( 160)					int range_yReset2 = range_y2;
HXDLIN( 160)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 160)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 160)					int _this_min2 = 0;
HXDLIN( 160)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 160)					int width2 = ::Std_obj::_hx_int(w4);
HXDLIN( 160)					int height2 = ::Std_obj::_hx_int(h2);
HXDLIN( 160)					 ::Dynamic imageType2 = null();
HXDLIN( 160)					 ::pi_xy::ImageStruct this29 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 160)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 160)					::Dynamic _hx_tmp15;
HXDLIN( 160)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE( 160)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 160)							 ::iterMagic::BytesImg b8 = byt2;
HXDLIN( 160)							{
HXLINE( 160)								b8->width = width2;
HXDLIN( 160)								b8->height = height2;
HXDLIN( 160)								b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 160)								b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN( 160)								{
HXLINE( 160)									int len4 = b8->length;
HXDLIN( 160)									int w5 = 0;
HXDLIN( 160)									{
HXLINE( 160)										int _g32 = 0;
HXDLIN( 160)										int _g33 = b8->height;
HXDLIN( 160)										while((_g32 < _g33)){
HXLINE( 160)											_g32 = (_g32 + 1);
HXDLIN( 160)											int y6 = (_g32 - 1);
HXDLIN( 160)											{
HXLINE( 160)												int _g34 = 0;
HXDLIN( 160)												int _g35 = b8->width;
HXDLIN( 160)												while((_g34 < _g35)){
HXLINE( 160)													_g34 = (_g34 + 1);
HXDLIN( 160)													int x6 = (_g34 - 1);
HXDLIN( 160)													{
HXLINE( 160)														w5 = (w5 + 1);
HXDLIN( 160)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 160)													{
HXLINE( 160)														w5 = (w5 + 1);
HXDLIN( 160)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 160)													{
HXLINE( 160)														w5 = (w5 + 1);
HXDLIN( 160)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 160)													{
HXLINE( 160)														w5 = (w5 + 1);
HXDLIN( 160)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 160)							_hx_tmp15 = b8;
            						}
            						break;
            						case (int)1: {
HXLINE( 160)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 160)							 ::iterMagic::ArrIntImg a7 = arrI2;
HXDLIN( 160)							{
HXLINE( 160)								a7->width = width2;
HXDLIN( 160)								a7->height = height2;
HXDLIN( 160)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 160)								a7->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 160)								{
HXLINE( 160)									int _g36 = 0;
HXDLIN( 160)									int _g37 = a7->length;
HXDLIN( 160)									while((_g36 < _g37)){
HXLINE( 160)										_g36 = (_g36 + 1);
HXDLIN( 160)										int i16 = (_g36 - 1);
HXDLIN( 160)										a7->data[i16] = 0;
            									}
            								}
            							}
HXDLIN( 160)							_hx_tmp15 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE( 160)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 160)							 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN( 160)							{
HXLINE( 160)								b9->width = width2;
HXDLIN( 160)								b9->height = height2;
HXDLIN( 160)								b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 160)								int size2 = (b9->length * 4);
HXDLIN( 160)								b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 160)								{
HXLINE( 160)									int _g38 = 0;
HXDLIN( 160)									int _g39 = b9->length;
HXDLIN( 160)									while((_g38 < _g39)){
HXLINE( 160)										_g38 = (_g38 + 1);
HXDLIN( 160)										int i17 = (_g38 - 1);
HXDLIN( 160)										{
HXLINE( 160)											 ::haxe::io::ArrayBufferViewImpl this30 = b9->data;
HXDLIN( 160)											bool _hx_tmp16;
HXDLIN( 160)											if ((i17 >= 0)) {
HXLINE( 160)												_hx_tmp16 = (i17 < (this30->byteLength >> 2));
            											}
            											else {
HXLINE( 160)												_hx_tmp16 = false;
            											}
HXDLIN( 160)											if (_hx_tmp16) {
HXLINE( 160)												 ::haxe::io::Bytes _this2 = this30->bytes;
HXDLIN( 160)												int pos2 = ((i17 << 2) + this30->byteOffset);
HXDLIN( 160)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 160)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 160)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 160)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 160)							_hx_tmp15 = b9;
            						}
            						break;
            						case (int)3: {
HXLINE( 160)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 160)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 160)							{
HXLINE( 160)								v4->width = width2;
HXDLIN( 160)								v4->height = height2;
HXDLIN( 160)								v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 160)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 160)								{
HXLINE( 160)									int _g40 = 0;
HXDLIN( 160)									int _g41 = v4->length;
HXDLIN( 160)									while((_g40 < _g41)){
HXLINE( 160)										_g40 = (_g40 + 1);
HXDLIN( 160)										int i18 = (_g40 - 1);
HXDLIN( 160)										v4->data->__unsafe_set(i18,0);
            									}
            								}
            							}
HXDLIN( 160)							_hx_tmp15 = v4;
            						}
            						break;
            						case (int)4: {
HXLINE( 160)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 160)							 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN( 160)							{
HXLINE( 160)								b10->width = width2;
HXDLIN( 160)								b10->height = height2;
HXDLIN( 160)								b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 160)								b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 160)								{
HXLINE( 160)									int len5 = b10->length;
HXDLIN( 160)									 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN( 160)									if (::hx::IsNull( d2->head )) {
HXLINE( 160)										int _g42 = 0;
HXDLIN( 160)										int _g43 = len5;
HXDLIN( 160)										while((_g42 < _g43)){
HXLINE( 160)											_g42 = (_g42 + 1);
HXDLIN( 160)											int i19 = (_g42 - 1);
HXDLIN( 160)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE( 160)										int _g44 = 0;
HXDLIN( 160)										int _g45 = len5;
HXDLIN( 160)										while((_g44 < _g45)){
HXLINE( 160)											_g44 = (_g44 + 1);
HXDLIN( 160)											int i20 = (_g44 - 1);
HXDLIN( 160)											{
HXLINE( 160)												 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN( 160)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 160)												{
HXLINE( 160)													int _g46 = 0;
HXDLIN( 160)													int _g47 = i20;
HXDLIN( 160)													while((_g46 < _g47)){
HXLINE( 160)														_g46 = (_g46 + 1);
HXDLIN( 160)														int i21 = (_g46 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 160)												if (::hx::IsNull( prev2 )) {
HXLINE( 160)													b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 160)													l2 = null();
            												}
            												else {
HXLINE( 160)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 160)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 160)							_hx_tmp15 = b10;
            						}
            						break;
            					}
HXDLIN( 160)					this29->image = _hx_tmp15;
HXDLIN( 160)					this29->width = width2;
HXDLIN( 160)					this29->height = height2;
HXDLIN( 160)					this29->imageType = ( (int)(imageType2) );
HXDLIN( 160)					 ::pi_xy::ImageStruct nextImage2 = this29;
HXDLIN( 160)					nextImage2->transparent = transparent;
HXDLIN( 160)					while((_this_min2 < _this_max2)){
HXLINE( 160)						_this_min2 = (_this_min2 + 1);
HXDLIN( 160)						int i22 = (_this_min2 - 1);
HXDLIN( 160)						if ((range_y2 > range_yMax2)) {
HXLINE(  94)							range_y2 = range_yReset2;
HXLINE( 160)							range_x2 = (range_x2 + 1);
            						}
HXDLIN( 160)						range_y2 = (range_y2 + 1);
HXDLIN( 160)						int i23 = i22;
HXDLIN( 160)						{
HXLINE( 160)							int x7 = (range_xMax2 - range_x2);
HXDLIN( 160)							int y7 = (range_yMax2 - range_y2);
HXDLIN( 160)							int x8 = range_x2;
HXDLIN( 160)							int y8 = range_y2;
HXDLIN( 160)							::Dynamic this31 = thisImage3->image;
HXDLIN( 160)							int index4;
HXDLIN( 160)							if (thisImage3->useVirtualPos) {
HXLINE( 160)								index4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - thisImage3->virtualY) * ( (Float)(thisImage3->width) )) + x8) - thisImage3->virtualX));
            							}
            							else {
HXLINE( 160)								index4 = ::Std_obj::_hx_int(( (Float)(((y8 * thisImage3->width) + x8)) ));
            							}
HXDLIN( 160)							int c4 = ::iterMagic::Iimg_obj::get(this31,index4);
HXDLIN( 160)							int color2;
HXDLIN( 160)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)								color2 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            							}
            							else {
HXLINE( 160)								color2 = c4;
            							}
HXDLIN( 160)							int c5 = color2;
HXDLIN( 160)							bool _hx_tmp17;
HXDLIN( 160)							if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 160)								_hx_tmp17 = nextImage2->transparent;
            							}
            							else {
HXLINE( 160)								_hx_tmp17 = false;
            							}
HXDLIN( 160)							if (_hx_tmp17) {
HXLINE( 160)								int location2;
HXDLIN( 160)								if (nextImage2->useVirtualPos) {
HXLINE( 160)									location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXLINE( 160)									location2 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN( 160)								int this32 = ::iterMagic::Iimg_obj::get(nextImage2->image,location2);
HXDLIN( 160)								int this33;
HXDLIN( 160)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)									this33 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            								}
            								else {
HXLINE( 160)									this33 = this32;
            								}
HXDLIN( 160)								Float a12;
HXDLIN( 160)								int this34 = ((this33 >> 24) & 255);
HXDLIN( 160)								if ((this34 == 0)) {
HXLINE( 160)									a12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									a12 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float r12;
HXDLIN( 160)								int this35 = ((this33 >> 16) & 255);
HXDLIN( 160)								if ((this35 == 0)) {
HXLINE( 160)									r12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									r12 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float g12;
HXDLIN( 160)								int this36 = ((this33 >> 8) & 255);
HXDLIN( 160)								if ((this36 == 0)) {
HXLINE( 160)									g12 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									g12 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float b13;
HXDLIN( 160)								int this37 = (this33 & 255);
HXDLIN( 160)								if ((this37 == 0)) {
HXLINE( 160)									b13 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									b13 = (( (Float)(this37) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float a22;
HXDLIN( 160)								int this38 = ((color2 >> 24) & 255);
HXDLIN( 160)								if ((this38 == 0)) {
HXLINE( 160)									a22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									a22 = (( (Float)(this38) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float r22;
HXDLIN( 160)								int this39 = ((color2 >> 16) & 255);
HXDLIN( 160)								if ((this39 == 0)) {
HXLINE( 160)									r22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									r22 = (( (Float)(this39) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float g22;
HXDLIN( 160)								int this40 = ((color2 >> 8) & 255);
HXDLIN( 160)								if ((this40 == 0)) {
HXLINE( 160)									g22 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									g22 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float b23;
HXDLIN( 160)								int this41 = (color2 & 255);
HXDLIN( 160)								if ((this41 == 0)) {
HXLINE( 160)									b23 = ((Float)0.);
            								}
            								else {
HXLINE( 160)									b23 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN( 160)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 160)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 160)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 160)								int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 160)								int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 160)								int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN( 160)								{
HXLINE( 160)									int _hx_tmp18;
HXDLIN( 160)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)										_hx_tmp18 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE( 160)										_hx_tmp18 = blended2;
            									}
HXDLIN( 160)									::iterMagic::Iimg_obj::set(nextImage2->image,location2,_hx_tmp18);
            								}
            							}
            							else {
HXLINE( 160)								::Dynamic this42 = nextImage2->image;
HXDLIN( 160)								int index5;
HXDLIN( 160)								if (nextImage2->useVirtualPos) {
HXLINE( 160)									index5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXLINE( 160)									index5 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN( 160)								int _hx_tmp19;
HXDLIN( 160)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)									_hx_tmp19 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 160)									_hx_tmp19 = c5;
            								}
HXDLIN( 160)								::iterMagic::Iimg_obj::set(this42,index5,_hx_tmp19);
            							}
            						}
            					}
HXDLIN( 160)					bool _hx_tmp20;
HXDLIN( 160)					if (::hx::IsNotNull( thisImage3->mask )) {
HXLINE( 160)						_hx_tmp20 = includeMask;
            					}
            					else {
HXLINE( 160)						_hx_tmp20 = false;
            					}
HXDLIN( 160)					if (_hx_tmp20) {
HXLINE( 160)						 ::pi_xy::ImageStruct v5 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(thisImage3->mask,( (Float)(0) ),( (Float)(0) ),w4,h2,thisImage3->mask->transparent,includeMask);
HXDLIN( 160)						nextImage2->useMask = true;
HXDLIN( 160)						nextImage2->mask = v5;
            					}
HXDLIN( 160)					return nextImage2;
            				}
            				else {
HXLINE( 162)					 ::pi_xy::ImageStruct this43 = thisImage;
HXDLIN( 162)					Float centreX1 = centreX;
HXDLIN( 162)					Float centreY1 = centreY;
HXDLIN( 162)					Float ax = ((Float)0.);
HXDLIN( 162)					Float ay = ((Float)0.);
HXDLIN( 162)					if ((centreX1 != ((Float)0.))) {
HXLINE( 173)						centreX1 = ((( (Float)(this43->width) ) / ( (Float)(2) )) + centreX1);
HXLINE( 162)						ax = (ax - centreX1);
            					}
HXDLIN( 162)					if ((centreY1 != ((Float)0.))) {
HXLINE( 177)						centreY1 = ((( (Float)(this43->height) ) / ( (Float)(2) )) + centreY1);
HXLINE( 162)						ay = (ay - centreY1);
            					}
HXDLIN( 162)					Float bx = (ax + this43->width);
HXDLIN( 162)					Float by = ay;
HXDLIN( 162)					Float cx = bx;
HXDLIN( 162)					Float cy = (ay + this43->height);
HXDLIN( 162)					Float dx = ax;
HXDLIN( 162)					Float dy = cy;
HXDLIN( 162)					Float sin = ::Math_obj::sin(theta);
HXDLIN( 162)					Float cos = ::Math_obj::cos(theta);
HXDLIN( 162)					Float temp = ax;
HXLINE( 189)					ax = ((temp * cos) - (ay * sin));
HXLINE( 190)					ay = ((ay * cos) + (temp * sin));
HXLINE( 162)					Float temp1 = bx;
HXLINE( 192)					bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)					by = ((by * cos) + (temp1 * sin));
HXLINE( 162)					Float temp2 = cx;
HXLINE( 195)					cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)					cy = ((cy * cos) + (temp2 * sin));
HXLINE( 162)					Float temp3 = dx;
HXLINE( 198)					dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)					dy = ((dy * cos) + (temp3 * sin));
HXLINE( 162)					if ((centreX1 != ((Float)0.))) {
HXLINE( 162)						ax = (ax + centreX1);
HXDLIN( 162)						bx = (bx + centreX1);
HXDLIN( 162)						cx = (cx + centreX1);
HXDLIN( 162)						dx = (dx + centreX1);
            					}
HXDLIN( 162)					if ((centreY1 != ((Float)0.))) {
HXLINE( 162)						ay = (ay + centreY1);
HXDLIN( 162)						by = (by + centreY1);
HXDLIN( 162)						cy = (cy + centreY1);
HXDLIN( 162)						dy = (dy + centreY1);
            					}
HXDLIN( 162)					int min = ::Math_obj::floor(ax);
HXDLIN( 162)					int max = ::Math_obj::ceil(ax);
HXDLIN( 162)					if ((bx < min)) {
HXLINE(  31)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXLINE( 162)						if ((bx > max)) {
HXLINE(  33)							max = ::Math_obj::ceil(bx);
            						}
            					}
HXLINE( 162)					if ((cx < min)) {
HXLINE(  36)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 162)						if ((cx > max)) {
HXLINE(  38)							max = ::Math_obj::ceil(cx);
            						}
            					}
HXLINE( 162)					if ((dx < min)) {
HXLINE(  41)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 162)						if ((dx > max)) {
HXLINE(  43)							max = ::Math_obj::ceil(dx);
            						}
            					}
HXLINE( 162)					int ii_min6 = min;
HXDLIN( 162)					int ii_max6 = max;
HXDLIN( 162)					 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
HXDLIN( 162)					int min1 = ::Math_obj::floor(ay);
HXDLIN( 162)					int max1 = ::Math_obj::ceil(ay);
HXDLIN( 162)					if ((by < min1)) {
HXLINE(  31)						min1 = ::Math_obj::floor(by);
            					}
            					else {
HXLINE( 162)						if ((by > max1)) {
HXLINE(  33)							max1 = ::Math_obj::ceil(by);
            						}
            					}
HXLINE( 162)					if ((cy < min1)) {
HXLINE(  36)						min1 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 162)						if ((cy > max1)) {
HXLINE(  38)							max1 = ::Math_obj::ceil(cy);
            						}
            					}
HXLINE( 162)					if ((dy < min1)) {
HXLINE(  41)						min1 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 162)						if ((dy > max1)) {
HXLINE(  43)							max1 = ::Math_obj::ceil(dy);
            						}
            					}
HXLINE( 162)					int ii_min7 = min1;
HXDLIN( 162)					int ii_max7 = max1;
HXDLIN( 162)					 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
HXDLIN( 162)					int minX = boundX->start;
HXDLIN( 162)					int wid = ((boundX->max - boundX->start) + 1);
HXDLIN( 162)					int minY = boundY->start;
HXDLIN( 162)					int hi = ((boundY->max - boundY->start) + 1);
HXDLIN( 162)					 ::Dynamic imageType3 = null();
HXDLIN( 162)					 ::pi_xy::ImageStruct this44 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 162)					::Dynamic _hx_tmp21;
HXDLIN( 162)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 162)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::BytesImg b15 = byt3;
HXDLIN( 162)							{
HXLINE( 162)								b15->width = wid;
HXDLIN( 162)								b15->height = hi;
HXDLIN( 162)								b15->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 162)								b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN( 162)								{
HXLINE( 162)									int len6 = b15->length;
HXDLIN( 162)									int w6 = 0;
HXDLIN( 162)									{
HXLINE( 162)										int _g48 = 0;
HXDLIN( 162)										int _g49 = b15->height;
HXDLIN( 162)										while((_g48 < _g49)){
HXLINE( 162)											_g48 = (_g48 + 1);
HXDLIN( 162)											int y9 = (_g48 - 1);
HXDLIN( 162)											{
HXLINE( 162)												int _g50 = 0;
HXDLIN( 162)												int _g51 = b15->width;
HXDLIN( 162)												while((_g50 < _g51)){
HXLINE( 162)													_g50 = (_g50 + 1);
HXDLIN( 162)													int x9 = (_g50 - 1);
HXDLIN( 162)													{
HXLINE( 162)														w6 = (w6 + 1);
HXDLIN( 162)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w6 = (w6 + 1);
HXDLIN( 162)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w6 = (w6 + 1);
HXDLIN( 162)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w6 = (w6 + 1);
HXDLIN( 162)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							_hx_tmp21 = b15;
            						}
            						break;
            						case (int)1: {
HXLINE( 162)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::ArrIntImg a9 = arrI3;
HXDLIN( 162)							{
HXLINE( 162)								a9->width = wid;
HXDLIN( 162)								a9->height = hi;
HXDLIN( 162)								a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)								a9->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 162)								{
HXLINE( 162)									int _g52 = 0;
HXDLIN( 162)									int _g53 = a9->length;
HXDLIN( 162)									while((_g52 < _g53)){
HXLINE( 162)										_g52 = (_g52 + 1);
HXDLIN( 162)										int i24 = (_g52 - 1);
HXDLIN( 162)										a9->data[i24] = 0;
            									}
            								}
            							}
HXDLIN( 162)							_hx_tmp21 = a9;
            						}
            						break;
            						case (int)2: {
HXLINE( 162)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::U32ArrImg b16 = u32a3;
HXDLIN( 162)							{
HXLINE( 162)								b16->width = wid;
HXDLIN( 162)								b16->height = hi;
HXDLIN( 162)								b16->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 162)								int size3 = (b16->length * 4);
HXDLIN( 162)								b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 162)								{
HXLINE( 162)									int _g54 = 0;
HXDLIN( 162)									int _g55 = b16->length;
HXDLIN( 162)									while((_g54 < _g55)){
HXLINE( 162)										_g54 = (_g54 + 1);
HXDLIN( 162)										int i25 = (_g54 - 1);
HXDLIN( 162)										{
HXLINE( 162)											 ::haxe::io::ArrayBufferViewImpl this45 = b16->data;
HXDLIN( 162)											bool _hx_tmp22;
HXDLIN( 162)											if ((i25 >= 0)) {
HXLINE( 162)												_hx_tmp22 = (i25 < (this45->byteLength >> 2));
            											}
            											else {
HXLINE( 162)												_hx_tmp22 = false;
            											}
HXDLIN( 162)											if (_hx_tmp22) {
HXLINE( 162)												 ::haxe::io::Bytes _this3 = this45->bytes;
HXDLIN( 162)												int pos3 = ((i25 << 2) + this45->byteOffset);
HXDLIN( 162)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 162)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							_hx_tmp21 = b16;
            						}
            						break;
            						case (int)3: {
HXLINE( 162)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::VecIntImg v6 = vec3;
HXDLIN( 162)							{
HXLINE( 162)								v6->width = wid;
HXDLIN( 162)								v6->height = hi;
HXDLIN( 162)								v6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 162)								v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 162)								{
HXLINE( 162)									int _g56 = 0;
HXDLIN( 162)									int _g57 = v6->length;
HXDLIN( 162)									while((_g56 < _g57)){
HXLINE( 162)										_g56 = (_g56 + 1);
HXDLIN( 162)										int i26 = (_g56 - 1);
HXDLIN( 162)										v6->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN( 162)							_hx_tmp21 = v6;
            						}
            						break;
            						case (int)4: {
HXLINE( 162)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::StackIntImg b17 = sInt3;
HXDLIN( 162)							{
HXLINE( 162)								b17->width = wid;
HXDLIN( 162)								b17->height = hi;
HXDLIN( 162)								b17->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 162)								b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)								{
HXLINE( 162)									int len7 = b17->length;
HXDLIN( 162)									 ::haxe::ds::GenericStack_Int d3 = b17->data;
HXDLIN( 162)									if (::hx::IsNull( d3->head )) {
HXLINE( 162)										int _g58 = 0;
HXDLIN( 162)										int _g59 = len7;
HXDLIN( 162)										while((_g58 < _g59)){
HXLINE( 162)											_g58 = (_g58 + 1);
HXDLIN( 162)											int i27 = (_g58 - 1);
HXDLIN( 162)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 162)										int _g60 = 0;
HXDLIN( 162)										int _g61 = len7;
HXDLIN( 162)										while((_g60 < _g61)){
HXLINE( 162)											_g60 = (_g60 + 1);
HXDLIN( 162)											int i28 = (_g60 - 1);
HXDLIN( 162)											{
HXLINE( 162)												 ::haxe::ds::GenericCell_Int l3 = b17->data->head;
HXDLIN( 162)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 162)												{
HXLINE( 162)													int _g62 = 0;
HXDLIN( 162)													int _g63 = i28;
HXDLIN( 162)													while((_g62 < _g63)){
HXLINE( 162)														_g62 = (_g62 + 1);
HXDLIN( 162)														int i29 = (_g62 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 162)												if (::hx::IsNull( prev3 )) {
HXLINE( 162)													b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 162)													l3 = null();
            												}
            												else {
HXLINE( 162)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 162)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							_hx_tmp21 = b17;
            						}
            						break;
            					}
HXDLIN( 162)					this44->image = _hx_tmp21;
HXDLIN( 162)					this44->width = wid;
HXDLIN( 162)					this44->height = hi;
HXDLIN( 162)					this44->imageType = ( (int)(imageType3) );
HXDLIN( 162)					 ::pi_xy::ImageStruct nextImage3 = this44;
HXDLIN( 162)					nextImage3->transparent = true;
HXDLIN( 162)					if ((minX < ((Float)0.))) {
HXLINE( 162)						ax = (ax - ( (Float)(minX) ));
HXDLIN( 162)						bx = (bx - ( (Float)(minX) ));
HXDLIN( 162)						cx = (cx - ( (Float)(minX) ));
HXDLIN( 162)						dx = (dx - ( (Float)(minX) ));
            					}
HXDLIN( 162)					if ((minY < ((Float)0.))) {
HXLINE( 162)						ay = (ay - ( (Float)(minY) ));
HXDLIN( 162)						by = (by - ( (Float)(minY) ));
HXDLIN( 162)						cy = (cy - ( (Float)(minY) ));
HXDLIN( 162)						dy = (dy - ( (Float)(minY) ));
            					}
HXDLIN( 162)					{
HXLINE( 162)						 ::pi_xy::ImageStruct this46 = nextImage3;
HXDLIN( 162)						Float win_x = ( (Float)(0) );
HXDLIN( 162)						Float win_y = ( (Float)(0) );
HXDLIN( 162)						Float win_width = ( (Float)(this43->width) );
HXDLIN( 162)						Float win_height = ( (Float)(this43->height) );
HXDLIN( 162)						{
HXLINE( 162)							Float bu = ((Float)1.);
HXDLIN( 162)							Float bv = ((Float)0.);
HXDLIN( 162)							Float cu = ((Float)1.);
HXDLIN( 162)							Float cv = ((Float)1.);
HXDLIN( 162)							Float du = ((Float)0.);
HXDLIN( 162)							Float dv = ((Float)1.);
HXDLIN( 162)							Float au = ((Float)0.);
HXDLIN( 162)							Float av = ((Float)0.);
HXDLIN( 162)							Float bu1 = bu;
HXDLIN( 162)							Float bv1 = bv;
HXDLIN( 162)							bool hasUndo = false;
HXDLIN( 162)							Float temp4 = au;
HXLINE( 422)							au = bu1;
HXLINE( 423)							bu1 = temp4;
HXLINE( 424)							temp4 = av;
HXLINE( 425)							av = bv1;
HXLINE( 426)							bv1 = temp4;
HXLINE( 162)							Float bcx = (bx - dx);
HXDLIN( 162)							Float bcy = (by - dy);
HXDLIN( 162)							Float acx = (ax - dx);
HXDLIN( 162)							Float acy = (ay - dy);
HXDLIN( 162)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 162)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 162)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 162)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 162)							if ((ax > bx)) {
HXLINE( 162)								if ((ax > dx)) {
HXLINE( 162)									int min2;
HXDLIN( 162)									if ((bx > dx)) {
HXLINE( 162)										min2 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 162)										min2 = ::Math_obj::floor(bx);
            									}
HXDLIN( 162)									int ii_min8 = min2;
HXDLIN( 162)									int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 162)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE( 162)									int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 162)									int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 162)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE( 162)								if ((bx > dx)) {
HXLINE( 162)									int min3;
HXDLIN( 162)									if ((ax > dx)) {
HXLINE( 162)										min3 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 162)										min3 = ::Math_obj::ceil(ax);
            									}
HXDLIN( 162)									int ii_min10 = min3;
HXDLIN( 162)									int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 162)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE( 162)									int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 162)									int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 162)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 162)							if ((ay > by)) {
HXLINE( 162)								if ((ay > dy)) {
HXLINE( 162)									int min4;
HXDLIN( 162)									if ((by > dy)) {
HXLINE( 162)										min4 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 162)										min4 = ::Math_obj::floor(by);
            									}
HXDLIN( 162)									int ii_min12 = min4;
HXDLIN( 162)									int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 162)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE( 162)									int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 162)									int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 162)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE( 162)								if ((by > dy)) {
HXLINE( 162)									int min5;
HXDLIN( 162)									if ((ay > dy)) {
HXLINE( 162)										min5 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 162)										min5 = ::Math_obj::ceil(ay);
            									}
HXDLIN( 162)									int ii_min14 = min5;
HXDLIN( 162)									int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 162)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE( 162)									int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 162)									int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 162)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 162)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 162)							if (hasUndo) {
HXLINE( 162)								int width3 = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 162)								int height3 = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 162)								 ::Dynamic imageType4 = null();
HXDLIN( 162)								 ::pi_xy::ImageStruct this47 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)								if (::hx::IsNull( imageType4 )) {
HXLINE(  54)									imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 162)								::Dynamic undoImage1;
HXDLIN( 162)								switch((int)(( (int)(imageType4) ))){
            									case (int)0: {
HXLINE( 162)										 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::BytesImg b18 = byt4;
HXDLIN( 162)										{
HXLINE( 162)											b18->width = width3;
HXDLIN( 162)											b18->height = height3;
HXDLIN( 162)											b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 162)											b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 162)											{
HXLINE( 162)												int len8 = b18->length;
HXDLIN( 162)												int w7 = 0;
HXDLIN( 162)												{
HXLINE( 162)													int _g64 = 0;
HXDLIN( 162)													int _g65 = b18->height;
HXDLIN( 162)													while((_g64 < _g65)){
HXLINE( 162)														_g64 = (_g64 + 1);
HXDLIN( 162)														int y10 = (_g64 - 1);
HXDLIN( 162)														{
HXLINE( 162)															int _g66 = 0;
HXDLIN( 162)															int _g67 = b18->width;
HXDLIN( 162)															while((_g66 < _g67)){
HXLINE( 162)																_g66 = (_g66 + 1);
HXDLIN( 162)																int x10 = (_g66 - 1);
HXDLIN( 162)																{
HXLINE( 162)																	w7 = (w7 + 1);
HXDLIN( 162)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w7 = (w7 + 1);
HXDLIN( 162)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w7 = (w7 + 1);
HXDLIN( 162)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w7 = (w7 + 1);
HXDLIN( 162)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage1 = b18;
            									}
            									break;
            									case (int)1: {
HXLINE( 162)										 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::ArrIntImg a10 = arrI4;
HXDLIN( 162)										{
HXLINE( 162)											a10->width = width3;
HXDLIN( 162)											a10->height = height3;
HXDLIN( 162)											a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)											a10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 162)											{
HXLINE( 162)												int _g68 = 0;
HXDLIN( 162)												int _g69 = a10->length;
HXDLIN( 162)												while((_g68 < _g69)){
HXLINE( 162)													_g68 = (_g68 + 1);
HXDLIN( 162)													int i30 = (_g68 - 1);
HXDLIN( 162)													a10->data[i30] = 0;
            												}
            											}
            										}
HXDLIN( 162)										undoImage1 = a10;
            									}
            									break;
            									case (int)2: {
HXLINE( 162)										 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::U32ArrImg b19 = u32a4;
HXDLIN( 162)										{
HXLINE( 162)											b19->width = width3;
HXDLIN( 162)											b19->height = height3;
HXDLIN( 162)											b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 162)											int size4 = (b19->length * 4);
HXDLIN( 162)											b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 162)											{
HXLINE( 162)												int _g70 = 0;
HXDLIN( 162)												int _g71 = b19->length;
HXDLIN( 162)												while((_g70 < _g71)){
HXLINE( 162)													_g70 = (_g70 + 1);
HXDLIN( 162)													int i31 = (_g70 - 1);
HXDLIN( 162)													{
HXLINE( 162)														 ::haxe::io::ArrayBufferViewImpl this48 = b19->data;
HXDLIN( 162)														bool undoImage2;
HXDLIN( 162)														if ((i31 >= 0)) {
HXLINE( 162)															undoImage2 = (i31 < (this48->byteLength >> 2));
            														}
            														else {
HXLINE( 162)															undoImage2 = false;
            														}
HXDLIN( 162)														if (undoImage2) {
HXLINE( 162)															 ::haxe::io::Bytes _this4 = this48->bytes;
HXDLIN( 162)															int pos4 = ((i31 << 2) + this48->byteOffset);
HXDLIN( 162)															_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 162)															_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)															_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)															_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage1 = b19;
            									}
            									break;
            									case (int)3: {
HXLINE( 162)										 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::VecIntImg v7 = vec4;
HXDLIN( 162)										{
HXLINE( 162)											v7->width = width3;
HXDLIN( 162)											v7->height = height3;
HXDLIN( 162)											v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 162)											v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 162)											{
HXLINE( 162)												int _g72 = 0;
HXDLIN( 162)												int _g73 = v7->length;
HXDLIN( 162)												while((_g72 < _g73)){
HXLINE( 162)													_g72 = (_g72 + 1);
HXDLIN( 162)													int i32 = (_g72 - 1);
HXDLIN( 162)													v7->data->__unsafe_set(i32,0);
            												}
            											}
            										}
HXDLIN( 162)										undoImage1 = v7;
            									}
            									break;
            									case (int)4: {
HXLINE( 162)										 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::StackIntImg b20 = sInt4;
HXDLIN( 162)										{
HXLINE( 162)											b20->width = width3;
HXDLIN( 162)											b20->height = height3;
HXDLIN( 162)											b20->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 162)											b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)											{
HXLINE( 162)												int len9 = b20->length;
HXDLIN( 162)												 ::haxe::ds::GenericStack_Int d4 = b20->data;
HXDLIN( 162)												if (::hx::IsNull( d4->head )) {
HXLINE( 162)													int _g74 = 0;
HXDLIN( 162)													int _g75 = len9;
HXDLIN( 162)													while((_g74 < _g75)){
HXLINE( 162)														_g74 = (_g74 + 1);
HXDLIN( 162)														int i33 = (_g74 - 1);
HXDLIN( 162)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXLINE( 162)													int _g76 = 0;
HXDLIN( 162)													int _g77 = len9;
HXDLIN( 162)													while((_g76 < _g77)){
HXLINE( 162)														_g76 = (_g76 + 1);
HXDLIN( 162)														int i34 = (_g76 - 1);
HXDLIN( 162)														{
HXLINE( 162)															 ::haxe::ds::GenericCell_Int l4 = b20->data->head;
HXDLIN( 162)															 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 162)															{
HXLINE( 162)																int _g78 = 0;
HXDLIN( 162)																int _g79 = i34;
HXDLIN( 162)																while((_g78 < _g79)){
HXLINE( 162)																	_g78 = (_g78 + 1);
HXDLIN( 162)																	int i35 = (_g78 - 1);
HXLINE( 345)																	prev4 = l4;
HXLINE( 346)																	l4 = l4->next;
            																}
            															}
HXLINE( 162)															if (::hx::IsNull( prev4 )) {
HXLINE( 162)																b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 162)																l4 = null();
            															}
            															else {
HXLINE( 162)																prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 162)																l4 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage1 = b20;
            									}
            									break;
            								}
HXDLIN( 162)								this47->image = undoImage1;
HXDLIN( 162)								this47->width = width3;
HXDLIN( 162)								this47->height = height3;
HXDLIN( 162)								this47->imageType = ( (int)(imageType4) );
HXDLIN( 162)								undoImage = this47;
HXDLIN( 162)								{
HXLINE( 162)									int rectLeft = xIter3->start;
HXDLIN( 162)									int rectTop = yIter3->start;
HXDLIN( 162)									int rectRight = xIter3->max;
HXDLIN( 162)									bool forceClear = false;
HXDLIN( 162)									{
HXLINE( 162)										int _g80 = rectTop;
HXDLIN( 162)										int _g81 = yIter3->max;
HXDLIN( 162)										while((_g80 < _g81)){
HXLINE( 162)											_g80 = (_g80 + 1);
HXDLIN( 162)											int dy1 = (_g80 - 1);
HXDLIN( 162)											{
HXLINE( 162)												int _g82 = rectLeft;
HXDLIN( 162)												int _g83 = rectRight;
HXDLIN( 162)												while((_g82 < _g83)){
HXLINE( 162)													_g82 = (_g82 + 1);
HXDLIN( 162)													int dx1 = (_g82 - 1);
HXDLIN( 162)													::Dynamic this49 = this46->image;
HXDLIN( 162)													int index6;
HXDLIN( 162)													if (this46->useVirtualPos) {
HXLINE( 162)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this46->virtualY) * ( (Float)(this46->width) )) + dx1) - this46->virtualX));
            													}
            													else {
HXLINE( 162)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this46->width) + dx1)) ));
            													}
HXDLIN( 162)													int c6 = ::iterMagic::Iimg_obj::get(this49,index6);
HXDLIN( 162)													int col;
HXDLIN( 162)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)														col = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE( 162)														col = c6;
            													}
HXDLIN( 162)													bool _hx_tmp23;
HXDLIN( 162)													if (this46->useMask) {
HXLINE( 162)														_hx_tmp23 = ::hx::IsNotNull( this46->mask );
            													}
            													else {
HXLINE( 162)														_hx_tmp23 = false;
            													}
HXDLIN( 162)													if (_hx_tmp23) {
HXLINE( 162)														 ::pi_xy::ImageStruct this50 = this46->mask;
HXDLIN( 162)														::Dynamic this51 = this50->image;
HXDLIN( 162)														int index7;
HXDLIN( 162)														if (this50->useVirtualPos) {
HXLINE( 162)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this50->virtualY) * ( (Float)(this50->width) )) + dx1) - this50->virtualX));
            														}
            														else {
HXLINE( 162)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this50->width) + dx1)) ));
            														}
HXDLIN( 162)														int c7 = ::iterMagic::Iimg_obj::get(this51,index7);
HXDLIN( 162)														int v8;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															v8 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															v8 = c7;
            														}
HXDLIN( 162)														int maskPixel = v8;
HXDLIN( 162)														int this52 = col;
HXDLIN( 162)														if ((maskPixel == 0)) {
HXLINE( 162)															col = this52;
            														}
            														else {
HXLINE( 162)															Float m0;
HXDLIN( 162)															int this53 = ((maskPixel >> 24) & 255);
HXDLIN( 162)															if ((this53 == 0)) {
HXLINE( 162)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m0 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m1;
HXDLIN( 162)															int this54 = ((maskPixel >> 16) & 255);
HXDLIN( 162)															if ((this54 == 0)) {
HXLINE( 162)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m1 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m2;
HXDLIN( 162)															int this55 = ((maskPixel >> 8) & 255);
HXDLIN( 162)															if ((this55 == 0)) {
HXLINE( 162)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m2 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m3;
HXDLIN( 162)															int this56 = (maskPixel & 255);
HXDLIN( 162)															if ((this56 == 0)) {
HXLINE( 162)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m3 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this52 >> 24) & 255)) )));
HXDLIN( 162)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this52 >> 16) & 255)) )));
HXDLIN( 162)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this52 >> 8) & 255)) )));
HXDLIN( 162)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this52 & 255)) )));
HXDLIN( 162)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 162)													if ((col != 0)) {
HXLINE( 162)														int x11 = (dx1 - rectLeft);
HXDLIN( 162)														int y11 = (dy1 - rectTop);
HXDLIN( 162)														int c8 = col;
HXDLIN( 162)														bool _hx_tmp24;
HXDLIN( 162)														if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 162)															_hx_tmp24 = undoImage->transparent;
            														}
            														else {
HXLINE( 162)															_hx_tmp24 = false;
            														}
HXDLIN( 162)														if (_hx_tmp24) {
HXLINE( 162)															int location3;
HXDLIN( 162)															if (undoImage->useVirtualPos) {
HXLINE( 162)																location3 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXLINE( 162)																location3 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN( 162)															int this57 = ::iterMagic::Iimg_obj::get(undoImage->image,location3);
HXDLIN( 162)															int this58;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																this58 = this57;
            															}
HXDLIN( 162)															Float a13;
HXDLIN( 162)															int this59 = ((this58 >> 24) & 255);
HXDLIN( 162)															if ((this59 == 0)) {
HXLINE( 162)																a13 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r13;
HXDLIN( 162)															int this60 = ((this58 >> 16) & 255);
HXDLIN( 162)															if ((this60 == 0)) {
HXLINE( 162)																r13 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g13;
HXDLIN( 162)															int this61 = ((this58 >> 8) & 255);
HXDLIN( 162)															if ((this61 == 0)) {
HXLINE( 162)																g13 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b110;
HXDLIN( 162)															int this62 = (this58 & 255);
HXDLIN( 162)															if ((this62 == 0)) {
HXLINE( 162)																b110 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b110 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a23;
HXDLIN( 162)															int this63 = ((col >> 24) & 255);
HXDLIN( 162)															if ((this63 == 0)) {
HXLINE( 162)																a23 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r23;
HXDLIN( 162)															int this64 = ((col >> 16) & 255);
HXDLIN( 162)															if ((this64 == 0)) {
HXLINE( 162)																r23 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g23;
HXDLIN( 162)															int this65 = ((col >> 8) & 255);
HXDLIN( 162)															if ((this65 == 0)) {
HXLINE( 162)																g23 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b24;
HXDLIN( 162)															int this66 = (col & 255);
HXDLIN( 162)															if ((this66 == 0)) {
HXLINE( 162)																b24 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 162)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 162)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 162)															int b25 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN( 162)															int a14 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 162)															int blended3 = ((((a14 << 24) | (r5 << 16)) | (g5 << 8)) | b25);
HXDLIN( 162)															{
HXLINE( 162)																int _hx_tmp25;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp25 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp25 = blended3;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(undoImage->image,location3,_hx_tmp25);
            															}
            														}
            														else {
HXLINE( 162)															::Dynamic this67 = undoImage->image;
HXDLIN( 162)															int index8;
HXDLIN( 162)															if (undoImage->useVirtualPos) {
HXLINE( 162)																index8 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXLINE( 162)																index8 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN( 162)															int _hx_tmp26;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp26 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp26 = c8;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this67,index8,_hx_tmp26);
            														}
            													}
            													else {
HXLINE( 162)														if (forceClear) {
HXLINE( 162)															::Dynamic this68 = undoImage->image;
HXDLIN( 162)															int x12 = (dx1 - rectLeft);
HXDLIN( 162)															int y12 = (dy1 - rectTop);
HXDLIN( 162)															int index9;
HXDLIN( 162)															if (undoImage->useVirtualPos) {
HXLINE( 162)																index9 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x12) - undoImage->virtualX));
            															}
            															else {
HXLINE( 162)																index9 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage->width) + x12)) ));
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this68,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							{
HXLINE( 162)								int _g_min = xIter3->start;
HXDLIN( 162)								int _g_max = xIter3->max;
HXDLIN( 162)								while((_g_min < _g_max)){
HXLINE( 162)									_g_min = (_g_min + 1);
HXDLIN( 162)									int px = (_g_min - 1);
HXDLIN( 162)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 162)									{
HXLINE( 162)										int _g_min1 = yIter3->start;
HXDLIN( 162)										int _g_max1 = yIter3->max;
HXDLIN( 162)										while((_g_min1 < _g_max1)){
HXLINE( 162)											_g_min1 = (_g_min1 + 1);
HXDLIN( 162)											int py = (_g_min1 - 1);
HXDLIN( 162)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 162)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 162)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 162)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 162)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 162)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 162)											bool _hx_tmp27;
HXDLIN( 162)											bool _hx_tmp28;
HXDLIN( 162)											if ((ratioA >= 0)) {
HXLINE( 162)												_hx_tmp28 = (ratioB >= 0);
            											}
            											else {
HXLINE( 162)												_hx_tmp28 = false;
            											}
HXDLIN( 162)											if (_hx_tmp28) {
HXLINE( 162)												_hx_tmp27 = (ratioC >= 0);
            											}
            											else {
HXLINE( 162)												_hx_tmp27 = false;
            											}
HXDLIN( 162)											if (_hx_tmp27) {
HXLINE( 162)												Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN( 162)												Float v9 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN( 162)												int x13 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN( 162)												int y13 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN( 162)												::Dynamic this69 = this43->image;
HXDLIN( 162)												int index10;
HXDLIN( 162)												if (this43->useVirtualPos) {
HXLINE( 162)													index10 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this43->virtualY) * ( (Float)(this43->width) )) + x13) - this43->virtualX));
            												}
            												else {
HXLINE( 162)													index10 = ::Std_obj::_hx_int(( (Float)(((y13 * this43->width) + x13)) ));
            												}
HXDLIN( 162)												int c9 = ::iterMagic::Iimg_obj::get(this69,index10);
HXDLIN( 162)												int col1;
HXDLIN( 162)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)													col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 162)													col1 = c9;
            												}
HXDLIN( 162)												{
HXLINE( 162)													int c10 = col1;
HXDLIN( 162)													bool _hx_tmp29;
HXDLIN( 162)													if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 162)														_hx_tmp29 = this46->transparent;
            													}
            													else {
HXLINE( 162)														_hx_tmp29 = false;
            													}
HXDLIN( 162)													if (_hx_tmp29) {
HXLINE( 162)														int location4;
HXDLIN( 162)														if (this46->useVirtualPos) {
HXLINE( 162)															location4 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this46->virtualY) * ( (Float)(this46->width) )) + px) - this46->virtualX));
            														}
            														else {
HXLINE( 162)															location4 = ::Std_obj::_hx_int(( (Float)(((py * this46->width) + px)) ));
            														}
HXDLIN( 162)														int this70 = ::iterMagic::Iimg_obj::get(this46->image,location4);
HXDLIN( 162)														int this71;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															this71 = ((((((this70 >> 24) & 255) << 24) | ((this70 & 255) << 16)) | (((this70 >> 8) & 255) << 8)) | ((this70 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															this71 = this70;
            														}
HXDLIN( 162)														Float a15;
HXDLIN( 162)														int this72 = ((this71 >> 24) & 255);
HXDLIN( 162)														if ((this72 == 0)) {
HXLINE( 162)															a15 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float r14;
HXDLIN( 162)														int this73 = ((this71 >> 16) & 255);
HXDLIN( 162)														if ((this73 == 0)) {
HXLINE( 162)															r14 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															r14 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float g14;
HXDLIN( 162)														int this74 = ((this71 >> 8) & 255);
HXDLIN( 162)														if ((this74 == 0)) {
HXLINE( 162)															g14 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															g14 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float b111;
HXDLIN( 162)														int this75 = (this71 & 255);
HXDLIN( 162)														if ((this75 == 0)) {
HXLINE( 162)															b111 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															b111 = (( (Float)(this75) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float a24;
HXDLIN( 162)														int this76 = ((col1 >> 24) & 255);
HXDLIN( 162)														if ((this76 == 0)) {
HXLINE( 162)															a24 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															a24 = (( (Float)(this76) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float r24;
HXDLIN( 162)														int this77 = ((col1 >> 16) & 255);
HXDLIN( 162)														if ((this77 == 0)) {
HXLINE( 162)															r24 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															r24 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float g24;
HXDLIN( 162)														int this78 = ((col1 >> 8) & 255);
HXDLIN( 162)														if ((this78 == 0)) {
HXLINE( 162)															g24 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															g24 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float b26;
HXDLIN( 162)														int this79 = (col1 & 255);
HXDLIN( 162)														if ((this79 == 0)) {
HXLINE( 162)															b26 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															b26 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 162)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 162)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 162)														int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b26 * a24))));
HXDLIN( 162)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 162)														int blended4 = ((((a16 << 24) | (r6 << 16)) | (g6 << 8)) | b27);
HXDLIN( 162)														{
HXLINE( 162)															int _hx_tmp30;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp30 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp30 = blended4;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this46->image,location4,_hx_tmp30);
            														}
            													}
            													else {
HXLINE( 162)														::Dynamic this80 = this46->image;
HXDLIN( 162)														int index11;
HXDLIN( 162)														if (this46->useVirtualPos) {
HXLINE( 162)															index11 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this46->virtualY) * ( (Float)(this46->width) )) + px) - this46->virtualX));
            														}
            														else {
HXLINE( 162)															index11 = ::Std_obj::_hx_int(( (Float)(((py * this46->width) + px)) ));
            														}
HXDLIN( 162)														int _hx_tmp31;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															_hx_tmp31 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															_hx_tmp31 = c10;
            														}
HXDLIN( 162)														::iterMagic::Iimg_obj::set(this80,index11,_hx_tmp31);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 162)							int v_undoY;
HXDLIN( 162)							int v_undoX;
HXDLIN( 162)							Float v_ty;
HXDLIN( 162)							Float v_tx;
HXDLIN( 162)							Float v_t0;
HXDLIN( 162)							Float v_sy;
HXDLIN( 162)							Float v_sx;
HXDLIN( 162)							Float v_s0;
HXDLIN( 162)							Float v_A;
HXDLIN( 162)							Float ax1 = ax;
HXDLIN( 162)							Float ay1 = ay;
HXDLIN( 162)							 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 162)							Float bx1 = bx;
HXDLIN( 162)							Float by1 = by;
HXDLIN( 162)							Float cx1 = dx;
HXDLIN( 162)							Float cy1 = dy;
HXDLIN( 162)							bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN( 162)							if (!(adjustWinding)) {
HXLINE( 162)								Float bx_ = bx1;
HXDLIN( 162)								Float by_ = by1;
HXLINE(  24)								bx1 = cx1;
HXLINE(  25)								by1 = cy1;
HXLINE(  26)								cx1 = bx_;
HXLINE(  27)								cy1 = by_;
            							}
HXLINE( 162)							Float v_ax = ax1;
HXDLIN( 162)							Float v_ay = ay1;
HXDLIN( 162)							Float v_bx = bx1;
HXDLIN( 162)							Float v_by = by1;
HXDLIN( 162)							Float v_cx = cx1;
HXDLIN( 162)							Float v_cy = cy1;
HXDLIN( 162)							bool v_preCalculated = true;
HXDLIN( 162)							{
HXLINE( 162)								v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 162)								v_sx = (v_cy - v_ay);
HXDLIN( 162)								v_sy = (v_ax - v_cx);
HXDLIN( 162)								v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 162)								v_tx = (v_ay - v_by);
HXDLIN( 162)								v_ty = (v_bx - v_ax);
HXDLIN( 162)								v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 162)								Float a17 = v_ax;
HXDLIN( 162)								Float b28 = v_bx;
HXDLIN( 162)								Float c11 = v_cx;
HXDLIN( 162)								if ((a17 > b28)) {
HXLINE( 162)									if ((a17 > c11)) {
HXLINE( 162)										int min6;
HXDLIN( 162)										if ((b28 > c11)) {
HXLINE( 162)											min6 = ::Math_obj::floor(c11);
            										}
            										else {
HXLINE( 162)											min6 = ::Math_obj::floor(b28);
            										}
HXDLIN( 162)										int ii_min16 = min6;
HXDLIN( 162)										int ii_max16 = ::Math_obj::ceil(a17);
HXDLIN( 162)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXLINE( 162)										int ii_min17 = ::Math_obj::floor(b28);
HXDLIN( 162)										int ii_max17 = ::Math_obj::ceil(c11);
HXDLIN( 162)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
            								else {
HXLINE( 162)									if ((b28 > c11)) {
HXLINE( 162)										int min7;
HXDLIN( 162)										if ((a17 > c11)) {
HXLINE( 162)											min7 = ::Math_obj::floor(c11);
            										}
            										else {
HXLINE( 162)											min7 = ::Math_obj::ceil(a17);
            										}
HXDLIN( 162)										int ii_min18 = min7;
HXDLIN( 162)										int ii_max18 = ::Math_obj::ceil(b28);
HXDLIN( 162)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            									}
            									else {
HXLINE( 162)										int ii_min19 = ::Math_obj::floor(a17);
HXDLIN( 162)										int ii_max19 = ::Math_obj::ceil(c11);
HXDLIN( 162)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            									}
            								}
HXDLIN( 162)								Float a18 = v_ay;
HXDLIN( 162)								Float b29 = v_by;
HXDLIN( 162)								Float c12 = v_cy;
HXDLIN( 162)								if ((a18 > b29)) {
HXLINE( 162)									if ((a18 > c12)) {
HXLINE( 162)										int min8;
HXDLIN( 162)										if ((b29 > c12)) {
HXLINE( 162)											min8 = ::Math_obj::floor(c12);
            										}
            										else {
HXLINE( 162)											min8 = ::Math_obj::floor(b29);
            										}
HXDLIN( 162)										int ii_min20 = min8;
HXDLIN( 162)										int ii_max20 = ::Math_obj::ceil(a18);
HXDLIN( 162)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            									}
            									else {
HXLINE( 162)										int ii_min21 = ::Math_obj::floor(b29);
HXDLIN( 162)										int ii_max21 = ::Math_obj::ceil(c12);
HXDLIN( 162)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            									}
            								}
            								else {
HXLINE( 162)									if ((b29 > c12)) {
HXLINE( 162)										int min9;
HXDLIN( 162)										if ((a18 > c12)) {
HXLINE( 162)											min9 = ::Math_obj::floor(c12);
            										}
            										else {
HXLINE( 162)											min9 = ::Math_obj::ceil(a18);
            										}
HXDLIN( 162)										int ii_min22 = min9;
HXDLIN( 162)										int ii_max22 = ::Math_obj::ceil(b29);
HXDLIN( 162)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            									}
            									else {
HXLINE( 162)										int ii_min23 = ::Math_obj::floor(a18);
HXDLIN( 162)										int ii_max23 = ::Math_obj::ceil(c12);
HXDLIN( 162)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            									}
            								}
            							}
HXDLIN( 162)							if (hasUndo) {
HXLINE( 162)								v_undoImage = undoImage;
HXDLIN( 162)								v_undoX = xIter3->start;
HXDLIN( 162)								v_undoY = yIter3->start;
            							}
HXDLIN( 162)							Float au1 = bu;
HXDLIN( 162)							Float av1 = bv;
HXDLIN( 162)							Float bu2 = cu;
HXDLIN( 162)							Float bv2 = cv;
HXDLIN( 162)							bool hasUndo1 = false;
HXDLIN( 162)							Float temp5 = au1;
HXLINE( 422)							au1 = bu2;
HXLINE( 423)							bu2 = temp5;
HXLINE( 424)							temp5 = av1;
HXLINE( 425)							av1 = bv2;
HXLINE( 426)							bv2 = temp5;
HXLINE( 162)							Float bcx1 = (cx - dx);
HXDLIN( 162)							Float bcy1 = (cy - dy);
HXDLIN( 162)							Float acx1 = (bx - dx);
HXDLIN( 162)							Float acy1 = (by - dy);
HXDLIN( 162)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 162)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 162)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 162)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 162)							if ((bx > cx)) {
HXLINE( 162)								if ((bx > dx)) {
HXLINE( 162)									int min10;
HXDLIN( 162)									if ((cx > dx)) {
HXLINE( 162)										min10 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 162)										min10 = ::Math_obj::floor(cx);
            									}
HXDLIN( 162)									int ii_min24 = min10;
HXDLIN( 162)									int ii_max24 = ::Math_obj::ceil(bx);
HXDLIN( 162)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            								else {
HXLINE( 162)									int ii_min25 = ::Math_obj::floor(cx);
HXDLIN( 162)									int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN( 162)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            							}
            							else {
HXLINE( 162)								if ((cx > dx)) {
HXLINE( 162)									int min11;
HXDLIN( 162)									if ((bx > dx)) {
HXLINE( 162)										min11 = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE( 162)										min11 = ::Math_obj::ceil(bx);
            									}
HXDLIN( 162)									int ii_min26 = min11;
HXDLIN( 162)									int ii_max26 = ::Math_obj::ceil(cx);
HXDLIN( 162)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            								else {
HXLINE( 162)									int ii_min27 = ::Math_obj::floor(bx);
HXDLIN( 162)									int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN( 162)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            							}
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 162)							if ((by > cy)) {
HXLINE( 162)								if ((by > dy)) {
HXLINE( 162)									int min12;
HXDLIN( 162)									if ((cy > dy)) {
HXLINE( 162)										min12 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 162)										min12 = ::Math_obj::floor(cy);
            									}
HXDLIN( 162)									int ii_min28 = min12;
HXDLIN( 162)									int ii_max28 = ::Math_obj::ceil(by);
HXDLIN( 162)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            								else {
HXLINE( 162)									int ii_min29 = ::Math_obj::floor(cy);
HXDLIN( 162)									int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN( 162)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            								}
            							}
            							else {
HXLINE( 162)								if ((cy > dy)) {
HXLINE( 162)									int min13;
HXDLIN( 162)									if ((by > dy)) {
HXLINE( 162)										min13 = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE( 162)										min13 = ::Math_obj::ceil(by);
            									}
HXDLIN( 162)									int ii_min30 = min13;
HXDLIN( 162)									int ii_max30 = ::Math_obj::ceil(cy);
HXDLIN( 162)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            								}
            								else {
HXLINE( 162)									int ii_min31 = ::Math_obj::floor(by);
HXDLIN( 162)									int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN( 162)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            								}
            							}
HXDLIN( 162)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 162)							if (hasUndo1) {
HXLINE( 162)								int width4 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 162)								int height4 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 162)								 ::Dynamic imageType5 = null();
HXDLIN( 162)								 ::pi_xy::ImageStruct this81 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)								if (::hx::IsNull( imageType5 )) {
HXLINE(  54)									imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 162)								::Dynamic undoImage4;
HXDLIN( 162)								switch((int)(( (int)(imageType5) ))){
            									case (int)0: {
HXLINE( 162)										 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::BytesImg b30 = byt5;
HXDLIN( 162)										{
HXLINE( 162)											b30->width = width4;
HXDLIN( 162)											b30->height = height4;
HXDLIN( 162)											b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 162)											b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN( 162)											{
HXLINE( 162)												int len10 = b30->length;
HXDLIN( 162)												int w8 = 0;
HXDLIN( 162)												{
HXLINE( 162)													int _g84 = 0;
HXDLIN( 162)													int _g85 = b30->height;
HXDLIN( 162)													while((_g84 < _g85)){
HXLINE( 162)														_g84 = (_g84 + 1);
HXDLIN( 162)														int y14 = (_g84 - 1);
HXDLIN( 162)														{
HXLINE( 162)															int _g86 = 0;
HXDLIN( 162)															int _g87 = b30->width;
HXDLIN( 162)															while((_g86 < _g87)){
HXLINE( 162)																_g86 = (_g86 + 1);
HXDLIN( 162)																int x14 = (_g86 - 1);
HXDLIN( 162)																{
HXLINE( 162)																	w8 = (w8 + 1);
HXDLIN( 162)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w8 = (w8 + 1);
HXDLIN( 162)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w8 = (w8 + 1);
HXDLIN( 162)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 162)																{
HXLINE( 162)																	w8 = (w8 + 1);
HXDLIN( 162)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage4 = b30;
            									}
            									break;
            									case (int)1: {
HXLINE( 162)										 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::ArrIntImg a19 = arrI5;
HXDLIN( 162)										{
HXLINE( 162)											a19->width = width4;
HXDLIN( 162)											a19->height = height4;
HXDLIN( 162)											a19->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)											a19->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 162)											{
HXLINE( 162)												int _g88 = 0;
HXDLIN( 162)												int _g89 = a19->length;
HXDLIN( 162)												while((_g88 < _g89)){
HXLINE( 162)													_g88 = (_g88 + 1);
HXDLIN( 162)													int i36 = (_g88 - 1);
HXDLIN( 162)													a19->data[i36] = 0;
            												}
            											}
            										}
HXDLIN( 162)										undoImage4 = a19;
            									}
            									break;
            									case (int)2: {
HXLINE( 162)										 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::U32ArrImg b31 = u32a5;
HXDLIN( 162)										{
HXLINE( 162)											b31->width = width4;
HXDLIN( 162)											b31->height = height4;
HXDLIN( 162)											b31->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 162)											int size5 = (b31->length * 4);
HXDLIN( 162)											b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 162)											{
HXLINE( 162)												int _g90 = 0;
HXDLIN( 162)												int _g91 = b31->length;
HXDLIN( 162)												while((_g90 < _g91)){
HXLINE( 162)													_g90 = (_g90 + 1);
HXDLIN( 162)													int i37 = (_g90 - 1);
HXDLIN( 162)													{
HXLINE( 162)														 ::haxe::io::ArrayBufferViewImpl this82 = b31->data;
HXDLIN( 162)														bool undoImage5;
HXDLIN( 162)														if ((i37 >= 0)) {
HXLINE( 162)															undoImage5 = (i37 < (this82->byteLength >> 2));
            														}
            														else {
HXLINE( 162)															undoImage5 = false;
            														}
HXDLIN( 162)														if (undoImage5) {
HXLINE( 162)															 ::haxe::io::Bytes _this5 = this82->bytes;
HXDLIN( 162)															int pos5 = ((i37 << 2) + this82->byteOffset);
HXDLIN( 162)															_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 162)															_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)															_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)															_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage4 = b31;
            									}
            									break;
            									case (int)3: {
HXLINE( 162)										 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::VecIntImg v10 = vec5;
HXDLIN( 162)										{
HXLINE( 162)											v10->width = width4;
HXDLIN( 162)											v10->height = height4;
HXDLIN( 162)											v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 162)											v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 162)											{
HXLINE( 162)												int _g92 = 0;
HXDLIN( 162)												int _g93 = v10->length;
HXDLIN( 162)												while((_g92 < _g93)){
HXLINE( 162)													_g92 = (_g92 + 1);
HXDLIN( 162)													int i38 = (_g92 - 1);
HXDLIN( 162)													v10->data->__unsafe_set(i38,0);
            												}
            											}
            										}
HXDLIN( 162)										undoImage4 = v10;
            									}
            									break;
            									case (int)4: {
HXLINE( 162)										 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)										 ::iterMagic::StackIntImg b32 = sInt5;
HXDLIN( 162)										{
HXLINE( 162)											b32->width = width4;
HXDLIN( 162)											b32->height = height4;
HXDLIN( 162)											b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 162)											b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)											{
HXLINE( 162)												int len11 = b32->length;
HXDLIN( 162)												 ::haxe::ds::GenericStack_Int d5 = b32->data;
HXDLIN( 162)												if (::hx::IsNull( d5->head )) {
HXLINE( 162)													int _g94 = 0;
HXDLIN( 162)													int _g95 = len11;
HXDLIN( 162)													while((_g94 < _g95)){
HXLINE( 162)														_g94 = (_g94 + 1);
HXDLIN( 162)														int i39 = (_g94 - 1);
HXDLIN( 162)														d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            													}
            												}
            												else {
HXLINE( 162)													int _g96 = 0;
HXDLIN( 162)													int _g97 = len11;
HXDLIN( 162)													while((_g96 < _g97)){
HXLINE( 162)														_g96 = (_g96 + 1);
HXDLIN( 162)														int i40 = (_g96 - 1);
HXDLIN( 162)														{
HXLINE( 162)															 ::haxe::ds::GenericCell_Int l5 = b32->data->head;
HXDLIN( 162)															 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 162)															{
HXLINE( 162)																int _g98 = 0;
HXDLIN( 162)																int _g99 = i40;
HXDLIN( 162)																while((_g98 < _g99)){
HXLINE( 162)																	_g98 = (_g98 + 1);
HXDLIN( 162)																	int i41 = (_g98 - 1);
HXLINE( 345)																	prev5 = l5;
HXLINE( 346)																	l5 = l5->next;
            																}
            															}
HXLINE( 162)															if (::hx::IsNull( prev5 )) {
HXLINE( 162)																b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 162)																l5 = null();
            															}
            															else {
HXLINE( 162)																prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 162)																l5 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 162)										undoImage4 = b32;
            									}
            									break;
            								}
HXDLIN( 162)								this81->image = undoImage4;
HXDLIN( 162)								this81->width = width4;
HXDLIN( 162)								this81->height = height4;
HXDLIN( 162)								this81->imageType = ( (int)(imageType5) );
HXDLIN( 162)								undoImage3 = this81;
HXDLIN( 162)								{
HXLINE( 162)									int rectLeft1 = xIter31->start;
HXDLIN( 162)									int rectTop1 = yIter31->start;
HXDLIN( 162)									int rectRight1 = xIter31->max;
HXDLIN( 162)									bool forceClear1 = false;
HXDLIN( 162)									{
HXLINE( 162)										int _g100 = rectTop1;
HXDLIN( 162)										int _g101 = yIter31->max;
HXDLIN( 162)										while((_g100 < _g101)){
HXLINE( 162)											_g100 = (_g100 + 1);
HXDLIN( 162)											int dy2 = (_g100 - 1);
HXDLIN( 162)											{
HXLINE( 162)												int _g102 = rectLeft1;
HXDLIN( 162)												int _g103 = rectRight1;
HXDLIN( 162)												while((_g102 < _g103)){
HXLINE( 162)													_g102 = (_g102 + 1);
HXDLIN( 162)													int dx2 = (_g102 - 1);
HXDLIN( 162)													::Dynamic this83 = this46->image;
HXDLIN( 162)													int index12;
HXDLIN( 162)													if (this46->useVirtualPos) {
HXLINE( 162)														index12 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this46->virtualY) * ( (Float)(this46->width) )) + dx2) - this46->virtualX));
            													}
            													else {
HXLINE( 162)														index12 = ::Std_obj::_hx_int(( (Float)(((dy2 * this46->width) + dx2)) ));
            													}
HXDLIN( 162)													int c13 = ::iterMagic::Iimg_obj::get(this83,index12);
HXDLIN( 162)													int col2;
HXDLIN( 162)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)														col2 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE( 162)														col2 = c13;
            													}
HXDLIN( 162)													bool _hx_tmp32;
HXDLIN( 162)													if (this46->useMask) {
HXLINE( 162)														_hx_tmp32 = ::hx::IsNotNull( this46->mask );
            													}
            													else {
HXLINE( 162)														_hx_tmp32 = false;
            													}
HXDLIN( 162)													if (_hx_tmp32) {
HXLINE( 162)														 ::pi_xy::ImageStruct this84 = this46->mask;
HXDLIN( 162)														::Dynamic this85 = this84->image;
HXDLIN( 162)														int index13;
HXDLIN( 162)														if (this84->useVirtualPos) {
HXLINE( 162)															index13 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this84->virtualY) * ( (Float)(this84->width) )) + dx2) - this84->virtualX));
            														}
            														else {
HXLINE( 162)															index13 = ::Std_obj::_hx_int(( (Float)(((dy2 * this84->width) + dx2)) ));
            														}
HXDLIN( 162)														int c14 = ::iterMagic::Iimg_obj::get(this85,index13);
HXDLIN( 162)														int v11;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															v11 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															v11 = c14;
            														}
HXDLIN( 162)														int maskPixel1 = v11;
HXDLIN( 162)														int this86 = col2;
HXDLIN( 162)														if ((maskPixel1 == 0)) {
HXLINE( 162)															col2 = this86;
            														}
            														else {
HXLINE( 162)															Float m01;
HXDLIN( 162)															int this87 = ((maskPixel1 >> 24) & 255);
HXDLIN( 162)															if ((this87 == 0)) {
HXLINE( 162)																m01 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m01 = (( (Float)(this87) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m11;
HXDLIN( 162)															int this88 = ((maskPixel1 >> 16) & 255);
HXDLIN( 162)															if ((this88 == 0)) {
HXLINE( 162)																m11 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m11 = (( (Float)(this88) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m21;
HXDLIN( 162)															int this89 = ((maskPixel1 >> 8) & 255);
HXDLIN( 162)															if ((this89 == 0)) {
HXLINE( 162)																m21 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m21 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float m31;
HXDLIN( 162)															int this90 = (maskPixel1 & 255);
HXDLIN( 162)															if ((this90 == 0)) {
HXLINE( 162)																m31 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																m31 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this86 >> 24) & 255)) )));
HXDLIN( 162)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this86 >> 16) & 255)) )));
HXDLIN( 162)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this86 >> 8) & 255)) )));
HXDLIN( 162)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this86 & 255)) )));
HXDLIN( 162)															col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 162)													if ((col2 != 0)) {
HXLINE( 162)														int x15 = (dx2 - rectLeft1);
HXDLIN( 162)														int y15 = (dy2 - rectTop1);
HXDLIN( 162)														int c15 = col2;
HXDLIN( 162)														bool _hx_tmp33;
HXDLIN( 162)														if ((((c15 >> 24) & 255) < 254)) {
HXLINE( 162)															_hx_tmp33 = undoImage3->transparent;
            														}
            														else {
HXLINE( 162)															_hx_tmp33 = false;
            														}
HXDLIN( 162)														if (_hx_tmp33) {
HXLINE( 162)															int location5;
HXDLIN( 162)															if (undoImage3->useVirtualPos) {
HXLINE( 162)																location5 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 162)																location5 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN( 162)															int this91 = ::iterMagic::Iimg_obj::get(undoImage3->image,location5);
HXDLIN( 162)															int this92;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																this92 = this91;
            															}
HXDLIN( 162)															Float a110;
HXDLIN( 162)															int this93 = ((this92 >> 24) & 255);
HXDLIN( 162)															if ((this93 == 0)) {
HXLINE( 162)																a110 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a110 = (( (Float)(this93) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r15;
HXDLIN( 162)															int this94 = ((this92 >> 16) & 255);
HXDLIN( 162)															if ((this94 == 0)) {
HXLINE( 162)																r15 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r15 = (( (Float)(this94) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g15;
HXDLIN( 162)															int this95 = ((this92 >> 8) & 255);
HXDLIN( 162)															if ((this95 == 0)) {
HXLINE( 162)																g15 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g15 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b112;
HXDLIN( 162)															int this96 = (this92 & 255);
HXDLIN( 162)															if ((this96 == 0)) {
HXLINE( 162)																b112 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b112 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a25;
HXDLIN( 162)															int this97 = ((col2 >> 24) & 255);
HXDLIN( 162)															if ((this97 == 0)) {
HXLINE( 162)																a25 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a25 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r25;
HXDLIN( 162)															int this98 = ((col2 >> 16) & 255);
HXDLIN( 162)															if ((this98 == 0)) {
HXLINE( 162)																r25 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r25 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g25;
HXDLIN( 162)															int this99 = ((col2 >> 8) & 255);
HXDLIN( 162)															if ((this99 == 0)) {
HXLINE( 162)																g25 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g25 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b210;
HXDLIN( 162)															int this100 = (col2 & 255);
HXDLIN( 162)															if ((this100 == 0)) {
HXLINE( 162)																b210 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b210 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 162)															int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 162)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 162)															int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a35) + (b210 * a25))));
HXDLIN( 162)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 162)															int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b33);
HXDLIN( 162)															{
HXLINE( 162)																int _hx_tmp34;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp34 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp34 = blended5;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(undoImage3->image,location5,_hx_tmp34);
            															}
            														}
            														else {
HXLINE( 162)															::Dynamic this101 = undoImage3->image;
HXDLIN( 162)															int index14;
HXDLIN( 162)															if (undoImage3->useVirtualPos) {
HXLINE( 162)																index14 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 162)																index14 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN( 162)															int _hx_tmp35;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp35 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp35 = c15;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this101,index14,_hx_tmp35);
            														}
            													}
            													else {
HXLINE( 162)														if (forceClear1) {
HXLINE( 162)															::Dynamic this102 = undoImage3->image;
HXDLIN( 162)															int x16 = (dx2 - rectLeft1);
HXDLIN( 162)															int y16 = (dy2 - rectTop1);
HXDLIN( 162)															int index15;
HXDLIN( 162)															if (undoImage3->useVirtualPos) {
HXLINE( 162)																index15 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x16) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 162)																index15 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage3->width) + x16)) ));
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this102,index15,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							{
HXLINE( 162)								int _g_min2 = xIter31->start;
HXDLIN( 162)								int _g_max2 = xIter31->max;
HXDLIN( 162)								while((_g_min2 < _g_max2)){
HXLINE( 162)									_g_min2 = (_g_min2 + 1);
HXDLIN( 162)									int px1 = (_g_min2 - 1);
HXDLIN( 162)									Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN( 162)									{
HXLINE( 162)										int _g_min3 = yIter31->start;
HXDLIN( 162)										int _g_max3 = yIter31->max;
HXDLIN( 162)										while((_g_min3 < _g_max3)){
HXLINE( 162)											_g_min3 = (_g_min3 + 1);
HXDLIN( 162)											int py1 = (_g_min3 - 1);
HXDLIN( 162)											Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN( 162)											Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 162)											Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 162)											Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 162)											Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 162)											Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 162)											bool _hx_tmp36;
HXDLIN( 162)											bool _hx_tmp37;
HXDLIN( 162)											if ((ratioA1 >= 0)) {
HXLINE( 162)												_hx_tmp37 = (ratioB1 >= 0);
            											}
            											else {
HXLINE( 162)												_hx_tmp37 = false;
            											}
HXDLIN( 162)											if (_hx_tmp37) {
HXLINE( 162)												_hx_tmp36 = (ratioC1 >= 0);
            											}
            											else {
HXLINE( 162)												_hx_tmp36 = false;
            											}
HXDLIN( 162)											if (_hx_tmp36) {
HXLINE( 162)												Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN( 162)												Float v12 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN( 162)												int x17 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN( 162)												int y17 = ::Std_obj::_hx_int(((v12 * win_height) + win_y));
HXDLIN( 162)												::Dynamic this103 = this43->image;
HXDLIN( 162)												int index16;
HXDLIN( 162)												if (this43->useVirtualPos) {
HXLINE( 162)													index16 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this43->virtualY) * ( (Float)(this43->width) )) + x17) - this43->virtualX));
            												}
            												else {
HXLINE( 162)													index16 = ::Std_obj::_hx_int(( (Float)(((y17 * this43->width) + x17)) ));
            												}
HXDLIN( 162)												int c16 = ::iterMagic::Iimg_obj::get(this103,index16);
HXDLIN( 162)												int col3;
HXDLIN( 162)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)													col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXLINE( 162)													col3 = c16;
            												}
HXDLIN( 162)												{
HXLINE( 162)													int c17 = col3;
HXDLIN( 162)													bool _hx_tmp38;
HXDLIN( 162)													if ((((c17 >> 24) & 255) < 254)) {
HXLINE( 162)														_hx_tmp38 = this46->transparent;
            													}
            													else {
HXLINE( 162)														_hx_tmp38 = false;
            													}
HXDLIN( 162)													if (_hx_tmp38) {
HXLINE( 162)														int location6;
HXDLIN( 162)														if (this46->useVirtualPos) {
HXLINE( 162)															location6 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this46->virtualY) * ( (Float)(this46->width) )) + px1) - this46->virtualX));
            														}
            														else {
HXLINE( 162)															location6 = ::Std_obj::_hx_int(( (Float)(((py1 * this46->width) + px1)) ));
            														}
HXDLIN( 162)														int this104 = ::iterMagic::Iimg_obj::get(this46->image,location6);
HXDLIN( 162)														int this105;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															this105 = ((((((this104 >> 24) & 255) << 24) | ((this104 & 255) << 16)) | (((this104 >> 8) & 255) << 8)) | ((this104 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															this105 = this104;
            														}
HXDLIN( 162)														Float a111;
HXDLIN( 162)														int this106 = ((this105 >> 24) & 255);
HXDLIN( 162)														if ((this106 == 0)) {
HXLINE( 162)															a111 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															a111 = (( (Float)(this106) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float r16;
HXDLIN( 162)														int this107 = ((this105 >> 16) & 255);
HXDLIN( 162)														if ((this107 == 0)) {
HXLINE( 162)															r16 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															r16 = (( (Float)(this107) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float g16;
HXDLIN( 162)														int this108 = ((this105 >> 8) & 255);
HXDLIN( 162)														if ((this108 == 0)) {
HXLINE( 162)															g16 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															g16 = (( (Float)(this108) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float b113;
HXDLIN( 162)														int this109 = (this105 & 255);
HXDLIN( 162)														if ((this109 == 0)) {
HXLINE( 162)															b113 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															b113 = (( (Float)(this109) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float a26;
HXDLIN( 162)														int this110 = ((col3 >> 24) & 255);
HXDLIN( 162)														if ((this110 == 0)) {
HXLINE( 162)															a26 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															a26 = (( (Float)(this110) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float r26;
HXDLIN( 162)														int this111 = ((col3 >> 16) & 255);
HXDLIN( 162)														if ((this111 == 0)) {
HXLINE( 162)															r26 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															r26 = (( (Float)(this111) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float g26;
HXDLIN( 162)														int this112 = ((col3 >> 8) & 255);
HXDLIN( 162)														if ((this112 == 0)) {
HXLINE( 162)															g26 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															g26 = (( (Float)(this112) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float b211;
HXDLIN( 162)														int this113 = (col3 & 255);
HXDLIN( 162)														if ((this113 == 0)) {
HXLINE( 162)															b211 = ((Float)0.);
            														}
            														else {
HXLINE( 162)															b211 = (( (Float)(this113) ) / ( (Float)(255) ));
            														}
HXDLIN( 162)														Float a36 = (a111 * (( (Float)(1) ) - a26));
HXDLIN( 162)														int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 162)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 162)														int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a36) + (b211 * a26))));
HXDLIN( 162)														int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 162)														int blended6 = ((((a27 << 24) | (r8 << 16)) | (g8 << 8)) | b34);
HXDLIN( 162)														{
HXLINE( 162)															int _hx_tmp39;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp39 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp39 = blended6;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this46->image,location6,_hx_tmp39);
            														}
            													}
            													else {
HXLINE( 162)														::Dynamic this114 = this46->image;
HXDLIN( 162)														int index17;
HXDLIN( 162)														if (this46->useVirtualPos) {
HXLINE( 162)															index17 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this46->virtualY) * ( (Float)(this46->width) )) + px1) - this46->virtualX));
            														}
            														else {
HXLINE( 162)															index17 = ::Std_obj::_hx_int(( (Float)(((py1 * this46->width) + px1)) ));
            														}
HXDLIN( 162)														int _hx_tmp40;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															_hx_tmp40 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															_hx_tmp40 = c17;
            														}
HXDLIN( 162)														::iterMagic::Iimg_obj::set(this114,index17,_hx_tmp40);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 162)							 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 162)							int v_undoY1;
HXDLIN( 162)							int v_undoX1;
HXDLIN( 162)							Float v_ty1;
HXDLIN( 162)							Float v_tx1;
HXDLIN( 162)							Float v_t01;
HXDLIN( 162)							Float v_sy1;
HXDLIN( 162)							Float v_sx1;
HXDLIN( 162)							Float v_s01;
HXDLIN( 162)							Float v_A1;
HXDLIN( 162)							Float ax2 = bx;
HXDLIN( 162)							Float ay2 = by;
HXDLIN( 162)							 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 162)							Float bx2 = cx;
HXDLIN( 162)							Float by2 = cy;
HXDLIN( 162)							Float cx2 = dx;
HXDLIN( 162)							Float cy2 = dy;
HXDLIN( 162)							bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN( 162)							if (!(adjustWinding1)) {
HXLINE( 162)								Float bx_1 = bx2;
HXDLIN( 162)								Float by_1 = by2;
HXLINE(  24)								bx2 = cx2;
HXLINE(  25)								by2 = cy2;
HXLINE(  26)								cx2 = bx_1;
HXLINE(  27)								cy2 = by_1;
            							}
HXLINE( 162)							Float v_ax1 = ax2;
HXDLIN( 162)							Float v_ay1 = ay2;
HXDLIN( 162)							Float v_bx1 = bx2;
HXDLIN( 162)							Float v_by1 = by2;
HXDLIN( 162)							Float v_cx1 = cx2;
HXDLIN( 162)							Float v_cy1 = cy2;
HXDLIN( 162)							bool v_preCalculated1 = true;
HXDLIN( 162)							{
HXLINE( 162)								v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 162)								v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 162)								v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 162)								v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 162)								v_tx1 = (v_ay1 - v_by1);
HXDLIN( 162)								v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 162)								v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 162)								Float a28 = v_ax1;
HXDLIN( 162)								Float b35 = v_bx1;
HXDLIN( 162)								Float c18 = v_cx1;
HXDLIN( 162)								if ((a28 > b35)) {
HXLINE( 162)									if ((a28 > c18)) {
HXLINE( 162)										int min14;
HXDLIN( 162)										if ((b35 > c18)) {
HXLINE( 162)											min14 = ::Math_obj::floor(c18);
            										}
            										else {
HXLINE( 162)											min14 = ::Math_obj::floor(b35);
            										}
HXDLIN( 162)										int ii_min32 = min14;
HXDLIN( 162)										int ii_max32 = ::Math_obj::ceil(a28);
HXDLIN( 162)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            									}
            									else {
HXLINE( 162)										int ii_min33 = ::Math_obj::floor(b35);
HXDLIN( 162)										int ii_max33 = ::Math_obj::ceil(c18);
HXDLIN( 162)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            									}
            								}
            								else {
HXLINE( 162)									if ((b35 > c18)) {
HXLINE( 162)										int min15;
HXDLIN( 162)										if ((a28 > c18)) {
HXLINE( 162)											min15 = ::Math_obj::floor(c18);
            										}
            										else {
HXLINE( 162)											min15 = ::Math_obj::ceil(a28);
            										}
HXDLIN( 162)										int ii_min34 = min15;
HXDLIN( 162)										int ii_max34 = ::Math_obj::ceil(b35);
HXDLIN( 162)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            									}
            									else {
HXLINE( 162)										int ii_min35 = ::Math_obj::floor(a28);
HXDLIN( 162)										int ii_max35 = ::Math_obj::ceil(c18);
HXDLIN( 162)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            									}
            								}
HXDLIN( 162)								Float a29 = v_ay1;
HXDLIN( 162)								Float b36 = v_by1;
HXDLIN( 162)								Float c19 = v_cy1;
HXDLIN( 162)								if ((a29 > b36)) {
HXLINE( 162)									if ((a29 > c19)) {
HXLINE( 162)										int min16;
HXDLIN( 162)										if ((b36 > c19)) {
HXLINE( 162)											min16 = ::Math_obj::floor(c19);
            										}
            										else {
HXLINE( 162)											min16 = ::Math_obj::floor(b36);
            										}
HXDLIN( 162)										int ii_min36 = min16;
HXDLIN( 162)										int ii_max36 = ::Math_obj::ceil(a29);
HXDLIN( 162)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            									}
            									else {
HXLINE( 162)										int ii_min37 = ::Math_obj::floor(b36);
HXDLIN( 162)										int ii_max37 = ::Math_obj::ceil(c19);
HXDLIN( 162)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            									}
            								}
            								else {
HXLINE( 162)									if ((b36 > c19)) {
HXLINE( 162)										int min17;
HXDLIN( 162)										if ((a29 > c19)) {
HXLINE( 162)											min17 = ::Math_obj::floor(c19);
            										}
            										else {
HXLINE( 162)											min17 = ::Math_obj::ceil(a29);
            										}
HXDLIN( 162)										int ii_min38 = min17;
HXDLIN( 162)										int ii_max38 = ::Math_obj::ceil(b36);
HXDLIN( 162)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            									}
            									else {
HXLINE( 162)										int ii_min39 = ::Math_obj::floor(a29);
HXDLIN( 162)										int ii_max39 = ::Math_obj::ceil(c19);
HXDLIN( 162)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            									}
            								}
            							}
HXDLIN( 162)							if (hasUndo1) {
HXLINE( 162)								v_undoImage1 = undoImage3;
HXDLIN( 162)								v_undoX1 = xIter31->start;
HXDLIN( 162)								v_undoY1 = yIter31->start;
            							}
            						}
            					}
HXDLIN( 162)					bool _hx_tmp41;
HXDLIN( 162)					if (::hx::IsNotNull( nextImage3->mask )) {
HXLINE( 162)						_hx_tmp41 = includeMask;
            					}
            					else {
HXLINE( 162)						_hx_tmp41 = false;
            					}
HXDLIN( 162)					if (_hx_tmp41) {
HXLINE( 162)						 ::pi_xy::ImageStruct this115 = this43->mask;
HXDLIN( 162)						bool transparent1 = this43->mask->transparent;
HXDLIN( 162)						Float centreX2 = centreX1;
HXDLIN( 162)						Float centreY2 = centreY1;
HXDLIN( 162)						Float ax3 = ((Float)0.);
HXDLIN( 162)						Float ay3 = ((Float)0.);
HXDLIN( 162)						if ((centreX2 != ((Float)0.))) {
HXLINE( 173)							centreX2 = ((( (Float)(this115->width) ) / ( (Float)(2) )) + centreX2);
HXLINE( 162)							ax3 = (ax3 - centreX2);
            						}
HXDLIN( 162)						if ((centreY2 != ((Float)0.))) {
HXLINE( 177)							centreY2 = ((( (Float)(this115->height) ) / ( (Float)(2) )) + centreY2);
HXLINE( 162)							ay3 = (ay3 - centreY2);
            						}
HXDLIN( 162)						Float bx3 = (ax3 + this115->width);
HXDLIN( 162)						Float by3 = ay3;
HXDLIN( 162)						Float cx3 = bx3;
HXDLIN( 162)						Float cy3 = (ay3 + this115->height);
HXDLIN( 162)						Float dx3 = ax3;
HXDLIN( 162)						Float dy3 = cy3;
HXDLIN( 162)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 162)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 162)						Float temp6 = ax3;
HXLINE( 189)						ax3 = ((temp6 * cos1) - (ay3 * sin1));
HXLINE( 190)						ay3 = ((ay3 * cos1) + (temp6 * sin1));
HXLINE( 162)						Float temp7 = bx3;
HXLINE( 192)						bx3 = ((temp7 * cos1) - (by3 * sin1));
HXLINE( 193)						by3 = ((by3 * cos1) + (temp7 * sin1));
HXLINE( 162)						Float temp8 = cx3;
HXLINE( 195)						cx3 = ((temp8 * cos1) - (cy3 * sin1));
HXLINE( 196)						cy3 = ((cy3 * cos1) + (temp8 * sin1));
HXLINE( 162)						Float temp9 = dx3;
HXLINE( 198)						dx3 = ((temp9 * cos1) - (dy3 * sin1));
HXLINE( 199)						dy3 = ((dy3 * cos1) + (temp9 * sin1));
HXLINE( 162)						if ((centreX2 != ((Float)0.))) {
HXLINE( 162)							ax3 = (ax3 + centreX2);
HXDLIN( 162)							bx3 = (bx3 + centreX2);
HXDLIN( 162)							cx3 = (cx3 + centreX2);
HXDLIN( 162)							dx3 = (dx3 + centreX2);
            						}
HXDLIN( 162)						if ((centreY2 != ((Float)0.))) {
HXLINE( 162)							ay3 = (ay3 + centreY2);
HXDLIN( 162)							by3 = (by3 + centreY2);
HXDLIN( 162)							cy3 = (cy3 + centreY2);
HXDLIN( 162)							dy3 = (dy3 + centreY2);
            						}
HXDLIN( 162)						int min18 = ::Math_obj::floor(ax3);
HXDLIN( 162)						int max2 = ::Math_obj::ceil(ax3);
HXDLIN( 162)						if ((bx3 < min18)) {
HXLINE(  31)							min18 = ::Math_obj::floor(bx3);
            						}
            						else {
HXLINE( 162)							if ((bx3 > max2)) {
HXLINE(  33)								max2 = ::Math_obj::ceil(bx3);
            							}
            						}
HXLINE( 162)						if ((cx3 < min18)) {
HXLINE(  36)							min18 = ::Math_obj::floor(cx3);
            						}
            						else {
HXLINE( 162)							if ((cx3 > max2)) {
HXLINE(  38)								max2 = ::Math_obj::ceil(cx3);
            							}
            						}
HXLINE( 162)						if ((dx3 < min18)) {
HXLINE(  41)							min18 = ::Math_obj::floor(dx3);
            						}
            						else {
HXLINE( 162)							if ((dx3 > max2)) {
HXLINE(  43)								max2 = ::Math_obj::ceil(dx3);
            							}
            						}
HXLINE( 162)						int ii_min40 = min18;
HXDLIN( 162)						int ii_max40 = max2;
HXDLIN( 162)						 ::pi_xy::iter::IntIterStart boundX1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
HXDLIN( 162)						int min19 = ::Math_obj::floor(ay3);
HXDLIN( 162)						int max3 = ::Math_obj::ceil(ay3);
HXDLIN( 162)						if ((by3 < min19)) {
HXLINE(  31)							min19 = ::Math_obj::floor(by3);
            						}
            						else {
HXLINE( 162)							if ((by3 > max3)) {
HXLINE(  33)								max3 = ::Math_obj::ceil(by3);
            							}
            						}
HXLINE( 162)						if ((cy3 < min19)) {
HXLINE(  36)							min19 = ::Math_obj::floor(cy3);
            						}
            						else {
HXLINE( 162)							if ((cy3 > max3)) {
HXLINE(  38)								max3 = ::Math_obj::ceil(cy3);
            							}
            						}
HXLINE( 162)						if ((dy3 < min19)) {
HXLINE(  41)							min19 = ::Math_obj::floor(dy3);
            						}
            						else {
HXLINE( 162)							if ((dy3 > max3)) {
HXLINE(  43)								max3 = ::Math_obj::ceil(dy3);
            							}
            						}
HXLINE( 162)						int ii_min41 = min19;
HXDLIN( 162)						int ii_max41 = max3;
HXDLIN( 162)						 ::pi_xy::iter::IntIterStart boundY1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
HXDLIN( 162)						int minX1 = boundX1->start;
HXDLIN( 162)						int wid1 = ((boundX1->max - boundX1->start) + 1);
HXDLIN( 162)						int minY1 = boundY1->start;
HXDLIN( 162)						int hi1 = ((boundY1->max - boundY1->start) + 1);
HXDLIN( 162)						 ::Dynamic imageType6 = null();
HXDLIN( 162)						 ::pi_xy::ImageStruct this116 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 162)						::Dynamic _hx_tmp42;
HXDLIN( 162)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXLINE( 162)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)								 ::iterMagic::BytesImg b37 = byt6;
HXDLIN( 162)								{
HXLINE( 162)									b37->width = wid1;
HXDLIN( 162)									b37->height = hi1;
HXDLIN( 162)									b37->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 162)									b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN( 162)									{
HXLINE( 162)										int len12 = b37->length;
HXDLIN( 162)										int w9 = 0;
HXDLIN( 162)										{
HXLINE( 162)											int _g104 = 0;
HXDLIN( 162)											int _g105 = b37->height;
HXDLIN( 162)											while((_g104 < _g105)){
HXLINE( 162)												_g104 = (_g104 + 1);
HXDLIN( 162)												int y18 = (_g104 - 1);
HXDLIN( 162)												{
HXLINE( 162)													int _g106 = 0;
HXDLIN( 162)													int _g107 = b37->width;
HXDLIN( 162)													while((_g106 < _g107)){
HXLINE( 162)														_g106 = (_g106 + 1);
HXDLIN( 162)														int x18 = (_g106 - 1);
HXDLIN( 162)														{
HXLINE( 162)															w9 = (w9 + 1);
HXDLIN( 162)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 162)														{
HXLINE( 162)															w9 = (w9 + 1);
HXDLIN( 162)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 162)														{
HXLINE( 162)															w9 = (w9 + 1);
HXDLIN( 162)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 162)														{
HXLINE( 162)															w9 = (w9 + 1);
HXDLIN( 162)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								_hx_tmp42 = b37;
            							}
            							break;
            							case (int)1: {
HXLINE( 162)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)								 ::iterMagic::ArrIntImg a30 = arrI6;
HXDLIN( 162)								{
HXLINE( 162)									a30->width = wid1;
HXDLIN( 162)									a30->height = hi1;
HXDLIN( 162)									a30->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)									a30->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 162)									{
HXLINE( 162)										int _g108 = 0;
HXDLIN( 162)										int _g109 = a30->length;
HXDLIN( 162)										while((_g108 < _g109)){
HXLINE( 162)											_g108 = (_g108 + 1);
HXDLIN( 162)											int i42 = (_g108 - 1);
HXDLIN( 162)											a30->data[i42] = 0;
            										}
            									}
            								}
HXDLIN( 162)								_hx_tmp42 = a30;
            							}
            							break;
            							case (int)2: {
HXLINE( 162)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)								 ::iterMagic::U32ArrImg b38 = u32a6;
HXDLIN( 162)								{
HXLINE( 162)									b38->width = wid1;
HXDLIN( 162)									b38->height = hi1;
HXDLIN( 162)									b38->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 162)									int size6 = (b38->length * 4);
HXDLIN( 162)									b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 162)									{
HXLINE( 162)										int _g110 = 0;
HXDLIN( 162)										int _g111 = b38->length;
HXDLIN( 162)										while((_g110 < _g111)){
HXLINE( 162)											_g110 = (_g110 + 1);
HXDLIN( 162)											int i43 = (_g110 - 1);
HXDLIN( 162)											{
HXLINE( 162)												 ::haxe::io::ArrayBufferViewImpl this117 = b38->data;
HXDLIN( 162)												bool _hx_tmp43;
HXDLIN( 162)												if ((i43 >= 0)) {
HXLINE( 162)													_hx_tmp43 = (i43 < (this117->byteLength >> 2));
            												}
            												else {
HXLINE( 162)													_hx_tmp43 = false;
            												}
HXDLIN( 162)												if (_hx_tmp43) {
HXLINE( 162)													 ::haxe::io::Bytes _this6 = this117->bytes;
HXDLIN( 162)													int pos6 = ((i43 << 2) + this117->byteOffset);
HXDLIN( 162)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 162)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								_hx_tmp42 = b38;
            							}
            							break;
            							case (int)3: {
HXLINE( 162)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)								 ::iterMagic::VecIntImg v13 = vec6;
HXDLIN( 162)								{
HXLINE( 162)									v13->width = wid1;
HXDLIN( 162)									v13->height = hi1;
HXDLIN( 162)									v13->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 162)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 162)									{
HXLINE( 162)										int _g112 = 0;
HXDLIN( 162)										int _g113 = v13->length;
HXDLIN( 162)										while((_g112 < _g113)){
HXLINE( 162)											_g112 = (_g112 + 1);
HXDLIN( 162)											int i44 = (_g112 - 1);
HXDLIN( 162)											v13->data->__unsafe_set(i44,0);
            										}
            									}
            								}
HXDLIN( 162)								_hx_tmp42 = v13;
            							}
            							break;
            							case (int)4: {
HXLINE( 162)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)								 ::iterMagic::StackIntImg b39 = sInt6;
HXDLIN( 162)								{
HXLINE( 162)									b39->width = wid1;
HXDLIN( 162)									b39->height = hi1;
HXDLIN( 162)									b39->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 162)									b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)									{
HXLINE( 162)										int len13 = b39->length;
HXDLIN( 162)										 ::haxe::ds::GenericStack_Int d6 = b39->data;
HXDLIN( 162)										if (::hx::IsNull( d6->head )) {
HXLINE( 162)											int _g114 = 0;
HXDLIN( 162)											int _g115 = len13;
HXDLIN( 162)											while((_g114 < _g115)){
HXLINE( 162)												_g114 = (_g114 + 1);
HXDLIN( 162)												int i45 = (_g114 - 1);
HXDLIN( 162)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXLINE( 162)											int _g116 = 0;
HXDLIN( 162)											int _g117 = len13;
HXDLIN( 162)											while((_g116 < _g117)){
HXLINE( 162)												_g116 = (_g116 + 1);
HXDLIN( 162)												int i46 = (_g116 - 1);
HXDLIN( 162)												{
HXLINE( 162)													 ::haxe::ds::GenericCell_Int l6 = b39->data->head;
HXDLIN( 162)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 162)													{
HXLINE( 162)														int _g118 = 0;
HXDLIN( 162)														int _g119 = i46;
HXDLIN( 162)														while((_g118 < _g119)){
HXLINE( 162)															_g118 = (_g118 + 1);
HXDLIN( 162)															int i47 = (_g118 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE( 162)													if (::hx::IsNull( prev6 )) {
HXLINE( 162)														b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 162)														l6 = null();
            													}
            													else {
HXLINE( 162)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 162)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								_hx_tmp42 = b39;
            							}
            							break;
            						}
HXDLIN( 162)						this116->image = _hx_tmp42;
HXDLIN( 162)						this116->width = wid1;
HXDLIN( 162)						this116->height = hi1;
HXDLIN( 162)						this116->imageType = ( (int)(imageType6) );
HXDLIN( 162)						 ::pi_xy::ImageStruct nextImage4 = this116;
HXDLIN( 162)						nextImage4->transparent = true;
HXDLIN( 162)						if ((minX1 < ((Float)0.))) {
HXLINE( 162)							ax3 = (ax3 - ( (Float)(minX1) ));
HXDLIN( 162)							bx3 = (bx3 - ( (Float)(minX1) ));
HXDLIN( 162)							cx3 = (cx3 - ( (Float)(minX1) ));
HXDLIN( 162)							dx3 = (dx3 - ( (Float)(minX1) ));
            						}
HXDLIN( 162)						if ((minY1 < ((Float)0.))) {
HXLINE( 162)							ay3 = (ay3 - ( (Float)(minY1) ));
HXDLIN( 162)							by3 = (by3 - ( (Float)(minY1) ));
HXDLIN( 162)							cy3 = (cy3 - ( (Float)(minY1) ));
HXDLIN( 162)							dy3 = (dy3 - ( (Float)(minY1) ));
            						}
HXDLIN( 162)						{
HXLINE( 162)							 ::pi_xy::ImageStruct this118 = nextImage4;
HXDLIN( 162)							Float win_x1 = ( (Float)(0) );
HXDLIN( 162)							Float win_y1 = ( (Float)(0) );
HXDLIN( 162)							Float win_width1 = ( (Float)(this115->width) );
HXDLIN( 162)							Float win_height1 = ( (Float)(this115->height) );
HXDLIN( 162)							{
HXLINE( 162)								Float bu3 = ((Float)1.);
HXDLIN( 162)								Float bv3 = ((Float)0.);
HXDLIN( 162)								Float cu1 = ((Float)1.);
HXDLIN( 162)								Float cv1 = ((Float)1.);
HXDLIN( 162)								Float du1 = ((Float)0.);
HXDLIN( 162)								Float dv1 = ((Float)1.);
HXDLIN( 162)								Float au2 = ((Float)0.);
HXDLIN( 162)								Float av2 = ((Float)0.);
HXDLIN( 162)								Float bu4 = bu3;
HXDLIN( 162)								Float bv4 = bv3;
HXDLIN( 162)								bool hasUndo2 = false;
HXDLIN( 162)								Float temp10 = au2;
HXLINE( 422)								au2 = bu4;
HXLINE( 423)								bu4 = temp10;
HXLINE( 424)								temp10 = av2;
HXLINE( 425)								av2 = bv4;
HXLINE( 426)								bv4 = temp10;
HXLINE( 162)								Float bcx2 = (bx3 - dx3);
HXDLIN( 162)								Float bcy2 = (by3 - dy3);
HXDLIN( 162)								Float acx2 = (ax3 - dx3);
HXDLIN( 162)								Float acy2 = (ay3 - dy3);
HXDLIN( 162)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 162)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 162)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 162)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 162)								if ((ax3 > bx3)) {
HXLINE( 162)									if ((ax3 > dx3)) {
HXLINE( 162)										int min20;
HXDLIN( 162)										if ((bx3 > dx3)) {
HXLINE( 162)											min20 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 162)											min20 = ::Math_obj::floor(bx3);
            										}
HXDLIN( 162)										int ii_min42 = min20;
HXDLIN( 162)										int ii_max42 = ::Math_obj::ceil(ax3);
HXDLIN( 162)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            									}
            									else {
HXLINE( 162)										int ii_min43 = ::Math_obj::floor(bx3);
HXDLIN( 162)										int ii_max43 = ::Math_obj::ceil(dx3);
HXDLIN( 162)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            									}
            								}
            								else {
HXLINE( 162)									if ((bx3 > dx3)) {
HXLINE( 162)										int min21;
HXDLIN( 162)										if ((ax3 > dx3)) {
HXLINE( 162)											min21 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 162)											min21 = ::Math_obj::ceil(ax3);
            										}
HXDLIN( 162)										int ii_min44 = min21;
HXDLIN( 162)										int ii_max44 = ::Math_obj::ceil(bx3);
HXDLIN( 162)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            									}
            									else {
HXLINE( 162)										int ii_min45 = ::Math_obj::floor(ax3);
HXDLIN( 162)										int ii_max45 = ::Math_obj::ceil(dx3);
HXDLIN( 162)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            									}
            								}
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 162)								if ((ay3 > by3)) {
HXLINE( 162)									if ((ay3 > dy3)) {
HXLINE( 162)										int min22;
HXDLIN( 162)										if ((by3 > dy3)) {
HXLINE( 162)											min22 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 162)											min22 = ::Math_obj::floor(by3);
            										}
HXDLIN( 162)										int ii_min46 = min22;
HXDLIN( 162)										int ii_max46 = ::Math_obj::ceil(ay3);
HXDLIN( 162)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            									}
            									else {
HXLINE( 162)										int ii_min47 = ::Math_obj::floor(by3);
HXDLIN( 162)										int ii_max47 = ::Math_obj::ceil(dy3);
HXDLIN( 162)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            									}
            								}
            								else {
HXLINE( 162)									if ((by3 > dy3)) {
HXLINE( 162)										int min23;
HXDLIN( 162)										if ((ay3 > dy3)) {
HXLINE( 162)											min23 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 162)											min23 = ::Math_obj::ceil(ay3);
            										}
HXDLIN( 162)										int ii_min48 = min23;
HXDLIN( 162)										int ii_max48 = ::Math_obj::ceil(by3);
HXDLIN( 162)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            									}
            									else {
HXLINE( 162)										int ii_min49 = ::Math_obj::floor(ay3);
HXDLIN( 162)										int ii_max49 = ::Math_obj::ceil(dy3);
HXDLIN( 162)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            									}
            								}
HXDLIN( 162)								 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 162)								if (hasUndo2) {
HXLINE( 162)									int width5 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 162)									int height5 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 162)									 ::Dynamic imageType7 = null();
HXDLIN( 162)									 ::pi_xy::ImageStruct this119 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)									if (::hx::IsNull( imageType7 )) {
HXLINE(  54)										imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 162)									::Dynamic undoImage7;
HXDLIN( 162)									switch((int)(( (int)(imageType7) ))){
            										case (int)0: {
HXLINE( 162)											 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::BytesImg b40 = byt7;
HXDLIN( 162)											{
HXLINE( 162)												b40->width = width5;
HXDLIN( 162)												b40->height = height5;
HXDLIN( 162)												b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 162)												b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN( 162)												{
HXLINE( 162)													int len14 = b40->length;
HXDLIN( 162)													int w10 = 0;
HXDLIN( 162)													{
HXLINE( 162)														int _g120 = 0;
HXDLIN( 162)														int _g121 = b40->height;
HXDLIN( 162)														while((_g120 < _g121)){
HXLINE( 162)															_g120 = (_g120 + 1);
HXDLIN( 162)															int y19 = (_g120 - 1);
HXDLIN( 162)															{
HXLINE( 162)																int _g122 = 0;
HXDLIN( 162)																int _g123 = b40->width;
HXDLIN( 162)																while((_g122 < _g123)){
HXLINE( 162)																	_g122 = (_g122 + 1);
HXDLIN( 162)																	int x19 = (_g122 - 1);
HXDLIN( 162)																	{
HXLINE( 162)																		w10 = (w10 + 1);
HXDLIN( 162)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w10 = (w10 + 1);
HXDLIN( 162)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w10 = (w10 + 1);
HXDLIN( 162)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w10 = (w10 + 1);
HXDLIN( 162)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage7 = b40;
            										}
            										break;
            										case (int)1: {
HXLINE( 162)											 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::ArrIntImg a37 = arrI7;
HXDLIN( 162)											{
HXLINE( 162)												a37->width = width5;
HXDLIN( 162)												a37->height = height5;
HXDLIN( 162)												a37->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)												a37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 162)												{
HXLINE( 162)													int _g124 = 0;
HXDLIN( 162)													int _g125 = a37->length;
HXDLIN( 162)													while((_g124 < _g125)){
HXLINE( 162)														_g124 = (_g124 + 1);
HXDLIN( 162)														int i48 = (_g124 - 1);
HXDLIN( 162)														a37->data[i48] = 0;
            													}
            												}
            											}
HXDLIN( 162)											undoImage7 = a37;
            										}
            										break;
            										case (int)2: {
HXLINE( 162)											 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::U32ArrImg b41 = u32a7;
HXDLIN( 162)											{
HXLINE( 162)												b41->width = width5;
HXDLIN( 162)												b41->height = height5;
HXDLIN( 162)												b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 162)												int size7 = (b41->length * 4);
HXDLIN( 162)												b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 162)												{
HXLINE( 162)													int _g126 = 0;
HXDLIN( 162)													int _g127 = b41->length;
HXDLIN( 162)													while((_g126 < _g127)){
HXLINE( 162)														_g126 = (_g126 + 1);
HXDLIN( 162)														int i49 = (_g126 - 1);
HXDLIN( 162)														{
HXLINE( 162)															 ::haxe::io::ArrayBufferViewImpl this120 = b41->data;
HXDLIN( 162)															bool undoImage8;
HXDLIN( 162)															if ((i49 >= 0)) {
HXLINE( 162)																undoImage8 = (i49 < (this120->byteLength >> 2));
            															}
            															else {
HXLINE( 162)																undoImage8 = false;
            															}
HXDLIN( 162)															if (undoImage8) {
HXLINE( 162)																 ::haxe::io::Bytes _this7 = this120->bytes;
HXDLIN( 162)																int pos7 = ((i49 << 2) + this120->byteOffset);
HXDLIN( 162)																_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 162)																_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)																_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)																_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage7 = b41;
            										}
            										break;
            										case (int)3: {
HXLINE( 162)											 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::VecIntImg v14 = vec7;
HXDLIN( 162)											{
HXLINE( 162)												v14->width = width5;
HXDLIN( 162)												v14->height = height5;
HXDLIN( 162)												v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 162)												v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN( 162)												{
HXLINE( 162)													int _g128 = 0;
HXDLIN( 162)													int _g129 = v14->length;
HXDLIN( 162)													while((_g128 < _g129)){
HXLINE( 162)														_g128 = (_g128 + 1);
HXDLIN( 162)														int i50 = (_g128 - 1);
HXDLIN( 162)														v14->data->__unsafe_set(i50,0);
            													}
            												}
            											}
HXDLIN( 162)											undoImage7 = v14;
            										}
            										break;
            										case (int)4: {
HXLINE( 162)											 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::StackIntImg b42 = sInt7;
HXDLIN( 162)											{
HXLINE( 162)												b42->width = width5;
HXDLIN( 162)												b42->height = height5;
HXDLIN( 162)												b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 162)												b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)												{
HXLINE( 162)													int len15 = b42->length;
HXDLIN( 162)													 ::haxe::ds::GenericStack_Int d7 = b42->data;
HXDLIN( 162)													if (::hx::IsNull( d7->head )) {
HXLINE( 162)														int _g130 = 0;
HXDLIN( 162)														int _g131 = len15;
HXDLIN( 162)														while((_g130 < _g131)){
HXLINE( 162)															_g130 = (_g130 + 1);
HXDLIN( 162)															int i51 = (_g130 - 1);
HXDLIN( 162)															d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            														}
            													}
            													else {
HXLINE( 162)														int _g132 = 0;
HXDLIN( 162)														int _g133 = len15;
HXDLIN( 162)														while((_g132 < _g133)){
HXLINE( 162)															_g132 = (_g132 + 1);
HXDLIN( 162)															int i52 = (_g132 - 1);
HXDLIN( 162)															{
HXLINE( 162)																 ::haxe::ds::GenericCell_Int l7 = b42->data->head;
HXDLIN( 162)																 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 162)																{
HXLINE( 162)																	int _g134 = 0;
HXDLIN( 162)																	int _g135 = i52;
HXDLIN( 162)																	while((_g134 < _g135)){
HXLINE( 162)																		_g134 = (_g134 + 1);
HXDLIN( 162)																		int i53 = (_g134 - 1);
HXLINE( 345)																		prev7 = l7;
HXLINE( 346)																		l7 = l7->next;
            																	}
            																}
HXLINE( 162)																if (::hx::IsNull( prev7 )) {
HXLINE( 162)																	b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 162)																	l7 = null();
            																}
            																else {
HXLINE( 162)																	prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 162)																	l7 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage7 = b42;
            										}
            										break;
            									}
HXDLIN( 162)									this119->image = undoImage7;
HXDLIN( 162)									this119->width = width5;
HXDLIN( 162)									this119->height = height5;
HXDLIN( 162)									this119->imageType = ( (int)(imageType7) );
HXDLIN( 162)									undoImage6 = this119;
HXDLIN( 162)									{
HXLINE( 162)										int rectLeft2 = xIter32->start;
HXDLIN( 162)										int rectTop2 = yIter32->start;
HXDLIN( 162)										int rectRight2 = xIter32->max;
HXDLIN( 162)										bool forceClear2 = false;
HXDLIN( 162)										{
HXLINE( 162)											int _g136 = rectTop2;
HXDLIN( 162)											int _g137 = yIter32->max;
HXDLIN( 162)											while((_g136 < _g137)){
HXLINE( 162)												_g136 = (_g136 + 1);
HXDLIN( 162)												int dy4 = (_g136 - 1);
HXDLIN( 162)												{
HXLINE( 162)													int _g138 = rectLeft2;
HXDLIN( 162)													int _g139 = rectRight2;
HXDLIN( 162)													while((_g138 < _g139)){
HXLINE( 162)														_g138 = (_g138 + 1);
HXDLIN( 162)														int dx4 = (_g138 - 1);
HXDLIN( 162)														::Dynamic this121 = this118->image;
HXDLIN( 162)														int index18;
HXDLIN( 162)														if (this118->useVirtualPos) {
HXLINE( 162)															index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this118->virtualY) * ( (Float)(this118->width) )) + dx4) - this118->virtualX));
            														}
            														else {
HXLINE( 162)															index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this118->width) + dx4)) ));
            														}
HXDLIN( 162)														int c20 = ::iterMagic::Iimg_obj::get(this121,index18);
HXDLIN( 162)														int col4;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															col4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															col4 = c20;
            														}
HXDLIN( 162)														bool _hx_tmp44;
HXDLIN( 162)														if (this118->useMask) {
HXLINE( 162)															_hx_tmp44 = ::hx::IsNotNull( this118->mask );
            														}
            														else {
HXLINE( 162)															_hx_tmp44 = false;
            														}
HXDLIN( 162)														if (_hx_tmp44) {
HXLINE( 162)															 ::pi_xy::ImageStruct this122 = this118->mask;
HXDLIN( 162)															::Dynamic this123 = this122->image;
HXDLIN( 162)															int index19;
HXDLIN( 162)															if (this122->useVirtualPos) {
HXLINE( 162)																index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this122->virtualY) * ( (Float)(this122->width) )) + dx4) - this122->virtualX));
            															}
            															else {
HXLINE( 162)																index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this122->width) + dx4)) ));
            															}
HXDLIN( 162)															int c21 = ::iterMagic::Iimg_obj::get(this123,index19);
HXDLIN( 162)															int v15;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																v15 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																v15 = c21;
            															}
HXDLIN( 162)															int maskPixel2 = v15;
HXDLIN( 162)															int this124 = col4;
HXDLIN( 162)															if ((maskPixel2 == 0)) {
HXLINE( 162)																col4 = this124;
            															}
            															else {
HXLINE( 162)																Float m02;
HXDLIN( 162)																int this125 = ((maskPixel2 >> 24) & 255);
HXDLIN( 162)																if ((this125 == 0)) {
HXLINE( 162)																	m02 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m02 = (( (Float)(this125) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m12;
HXDLIN( 162)																int this126 = ((maskPixel2 >> 16) & 255);
HXDLIN( 162)																if ((this126 == 0)) {
HXLINE( 162)																	m12 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m12 = (( (Float)(this126) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m22;
HXDLIN( 162)																int this127 = ((maskPixel2 >> 8) & 255);
HXDLIN( 162)																if ((this127 == 0)) {
HXLINE( 162)																	m22 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m22 = (( (Float)(this127) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m32;
HXDLIN( 162)																int this128 = (maskPixel2 & 255);
HXDLIN( 162)																if ((this128 == 0)) {
HXLINE( 162)																	m32 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m32 = (( (Float)(this128) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this124 >> 24) & 255)) )));
HXDLIN( 162)																int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this124 >> 16) & 255)) )));
HXDLIN( 162)																int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this124 >> 8) & 255)) )));
HXDLIN( 162)																int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this124 & 255)) )));
HXDLIN( 162)																col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 162)														if ((col4 != 0)) {
HXLINE( 162)															int x20 = (dx4 - rectLeft2);
HXDLIN( 162)															int y20 = (dy4 - rectTop2);
HXDLIN( 162)															int c22 = col4;
HXDLIN( 162)															bool _hx_tmp45;
HXDLIN( 162)															if ((((c22 >> 24) & 255) < 254)) {
HXLINE( 162)																_hx_tmp45 = undoImage6->transparent;
            															}
            															else {
HXLINE( 162)																_hx_tmp45 = false;
            															}
HXDLIN( 162)															if (_hx_tmp45) {
HXLINE( 162)																int location7;
HXDLIN( 162)																if (undoImage6->useVirtualPos) {
HXLINE( 162)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 162)																	location7 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN( 162)																int this129 = ::iterMagic::Iimg_obj::get(undoImage6->image,location7);
HXDLIN( 162)																int this130;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	this130 = ((((((this129 >> 24) & 255) << 24) | ((this129 & 255) << 16)) | (((this129 >> 8) & 255) << 8)) | ((this129 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	this130 = this129;
            																}
HXDLIN( 162)																Float a112;
HXDLIN( 162)																int this131 = ((this130 >> 24) & 255);
HXDLIN( 162)																if ((this131 == 0)) {
HXLINE( 162)																	a112 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	a112 = (( (Float)(this131) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float r17;
HXDLIN( 162)																int this132 = ((this130 >> 16) & 255);
HXDLIN( 162)																if ((this132 == 0)) {
HXLINE( 162)																	r17 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	r17 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float g17;
HXDLIN( 162)																int this133 = ((this130 >> 8) & 255);
HXDLIN( 162)																if ((this133 == 0)) {
HXLINE( 162)																	g17 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	g17 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float b114;
HXDLIN( 162)																int this134 = (this130 & 255);
HXDLIN( 162)																if ((this134 == 0)) {
HXLINE( 162)																	b114 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	b114 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float a210;
HXDLIN( 162)																int this135 = ((col4 >> 24) & 255);
HXDLIN( 162)																if ((this135 == 0)) {
HXLINE( 162)																	a210 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	a210 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float r27;
HXDLIN( 162)																int this136 = ((col4 >> 16) & 255);
HXDLIN( 162)																if ((this136 == 0)) {
HXLINE( 162)																	r27 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	r27 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float g27;
HXDLIN( 162)																int this137 = ((col4 >> 8) & 255);
HXDLIN( 162)																if ((this137 == 0)) {
HXLINE( 162)																	g27 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	g27 = (( (Float)(this137) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float b212;
HXDLIN( 162)																int this138 = (col4 & 255);
HXDLIN( 162)																if ((this138 == 0)) {
HXLINE( 162)																	b212 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	b212 = (( (Float)(this138) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 162)																int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a38) + (r27 * a210))));
HXDLIN( 162)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a38) + (g27 * a210))));
HXDLIN( 162)																int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN( 162)																int a39 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 162)																int blended7 = ((((a39 << 24) | (r9 << 16)) | (g9 << 8)) | b43);
HXDLIN( 162)																{
HXLINE( 162)																	int _hx_tmp46;
HXDLIN( 162)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																		_hx_tmp46 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXLINE( 162)																		_hx_tmp46 = blended7;
            																	}
HXDLIN( 162)																	::iterMagic::Iimg_obj::set(undoImage6->image,location7,_hx_tmp46);
            																}
            															}
            															else {
HXLINE( 162)																::Dynamic this139 = undoImage6->image;
HXDLIN( 162)																int index20;
HXDLIN( 162)																if (undoImage6->useVirtualPos) {
HXLINE( 162)																	index20 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 162)																	index20 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN( 162)																int _hx_tmp47;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp47 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp47 = c22;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this139,index20,_hx_tmp47);
            															}
            														}
            														else {
HXLINE( 162)															if (forceClear2) {
HXLINE( 162)																::Dynamic this140 = undoImage6->image;
HXDLIN( 162)																int x21 = (dx4 - rectLeft2);
HXDLIN( 162)																int y21 = (dy4 - rectTop2);
HXDLIN( 162)																int index21;
HXDLIN( 162)																if (undoImage6->useVirtualPos) {
HXLINE( 162)																	index21 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x21) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 162)																	index21 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage6->width) + x21)) ));
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this140,index21,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								{
HXLINE( 162)									int _g_min4 = xIter32->start;
HXDLIN( 162)									int _g_max4 = xIter32->max;
HXDLIN( 162)									while((_g_min4 < _g_max4)){
HXLINE( 162)										_g_min4 = (_g_min4 + 1);
HXDLIN( 162)										int px2 = (_g_min4 - 1);
HXDLIN( 162)										Float pcx2 = (( (Float)(px2) ) - dx3);
HXDLIN( 162)										{
HXLINE( 162)											int _g_min5 = yIter32->start;
HXDLIN( 162)											int _g_max5 = yIter32->max;
HXDLIN( 162)											while((_g_min5 < _g_max5)){
HXLINE( 162)												_g_min5 = (_g_min5 + 1);
HXDLIN( 162)												int py2 = (_g_min5 - 1);
HXDLIN( 162)												Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN( 162)												Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 162)												Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 162)												Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 162)												Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 162)												Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 162)												bool _hx_tmp48;
HXDLIN( 162)												bool _hx_tmp49;
HXDLIN( 162)												if ((ratioA2 >= 0)) {
HXLINE( 162)													_hx_tmp49 = (ratioB2 >= 0);
            												}
            												else {
HXLINE( 162)													_hx_tmp49 = false;
            												}
HXDLIN( 162)												if (_hx_tmp49) {
HXLINE( 162)													_hx_tmp48 = (ratioC2 >= 0);
            												}
            												else {
HXLINE( 162)													_hx_tmp48 = false;
            												}
HXDLIN( 162)												if (_hx_tmp48) {
HXLINE( 162)													Float u2 = (((au2 * ratioA2) + (bu4 * ratioB2)) + (du1 * ratioC2));
HXDLIN( 162)													Float v16 = (((av2 * ratioA2) + (bv4 * ratioB2)) + (dv1 * ratioC2));
HXDLIN( 162)													int x22 = ::Std_obj::_hx_int(((u2 * win_width1) + win_x1));
HXDLIN( 162)													int y22 = ::Std_obj::_hx_int(((v16 * win_height1) + win_y1));
HXDLIN( 162)													::Dynamic this141 = this115->image;
HXDLIN( 162)													int index22;
HXDLIN( 162)													if (this115->useVirtualPos) {
HXLINE( 162)														index22 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this115->virtualY) * ( (Float)(this115->width) )) + x22) - this115->virtualX));
            													}
            													else {
HXLINE( 162)														index22 = ::Std_obj::_hx_int(( (Float)(((y22 * this115->width) + x22)) ));
            													}
HXDLIN( 162)													int c23 = ::iterMagic::Iimg_obj::get(this141,index22);
HXDLIN( 162)													int col5;
HXDLIN( 162)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)														col5 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXLINE( 162)														col5 = c23;
            													}
HXDLIN( 162)													{
HXLINE( 162)														int c24 = col5;
HXDLIN( 162)														bool _hx_tmp50;
HXDLIN( 162)														if ((((c24 >> 24) & 255) < 254)) {
HXLINE( 162)															_hx_tmp50 = this118->transparent;
            														}
            														else {
HXLINE( 162)															_hx_tmp50 = false;
            														}
HXDLIN( 162)														if (_hx_tmp50) {
HXLINE( 162)															int location8;
HXDLIN( 162)															if (this118->useVirtualPos) {
HXLINE( 162)																location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this118->virtualY) * ( (Float)(this118->width) )) + px2) - this118->virtualX));
            															}
            															else {
HXLINE( 162)																location8 = ::Std_obj::_hx_int(( (Float)(((py2 * this118->width) + px2)) ));
            															}
HXDLIN( 162)															int this142 = ::iterMagic::Iimg_obj::get(this118->image,location8);
HXDLIN( 162)															int this143;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																this143 = ((((((this142 >> 24) & 255) << 24) | ((this142 & 255) << 16)) | (((this142 >> 8) & 255) << 8)) | ((this142 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																this143 = this142;
            															}
HXDLIN( 162)															Float a113;
HXDLIN( 162)															int this144 = ((this143 >> 24) & 255);
HXDLIN( 162)															if ((this144 == 0)) {
HXLINE( 162)																a113 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a113 = (( (Float)(this144) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r18;
HXDLIN( 162)															int this145 = ((this143 >> 16) & 255);
HXDLIN( 162)															if ((this145 == 0)) {
HXLINE( 162)																r18 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r18 = (( (Float)(this145) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g18;
HXDLIN( 162)															int this146 = ((this143 >> 8) & 255);
HXDLIN( 162)															if ((this146 == 0)) {
HXLINE( 162)																g18 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g18 = (( (Float)(this146) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b115;
HXDLIN( 162)															int this147 = (this143 & 255);
HXDLIN( 162)															if ((this147 == 0)) {
HXLINE( 162)																b115 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b115 = (( (Float)(this147) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a211;
HXDLIN( 162)															int this148 = ((col5 >> 24) & 255);
HXDLIN( 162)															if ((this148 == 0)) {
HXLINE( 162)																a211 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a211 = (( (Float)(this148) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r28;
HXDLIN( 162)															int this149 = ((col5 >> 16) & 255);
HXDLIN( 162)															if ((this149 == 0)) {
HXLINE( 162)																r28 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r28 = (( (Float)(this149) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g28;
HXDLIN( 162)															int this150 = ((col5 >> 8) & 255);
HXDLIN( 162)															if ((this150 == 0)) {
HXLINE( 162)																g28 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g28 = (( (Float)(this150) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b213;
HXDLIN( 162)															int this151 = (col5 & 255);
HXDLIN( 162)															if ((this151 == 0)) {
HXLINE( 162)																b213 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b213 = (( (Float)(this151) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 162)															int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a310) + (r28 * a211))));
HXDLIN( 162)															int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN( 162)															int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN( 162)															int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 162)															int blended8 = ((((a40 << 24) | (r10 << 16)) | (g10 << 8)) | b44);
HXDLIN( 162)															{
HXLINE( 162)																int _hx_tmp51;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp51 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp51 = blended8;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this118->image,location8,_hx_tmp51);
            															}
            														}
            														else {
HXLINE( 162)															::Dynamic this152 = this118->image;
HXDLIN( 162)															int index23;
HXDLIN( 162)															if (this118->useVirtualPos) {
HXLINE( 162)																index23 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this118->virtualY) * ( (Float)(this118->width) )) + px2) - this118->virtualX));
            															}
            															else {
HXLINE( 162)																index23 = ::Std_obj::_hx_int(( (Float)(((py2 * this118->width) + px2)) ));
            															}
HXDLIN( 162)															int _hx_tmp52;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp52 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp52 = c24;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this152,index23,_hx_tmp52);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN( 162)								int v_undoY2;
HXDLIN( 162)								int v_undoX2;
HXDLIN( 162)								Float v_ty2;
HXDLIN( 162)								Float v_tx2;
HXDLIN( 162)								Float v_t02;
HXDLIN( 162)								Float v_sy2;
HXDLIN( 162)								Float v_sx2;
HXDLIN( 162)								Float v_s02;
HXDLIN( 162)								Float v_A2;
HXDLIN( 162)								Float ax4 = ax3;
HXDLIN( 162)								Float ay4 = ay3;
HXDLIN( 162)								 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN( 162)								Float bx4 = bx3;
HXDLIN( 162)								Float by4 = by3;
HXDLIN( 162)								Float cx4 = dx3;
HXDLIN( 162)								Float cy4 = dy3;
HXDLIN( 162)								bool adjustWinding2 = (((((ax4 * by4) - (bx4 * ay4)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay4) - (ax4 * cy4))) > 0);
HXDLIN( 162)								if (!(adjustWinding2)) {
HXLINE( 162)									Float bx_2 = bx4;
HXDLIN( 162)									Float by_2 = by4;
HXLINE(  24)									bx4 = cx4;
HXLINE(  25)									by4 = cy4;
HXLINE(  26)									cx4 = bx_2;
HXLINE(  27)									cy4 = by_2;
            								}
HXLINE( 162)								Float v_ax2 = ax4;
HXDLIN( 162)								Float v_ay2 = ay4;
HXDLIN( 162)								Float v_bx2 = bx4;
HXDLIN( 162)								Float v_by2 = by4;
HXDLIN( 162)								Float v_cx2 = cx4;
HXDLIN( 162)								Float v_cy2 = cy4;
HXDLIN( 162)								bool v_preCalculated2 = true;
HXDLIN( 162)								{
HXLINE(  93)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  93)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  93)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  93)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  93)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  93)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  93)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXLINE( 162)									Float a41 = v_ax2;
HXDLIN( 162)									Float b45 = v_bx2;
HXDLIN( 162)									Float c25 = v_cx2;
HXDLIN( 162)									if ((a41 > b45)) {
HXLINE( 162)										if ((a41 > c25)) {
HXLINE( 162)											int min24;
HXDLIN( 162)											if ((b45 > c25)) {
HXLINE( 162)												min24 = ::Math_obj::floor(c25);
            											}
            											else {
HXLINE( 162)												min24 = ::Math_obj::floor(b45);
            											}
HXDLIN( 162)											int ii_min50 = min24;
HXDLIN( 162)											int ii_max50 = ::Math_obj::ceil(a41);
HXDLIN( 162)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            										}
            										else {
HXLINE( 162)											int ii_min51 = ::Math_obj::floor(b45);
HXDLIN( 162)											int ii_max51 = ::Math_obj::ceil(c25);
HXDLIN( 162)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            										}
            									}
            									else {
HXLINE( 162)										if ((b45 > c25)) {
HXLINE( 162)											int min25;
HXDLIN( 162)											if ((a41 > c25)) {
HXLINE( 162)												min25 = ::Math_obj::floor(c25);
            											}
            											else {
HXLINE( 162)												min25 = ::Math_obj::ceil(a41);
            											}
HXDLIN( 162)											int ii_min52 = min25;
HXDLIN( 162)											int ii_max52 = ::Math_obj::ceil(b45);
HXDLIN( 162)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            										}
            										else {
HXLINE( 162)											int ii_min53 = ::Math_obj::floor(a41);
HXDLIN( 162)											int ii_max53 = ::Math_obj::ceil(c25);
HXDLIN( 162)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            										}
            									}
HXDLIN( 162)									Float a42 = v_ay2;
HXDLIN( 162)									Float b46 = v_by2;
HXDLIN( 162)									Float c26 = v_cy2;
HXDLIN( 162)									if ((a42 > b46)) {
HXLINE( 162)										if ((a42 > c26)) {
HXLINE( 162)											int min26;
HXDLIN( 162)											if ((b46 > c26)) {
HXLINE( 162)												min26 = ::Math_obj::floor(c26);
            											}
            											else {
HXLINE( 162)												min26 = ::Math_obj::floor(b46);
            											}
HXDLIN( 162)											int ii_min54 = min26;
HXDLIN( 162)											int ii_max54 = ::Math_obj::ceil(a42);
HXDLIN( 162)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            										}
            										else {
HXLINE( 162)											int ii_min55 = ::Math_obj::floor(b46);
HXDLIN( 162)											int ii_max55 = ::Math_obj::ceil(c26);
HXDLIN( 162)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            										}
            									}
            									else {
HXLINE( 162)										if ((b46 > c26)) {
HXLINE( 162)											int min27;
HXDLIN( 162)											if ((a42 > c26)) {
HXLINE( 162)												min27 = ::Math_obj::floor(c26);
            											}
            											else {
HXLINE( 162)												min27 = ::Math_obj::ceil(a42);
            											}
HXDLIN( 162)											int ii_min56 = min27;
HXDLIN( 162)											int ii_max56 = ::Math_obj::ceil(b46);
HXDLIN( 162)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            										}
            										else {
HXLINE( 162)											int ii_min57 = ::Math_obj::floor(a42);
HXDLIN( 162)											int ii_max57 = ::Math_obj::ceil(c26);
HXDLIN( 162)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            										}
            									}
            								}
HXDLIN( 162)								if (hasUndo2) {
HXLINE(  93)									v_undoImage2 = undoImage6;
HXDLIN(  93)									v_undoX2 = xIter32->start;
HXDLIN(  93)									v_undoY2 = yIter32->start;
            								}
HXLINE( 162)								Float au3 = bu3;
HXDLIN( 162)								Float av3 = bv3;
HXDLIN( 162)								Float bu5 = cu1;
HXDLIN( 162)								Float bv5 = cv1;
HXDLIN( 162)								bool hasUndo3 = false;
HXDLIN( 162)								Float temp11 = au3;
HXLINE( 422)								au3 = bu5;
HXLINE( 423)								bu5 = temp11;
HXLINE( 424)								temp11 = av3;
HXLINE( 425)								av3 = bv5;
HXLINE( 426)								bv5 = temp11;
HXLINE( 162)								Float bcx3 = (cx3 - dx3);
HXDLIN( 162)								Float bcy3 = (cy3 - dy3);
HXDLIN( 162)								Float acx3 = (bx3 - dx3);
HXDLIN( 162)								Float acy3 = (by3 - dy3);
HXDLIN( 162)								Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 162)								Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 162)								Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 162)								Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 162)								if ((bx3 > cx3)) {
HXLINE( 162)									if ((bx3 > dx3)) {
HXLINE( 162)										int min28;
HXDLIN( 162)										if ((cx3 > dx3)) {
HXLINE( 162)											min28 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 162)											min28 = ::Math_obj::floor(cx3);
            										}
HXDLIN( 162)										int ii_min58 = min28;
HXDLIN( 162)										int ii_max58 = ::Math_obj::ceil(bx3);
HXDLIN( 162)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            									}
            									else {
HXLINE( 162)										int ii_min59 = ::Math_obj::floor(cx3);
HXDLIN( 162)										int ii_max59 = ::Math_obj::ceil(dx3);
HXDLIN( 162)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            									}
            								}
            								else {
HXLINE( 162)									if ((cx3 > dx3)) {
HXLINE( 162)										int min29;
HXDLIN( 162)										if ((bx3 > dx3)) {
HXLINE( 162)											min29 = ::Math_obj::floor(dx3);
            										}
            										else {
HXLINE( 162)											min29 = ::Math_obj::ceil(bx3);
            										}
HXDLIN( 162)										int ii_min60 = min29;
HXDLIN( 162)										int ii_max60 = ::Math_obj::ceil(cx3);
HXDLIN( 162)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            									}
            									else {
HXLINE( 162)										int ii_min61 = ::Math_obj::floor(bx3);
HXDLIN( 162)										int ii_max61 = ::Math_obj::ceil(dx3);
HXDLIN( 162)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            									}
            								}
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 162)								if ((by3 > cy3)) {
HXLINE( 162)									if ((by3 > dy3)) {
HXLINE( 162)										int min30;
HXDLIN( 162)										if ((cy3 > dy3)) {
HXLINE( 162)											min30 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 162)											min30 = ::Math_obj::floor(cy3);
            										}
HXDLIN( 162)										int ii_min62 = min30;
HXDLIN( 162)										int ii_max62 = ::Math_obj::ceil(by3);
HXDLIN( 162)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            									}
            									else {
HXLINE( 162)										int ii_min63 = ::Math_obj::floor(cy3);
HXDLIN( 162)										int ii_max63 = ::Math_obj::ceil(dy3);
HXDLIN( 162)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            									}
            								}
            								else {
HXLINE( 162)									if ((cy3 > dy3)) {
HXLINE( 162)										int min31;
HXDLIN( 162)										if ((by3 > dy3)) {
HXLINE( 162)											min31 = ::Math_obj::floor(dy3);
            										}
            										else {
HXLINE( 162)											min31 = ::Math_obj::ceil(by3);
            										}
HXDLIN( 162)										int ii_min64 = min31;
HXDLIN( 162)										int ii_max64 = ::Math_obj::ceil(cy3);
HXDLIN( 162)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            									}
            									else {
HXLINE( 162)										int ii_min65 = ::Math_obj::floor(by3);
HXDLIN( 162)										int ii_max65 = ::Math_obj::ceil(dy3);
HXDLIN( 162)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            									}
            								}
HXDLIN( 162)								 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 162)								if (hasUndo3) {
HXLINE( 162)									int width6 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 162)									int height6 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 162)									 ::Dynamic imageType8 = null();
HXDLIN( 162)									 ::pi_xy::ImageStruct this153 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)									if (::hx::IsNull( imageType8 )) {
HXLINE(  54)										imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 162)									::Dynamic undoImage10;
HXDLIN( 162)									switch((int)(( (int)(imageType8) ))){
            										case (int)0: {
HXLINE( 162)											 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::BytesImg b47 = byt8;
HXDLIN( 162)											{
HXLINE( 162)												b47->width = width6;
HXDLIN( 162)												b47->height = height6;
HXDLIN( 162)												b47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 162)												b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN( 162)												{
HXLINE( 162)													int len16 = b47->length;
HXDLIN( 162)													int w11 = 0;
HXDLIN( 162)													{
HXLINE( 162)														int _g140 = 0;
HXDLIN( 162)														int _g141 = b47->height;
HXDLIN( 162)														while((_g140 < _g141)){
HXLINE( 162)															_g140 = (_g140 + 1);
HXDLIN( 162)															int y23 = (_g140 - 1);
HXDLIN( 162)															{
HXLINE( 162)																int _g142 = 0;
HXDLIN( 162)																int _g143 = b47->width;
HXDLIN( 162)																while((_g142 < _g143)){
HXLINE( 162)																	_g142 = (_g142 + 1);
HXDLIN( 162)																	int x23 = (_g142 - 1);
HXDLIN( 162)																	{
HXLINE( 162)																		w11 = (w11 + 1);
HXDLIN( 162)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w11 = (w11 + 1);
HXDLIN( 162)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w11 = (w11 + 1);
HXDLIN( 162)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 162)																	{
HXLINE( 162)																		w11 = (w11 + 1);
HXDLIN( 162)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage10 = b47;
            										}
            										break;
            										case (int)1: {
HXLINE( 162)											 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::ArrIntImg a43 = arrI8;
HXDLIN( 162)											{
HXLINE( 162)												a43->width = width6;
HXDLIN( 162)												a43->height = height6;
HXDLIN( 162)												a43->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)												a43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 162)												{
HXLINE( 162)													int _g144 = 0;
HXDLIN( 162)													int _g145 = a43->length;
HXDLIN( 162)													while((_g144 < _g145)){
HXLINE( 162)														_g144 = (_g144 + 1);
HXDLIN( 162)														int i54 = (_g144 - 1);
HXDLIN( 162)														a43->data[i54] = 0;
            													}
            												}
            											}
HXDLIN( 162)											undoImage10 = a43;
            										}
            										break;
            										case (int)2: {
HXLINE( 162)											 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::U32ArrImg b48 = u32a8;
HXDLIN( 162)											{
HXLINE( 162)												b48->width = width6;
HXDLIN( 162)												b48->height = height6;
HXDLIN( 162)												b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 162)												int size8 = (b48->length * 4);
HXDLIN( 162)												b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN( 162)												{
HXLINE( 162)													int _g146 = 0;
HXDLIN( 162)													int _g147 = b48->length;
HXDLIN( 162)													while((_g146 < _g147)){
HXLINE( 162)														_g146 = (_g146 + 1);
HXDLIN( 162)														int i55 = (_g146 - 1);
HXDLIN( 162)														{
HXLINE( 162)															 ::haxe::io::ArrayBufferViewImpl this154 = b48->data;
HXDLIN( 162)															bool undoImage11;
HXDLIN( 162)															if ((i55 >= 0)) {
HXLINE( 162)																undoImage11 = (i55 < (this154->byteLength >> 2));
            															}
            															else {
HXLINE( 162)																undoImage11 = false;
            															}
HXDLIN( 162)															if (undoImage11) {
HXLINE( 162)																 ::haxe::io::Bytes _this8 = this154->bytes;
HXDLIN( 162)																int pos8 = ((i55 << 2) + this154->byteOffset);
HXDLIN( 162)																_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN( 162)																_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)																_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)																_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage10 = b48;
            										}
            										break;
            										case (int)3: {
HXLINE( 162)											 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::VecIntImg v17 = vec8;
HXDLIN( 162)											{
HXLINE( 162)												v17->width = width6;
HXDLIN( 162)												v17->height = height6;
HXDLIN( 162)												v17->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 162)												v17->data = ::Array_obj< int >::__new(v17->length);
HXDLIN( 162)												{
HXLINE( 162)													int _g148 = 0;
HXDLIN( 162)													int _g149 = v17->length;
HXDLIN( 162)													while((_g148 < _g149)){
HXLINE( 162)														_g148 = (_g148 + 1);
HXDLIN( 162)														int i56 = (_g148 - 1);
HXDLIN( 162)														v17->data->__unsafe_set(i56,0);
            													}
            												}
            											}
HXDLIN( 162)											undoImage10 = v17;
            										}
            										break;
            										case (int)4: {
HXLINE( 162)											 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)											 ::iterMagic::StackIntImg b49 = sInt8;
HXDLIN( 162)											{
HXLINE( 162)												b49->width = width6;
HXDLIN( 162)												b49->height = height6;
HXDLIN( 162)												b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 162)												b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)												{
HXLINE( 162)													int len17 = b49->length;
HXDLIN( 162)													 ::haxe::ds::GenericStack_Int d8 = b49->data;
HXDLIN( 162)													if (::hx::IsNull( d8->head )) {
HXLINE( 162)														int _g150 = 0;
HXDLIN( 162)														int _g151 = len17;
HXDLIN( 162)														while((_g150 < _g151)){
HXLINE( 162)															_g150 = (_g150 + 1);
HXDLIN( 162)															int i57 = (_g150 - 1);
HXDLIN( 162)															d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            														}
            													}
            													else {
HXLINE( 162)														int _g152 = 0;
HXDLIN( 162)														int _g153 = len17;
HXDLIN( 162)														while((_g152 < _g153)){
HXLINE( 162)															_g152 = (_g152 + 1);
HXDLIN( 162)															int i58 = (_g152 - 1);
HXDLIN( 162)															{
HXLINE( 162)																 ::haxe::ds::GenericCell_Int l8 = b49->data->head;
HXDLIN( 162)																 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN( 162)																{
HXLINE( 162)																	int _g154 = 0;
HXDLIN( 162)																	int _g155 = i58;
HXDLIN( 162)																	while((_g154 < _g155)){
HXLINE( 162)																		_g154 = (_g154 + 1);
HXDLIN( 162)																		int i59 = (_g154 - 1);
HXLINE( 345)																		prev8 = l8;
HXLINE( 346)																		l8 = l8->next;
            																	}
            																}
HXLINE( 162)																if (::hx::IsNull( prev8 )) {
HXLINE( 162)																	b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 162)																	l8 = null();
            																}
            																else {
HXLINE( 162)																	prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 162)																	l8 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 162)											undoImage10 = b49;
            										}
            										break;
            									}
HXDLIN( 162)									this153->image = undoImage10;
HXDLIN( 162)									this153->width = width6;
HXDLIN( 162)									this153->height = height6;
HXDLIN( 162)									this153->imageType = ( (int)(imageType8) );
HXDLIN( 162)									undoImage9 = this153;
HXDLIN( 162)									{
HXLINE( 162)										int rectLeft3 = xIter33->start;
HXDLIN( 162)										int rectTop3 = yIter33->start;
HXDLIN( 162)										int rectRight3 = xIter33->max;
HXDLIN( 162)										bool forceClear3 = false;
HXDLIN( 162)										{
HXLINE( 162)											int _g156 = rectTop3;
HXDLIN( 162)											int _g157 = yIter33->max;
HXDLIN( 162)											while((_g156 < _g157)){
HXLINE( 162)												_g156 = (_g156 + 1);
HXDLIN( 162)												int dy5 = (_g156 - 1);
HXDLIN( 162)												{
HXLINE( 162)													int _g158 = rectLeft3;
HXDLIN( 162)													int _g159 = rectRight3;
HXDLIN( 162)													while((_g158 < _g159)){
HXLINE( 162)														_g158 = (_g158 + 1);
HXDLIN( 162)														int dx5 = (_g158 - 1);
HXDLIN( 162)														::Dynamic this155 = this118->image;
HXDLIN( 162)														int index24;
HXDLIN( 162)														if (this118->useVirtualPos) {
HXLINE( 162)															index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this118->virtualY) * ( (Float)(this118->width) )) + dx5) - this118->virtualX));
            														}
            														else {
HXLINE( 162)															index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * this118->width) + dx5)) ));
            														}
HXDLIN( 162)														int c27 = ::iterMagic::Iimg_obj::get(this155,index24);
HXDLIN( 162)														int col6;
HXDLIN( 162)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)															col6 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            														}
            														else {
HXLINE( 162)															col6 = c27;
            														}
HXDLIN( 162)														bool _hx_tmp53;
HXDLIN( 162)														if (this118->useMask) {
HXLINE( 162)															_hx_tmp53 = ::hx::IsNotNull( this118->mask );
            														}
            														else {
HXLINE( 162)															_hx_tmp53 = false;
            														}
HXDLIN( 162)														if (_hx_tmp53) {
HXLINE( 162)															 ::pi_xy::ImageStruct this156 = this118->mask;
HXDLIN( 162)															::Dynamic this157 = this156->image;
HXDLIN( 162)															int index25;
HXDLIN( 162)															if (this156->useVirtualPos) {
HXLINE( 162)																index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this156->virtualY) * ( (Float)(this156->width) )) + dx5) - this156->virtualX));
            															}
            															else {
HXLINE( 162)																index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this156->width) + dx5)) ));
            															}
HXDLIN( 162)															int c28 = ::iterMagic::Iimg_obj::get(this157,index25);
HXDLIN( 162)															int v18;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																v18 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																v18 = c28;
            															}
HXDLIN( 162)															int maskPixel3 = v18;
HXDLIN( 162)															int this158 = col6;
HXDLIN( 162)															if ((maskPixel3 == 0)) {
HXLINE( 162)																col6 = this158;
            															}
            															else {
HXLINE( 162)																Float m03;
HXDLIN( 162)																int this159 = ((maskPixel3 >> 24) & 255);
HXDLIN( 162)																if ((this159 == 0)) {
HXLINE( 162)																	m03 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m03 = (( (Float)(this159) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m13;
HXDLIN( 162)																int this160 = ((maskPixel3 >> 16) & 255);
HXDLIN( 162)																if ((this160 == 0)) {
HXLINE( 162)																	m13 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m13 = (( (Float)(this160) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m23;
HXDLIN( 162)																int this161 = ((maskPixel3 >> 8) & 255);
HXDLIN( 162)																if ((this161 == 0)) {
HXLINE( 162)																	m23 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m23 = (( (Float)(this161) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float m33;
HXDLIN( 162)																int this162 = (maskPixel3 & 255);
HXDLIN( 162)																if ((this162 == 0)) {
HXLINE( 162)																	m33 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	m33 = (( (Float)(this162) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this158 >> 24) & 255)) )));
HXDLIN( 162)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this158 >> 16) & 255)) )));
HXDLIN( 162)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this158 >> 8) & 255)) )));
HXDLIN( 162)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this158 & 255)) )));
HXDLIN( 162)																col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 162)														if ((col6 != 0)) {
HXLINE( 162)															int x24 = (dx5 - rectLeft3);
HXDLIN( 162)															int y24 = (dy5 - rectTop3);
HXDLIN( 162)															int c29 = col6;
HXDLIN( 162)															bool _hx_tmp54;
HXDLIN( 162)															if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 162)																_hx_tmp54 = undoImage9->transparent;
            															}
            															else {
HXLINE( 162)																_hx_tmp54 = false;
            															}
HXDLIN( 162)															if (_hx_tmp54) {
HXLINE( 162)																int location9;
HXDLIN( 162)																if (undoImage9->useVirtualPos) {
HXLINE( 162)																	location9 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 162)																	location9 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN( 162)																int this163 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN( 162)																int this164;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	this164 = ((((((this163 >> 24) & 255) << 24) | ((this163 & 255) << 16)) | (((this163 >> 8) & 255) << 8)) | ((this163 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	this164 = this163;
            																}
HXDLIN( 162)																Float a114;
HXDLIN( 162)																int this165 = ((this164 >> 24) & 255);
HXDLIN( 162)																if ((this165 == 0)) {
HXLINE( 162)																	a114 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	a114 = (( (Float)(this165) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float r19;
HXDLIN( 162)																int this166 = ((this164 >> 16) & 255);
HXDLIN( 162)																if ((this166 == 0)) {
HXLINE( 162)																	r19 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	r19 = (( (Float)(this166) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float g19;
HXDLIN( 162)																int this167 = ((this164 >> 8) & 255);
HXDLIN( 162)																if ((this167 == 0)) {
HXLINE( 162)																	g19 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	g19 = (( (Float)(this167) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float b116;
HXDLIN( 162)																int this168 = (this164 & 255);
HXDLIN( 162)																if ((this168 == 0)) {
HXLINE( 162)																	b116 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	b116 = (( (Float)(this168) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float a212;
HXDLIN( 162)																int this169 = ((col6 >> 24) & 255);
HXDLIN( 162)																if ((this169 == 0)) {
HXLINE( 162)																	a212 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	a212 = (( (Float)(this169) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float r29;
HXDLIN( 162)																int this170 = ((col6 >> 16) & 255);
HXDLIN( 162)																if ((this170 == 0)) {
HXLINE( 162)																	r29 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	r29 = (( (Float)(this170) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float g29;
HXDLIN( 162)																int this171 = ((col6 >> 8) & 255);
HXDLIN( 162)																if ((this171 == 0)) {
HXLINE( 162)																	g29 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	g29 = (( (Float)(this171) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float b214;
HXDLIN( 162)																int this172 = (col6 & 255);
HXDLIN( 162)																if ((this172 == 0)) {
HXLINE( 162)																	b214 = ((Float)0.);
            																}
            																else {
HXLINE( 162)																	b214 = (( (Float)(this172) ) / ( (Float)(255) ));
            																}
HXDLIN( 162)																Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 162)																int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a311) + (r29 * a212))));
HXDLIN( 162)																int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN( 162)																int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN( 162)																int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 162)																int blended9 = ((((a44 << 24) | (r20 << 16)) | (g20 << 8)) | b50);
HXDLIN( 162)																{
HXLINE( 162)																	int _hx_tmp55;
HXDLIN( 162)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																		_hx_tmp55 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																	}
            																	else {
HXLINE( 162)																		_hx_tmp55 = blended9;
            																	}
HXDLIN( 162)																	::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp55);
            																}
            															}
            															else {
HXLINE( 162)																::Dynamic this173 = undoImage9->image;
HXDLIN( 162)																int index26;
HXDLIN( 162)																if (undoImage9->useVirtualPos) {
HXLINE( 162)																	index26 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 162)																	index26 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN( 162)																int _hx_tmp56;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp56 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp56 = c29;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this173,index26,_hx_tmp56);
            															}
            														}
            														else {
HXLINE( 162)															if (forceClear3) {
HXLINE( 162)																::Dynamic this174 = undoImage9->image;
HXDLIN( 162)																int x25 = (dx5 - rectLeft3);
HXDLIN( 162)																int y25 = (dy5 - rectTop3);
HXDLIN( 162)																int index27;
HXDLIN( 162)																if (undoImage9->useVirtualPos) {
HXLINE( 162)																	index27 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x25) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 162)																	index27 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage9->width) + x25)) ));
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this174,index27,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								{
HXLINE( 162)									int _g_min6 = xIter33->start;
HXDLIN( 162)									int _g_max6 = xIter33->max;
HXDLIN( 162)									while((_g_min6 < _g_max6)){
HXLINE( 162)										_g_min6 = (_g_min6 + 1);
HXDLIN( 162)										int px3 = (_g_min6 - 1);
HXDLIN( 162)										Float pcx3 = (( (Float)(px3) ) - dx3);
HXDLIN( 162)										{
HXLINE( 162)											int _g_min7 = yIter33->start;
HXDLIN( 162)											int _g_max7 = yIter33->max;
HXDLIN( 162)											while((_g_min7 < _g_max7)){
HXLINE( 162)												_g_min7 = (_g_min7 + 1);
HXDLIN( 162)												int py3 = (_g_min7 - 1);
HXDLIN( 162)												Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN( 162)												Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 162)												Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 162)												Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 162)												Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 162)												Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 162)												bool _hx_tmp57;
HXDLIN( 162)												bool _hx_tmp58;
HXDLIN( 162)												if ((ratioA3 >= 0)) {
HXLINE( 162)													_hx_tmp58 = (ratioB3 >= 0);
            												}
            												else {
HXLINE( 162)													_hx_tmp58 = false;
            												}
HXDLIN( 162)												if (_hx_tmp58) {
HXLINE( 162)													_hx_tmp57 = (ratioC3 >= 0);
            												}
            												else {
HXLINE( 162)													_hx_tmp57 = false;
            												}
HXDLIN( 162)												if (_hx_tmp57) {
HXLINE( 162)													Float u3 = (((au3 * ratioA3) + (bu5 * ratioB3)) + (du1 * ratioC3));
HXDLIN( 162)													Float v19 = (((av3 * ratioA3) + (bv5 * ratioB3)) + (dv1 * ratioC3));
HXDLIN( 162)													int x26 = ::Std_obj::_hx_int(((u3 * win_width1) + win_x1));
HXDLIN( 162)													int y26 = ::Std_obj::_hx_int(((v19 * win_height1) + win_y1));
HXDLIN( 162)													::Dynamic this175 = this115->image;
HXDLIN( 162)													int index28;
HXDLIN( 162)													if (this115->useVirtualPos) {
HXLINE( 162)														index28 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this115->virtualY) * ( (Float)(this115->width) )) + x26) - this115->virtualX));
            													}
            													else {
HXLINE( 162)														index28 = ::Std_obj::_hx_int(( (Float)(((y26 * this115->width) + x26)) ));
            													}
HXDLIN( 162)													int c30 = ::iterMagic::Iimg_obj::get(this175,index28);
HXDLIN( 162)													int col7;
HXDLIN( 162)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)														col7 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            													}
            													else {
HXLINE( 162)														col7 = c30;
            													}
HXDLIN( 162)													{
HXLINE( 162)														int c31 = col7;
HXDLIN( 162)														bool _hx_tmp59;
HXDLIN( 162)														if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 162)															_hx_tmp59 = this118->transparent;
            														}
            														else {
HXLINE( 162)															_hx_tmp59 = false;
            														}
HXDLIN( 162)														if (_hx_tmp59) {
HXLINE( 162)															int location10;
HXDLIN( 162)															if (this118->useVirtualPos) {
HXLINE( 162)																location10 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this118->virtualY) * ( (Float)(this118->width) )) + px3) - this118->virtualX));
            															}
            															else {
HXLINE( 162)																location10 = ::Std_obj::_hx_int(( (Float)(((py3 * this118->width) + px3)) ));
            															}
HXDLIN( 162)															int this176 = ::iterMagic::Iimg_obj::get(this118->image,location10);
HXDLIN( 162)															int this177;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																this177 = ((((((this176 >> 24) & 255) << 24) | ((this176 & 255) << 16)) | (((this176 >> 8) & 255) << 8)) | ((this176 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																this177 = this176;
            															}
HXDLIN( 162)															Float a115;
HXDLIN( 162)															int this178 = ((this177 >> 24) & 255);
HXDLIN( 162)															if ((this178 == 0)) {
HXLINE( 162)																a115 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a115 = (( (Float)(this178) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r110;
HXDLIN( 162)															int this179 = ((this177 >> 16) & 255);
HXDLIN( 162)															if ((this179 == 0)) {
HXLINE( 162)																r110 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r110 = (( (Float)(this179) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g110;
HXDLIN( 162)															int this180 = ((this177 >> 8) & 255);
HXDLIN( 162)															if ((this180 == 0)) {
HXLINE( 162)																g110 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g110 = (( (Float)(this180) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b117;
HXDLIN( 162)															int this181 = (this177 & 255);
HXDLIN( 162)															if ((this181 == 0)) {
HXLINE( 162)																b117 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b117 = (( (Float)(this181) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a213;
HXDLIN( 162)															int this182 = ((col7 >> 24) & 255);
HXDLIN( 162)															if ((this182 == 0)) {
HXLINE( 162)																a213 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																a213 = (( (Float)(this182) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float r210;
HXDLIN( 162)															int this183 = ((col7 >> 16) & 255);
HXDLIN( 162)															if ((this183 == 0)) {
HXLINE( 162)																r210 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																r210 = (( (Float)(this183) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float g210;
HXDLIN( 162)															int this184 = ((col7 >> 8) & 255);
HXDLIN( 162)															if ((this184 == 0)) {
HXLINE( 162)																g210 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																g210 = (( (Float)(this184) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float b215;
HXDLIN( 162)															int this185 = (col7 & 255);
HXDLIN( 162)															if ((this185 == 0)) {
HXLINE( 162)																b215 = ((Float)0.);
            															}
            															else {
HXLINE( 162)																b215 = (( (Float)(this185) ) / ( (Float)(255) ));
            															}
HXDLIN( 162)															Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 162)															int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a312) + (r210 * a213))));
HXDLIN( 162)															int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN( 162)															int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN( 162)															int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 162)															int blended10 = ((((a45 << 24) | (r30 << 16)) | (g30 << 8)) | b51);
HXDLIN( 162)															{
HXLINE( 162)																int _hx_tmp60;
HXDLIN( 162)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																	_hx_tmp60 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            																}
            																else {
HXLINE( 162)																	_hx_tmp60 = blended10;
            																}
HXDLIN( 162)																::iterMagic::Iimg_obj::set(this118->image,location10,_hx_tmp60);
            															}
            														}
            														else {
HXLINE( 162)															::Dynamic this186 = this118->image;
HXDLIN( 162)															int index29;
HXDLIN( 162)															if (this118->useVirtualPos) {
HXLINE( 162)																index29 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this118->virtualY) * ( (Float)(this118->width) )) + px3) - this118->virtualX));
            															}
            															else {
HXLINE( 162)																index29 = ::Std_obj::_hx_int(( (Float)(((py3 * this118->width) + px3)) ));
            															}
HXDLIN( 162)															int _hx_tmp61;
HXDLIN( 162)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)																_hx_tmp61 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            															}
            															else {
HXLINE( 162)																_hx_tmp61 = c31;
            															}
HXDLIN( 162)															::iterMagic::Iimg_obj::set(this186,index29,_hx_tmp61);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN( 162)								 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN( 162)								int v_undoY3;
HXDLIN( 162)								int v_undoX3;
HXDLIN( 162)								Float v_ty3;
HXDLIN( 162)								Float v_tx3;
HXDLIN( 162)								Float v_t03;
HXDLIN( 162)								Float v_sy3;
HXDLIN( 162)								Float v_sx3;
HXDLIN( 162)								Float v_s03;
HXDLIN( 162)								Float v_A3;
HXDLIN( 162)								Float ax5 = bx3;
HXDLIN( 162)								Float ay5 = by3;
HXDLIN( 162)								 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN( 162)								Float bx5 = cx3;
HXDLIN( 162)								Float by5 = cy3;
HXDLIN( 162)								Float cx5 = dx3;
HXDLIN( 162)								Float cy5 = dy3;
HXDLIN( 162)								bool adjustWinding3 = (((((ax5 * by5) - (bx5 * ay5)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay5) - (ax5 * cy5))) > 0);
HXDLIN( 162)								if (!(adjustWinding3)) {
HXLINE( 162)									Float bx_3 = bx5;
HXDLIN( 162)									Float by_3 = by5;
HXLINE(  24)									bx5 = cx5;
HXLINE(  25)									by5 = cy5;
HXLINE(  26)									cx5 = bx_3;
HXLINE(  27)									cy5 = by_3;
            								}
HXLINE( 162)								Float v_ax3 = ax5;
HXDLIN( 162)								Float v_ay3 = ay5;
HXDLIN( 162)								Float v_bx3 = bx5;
HXDLIN( 162)								Float v_by3 = by5;
HXDLIN( 162)								Float v_cx3 = cx5;
HXDLIN( 162)								Float v_cy3 = cy5;
HXDLIN( 162)								bool v_preCalculated3 = true;
HXDLIN( 162)								{
HXLINE(  93)									v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN(  93)									v_sx3 = (v_cy3 - v_ay3);
HXDLIN(  93)									v_sy3 = (v_ax3 - v_cx3);
HXDLIN(  93)									v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN(  93)									v_tx3 = (v_ay3 - v_by3);
HXDLIN(  93)									v_ty3 = (v_bx3 - v_ax3);
HXDLIN(  93)									v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXLINE( 162)									Float a46 = v_ax3;
HXDLIN( 162)									Float b52 = v_bx3;
HXDLIN( 162)									Float c32 = v_cx3;
HXDLIN( 162)									if ((a46 > b52)) {
HXLINE( 162)										if ((a46 > c32)) {
HXLINE( 162)											int min32;
HXDLIN( 162)											if ((b52 > c32)) {
HXLINE( 162)												min32 = ::Math_obj::floor(c32);
            											}
            											else {
HXLINE( 162)												min32 = ::Math_obj::floor(b52);
            											}
HXDLIN( 162)											int ii_min66 = min32;
HXDLIN( 162)											int ii_max66 = ::Math_obj::ceil(a46);
HXDLIN( 162)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            										}
            										else {
HXLINE( 162)											int ii_min67 = ::Math_obj::floor(b52);
HXDLIN( 162)											int ii_max67 = ::Math_obj::ceil(c32);
HXDLIN( 162)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            										}
            									}
            									else {
HXLINE( 162)										if ((b52 > c32)) {
HXLINE( 162)											int min33;
HXDLIN( 162)											if ((a46 > c32)) {
HXLINE( 162)												min33 = ::Math_obj::floor(c32);
            											}
            											else {
HXLINE( 162)												min33 = ::Math_obj::ceil(a46);
            											}
HXDLIN( 162)											int ii_min68 = min33;
HXDLIN( 162)											int ii_max68 = ::Math_obj::ceil(b52);
HXDLIN( 162)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            										}
            										else {
HXLINE( 162)											int ii_min69 = ::Math_obj::floor(a46);
HXDLIN( 162)											int ii_max69 = ::Math_obj::ceil(c32);
HXDLIN( 162)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            										}
            									}
HXDLIN( 162)									Float a47 = v_ay3;
HXDLIN( 162)									Float b53 = v_by3;
HXDLIN( 162)									Float c33 = v_cy3;
HXDLIN( 162)									if ((a47 > b53)) {
HXLINE( 162)										if ((a47 > c33)) {
HXLINE( 162)											int min34;
HXDLIN( 162)											if ((b53 > c33)) {
HXLINE( 162)												min34 = ::Math_obj::floor(c33);
            											}
            											else {
HXLINE( 162)												min34 = ::Math_obj::floor(b53);
            											}
HXDLIN( 162)											int ii_min70 = min34;
HXDLIN( 162)											int ii_max70 = ::Math_obj::ceil(a47);
HXDLIN( 162)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            										}
            										else {
HXLINE( 162)											int ii_min71 = ::Math_obj::floor(b53);
HXDLIN( 162)											int ii_max71 = ::Math_obj::ceil(c33);
HXDLIN( 162)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            										}
            									}
            									else {
HXLINE( 162)										if ((b53 > c33)) {
HXLINE( 162)											int min35;
HXDLIN( 162)											if ((a47 > c33)) {
HXLINE( 162)												min35 = ::Math_obj::floor(c33);
            											}
            											else {
HXLINE( 162)												min35 = ::Math_obj::ceil(a47);
            											}
HXDLIN( 162)											int ii_min72 = min35;
HXDLIN( 162)											int ii_max72 = ::Math_obj::ceil(b53);
HXDLIN( 162)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            										}
            										else {
HXLINE( 162)											int ii_min73 = ::Math_obj::floor(a47);
HXDLIN( 162)											int ii_max73 = ::Math_obj::ceil(c33);
HXDLIN( 162)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            										}
            									}
            								}
HXDLIN( 162)								if (hasUndo3) {
HXLINE(  93)									v_undoImage3 = undoImage9;
HXDLIN(  93)									v_undoX3 = xIter33->start;
HXDLIN(  93)									v_undoY3 = yIter33->start;
            								}
            							}
            						}
HXLINE( 162)						bool _hx_tmp62;
HXDLIN( 162)						if (::hx::IsNotNull( nextImage4->mask )) {
HXLINE( 162)							_hx_tmp62 = includeMask;
            						}
            						else {
HXLINE( 162)							_hx_tmp62 = false;
            						}
HXDLIN( 162)						if (_hx_tmp62) {
HXLINE( 162)							 ::pi_xy::ImageStruct v20 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this115->mask,theta,centreX2,centreY2,this115->mask->transparent,includeMask);
HXDLIN( 162)							nextImage4->useMask = true;
HXDLIN( 162)							nextImage4->mask = v20;
            						}
HXDLIN( 162)						 ::pi_xy::ImageStruct v21 = nextImage4;
HXDLIN( 162)						nextImage3->useMask = true;
HXDLIN( 162)						nextImage3->mask = v21;
            					}
HXDLIN( 162)					return nextImage3;
            				}
            			}
            		}
HXLINE( 155)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(SpinImage_Fields__obj,rotatingClockwiseRadians,return )

 ::pi_xy::ImageStruct SpinImage_Fields__obj::rotating( ::pi_xy::ImageStruct thisImage,Float theta,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a4487198a0754673_169_rotating)
HXLINE( 170)		Float ax = ((Float)0.);
HXLINE( 171)		Float ay = ((Float)0.);
HXLINE( 172)		if ((centreX != ((Float)0.))) {
HXLINE( 173)			centreX = ((( (Float)(thisImage->width) ) / ( (Float)(2) )) + centreX);
HXLINE( 174)			ax = (ax - centreX);
            		}
HXLINE( 176)		if ((centreY != ((Float)0.))) {
HXLINE( 177)			centreY = ((( (Float)(thisImage->height) ) / ( (Float)(2) )) + centreY);
HXLINE( 178)			ay = (ay - centreY);
            		}
HXLINE( 180)		Float bx = (ax + thisImage->width);
HXLINE( 181)		Float by = ay;
HXLINE( 182)		Float cx = bx;
HXLINE( 183)		Float cy = (ay + thisImage->height);
HXLINE( 184)		Float dx = ax;
HXLINE( 185)		Float dy = cy;
HXLINE( 186)		Float sin = ::Math_obj::sin(theta);
HXLINE( 187)		Float cos = ::Math_obj::cos(theta);
HXLINE( 188)		Float temp = ax;
HXLINE( 189)		ax = ((temp * cos) - (ay * sin));
HXLINE( 190)		ay = ((ay * cos) + (temp * sin));
HXLINE( 191)		Float temp1 = bx;
HXLINE( 192)		bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)		by = ((by * cos) + (temp1 * sin));
HXLINE( 194)		Float temp2 = cx;
HXLINE( 195)		cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)		cy = ((cy * cos) + (temp2 * sin));
HXLINE( 197)		Float temp3 = dx;
HXLINE( 198)		dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)		dy = ((dy * cos) + (temp3 * sin));
HXLINE( 200)		if ((centreX != ((Float)0.))) {
HXLINE( 201)			ax = (ax + centreX);
HXLINE( 202)			bx = (bx + centreX);
HXLINE( 203)			cx = (cx + centreX);
HXLINE( 204)			dx = (dx + centreX);
            		}
HXLINE( 206)		if ((centreY != ((Float)0.))) {
HXLINE( 207)			ay = (ay + centreY);
HXLINE( 208)			by = (by + centreY);
HXLINE( 209)			cy = (cy + centreY);
HXLINE( 210)			dy = (dy + centreY);
            		}
HXLINE( 212)		int min = ::Math_obj::floor(ax);
HXDLIN( 212)		int max = ::Math_obj::ceil(ax);
HXDLIN( 212)		if ((bx < min)) {
HXLINE(  31)			min = ::Math_obj::floor(bx);
            		}
            		else {
HXLINE( 212)			if ((bx > max)) {
HXLINE(  33)				max = ::Math_obj::ceil(bx);
            			}
            		}
HXLINE( 212)		if ((cx < min)) {
HXLINE(  36)			min = ::Math_obj::floor(cx);
            		}
            		else {
HXLINE( 212)			if ((cx > max)) {
HXLINE(  38)				max = ::Math_obj::ceil(cx);
            			}
            		}
HXLINE( 212)		if ((dx < min)) {
HXLINE(  41)			min = ::Math_obj::floor(dx);
            		}
            		else {
HXLINE( 212)			if ((dx > max)) {
HXLINE(  43)				max = ::Math_obj::ceil(dx);
            			}
            		}
HXLINE( 212)		int ii_min = min;
HXDLIN( 212)		int ii_max = max;
HXDLIN( 212)		 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXLINE( 213)		int min1 = ::Math_obj::floor(ay);
HXDLIN( 213)		int max1 = ::Math_obj::ceil(ay);
HXDLIN( 213)		if ((by < min1)) {
HXLINE(  31)			min1 = ::Math_obj::floor(by);
            		}
            		else {
HXLINE( 213)			if ((by > max1)) {
HXLINE(  33)				max1 = ::Math_obj::ceil(by);
            			}
            		}
HXLINE( 213)		if ((cy < min1)) {
HXLINE(  36)			min1 = ::Math_obj::floor(cy);
            		}
            		else {
HXLINE( 213)			if ((cy > max1)) {
HXLINE(  38)				max1 = ::Math_obj::ceil(cy);
            			}
            		}
HXLINE( 213)		if ((dy < min1)) {
HXLINE(  41)			min1 = ::Math_obj::floor(dy);
            		}
            		else {
HXLINE( 213)			if ((dy > max1)) {
HXLINE(  43)				max1 = ::Math_obj::ceil(dy);
            			}
            		}
HXLINE( 213)		int ii_min1 = min1;
HXDLIN( 213)		int ii_max1 = max1;
HXDLIN( 213)		 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXLINE( 214)		int minX = boundX->start;
HXLINE( 215)		int wid = ((boundX->max - boundX->start) + 1);
HXLINE( 216)		int minY = boundY->start;
HXLINE( 217)		int hi = ((boundY->max - boundY->start) + 1);
HXLINE( 218)		 ::Dynamic imageType = null();
HXDLIN( 218)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 218)		::Dynamic _hx_tmp;
HXDLIN( 218)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 218)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 218)				{
HXLINE( 218)					b->width = wid;
HXDLIN( 218)					b->height = hi;
HXDLIN( 218)					b->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 218)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 218)					{
HXLINE( 218)						int len = b->length;
HXDLIN( 218)						int w = 0;
HXDLIN( 218)						{
HXLINE( 218)							int _g = 0;
HXDLIN( 218)							int _g1 = b->height;
HXDLIN( 218)							while((_g < _g1)){
HXLINE( 218)								_g = (_g + 1);
HXDLIN( 218)								int y = (_g - 1);
HXDLIN( 218)								{
HXLINE( 218)									int _g2 = 0;
HXDLIN( 218)									int _g3 = b->width;
HXDLIN( 218)									while((_g2 < _g3)){
HXLINE( 218)										_g2 = (_g2 + 1);
HXDLIN( 218)										int x = (_g2 - 1);
HXDLIN( 218)										{
HXLINE( 218)											w = (w + 1);
HXDLIN( 218)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 218)										{
HXLINE( 218)											w = (w + 1);
HXDLIN( 218)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 218)										{
HXLINE( 218)											w = (w + 1);
HXDLIN( 218)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 218)										{
HXLINE( 218)											w = (w + 1);
HXDLIN( 218)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 218)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 218)				{
HXLINE( 218)					a->width = wid;
HXDLIN( 218)					a->height = hi;
HXDLIN( 218)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)					a->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 218)					{
HXLINE( 218)						int _g4 = 0;
HXDLIN( 218)						int _g5 = a->length;
HXDLIN( 218)						while((_g4 < _g5)){
HXLINE( 218)							_g4 = (_g4 + 1);
HXDLIN( 218)							int i = (_g4 - 1);
HXDLIN( 218)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 218)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 218)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 218)				{
HXLINE( 218)					b1->width = wid;
HXDLIN( 218)					b1->height = hi;
HXDLIN( 218)					b1->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 218)					int size = (b1->length * 4);
HXDLIN( 218)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 218)					{
HXLINE( 218)						int _g6 = 0;
HXDLIN( 218)						int _g7 = b1->length;
HXDLIN( 218)						while((_g6 < _g7)){
HXLINE( 218)							_g6 = (_g6 + 1);
HXDLIN( 218)							int i1 = (_g6 - 1);
HXDLIN( 218)							{
HXLINE( 218)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 218)								bool _hx_tmp1;
HXDLIN( 218)								if ((i1 >= 0)) {
HXLINE( 218)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE( 218)									_hx_tmp1 = false;
            								}
HXDLIN( 218)								if (_hx_tmp1) {
HXLINE( 218)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 218)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 218)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 218)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 218)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 218)				{
HXLINE( 218)					v->width = wid;
HXDLIN( 218)					v->height = hi;
HXDLIN( 218)					v->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 218)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 218)					{
HXLINE( 218)						int _g8 = 0;
HXDLIN( 218)						int _g9 = v->length;
HXDLIN( 218)						while((_g8 < _g9)){
HXLINE( 218)							_g8 = (_g8 + 1);
HXDLIN( 218)							int i2 = (_g8 - 1);
HXDLIN( 218)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 218)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 218)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 218)				{
HXLINE( 218)					b2->width = wid;
HXDLIN( 218)					b2->height = hi;
HXDLIN( 218)					b2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 218)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)					{
HXLINE( 218)						int len1 = b2->length;
HXDLIN( 218)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 218)						if (::hx::IsNull( d->head )) {
HXLINE( 218)							int _g10 = 0;
HXDLIN( 218)							int _g11 = len1;
HXDLIN( 218)							while((_g10 < _g11)){
HXLINE( 218)								_g10 = (_g10 + 1);
HXDLIN( 218)								int i3 = (_g10 - 1);
HXDLIN( 218)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 218)							int _g12 = 0;
HXDLIN( 218)							int _g13 = len1;
HXDLIN( 218)							while((_g12 < _g13)){
HXLINE( 218)								_g12 = (_g12 + 1);
HXDLIN( 218)								int i4 = (_g12 - 1);
HXDLIN( 218)								{
HXLINE( 218)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 218)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 218)									{
HXLINE( 218)										int _g14 = 0;
HXDLIN( 218)										int _g15 = i4;
HXDLIN( 218)										while((_g14 < _g15)){
HXLINE( 218)											_g14 = (_g14 + 1);
HXDLIN( 218)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 218)									if (::hx::IsNull( prev )) {
HXLINE( 218)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 218)										l = null();
            									}
            									else {
HXLINE( 218)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 218)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 218)		this1->image = _hx_tmp;
HXDLIN( 218)		this1->width = wid;
HXDLIN( 218)		this1->height = hi;
HXDLIN( 218)		this1->imageType = ( (int)(imageType) );
HXDLIN( 218)		 ::pi_xy::ImageStruct nextImage = this1;
HXLINE( 219)		nextImage->transparent = true;
HXLINE( 220)		if ((minX < ((Float)0.))) {
HXLINE( 221)			ax = (ax - ( (Float)(minX) ));
HXLINE( 222)			bx = (bx - ( (Float)(minX) ));
HXLINE( 223)			cx = (cx - ( (Float)(minX) ));
HXLINE( 224)			dx = (dx - ( (Float)(minX) ));
            		}
HXLINE( 226)		if ((minY < ((Float)0.))) {
HXLINE( 227)			ay = (ay - ( (Float)(minY) ));
HXLINE( 228)			by = (by - ( (Float)(minY) ));
HXLINE( 229)			cy = (cy - ( (Float)(minY) ));
HXLINE( 230)			dy = (dy - ( (Float)(minY) ));
            		}
HXLINE( 232)		{
HXLINE( 232)			 ::pi_xy::ImageStruct this3 = nextImage;
HXDLIN( 232)			Float win_x = ( (Float)(0) );
HXDLIN( 232)			Float win_y = ( (Float)(0) );
HXDLIN( 232)			Float win_width = ( (Float)(thisImage->width) );
HXDLIN( 232)			Float win_height = ( (Float)(thisImage->height) );
HXDLIN( 232)			{
HXLINE( 232)				Float bu = ((Float)1.);
HXDLIN( 232)				Float bv = ((Float)0.);
HXDLIN( 232)				Float cu = ((Float)1.);
HXDLIN( 232)				Float cv = ((Float)1.);
HXDLIN( 232)				Float du = ((Float)0.);
HXDLIN( 232)				Float dv = ((Float)1.);
HXDLIN( 232)				Float au = ((Float)0.);
HXDLIN( 232)				Float av = ((Float)0.);
HXDLIN( 232)				Float bu1 = bu;
HXDLIN( 232)				Float bv1 = bv;
HXDLIN( 232)				bool hasUndo = false;
HXDLIN( 232)				Float temp4 = au;
HXLINE( 422)				au = bu1;
HXLINE( 423)				bu1 = temp4;
HXLINE( 424)				temp4 = av;
HXLINE( 425)				av = bv1;
HXLINE( 426)				bv1 = temp4;
HXLINE( 232)				Float bcx = (bx - dx);
HXDLIN( 232)				Float bcy = (by - dy);
HXDLIN( 232)				Float acx = (ax - dx);
HXDLIN( 232)				Float acy = (ay - dy);
HXDLIN( 232)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 232)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 232)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 232)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 232)				if ((ax > bx)) {
HXLINE( 232)					if ((ax > dx)) {
HXLINE( 232)						int min2;
HXDLIN( 232)						if ((bx > dx)) {
HXLINE( 232)							min2 = ::Math_obj::floor(dx);
            						}
            						else {
HXLINE( 232)							min2 = ::Math_obj::floor(bx);
            						}
HXDLIN( 232)						int ii_min2 = min2;
HXDLIN( 232)						int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN( 232)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 232)						int ii_min3 = ::Math_obj::floor(bx);
HXDLIN( 232)						int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 232)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
            				else {
HXLINE( 232)					if ((bx > dx)) {
HXLINE( 232)						int min3;
HXDLIN( 232)						if ((ax > dx)) {
HXLINE( 232)							min3 = ::Math_obj::floor(dx);
            						}
            						else {
HXLINE( 232)							min3 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 232)						int ii_min4 = min3;
HXDLIN( 232)						int ii_max4 = ::Math_obj::ceil(bx);
HXDLIN( 232)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 232)						int ii_min5 = ::Math_obj::floor(ax);
HXDLIN( 232)						int ii_max5 = ::Math_obj::ceil(dx);
HXDLIN( 232)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 232)				if ((ay > by)) {
HXLINE( 232)					if ((ay > dy)) {
HXLINE( 232)						int min4;
HXDLIN( 232)						if ((by > dy)) {
HXLINE( 232)							min4 = ::Math_obj::floor(dy);
            						}
            						else {
HXLINE( 232)							min4 = ::Math_obj::floor(by);
            						}
HXDLIN( 232)						int ii_min6 = min4;
HXDLIN( 232)						int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN( 232)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 232)						int ii_min7 = ::Math_obj::floor(by);
HXDLIN( 232)						int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 232)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
            				else {
HXLINE( 232)					if ((by > dy)) {
HXLINE( 232)						int min5;
HXDLIN( 232)						if ((ay > dy)) {
HXLINE( 232)							min5 = ::Math_obj::floor(dy);
            						}
            						else {
HXLINE( 232)							min5 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 232)						int ii_min8 = min5;
HXDLIN( 232)						int ii_max8 = ::Math_obj::ceil(by);
HXDLIN( 232)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 232)						int ii_min9 = ::Math_obj::floor(ay);
HXDLIN( 232)						int ii_max9 = ::Math_obj::ceil(dy);
HXDLIN( 232)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
HXDLIN( 232)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 232)				if (hasUndo) {
HXLINE( 232)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 232)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 232)					 ::Dynamic imageType1 = null();
HXDLIN( 232)					 ::pi_xy::ImageStruct this4 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 232)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 232)					::Dynamic undoImage1;
HXDLIN( 232)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 232)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 232)							{
HXLINE( 232)								b3->width = width;
HXDLIN( 232)								b3->height = height;
HXDLIN( 232)								b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 232)								b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 232)								{
HXLINE( 232)									int len2 = b3->length;
HXDLIN( 232)									int w1 = 0;
HXDLIN( 232)									{
HXLINE( 232)										int _g16 = 0;
HXDLIN( 232)										int _g17 = b3->height;
HXDLIN( 232)										while((_g16 < _g17)){
HXLINE( 232)											_g16 = (_g16 + 1);
HXDLIN( 232)											int y1 = (_g16 - 1);
HXDLIN( 232)											{
HXLINE( 232)												int _g18 = 0;
HXDLIN( 232)												int _g19 = b3->width;
HXDLIN( 232)												while((_g18 < _g19)){
HXLINE( 232)													_g18 = (_g18 + 1);
HXDLIN( 232)													int x1 = (_g18 - 1);
HXDLIN( 232)													{
HXLINE( 232)														w1 = (w1 + 1);
HXDLIN( 232)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w1 = (w1 + 1);
HXDLIN( 232)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w1 = (w1 + 1);
HXDLIN( 232)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w1 = (w1 + 1);
HXDLIN( 232)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage1 = b3;
            						}
            						break;
            						case (int)1: {
HXLINE( 232)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 232)							{
HXLINE( 232)								a1->width = width;
HXDLIN( 232)								a1->height = height;
HXDLIN( 232)								a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 232)								a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 232)								{
HXLINE( 232)									int _g20 = 0;
HXDLIN( 232)									int _g21 = a1->length;
HXDLIN( 232)									while((_g20 < _g21)){
HXLINE( 232)										_g20 = (_g20 + 1);
HXDLIN( 232)										int i6 = (_g20 - 1);
HXDLIN( 232)										a1->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 232)							undoImage1 = a1;
            						}
            						break;
            						case (int)2: {
HXLINE( 232)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 232)							{
HXLINE( 232)								b4->width = width;
HXDLIN( 232)								b4->height = height;
HXDLIN( 232)								b4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 232)								int size1 = (b4->length * 4);
HXDLIN( 232)								b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 232)								{
HXLINE( 232)									int _g22 = 0;
HXDLIN( 232)									int _g23 = b4->length;
HXDLIN( 232)									while((_g22 < _g23)){
HXLINE( 232)										_g22 = (_g22 + 1);
HXDLIN( 232)										int i7 = (_g22 - 1);
HXDLIN( 232)										{
HXLINE( 232)											 ::haxe::io::ArrayBufferViewImpl this5 = b4->data;
HXDLIN( 232)											bool undoImage2;
HXDLIN( 232)											if ((i7 >= 0)) {
HXLINE( 232)												undoImage2 = (i7 < (this5->byteLength >> 2));
            											}
            											else {
HXLINE( 232)												undoImage2 = false;
            											}
HXDLIN( 232)											if (undoImage2) {
HXLINE( 232)												 ::haxe::io::Bytes _this1 = this5->bytes;
HXDLIN( 232)												int pos1 = ((i7 << 2) + this5->byteOffset);
HXDLIN( 232)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 232)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 232)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 232)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage1 = b4;
            						}
            						break;
            						case (int)3: {
HXLINE( 232)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 232)							{
HXLINE( 232)								v1->width = width;
HXDLIN( 232)								v1->height = height;
HXDLIN( 232)								v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 232)								v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 232)								{
HXLINE( 232)									int _g24 = 0;
HXDLIN( 232)									int _g25 = v1->length;
HXDLIN( 232)									while((_g24 < _g25)){
HXLINE( 232)										_g24 = (_g24 + 1);
HXDLIN( 232)										int i8 = (_g24 - 1);
HXDLIN( 232)										v1->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 232)							undoImage1 = v1;
            						}
            						break;
            						case (int)4: {
HXLINE( 232)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 232)							{
HXLINE( 232)								b5->width = width;
HXDLIN( 232)								b5->height = height;
HXDLIN( 232)								b5->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 232)								b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 232)								{
HXLINE( 232)									int len3 = b5->length;
HXDLIN( 232)									 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 232)									if (::hx::IsNull( d1->head )) {
HXLINE( 232)										int _g26 = 0;
HXDLIN( 232)										int _g27 = len3;
HXDLIN( 232)										while((_g26 < _g27)){
HXLINE( 232)											_g26 = (_g26 + 1);
HXDLIN( 232)											int i9 = (_g26 - 1);
HXDLIN( 232)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 232)										int _g28 = 0;
HXDLIN( 232)										int _g29 = len3;
HXDLIN( 232)										while((_g28 < _g29)){
HXLINE( 232)											_g28 = (_g28 + 1);
HXDLIN( 232)											int i10 = (_g28 - 1);
HXDLIN( 232)											{
HXLINE( 232)												 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 232)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 232)												{
HXLINE( 232)													int _g30 = 0;
HXDLIN( 232)													int _g31 = i10;
HXDLIN( 232)													while((_g30 < _g31)){
HXLINE( 232)														_g30 = (_g30 + 1);
HXDLIN( 232)														int i11 = (_g30 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 232)												if (::hx::IsNull( prev1 )) {
HXLINE( 232)													b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 232)													l1 = null();
            												}
            												else {
HXLINE( 232)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 232)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage1 = b5;
            						}
            						break;
            					}
HXDLIN( 232)					this4->image = undoImage1;
HXDLIN( 232)					this4->width = width;
HXDLIN( 232)					this4->height = height;
HXDLIN( 232)					this4->imageType = ( (int)(imageType1) );
HXDLIN( 232)					undoImage = this4;
HXDLIN( 232)					{
HXLINE( 232)						int rectLeft = xIter3->start;
HXDLIN( 232)						int rectTop = yIter3->start;
HXDLIN( 232)						int rectRight = xIter3->max;
HXDLIN( 232)						bool forceClear = false;
HXDLIN( 232)						{
HXLINE( 232)							int _g32 = rectTop;
HXDLIN( 232)							int _g33 = yIter3->max;
HXDLIN( 232)							while((_g32 < _g33)){
HXLINE( 232)								_g32 = (_g32 + 1);
HXDLIN( 232)								int dy1 = (_g32 - 1);
HXDLIN( 232)								{
HXLINE( 232)									int _g34 = rectLeft;
HXDLIN( 232)									int _g35 = rectRight;
HXDLIN( 232)									while((_g34 < _g35)){
HXLINE( 232)										_g34 = (_g34 + 1);
HXDLIN( 232)										int dx1 = (_g34 - 1);
HXDLIN( 232)										::Dynamic this6 = this3->image;
HXDLIN( 232)										int index;
HXDLIN( 232)										if (this3->useVirtualPos) {
HXLINE( 232)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx1) - this3->virtualX));
            										}
            										else {
HXLINE( 232)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this3->width) + dx1)) ));
            										}
HXDLIN( 232)										int c = ::iterMagic::Iimg_obj::get(this6,index);
HXDLIN( 232)										int col;
HXDLIN( 232)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 232)											col = c;
            										}
HXDLIN( 232)										bool _hx_tmp2;
HXDLIN( 232)										if (this3->useMask) {
HXLINE( 232)											_hx_tmp2 = ::hx::IsNotNull( this3->mask );
            										}
            										else {
HXLINE( 232)											_hx_tmp2 = false;
            										}
HXDLIN( 232)										if (_hx_tmp2) {
HXLINE( 232)											 ::pi_xy::ImageStruct this7 = this3->mask;
HXDLIN( 232)											::Dynamic this8 = this7->image;
HXDLIN( 232)											int index1;
HXDLIN( 232)											if (this7->useVirtualPos) {
HXLINE( 232)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this7->virtualY) * ( (Float)(this7->width) )) + dx1) - this7->virtualX));
            											}
            											else {
HXLINE( 232)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this7->width) + dx1)) ));
            											}
HXDLIN( 232)											int c1 = ::iterMagic::Iimg_obj::get(this8,index1);
HXDLIN( 232)											int v2;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												v2 = c1;
            											}
HXDLIN( 232)											int maskPixel = v2;
HXDLIN( 232)											int this9 = col;
HXDLIN( 232)											if ((maskPixel == 0)) {
HXLINE( 232)												col = this9;
            											}
            											else {
HXLINE( 232)												Float m0;
HXDLIN( 232)												int this10 = ((maskPixel >> 24) & 255);
HXDLIN( 232)												if ((this10 == 0)) {
HXLINE( 232)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m0 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m1;
HXDLIN( 232)												int this11 = ((maskPixel >> 16) & 255);
HXDLIN( 232)												if ((this11 == 0)) {
HXLINE( 232)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m1 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m2;
HXDLIN( 232)												int this12 = ((maskPixel >> 8) & 255);
HXDLIN( 232)												if ((this12 == 0)) {
HXLINE( 232)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m2 = (( (Float)(this12) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m3;
HXDLIN( 232)												int this13 = (maskPixel & 255);
HXDLIN( 232)												if ((this13 == 0)) {
HXLINE( 232)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m3 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this9 >> 24) & 255)) )));
HXDLIN( 232)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this9 >> 16) & 255)) )));
HXDLIN( 232)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this9 >> 8) & 255)) )));
HXDLIN( 232)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this9 & 255)) )));
HXDLIN( 232)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 232)										if ((col != 0)) {
HXLINE( 232)											int x2 = (dx1 - rectLeft);
HXDLIN( 232)											int y2 = (dy1 - rectTop);
HXDLIN( 232)											int c2 = col;
HXDLIN( 232)											bool _hx_tmp3;
HXDLIN( 232)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 232)												_hx_tmp3 = undoImage->transparent;
            											}
            											else {
HXLINE( 232)												_hx_tmp3 = false;
            											}
HXDLIN( 232)											if (_hx_tmp3) {
HXLINE( 232)												int location;
HXDLIN( 232)												if (undoImage->useVirtualPos) {
HXLINE( 232)													location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 232)													location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 232)												int this14 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 232)												int this15;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													this15 = this14;
            												}
HXDLIN( 232)												Float a11;
HXDLIN( 232)												int this16 = ((this15 >> 24) & 255);
HXDLIN( 232)												if ((this16 == 0)) {
HXLINE( 232)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float r1;
HXDLIN( 232)												int this17 = ((this15 >> 16) & 255);
HXDLIN( 232)												if ((this17 == 0)) {
HXLINE( 232)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													r1 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float g1;
HXDLIN( 232)												int this18 = ((this15 >> 8) & 255);
HXDLIN( 232)												if ((this18 == 0)) {
HXLINE( 232)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													g1 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float b11;
HXDLIN( 232)												int this19 = (this15 & 255);
HXDLIN( 232)												if ((this19 == 0)) {
HXLINE( 232)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float a2;
HXDLIN( 232)												int this20 = ((col >> 24) & 255);
HXDLIN( 232)												if ((this20 == 0)) {
HXLINE( 232)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													a2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float r2;
HXDLIN( 232)												int this21 = ((col >> 16) & 255);
HXDLIN( 232)												if ((this21 == 0)) {
HXLINE( 232)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													r2 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float g2;
HXDLIN( 232)												int this22 = ((col >> 8) & 255);
HXDLIN( 232)												if ((this22 == 0)) {
HXLINE( 232)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													g2 = (( (Float)(this22) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float b21;
HXDLIN( 232)												int this23 = (col & 255);
HXDLIN( 232)												if ((this23 == 0)) {
HXLINE( 232)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 232)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 232)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 232)												int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 232)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 232)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 232)												{
HXLINE( 232)													int _hx_tmp4;
HXDLIN( 232)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)														_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 232)														_hx_tmp4 = blended;
            													}
HXDLIN( 232)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp4);
            												}
            											}
            											else {
HXLINE( 232)												::Dynamic this24 = undoImage->image;
HXDLIN( 232)												int index2;
HXDLIN( 232)												if (undoImage->useVirtualPos) {
HXLINE( 232)													index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 232)													index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 232)												int _hx_tmp5;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													_hx_tmp5 = c2;
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this24,index2,_hx_tmp5);
            											}
            										}
            										else {
HXLINE( 232)											if (forceClear) {
HXLINE( 232)												::Dynamic this25 = undoImage->image;
HXDLIN( 232)												int x3 = (dx1 - rectLeft);
HXDLIN( 232)												int y3 = (dy1 - rectTop);
HXDLIN( 232)												int index3;
HXDLIN( 232)												if (undoImage->useVirtualPos) {
HXLINE( 232)													index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXLINE( 232)													index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this25,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 232)				{
HXLINE( 232)					int _g_min = xIter3->start;
HXDLIN( 232)					int _g_max = xIter3->max;
HXDLIN( 232)					while((_g_min < _g_max)){
HXLINE( 232)						_g_min = (_g_min + 1);
HXDLIN( 232)						int px = (_g_min - 1);
HXDLIN( 232)						Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 232)						{
HXLINE( 232)							int _g_min1 = yIter3->start;
HXDLIN( 232)							int _g_max1 = yIter3->max;
HXDLIN( 232)							while((_g_min1 < _g_max1)){
HXLINE( 232)								_g_min1 = (_g_min1 + 1);
HXDLIN( 232)								int py = (_g_min1 - 1);
HXDLIN( 232)								Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 232)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 232)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 232)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 232)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 232)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 232)								bool _hx_tmp6;
HXDLIN( 232)								bool _hx_tmp7;
HXDLIN( 232)								if ((ratioA >= 0)) {
HXLINE( 232)									_hx_tmp7 = (ratioB >= 0);
            								}
            								else {
HXLINE( 232)									_hx_tmp7 = false;
            								}
HXDLIN( 232)								if (_hx_tmp7) {
HXLINE( 232)									_hx_tmp6 = (ratioC >= 0);
            								}
            								else {
HXLINE( 232)									_hx_tmp6 = false;
            								}
HXDLIN( 232)								if (_hx_tmp6) {
HXLINE( 232)									Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN( 232)									Float v3 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN( 232)									int x4 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN( 232)									int y4 = ::Std_obj::_hx_int(((v3 * win_height) + win_y));
HXDLIN( 232)									::Dynamic this26 = thisImage->image;
HXDLIN( 232)									int index4;
HXDLIN( 232)									if (thisImage->useVirtualPos) {
HXLINE( 232)										index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x4) - thisImage->virtualX));
            									}
            									else {
HXLINE( 232)										index4 = ::Std_obj::_hx_int(( (Float)(((y4 * thisImage->width) + x4)) ));
            									}
HXDLIN( 232)									int c3 = ::iterMagic::Iimg_obj::get(this26,index4);
HXDLIN( 232)									int col1;
HXDLIN( 232)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 232)										col1 = c3;
            									}
HXDLIN( 232)									{
HXLINE( 232)										int c4 = col1;
HXDLIN( 232)										bool _hx_tmp8;
HXDLIN( 232)										if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 232)											_hx_tmp8 = this3->transparent;
            										}
            										else {
HXLINE( 232)											_hx_tmp8 = false;
            										}
HXDLIN( 232)										if (_hx_tmp8) {
HXLINE( 232)											int location1;
HXDLIN( 232)											if (this3->useVirtualPos) {
HXLINE( 232)												location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this3->virtualY) * ( (Float)(this3->width) )) + px) - this3->virtualX));
            											}
            											else {
HXLINE( 232)												location1 = ::Std_obj::_hx_int(( (Float)(((py * this3->width) + px)) ));
            											}
HXDLIN( 232)											int this27 = ::iterMagic::Iimg_obj::get(this3->image,location1);
HXDLIN( 232)											int this28;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												this28 = this27;
            											}
HXDLIN( 232)											Float a12;
HXDLIN( 232)											int this29 = ((this28 >> 24) & 255);
HXDLIN( 232)											if ((this29 == 0)) {
HXLINE( 232)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float r11;
HXDLIN( 232)											int this30 = ((this28 >> 16) & 255);
HXDLIN( 232)											if ((this30 == 0)) {
HXLINE( 232)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												r11 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float g11;
HXDLIN( 232)											int this31 = ((this28 >> 8) & 255);
HXDLIN( 232)											if ((this31 == 0)) {
HXLINE( 232)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												g11 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float b12;
HXDLIN( 232)											int this32 = (this28 & 255);
HXDLIN( 232)											if ((this32 == 0)) {
HXLINE( 232)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float a21;
HXDLIN( 232)											int this33 = ((col1 >> 24) & 255);
HXDLIN( 232)											if ((this33 == 0)) {
HXLINE( 232)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												a21 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float r21;
HXDLIN( 232)											int this34 = ((col1 >> 16) & 255);
HXDLIN( 232)											if ((this34 == 0)) {
HXLINE( 232)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												r21 = (( (Float)(this34) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float g21;
HXDLIN( 232)											int this35 = ((col1 >> 8) & 255);
HXDLIN( 232)											if ((this35 == 0)) {
HXLINE( 232)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												g21 = (( (Float)(this35) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float b22;
HXDLIN( 232)											int this36 = (col1 & 255);
HXDLIN( 232)											if ((this36 == 0)) {
HXLINE( 232)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 232)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 232)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 232)											int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 232)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 232)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 232)											{
HXLINE( 232)												int _hx_tmp9;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													_hx_tmp9 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													_hx_tmp9 = blended1;
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this3->image,location1,_hx_tmp9);
            											}
            										}
            										else {
HXLINE( 232)											::Dynamic this37 = this3->image;
HXDLIN( 232)											int index5;
HXDLIN( 232)											if (this3->useVirtualPos) {
HXLINE( 232)												index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this3->virtualY) * ( (Float)(this3->width) )) + px) - this3->virtualX));
            											}
            											else {
HXLINE( 232)												index5 = ::Std_obj::_hx_int(( (Float)(((py * this3->width) + px)) ));
            											}
HXDLIN( 232)											int _hx_tmp10;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												_hx_tmp10 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												_hx_tmp10 = c4;
            											}
HXDLIN( 232)											::iterMagic::Iimg_obj::set(this37,index5,_hx_tmp10);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 232)				int v_undoY;
HXDLIN( 232)				int v_undoX;
HXDLIN( 232)				Float v_ty;
HXDLIN( 232)				Float v_tx;
HXDLIN( 232)				Float v_t0;
HXDLIN( 232)				Float v_sy;
HXDLIN( 232)				Float v_sx;
HXDLIN( 232)				Float v_s0;
HXDLIN( 232)				Float v_A;
HXDLIN( 232)				Float ax1 = ax;
HXDLIN( 232)				Float ay1 = ay;
HXDLIN( 232)				 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 232)				Float bx1 = bx;
HXDLIN( 232)				Float by1 = by;
HXDLIN( 232)				Float cx1 = dx;
HXDLIN( 232)				Float cy1 = dy;
HXDLIN( 232)				bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN( 232)				if (!(adjustWinding)) {
HXLINE( 232)					Float bx_ = bx1;
HXDLIN( 232)					Float by_ = by1;
HXLINE(  24)					bx1 = cx1;
HXLINE(  25)					by1 = cy1;
HXLINE(  26)					cx1 = bx_;
HXLINE(  27)					cy1 = by_;
            				}
HXLINE( 232)				Float v_ax = ax1;
HXDLIN( 232)				Float v_ay = ay1;
HXDLIN( 232)				Float v_bx = bx1;
HXDLIN( 232)				Float v_by = by1;
HXDLIN( 232)				Float v_cx = cx1;
HXDLIN( 232)				Float v_cy = cy1;
HXDLIN( 232)				bool v_preCalculated = true;
HXDLIN( 232)				{
HXLINE( 232)					v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 232)					v_sx = (v_cy - v_ay);
HXDLIN( 232)					v_sy = (v_ax - v_cx);
HXDLIN( 232)					v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 232)					v_tx = (v_ay - v_by);
HXDLIN( 232)					v_ty = (v_bx - v_ax);
HXDLIN( 232)					v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 232)					Float a6 = v_ax;
HXDLIN( 232)					Float b8 = v_bx;
HXDLIN( 232)					Float c5 = v_cx;
HXDLIN( 232)					if ((a6 > b8)) {
HXLINE( 232)						if ((a6 > c5)) {
HXLINE( 232)							int min6;
HXDLIN( 232)							if ((b8 > c5)) {
HXLINE( 232)								min6 = ::Math_obj::floor(c5);
            							}
            							else {
HXLINE( 232)								min6 = ::Math_obj::floor(b8);
            							}
HXDLIN( 232)							int ii_min10 = min6;
HXDLIN( 232)							int ii_max10 = ::Math_obj::ceil(a6);
HXDLIN( 232)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXLINE( 232)							int ii_min11 = ::Math_obj::floor(b8);
HXDLIN( 232)							int ii_max11 = ::Math_obj::ceil(c5);
HXDLIN( 232)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
            					else {
HXLINE( 232)						if ((b8 > c5)) {
HXLINE( 232)							int min7;
HXDLIN( 232)							if ((a6 > c5)) {
HXLINE( 232)								min7 = ::Math_obj::floor(c5);
            							}
            							else {
HXLINE( 232)								min7 = ::Math_obj::ceil(a6);
            							}
HXDLIN( 232)							int ii_min12 = min7;
HXDLIN( 232)							int ii_max12 = ::Math_obj::ceil(b8);
HXDLIN( 232)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXLINE( 232)							int ii_min13 = ::Math_obj::floor(a6);
HXDLIN( 232)							int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN( 232)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
HXDLIN( 232)					Float a7 = v_ay;
HXDLIN( 232)					Float b9 = v_by;
HXDLIN( 232)					Float c6 = v_cy;
HXDLIN( 232)					if ((a7 > b9)) {
HXLINE( 232)						if ((a7 > c6)) {
HXLINE( 232)							int min8;
HXDLIN( 232)							if ((b9 > c6)) {
HXLINE( 232)								min8 = ::Math_obj::floor(c6);
            							}
            							else {
HXLINE( 232)								min8 = ::Math_obj::floor(b9);
            							}
HXDLIN( 232)							int ii_min14 = min8;
HXDLIN( 232)							int ii_max14 = ::Math_obj::ceil(a7);
HXDLIN( 232)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXLINE( 232)							int ii_min15 = ::Math_obj::floor(b9);
HXDLIN( 232)							int ii_max15 = ::Math_obj::ceil(c6);
HXDLIN( 232)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
            					else {
HXLINE( 232)						if ((b9 > c6)) {
HXLINE( 232)							int min9;
HXDLIN( 232)							if ((a7 > c6)) {
HXLINE( 232)								min9 = ::Math_obj::floor(c6);
            							}
            							else {
HXLINE( 232)								min9 = ::Math_obj::ceil(a7);
            							}
HXDLIN( 232)							int ii_min16 = min9;
HXDLIN( 232)							int ii_max16 = ::Math_obj::ceil(b9);
HXDLIN( 232)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXLINE( 232)							int ii_min17 = ::Math_obj::floor(a7);
HXDLIN( 232)							int ii_max17 = ::Math_obj::ceil(c6);
HXDLIN( 232)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            				}
HXDLIN( 232)				if (hasUndo) {
HXLINE( 232)					v_undoImage = undoImage;
HXDLIN( 232)					v_undoX = xIter3->start;
HXDLIN( 232)					v_undoY = yIter3->start;
            				}
HXDLIN( 232)				Float au1 = bu;
HXDLIN( 232)				Float av1 = bv;
HXDLIN( 232)				Float bu2 = cu;
HXDLIN( 232)				Float bv2 = cv;
HXDLIN( 232)				bool hasUndo1 = false;
HXDLIN( 232)				Float temp5 = au1;
HXLINE( 422)				au1 = bu2;
HXLINE( 423)				bu2 = temp5;
HXLINE( 424)				temp5 = av1;
HXLINE( 425)				av1 = bv2;
HXLINE( 426)				bv2 = temp5;
HXLINE( 232)				Float bcx1 = (cx - dx);
HXDLIN( 232)				Float bcy1 = (cy - dy);
HXDLIN( 232)				Float acx1 = (bx - dx);
HXDLIN( 232)				Float acy1 = (by - dy);
HXDLIN( 232)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 232)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 232)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 232)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 232)				if ((bx > cx)) {
HXLINE( 232)					if ((bx > dx)) {
HXLINE( 232)						int min10;
HXDLIN( 232)						if ((cx > dx)) {
HXLINE( 232)							min10 = ::Math_obj::floor(dx);
            						}
            						else {
HXLINE( 232)							min10 = ::Math_obj::floor(cx);
            						}
HXDLIN( 232)						int ii_min18 = min10;
HXDLIN( 232)						int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN( 232)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE( 232)						int ii_min19 = ::Math_obj::floor(cx);
HXDLIN( 232)						int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN( 232)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
            				else {
HXLINE( 232)					if ((cx > dx)) {
HXLINE( 232)						int min11;
HXDLIN( 232)						if ((bx > dx)) {
HXLINE( 232)							min11 = ::Math_obj::floor(dx);
            						}
            						else {
HXLINE( 232)							min11 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 232)						int ii_min20 = min11;
HXDLIN( 232)						int ii_max20 = ::Math_obj::ceil(cx);
HXDLIN( 232)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE( 232)						int ii_min21 = ::Math_obj::floor(bx);
HXDLIN( 232)						int ii_max21 = ::Math_obj::ceil(dx);
HXDLIN( 232)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 232)				if ((by > cy)) {
HXLINE( 232)					if ((by > dy)) {
HXLINE( 232)						int min12;
HXDLIN( 232)						if ((cy > dy)) {
HXLINE( 232)							min12 = ::Math_obj::floor(dy);
            						}
            						else {
HXLINE( 232)							min12 = ::Math_obj::floor(cy);
            						}
HXDLIN( 232)						int ii_min22 = min12;
HXDLIN( 232)						int ii_max22 = ::Math_obj::ceil(by);
HXDLIN( 232)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE( 232)						int ii_min23 = ::Math_obj::floor(cy);
HXDLIN( 232)						int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN( 232)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
            				else {
HXLINE( 232)					if ((cy > dy)) {
HXLINE( 232)						int min13;
HXDLIN( 232)						if ((by > dy)) {
HXLINE( 232)							min13 = ::Math_obj::floor(dy);
            						}
            						else {
HXLINE( 232)							min13 = ::Math_obj::ceil(by);
            						}
HXDLIN( 232)						int ii_min24 = min13;
HXDLIN( 232)						int ii_max24 = ::Math_obj::ceil(cy);
HXDLIN( 232)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXLINE( 232)						int ii_min25 = ::Math_obj::floor(by);
HXDLIN( 232)						int ii_max25 = ::Math_obj::ceil(dy);
HXDLIN( 232)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
HXDLIN( 232)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 232)				if (hasUndo1) {
HXLINE( 232)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 232)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 232)					 ::Dynamic imageType2 = null();
HXDLIN( 232)					 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 232)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 232)					::Dynamic undoImage4;
HXDLIN( 232)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE( 232)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::BytesImg b10 = byt2;
HXDLIN( 232)							{
HXLINE( 232)								b10->width = width1;
HXDLIN( 232)								b10->height = height1;
HXDLIN( 232)								b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 232)								b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN( 232)								{
HXLINE( 232)									int len4 = b10->length;
HXDLIN( 232)									int w2 = 0;
HXDLIN( 232)									{
HXLINE( 232)										int _g36 = 0;
HXDLIN( 232)										int _g37 = b10->height;
HXDLIN( 232)										while((_g36 < _g37)){
HXLINE( 232)											_g36 = (_g36 + 1);
HXDLIN( 232)											int y5 = (_g36 - 1);
HXDLIN( 232)											{
HXLINE( 232)												int _g38 = 0;
HXDLIN( 232)												int _g39 = b10->width;
HXDLIN( 232)												while((_g38 < _g39)){
HXLINE( 232)													_g38 = (_g38 + 1);
HXDLIN( 232)													int x5 = (_g38 - 1);
HXDLIN( 232)													{
HXLINE( 232)														w2 = (w2 + 1);
HXDLIN( 232)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w2 = (w2 + 1);
HXDLIN( 232)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w2 = (w2 + 1);
HXDLIN( 232)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 232)													{
HXLINE( 232)														w2 = (w2 + 1);
HXDLIN( 232)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage4 = b10;
            						}
            						break;
            						case (int)1: {
HXLINE( 232)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::ArrIntImg a8 = arrI2;
HXDLIN( 232)							{
HXLINE( 232)								a8->width = width1;
HXDLIN( 232)								a8->height = height1;
HXDLIN( 232)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 232)								a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 232)								{
HXLINE( 232)									int _g40 = 0;
HXDLIN( 232)									int _g41 = a8->length;
HXDLIN( 232)									while((_g40 < _g41)){
HXLINE( 232)										_g40 = (_g40 + 1);
HXDLIN( 232)										int i12 = (_g40 - 1);
HXDLIN( 232)										a8->data[i12] = 0;
            									}
            								}
            							}
HXDLIN( 232)							undoImage4 = a8;
            						}
            						break;
            						case (int)2: {
HXLINE( 232)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::U32ArrImg b13 = u32a2;
HXDLIN( 232)							{
HXLINE( 232)								b13->width = width1;
HXDLIN( 232)								b13->height = height1;
HXDLIN( 232)								b13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 232)								int size2 = (b13->length * 4);
HXDLIN( 232)								b13->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 232)								{
HXLINE( 232)									int _g42 = 0;
HXDLIN( 232)									int _g43 = b13->length;
HXDLIN( 232)									while((_g42 < _g43)){
HXLINE( 232)										_g42 = (_g42 + 1);
HXDLIN( 232)										int i13 = (_g42 - 1);
HXDLIN( 232)										{
HXLINE( 232)											 ::haxe::io::ArrayBufferViewImpl this39 = b13->data;
HXDLIN( 232)											bool undoImage5;
HXDLIN( 232)											if ((i13 >= 0)) {
HXLINE( 232)												undoImage5 = (i13 < (this39->byteLength >> 2));
            											}
            											else {
HXLINE( 232)												undoImage5 = false;
            											}
HXDLIN( 232)											if (undoImage5) {
HXLINE( 232)												 ::haxe::io::Bytes _this2 = this39->bytes;
HXDLIN( 232)												int pos2 = ((i13 << 2) + this39->byteOffset);
HXDLIN( 232)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 232)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 232)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 232)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage4 = b13;
            						}
            						break;
            						case (int)3: {
HXLINE( 232)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 232)							{
HXLINE( 232)								v4->width = width1;
HXDLIN( 232)								v4->height = height1;
HXDLIN( 232)								v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 232)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 232)								{
HXLINE( 232)									int _g44 = 0;
HXDLIN( 232)									int _g45 = v4->length;
HXDLIN( 232)									while((_g44 < _g45)){
HXLINE( 232)										_g44 = (_g44 + 1);
HXDLIN( 232)										int i14 = (_g44 - 1);
HXDLIN( 232)										v4->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN( 232)							undoImage4 = v4;
            						}
            						break;
            						case (int)4: {
HXLINE( 232)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 232)							 ::iterMagic::StackIntImg b14 = sInt2;
HXDLIN( 232)							{
HXLINE( 232)								b14->width = width1;
HXDLIN( 232)								b14->height = height1;
HXDLIN( 232)								b14->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 232)								b14->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 232)								{
HXLINE( 232)									int len5 = b14->length;
HXDLIN( 232)									 ::haxe::ds::GenericStack_Int d2 = b14->data;
HXDLIN( 232)									if (::hx::IsNull( d2->head )) {
HXLINE( 232)										int _g46 = 0;
HXDLIN( 232)										int _g47 = len5;
HXDLIN( 232)										while((_g46 < _g47)){
HXLINE( 232)											_g46 = (_g46 + 1);
HXDLIN( 232)											int i15 = (_g46 - 1);
HXDLIN( 232)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE( 232)										int _g48 = 0;
HXDLIN( 232)										int _g49 = len5;
HXDLIN( 232)										while((_g48 < _g49)){
HXLINE( 232)											_g48 = (_g48 + 1);
HXDLIN( 232)											int i16 = (_g48 - 1);
HXDLIN( 232)											{
HXLINE( 232)												 ::haxe::ds::GenericCell_Int l2 = b14->data->head;
HXDLIN( 232)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 232)												{
HXLINE( 232)													int _g50 = 0;
HXDLIN( 232)													int _g51 = i16;
HXDLIN( 232)													while((_g50 < _g51)){
HXLINE( 232)														_g50 = (_g50 + 1);
HXDLIN( 232)														int i17 = (_g50 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 232)												if (::hx::IsNull( prev2 )) {
HXLINE( 232)													b14->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 232)													l2 = null();
            												}
            												else {
HXLINE( 232)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 232)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 232)							undoImage4 = b14;
            						}
            						break;
            					}
HXDLIN( 232)					this38->image = undoImage4;
HXDLIN( 232)					this38->width = width1;
HXDLIN( 232)					this38->height = height1;
HXDLIN( 232)					this38->imageType = ( (int)(imageType2) );
HXDLIN( 232)					undoImage3 = this38;
HXDLIN( 232)					{
HXLINE( 232)						int rectLeft1 = xIter31->start;
HXDLIN( 232)						int rectTop1 = yIter31->start;
HXDLIN( 232)						int rectRight1 = xIter31->max;
HXDLIN( 232)						bool forceClear1 = false;
HXDLIN( 232)						{
HXLINE( 232)							int _g52 = rectTop1;
HXDLIN( 232)							int _g53 = yIter31->max;
HXDLIN( 232)							while((_g52 < _g53)){
HXLINE( 232)								_g52 = (_g52 + 1);
HXDLIN( 232)								int dy2 = (_g52 - 1);
HXDLIN( 232)								{
HXLINE( 232)									int _g54 = rectLeft1;
HXDLIN( 232)									int _g55 = rectRight1;
HXDLIN( 232)									while((_g54 < _g55)){
HXLINE( 232)										_g54 = (_g54 + 1);
HXDLIN( 232)										int dx2 = (_g54 - 1);
HXDLIN( 232)										::Dynamic this40 = this3->image;
HXDLIN( 232)										int index6;
HXDLIN( 232)										if (this3->useVirtualPos) {
HXLINE( 232)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx2) - this3->virtualX));
            										}
            										else {
HXLINE( 232)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this3->width) + dx2)) ));
            										}
HXDLIN( 232)										int c7 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 232)										int col2;
HXDLIN( 232)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)											col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 232)											col2 = c7;
            										}
HXDLIN( 232)										bool _hx_tmp11;
HXDLIN( 232)										if (this3->useMask) {
HXLINE( 232)											_hx_tmp11 = ::hx::IsNotNull( this3->mask );
            										}
            										else {
HXLINE( 232)											_hx_tmp11 = false;
            										}
HXDLIN( 232)										if (_hx_tmp11) {
HXLINE( 232)											 ::pi_xy::ImageStruct this41 = this3->mask;
HXDLIN( 232)											::Dynamic this42 = this41->image;
HXDLIN( 232)											int index7;
HXDLIN( 232)											if (this41->useVirtualPos) {
HXLINE( 232)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx2) - this41->virtualX));
            											}
            											else {
HXLINE( 232)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this41->width) + dx2)) ));
            											}
HXDLIN( 232)											int c8 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 232)											int v5;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												v5 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												v5 = c8;
            											}
HXDLIN( 232)											int maskPixel1 = v5;
HXDLIN( 232)											int this43 = col2;
HXDLIN( 232)											if ((maskPixel1 == 0)) {
HXLINE( 232)												col2 = this43;
            											}
            											else {
HXLINE( 232)												Float m01;
HXDLIN( 232)												int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 232)												if ((this44 == 0)) {
HXLINE( 232)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m11;
HXDLIN( 232)												int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 232)												if ((this45 == 0)) {
HXLINE( 232)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m21;
HXDLIN( 232)												int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 232)												if ((this46 == 0)) {
HXLINE( 232)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float m31;
HXDLIN( 232)												int this47 = (maskPixel1 & 255);
HXDLIN( 232)												if ((this47 == 0)) {
HXLINE( 232)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 232)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 232)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 232)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 232)												col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 232)										if ((col2 != 0)) {
HXLINE( 232)											int x6 = (dx2 - rectLeft1);
HXDLIN( 232)											int y6 = (dy2 - rectTop1);
HXDLIN( 232)											int c9 = col2;
HXDLIN( 232)											bool _hx_tmp12;
HXDLIN( 232)											if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 232)												_hx_tmp12 = undoImage3->transparent;
            											}
            											else {
HXLINE( 232)												_hx_tmp12 = false;
            											}
HXDLIN( 232)											if (_hx_tmp12) {
HXLINE( 232)												int location2;
HXDLIN( 232)												if (undoImage3->useVirtualPos) {
HXLINE( 232)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 232)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 232)												int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 232)												int this49;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													this49 = this48;
            												}
HXDLIN( 232)												Float a13;
HXDLIN( 232)												int this50 = ((this49 >> 24) & 255);
HXDLIN( 232)												if ((this50 == 0)) {
HXLINE( 232)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													a13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float r12;
HXDLIN( 232)												int this51 = ((this49 >> 16) & 255);
HXDLIN( 232)												if ((this51 == 0)) {
HXLINE( 232)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float g12;
HXDLIN( 232)												int this52 = ((this49 >> 8) & 255);
HXDLIN( 232)												if ((this52 == 0)) {
HXLINE( 232)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float b15;
HXDLIN( 232)												int this53 = (this49 & 255);
HXDLIN( 232)												if ((this53 == 0)) {
HXLINE( 232)													b15 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													b15 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float a22;
HXDLIN( 232)												int this54 = ((col2 >> 24) & 255);
HXDLIN( 232)												if ((this54 == 0)) {
HXLINE( 232)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float r22;
HXDLIN( 232)												int this55 = ((col2 >> 16) & 255);
HXDLIN( 232)												if ((this55 == 0)) {
HXLINE( 232)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float g22;
HXDLIN( 232)												int this56 = ((col2 >> 8) & 255);
HXDLIN( 232)												if ((this56 == 0)) {
HXLINE( 232)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float b23;
HXDLIN( 232)												int this57 = (col2 & 255);
HXDLIN( 232)												if ((this57 == 0)) {
HXLINE( 232)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 232)													b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 232)												Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 232)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 232)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 232)												int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a32) + (b23 * a22))));
HXDLIN( 232)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 232)												int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b16);
HXDLIN( 232)												{
HXLINE( 232)													int _hx_tmp13;
HXDLIN( 232)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)														_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 232)														_hx_tmp13 = blended2;
            													}
HXDLIN( 232)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp13);
            												}
            											}
            											else {
HXLINE( 232)												::Dynamic this58 = undoImage3->image;
HXDLIN( 232)												int index8;
HXDLIN( 232)												if (undoImage3->useVirtualPos) {
HXLINE( 232)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 232)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 232)												int _hx_tmp14;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													_hx_tmp14 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													_hx_tmp14 = c9;
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp14);
            											}
            										}
            										else {
HXLINE( 232)											if (forceClear1) {
HXLINE( 232)												::Dynamic this59 = undoImage3->image;
HXDLIN( 232)												int x7 = (dx2 - rectLeft1);
HXDLIN( 232)												int y7 = (dy2 - rectTop1);
HXDLIN( 232)												int index9;
HXDLIN( 232)												if (undoImage3->useVirtualPos) {
HXLINE( 232)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 232)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this59,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 232)				{
HXLINE( 232)					int _g_min2 = xIter31->start;
HXDLIN( 232)					int _g_max2 = xIter31->max;
HXDLIN( 232)					while((_g_min2 < _g_max2)){
HXLINE( 232)						_g_min2 = (_g_min2 + 1);
HXDLIN( 232)						int px1 = (_g_min2 - 1);
HXDLIN( 232)						Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN( 232)						{
HXLINE( 232)							int _g_min3 = yIter31->start;
HXDLIN( 232)							int _g_max3 = yIter31->max;
HXDLIN( 232)							while((_g_min3 < _g_max3)){
HXLINE( 232)								_g_min3 = (_g_min3 + 1);
HXDLIN( 232)								int py1 = (_g_min3 - 1);
HXDLIN( 232)								Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN( 232)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 232)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 232)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 232)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 232)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 232)								bool _hx_tmp15;
HXDLIN( 232)								bool _hx_tmp16;
HXDLIN( 232)								if ((ratioA1 >= 0)) {
HXLINE( 232)									_hx_tmp16 = (ratioB1 >= 0);
            								}
            								else {
HXLINE( 232)									_hx_tmp16 = false;
            								}
HXDLIN( 232)								if (_hx_tmp16) {
HXLINE( 232)									_hx_tmp15 = (ratioC1 >= 0);
            								}
            								else {
HXLINE( 232)									_hx_tmp15 = false;
            								}
HXDLIN( 232)								if (_hx_tmp15) {
HXLINE( 232)									Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN( 232)									Float v6 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN( 232)									int x8 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN( 232)									int y8 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN( 232)									::Dynamic this60 = thisImage->image;
HXDLIN( 232)									int index10;
HXDLIN( 232)									if (thisImage->useVirtualPos) {
HXLINE( 232)										index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x8) - thisImage->virtualX));
            									}
            									else {
HXLINE( 232)										index10 = ::Std_obj::_hx_int(( (Float)(((y8 * thisImage->width) + x8)) ));
            									}
HXDLIN( 232)									int c10 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 232)									int col3;
HXDLIN( 232)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)										col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE( 232)										col3 = c10;
            									}
HXDLIN( 232)									{
HXLINE( 232)										int c11 = col3;
HXDLIN( 232)										bool _hx_tmp17;
HXDLIN( 232)										if ((((c11 >> 24) & 255) < 254)) {
HXLINE( 232)											_hx_tmp17 = this3->transparent;
            										}
            										else {
HXLINE( 232)											_hx_tmp17 = false;
            										}
HXDLIN( 232)										if (_hx_tmp17) {
HXLINE( 232)											int location3;
HXDLIN( 232)											if (this3->useVirtualPos) {
HXLINE( 232)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this3->virtualY) * ( (Float)(this3->width) )) + px1) - this3->virtualX));
            											}
            											else {
HXLINE( 232)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this3->width) + px1)) ));
            											}
HXDLIN( 232)											int this61 = ::iterMagic::Iimg_obj::get(this3->image,location3);
HXDLIN( 232)											int this62;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												this62 = this61;
            											}
HXDLIN( 232)											Float a14;
HXDLIN( 232)											int this63 = ((this62 >> 24) & 255);
HXDLIN( 232)											if ((this63 == 0)) {
HXLINE( 232)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float r13;
HXDLIN( 232)											int this64 = ((this62 >> 16) & 255);
HXDLIN( 232)											if ((this64 == 0)) {
HXLINE( 232)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float g13;
HXDLIN( 232)											int this65 = ((this62 >> 8) & 255);
HXDLIN( 232)											if ((this65 == 0)) {
HXLINE( 232)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float b17;
HXDLIN( 232)											int this66 = (this62 & 255);
HXDLIN( 232)											if ((this66 == 0)) {
HXLINE( 232)												b17 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												b17 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float a23;
HXDLIN( 232)											int this67 = ((col3 >> 24) & 255);
HXDLIN( 232)											if ((this67 == 0)) {
HXLINE( 232)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float r23;
HXDLIN( 232)											int this68 = ((col3 >> 16) & 255);
HXDLIN( 232)											if ((this68 == 0)) {
HXLINE( 232)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float g23;
HXDLIN( 232)											int this69 = ((col3 >> 8) & 255);
HXDLIN( 232)											if ((this69 == 0)) {
HXLINE( 232)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float b24;
HXDLIN( 232)											int this70 = (col3 & 255);
HXDLIN( 232)											if ((this70 == 0)) {
HXLINE( 232)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 232)												b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            											}
HXDLIN( 232)											Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 232)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 232)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 232)											int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a33) + (b24 * a23))));
HXDLIN( 232)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 232)											int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b18);
HXDLIN( 232)											{
HXLINE( 232)												int _hx_tmp18;
HXDLIN( 232)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)													_hx_tmp18 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 232)													_hx_tmp18 = blended3;
            												}
HXDLIN( 232)												::iterMagic::Iimg_obj::set(this3->image,location3,_hx_tmp18);
            											}
            										}
            										else {
HXLINE( 232)											::Dynamic this71 = this3->image;
HXDLIN( 232)											int index11;
HXDLIN( 232)											if (this3->useVirtualPos) {
HXLINE( 232)												index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this3->virtualY) * ( (Float)(this3->width) )) + px1) - this3->virtualX));
            											}
            											else {
HXLINE( 232)												index11 = ::Std_obj::_hx_int(( (Float)(((py1 * this3->width) + px1)) ));
            											}
HXDLIN( 232)											int _hx_tmp19;
HXDLIN( 232)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 232)												_hx_tmp19 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXLINE( 232)												_hx_tmp19 = c11;
            											}
HXDLIN( 232)											::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp19);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 232)				 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 232)				int v_undoY1;
HXDLIN( 232)				int v_undoX1;
HXDLIN( 232)				Float v_ty1;
HXDLIN( 232)				Float v_tx1;
HXDLIN( 232)				Float v_t01;
HXDLIN( 232)				Float v_sy1;
HXDLIN( 232)				Float v_sx1;
HXDLIN( 232)				Float v_s01;
HXDLIN( 232)				Float v_A1;
HXDLIN( 232)				Float ax2 = bx;
HXDLIN( 232)				Float ay2 = by;
HXDLIN( 232)				 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 232)				Float bx2 = cx;
HXDLIN( 232)				Float by2 = cy;
HXDLIN( 232)				Float cx2 = dx;
HXDLIN( 232)				Float cy2 = dy;
HXDLIN( 232)				bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN( 232)				if (!(adjustWinding1)) {
HXLINE( 232)					Float bx_1 = bx2;
HXDLIN( 232)					Float by_1 = by2;
HXLINE(  24)					bx2 = cx2;
HXLINE(  25)					by2 = cy2;
HXLINE(  26)					cx2 = bx_1;
HXLINE(  27)					cy2 = by_1;
            				}
HXLINE( 232)				Float v_ax1 = ax2;
HXDLIN( 232)				Float v_ay1 = ay2;
HXDLIN( 232)				Float v_bx1 = bx2;
HXDLIN( 232)				Float v_by1 = by2;
HXDLIN( 232)				Float v_cx1 = cx2;
HXDLIN( 232)				Float v_cy1 = cy2;
HXDLIN( 232)				bool v_preCalculated1 = true;
HXDLIN( 232)				{
HXLINE( 232)					v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 232)					v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 232)					v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 232)					v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 232)					v_tx1 = (v_ay1 - v_by1);
HXDLIN( 232)					v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 232)					v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 232)					Float a15 = v_ax1;
HXDLIN( 232)					Float b19 = v_bx1;
HXDLIN( 232)					Float c12 = v_cx1;
HXDLIN( 232)					if ((a15 > b19)) {
HXLINE( 232)						if ((a15 > c12)) {
HXLINE( 232)							int min14;
HXDLIN( 232)							if ((b19 > c12)) {
HXLINE( 232)								min14 = ::Math_obj::floor(c12);
            							}
            							else {
HXLINE( 232)								min14 = ::Math_obj::floor(b19);
            							}
HXDLIN( 232)							int ii_min26 = min14;
HXDLIN( 232)							int ii_max26 = ::Math_obj::ceil(a15);
HXDLIN( 232)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXLINE( 232)							int ii_min27 = ::Math_obj::floor(b19);
HXDLIN( 232)							int ii_max27 = ::Math_obj::ceil(c12);
HXDLIN( 232)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
            					else {
HXLINE( 232)						if ((b19 > c12)) {
HXLINE( 232)							int min15;
HXDLIN( 232)							if ((a15 > c12)) {
HXLINE( 232)								min15 = ::Math_obj::floor(c12);
            							}
            							else {
HXLINE( 232)								min15 = ::Math_obj::ceil(a15);
            							}
HXDLIN( 232)							int ii_min28 = min15;
HXDLIN( 232)							int ii_max28 = ::Math_obj::ceil(b19);
HXDLIN( 232)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXLINE( 232)							int ii_min29 = ::Math_obj::floor(a15);
HXDLIN( 232)							int ii_max29 = ::Math_obj::ceil(c12);
HXDLIN( 232)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
HXDLIN( 232)					Float a16 = v_ay1;
HXDLIN( 232)					Float b20 = v_by1;
HXDLIN( 232)					Float c13 = v_cy1;
HXDLIN( 232)					if ((a16 > b20)) {
HXLINE( 232)						if ((a16 > c13)) {
HXLINE( 232)							int min16;
HXDLIN( 232)							if ((b20 > c13)) {
HXLINE( 232)								min16 = ::Math_obj::floor(c13);
            							}
            							else {
HXLINE( 232)								min16 = ::Math_obj::floor(b20);
            							}
HXDLIN( 232)							int ii_min30 = min16;
HXDLIN( 232)							int ii_max30 = ::Math_obj::ceil(a16);
HXDLIN( 232)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXLINE( 232)							int ii_min31 = ::Math_obj::floor(b20);
HXDLIN( 232)							int ii_max31 = ::Math_obj::ceil(c13);
HXDLIN( 232)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
            					else {
HXLINE( 232)						if ((b20 > c13)) {
HXLINE( 232)							int min17;
HXDLIN( 232)							if ((a16 > c13)) {
HXLINE( 232)								min17 = ::Math_obj::floor(c13);
            							}
            							else {
HXLINE( 232)								min17 = ::Math_obj::ceil(a16);
            							}
HXDLIN( 232)							int ii_min32 = min17;
HXDLIN( 232)							int ii_max32 = ::Math_obj::ceil(b20);
HXDLIN( 232)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            						}
            						else {
HXLINE( 232)							int ii_min33 = ::Math_obj::floor(a16);
HXDLIN( 232)							int ii_max33 = ::Math_obj::ceil(c13);
HXDLIN( 232)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            						}
            					}
            				}
HXDLIN( 232)				if (hasUndo1) {
HXLINE( 232)					v_undoImage1 = undoImage3;
HXDLIN( 232)					v_undoX1 = xIter31->start;
HXDLIN( 232)					v_undoY1 = yIter31->start;
            				}
            			}
            		}
HXLINE( 233)		bool _hx_tmp20;
HXDLIN( 233)		if (::hx::IsNotNull( nextImage->mask )) {
HXLINE( 233)			_hx_tmp20 = includeMask;
            		}
            		else {
HXLINE( 233)			_hx_tmp20 = false;
            		}
HXDLIN( 233)		if (_hx_tmp20) {
HXLINE( 234)			 ::pi_xy::ImageStruct this72 = thisImage->mask;
HXDLIN( 234)			bool transparent1 = thisImage->mask->transparent;
HXDLIN( 234)			Float centreX1 = centreX;
HXDLIN( 234)			Float centreY1 = centreY;
HXDLIN( 234)			Float ax3 = ((Float)0.);
HXDLIN( 234)			Float ay3 = ((Float)0.);
HXDLIN( 234)			if ((centreX1 != ((Float)0.))) {
HXLINE( 173)				centreX1 = ((( (Float)(this72->width) ) / ( (Float)(2) )) + centreX1);
HXLINE( 234)				ax3 = (ax3 - centreX1);
            			}
HXDLIN( 234)			if ((centreY1 != ((Float)0.))) {
HXLINE( 177)				centreY1 = ((( (Float)(this72->height) ) / ( (Float)(2) )) + centreY1);
HXLINE( 234)				ay3 = (ay3 - centreY1);
            			}
HXDLIN( 234)			Float bx3 = (ax3 + this72->width);
HXDLIN( 234)			Float by3 = ay3;
HXDLIN( 234)			Float cx3 = bx3;
HXDLIN( 234)			Float cy3 = (ay3 + this72->height);
HXDLIN( 234)			Float dx3 = ax3;
HXDLIN( 234)			Float dy3 = cy3;
HXDLIN( 234)			Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 234)			Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 234)			Float temp6 = ax3;
HXLINE( 189)			ax3 = ((temp6 * cos1) - (ay3 * sin1));
HXLINE( 190)			ay3 = ((ay3 * cos1) + (temp6 * sin1));
HXLINE( 234)			Float temp7 = bx3;
HXLINE( 192)			bx3 = ((temp7 * cos1) - (by3 * sin1));
HXLINE( 193)			by3 = ((by3 * cos1) + (temp7 * sin1));
HXLINE( 234)			Float temp8 = cx3;
HXLINE( 195)			cx3 = ((temp8 * cos1) - (cy3 * sin1));
HXLINE( 196)			cy3 = ((cy3 * cos1) + (temp8 * sin1));
HXLINE( 234)			Float temp9 = dx3;
HXLINE( 198)			dx3 = ((temp9 * cos1) - (dy3 * sin1));
HXLINE( 199)			dy3 = ((dy3 * cos1) + (temp9 * sin1));
HXLINE( 234)			if ((centreX1 != ((Float)0.))) {
HXLINE( 234)				ax3 = (ax3 + centreX1);
HXDLIN( 234)				bx3 = (bx3 + centreX1);
HXDLIN( 234)				cx3 = (cx3 + centreX1);
HXDLIN( 234)				dx3 = (dx3 + centreX1);
            			}
HXDLIN( 234)			if ((centreY1 != ((Float)0.))) {
HXLINE( 234)				ay3 = (ay3 + centreY1);
HXDLIN( 234)				by3 = (by3 + centreY1);
HXDLIN( 234)				cy3 = (cy3 + centreY1);
HXDLIN( 234)				dy3 = (dy3 + centreY1);
            			}
HXDLIN( 234)			int min18 = ::Math_obj::floor(ax3);
HXDLIN( 234)			int max2 = ::Math_obj::ceil(ax3);
HXDLIN( 234)			if ((bx3 < min18)) {
HXLINE(  31)				min18 = ::Math_obj::floor(bx3);
            			}
            			else {
HXLINE( 234)				if ((bx3 > max2)) {
HXLINE(  33)					max2 = ::Math_obj::ceil(bx3);
            				}
            			}
HXLINE( 234)			if ((cx3 < min18)) {
HXLINE(  36)				min18 = ::Math_obj::floor(cx3);
            			}
            			else {
HXLINE( 234)				if ((cx3 > max2)) {
HXLINE(  38)					max2 = ::Math_obj::ceil(cx3);
            				}
            			}
HXLINE( 234)			if ((dx3 < min18)) {
HXLINE(  41)				min18 = ::Math_obj::floor(dx3);
            			}
            			else {
HXLINE( 234)				if ((dx3 > max2)) {
HXLINE(  43)					max2 = ::Math_obj::ceil(dx3);
            				}
            			}
HXLINE( 234)			int ii_min34 = min18;
HXDLIN( 234)			int ii_max34 = max2;
HXDLIN( 234)			 ::pi_xy::iter::IntIterStart boundX1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
HXDLIN( 234)			int min19 = ::Math_obj::floor(ay3);
HXDLIN( 234)			int max3 = ::Math_obj::ceil(ay3);
HXDLIN( 234)			if ((by3 < min19)) {
HXLINE(  31)				min19 = ::Math_obj::floor(by3);
            			}
            			else {
HXLINE( 234)				if ((by3 > max3)) {
HXLINE(  33)					max3 = ::Math_obj::ceil(by3);
            				}
            			}
HXLINE( 234)			if ((cy3 < min19)) {
HXLINE(  36)				min19 = ::Math_obj::floor(cy3);
            			}
            			else {
HXLINE( 234)				if ((cy3 > max3)) {
HXLINE(  38)					max3 = ::Math_obj::ceil(cy3);
            				}
            			}
HXLINE( 234)			if ((dy3 < min19)) {
HXLINE(  41)				min19 = ::Math_obj::floor(dy3);
            			}
            			else {
HXLINE( 234)				if ((dy3 > max3)) {
HXLINE(  43)					max3 = ::Math_obj::ceil(dy3);
            				}
            			}
HXLINE( 234)			int ii_min35 = min19;
HXDLIN( 234)			int ii_max35 = max3;
HXDLIN( 234)			 ::pi_xy::iter::IntIterStart boundY1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
HXDLIN( 234)			int minX1 = boundX1->start;
HXDLIN( 234)			int wid1 = ((boundX1->max - boundX1->start) + 1);
HXDLIN( 234)			int minY1 = boundY1->start;
HXDLIN( 234)			int hi1 = ((boundY1->max - boundY1->start) + 1);
HXDLIN( 234)			 ::Dynamic imageType3 = null();
HXDLIN( 234)			 ::pi_xy::ImageStruct this73 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 234)			if (::hx::IsNull( imageType3 )) {
HXLINE(  54)				imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 234)			::Dynamic _hx_tmp21;
HXDLIN( 234)			switch((int)(( (int)(imageType3) ))){
            				case (int)0: {
HXLINE( 234)					 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 234)					 ::iterMagic::BytesImg b25 = byt3;
HXDLIN( 234)					{
HXLINE( 234)						b25->width = wid1;
HXDLIN( 234)						b25->height = hi1;
HXDLIN( 234)						b25->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 234)						b25->data = ::haxe::io::Bytes_obj::alloc((b25->length * 4));
HXDLIN( 234)						{
HXLINE( 234)							int len6 = b25->length;
HXDLIN( 234)							int w3 = 0;
HXDLIN( 234)							{
HXLINE( 234)								int _g56 = 0;
HXDLIN( 234)								int _g57 = b25->height;
HXDLIN( 234)								while((_g56 < _g57)){
HXLINE( 234)									_g56 = (_g56 + 1);
HXDLIN( 234)									int y9 = (_g56 - 1);
HXDLIN( 234)									{
HXLINE( 234)										int _g58 = 0;
HXDLIN( 234)										int _g59 = b25->width;
HXDLIN( 234)										while((_g58 < _g59)){
HXLINE( 234)											_g58 = (_g58 + 1);
HXDLIN( 234)											int x9 = (_g58 - 1);
HXDLIN( 234)											{
HXLINE( 234)												w3 = (w3 + 1);
HXDLIN( 234)												b25->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 234)											{
HXLINE( 234)												w3 = (w3 + 1);
HXDLIN( 234)												b25->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 234)											{
HXLINE( 234)												w3 = (w3 + 1);
HXDLIN( 234)												b25->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 234)											{
HXLINE( 234)												w3 = (w3 + 1);
HXDLIN( 234)												b25->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					_hx_tmp21 = b25;
            				}
            				break;
            				case (int)1: {
HXLINE( 234)					 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)					 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN( 234)					{
HXLINE( 234)						a17->width = wid1;
HXDLIN( 234)						a17->height = hi1;
HXDLIN( 234)						a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 234)						a17->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 234)						{
HXLINE( 234)							int _g60 = 0;
HXDLIN( 234)							int _g61 = a17->length;
HXDLIN( 234)							while((_g60 < _g61)){
HXLINE( 234)								_g60 = (_g60 + 1);
HXDLIN( 234)								int i18 = (_g60 - 1);
HXDLIN( 234)								a17->data[i18] = 0;
            							}
            						}
            					}
HXDLIN( 234)					_hx_tmp21 = a17;
            				}
            				break;
            				case (int)2: {
HXLINE( 234)					 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 234)					 ::iterMagic::U32ArrImg b26 = u32a3;
HXDLIN( 234)					{
HXLINE( 234)						b26->width = wid1;
HXDLIN( 234)						b26->height = hi1;
HXDLIN( 234)						b26->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 234)						int size3 = (b26->length * 4);
HXDLIN( 234)						b26->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 234)						{
HXLINE( 234)							int _g62 = 0;
HXDLIN( 234)							int _g63 = b26->length;
HXDLIN( 234)							while((_g62 < _g63)){
HXLINE( 234)								_g62 = (_g62 + 1);
HXDLIN( 234)								int i19 = (_g62 - 1);
HXDLIN( 234)								{
HXLINE( 234)									 ::haxe::io::ArrayBufferViewImpl this74 = b26->data;
HXDLIN( 234)									bool _hx_tmp22;
HXDLIN( 234)									if ((i19 >= 0)) {
HXLINE( 234)										_hx_tmp22 = (i19 < (this74->byteLength >> 2));
            									}
            									else {
HXLINE( 234)										_hx_tmp22 = false;
            									}
HXDLIN( 234)									if (_hx_tmp22) {
HXLINE( 234)										 ::haxe::io::Bytes _this3 = this74->bytes;
HXDLIN( 234)										int pos3 = ((i19 << 2) + this74->byteOffset);
HXDLIN( 234)										_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 234)										_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 234)										_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 234)										_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					_hx_tmp21 = b26;
            				}
            				break;
            				case (int)3: {
HXLINE( 234)					 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)					 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN( 234)					{
HXLINE( 234)						v7->width = wid1;
HXDLIN( 234)						v7->height = hi1;
HXDLIN( 234)						v7->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 234)						v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 234)						{
HXLINE( 234)							int _g64 = 0;
HXDLIN( 234)							int _g65 = v7->length;
HXDLIN( 234)							while((_g64 < _g65)){
HXLINE( 234)								_g64 = (_g64 + 1);
HXDLIN( 234)								int i20 = (_g64 - 1);
HXDLIN( 234)								v7->data->__unsafe_set(i20,0);
            							}
            						}
            					}
HXDLIN( 234)					_hx_tmp21 = v7;
            				}
            				break;
            				case (int)4: {
HXLINE( 234)					 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)					 ::iterMagic::StackIntImg b27 = sInt3;
HXDLIN( 234)					{
HXLINE( 234)						b27->width = wid1;
HXDLIN( 234)						b27->height = hi1;
HXDLIN( 234)						b27->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN( 234)						b27->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 234)						{
HXLINE( 234)							int len7 = b27->length;
HXDLIN( 234)							 ::haxe::ds::GenericStack_Int d3 = b27->data;
HXDLIN( 234)							if (::hx::IsNull( d3->head )) {
HXLINE( 234)								int _g66 = 0;
HXDLIN( 234)								int _g67 = len7;
HXDLIN( 234)								while((_g66 < _g67)){
HXLINE( 234)									_g66 = (_g66 + 1);
HXDLIN( 234)									int i21 = (_g66 - 1);
HXDLIN( 234)									d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            								}
            							}
            							else {
HXLINE( 234)								int _g68 = 0;
HXDLIN( 234)								int _g69 = len7;
HXDLIN( 234)								while((_g68 < _g69)){
HXLINE( 234)									_g68 = (_g68 + 1);
HXDLIN( 234)									int i22 = (_g68 - 1);
HXDLIN( 234)									{
HXLINE( 234)										 ::haxe::ds::GenericCell_Int l3 = b27->data->head;
HXDLIN( 234)										 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 234)										{
HXLINE( 234)											int _g70 = 0;
HXDLIN( 234)											int _g71 = i22;
HXDLIN( 234)											while((_g70 < _g71)){
HXLINE( 234)												_g70 = (_g70 + 1);
HXDLIN( 234)												int i23 = (_g70 - 1);
HXLINE( 345)												prev3 = l3;
HXLINE( 346)												l3 = l3->next;
            											}
            										}
HXLINE( 234)										if (::hx::IsNull( prev3 )) {
HXLINE( 234)											b27->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 234)											l3 = null();
            										}
            										else {
HXLINE( 234)											prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 234)											l3 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					_hx_tmp21 = b27;
            				}
            				break;
            			}
HXDLIN( 234)			this73->image = _hx_tmp21;
HXDLIN( 234)			this73->width = wid1;
HXDLIN( 234)			this73->height = hi1;
HXDLIN( 234)			this73->imageType = ( (int)(imageType3) );
HXDLIN( 234)			 ::pi_xy::ImageStruct nextImage1 = this73;
HXDLIN( 234)			nextImage1->transparent = true;
HXDLIN( 234)			if ((minX1 < ((Float)0.))) {
HXLINE( 234)				ax3 = (ax3 - ( (Float)(minX1) ));
HXDLIN( 234)				bx3 = (bx3 - ( (Float)(minX1) ));
HXDLIN( 234)				cx3 = (cx3 - ( (Float)(minX1) ));
HXDLIN( 234)				dx3 = (dx3 - ( (Float)(minX1) ));
            			}
HXDLIN( 234)			if ((minY1 < ((Float)0.))) {
HXLINE( 234)				ay3 = (ay3 - ( (Float)(minY1) ));
HXDLIN( 234)				by3 = (by3 - ( (Float)(minY1) ));
HXDLIN( 234)				cy3 = (cy3 - ( (Float)(minY1) ));
HXDLIN( 234)				dy3 = (dy3 - ( (Float)(minY1) ));
            			}
HXDLIN( 234)			{
HXLINE( 234)				 ::pi_xy::ImageStruct this75 = nextImage1;
HXDLIN( 234)				Float win_x1 = ( (Float)(0) );
HXDLIN( 234)				Float win_y1 = ( (Float)(0) );
HXDLIN( 234)				Float win_width1 = ( (Float)(this72->width) );
HXDLIN( 234)				Float win_height1 = ( (Float)(this72->height) );
HXDLIN( 234)				{
HXLINE( 234)					Float bu3 = ((Float)1.);
HXDLIN( 234)					Float bv3 = ((Float)0.);
HXDLIN( 234)					Float cu1 = ((Float)1.);
HXDLIN( 234)					Float cv1 = ((Float)1.);
HXDLIN( 234)					Float du1 = ((Float)0.);
HXDLIN( 234)					Float dv1 = ((Float)1.);
HXDLIN( 234)					Float au2 = ((Float)0.);
HXDLIN( 234)					Float av2 = ((Float)0.);
HXDLIN( 234)					Float bu4 = bu3;
HXDLIN( 234)					Float bv4 = bv3;
HXDLIN( 234)					bool hasUndo2 = false;
HXDLIN( 234)					Float temp10 = au2;
HXLINE( 422)					au2 = bu4;
HXLINE( 423)					bu4 = temp10;
HXLINE( 424)					temp10 = av2;
HXLINE( 425)					av2 = bv4;
HXLINE( 426)					bv4 = temp10;
HXLINE( 234)					Float bcx2 = (bx3 - dx3);
HXDLIN( 234)					Float bcy2 = (by3 - dy3);
HXDLIN( 234)					Float acx2 = (ax3 - dx3);
HXDLIN( 234)					Float acy2 = (ay3 - dy3);
HXDLIN( 234)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 234)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 234)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 234)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 234)					if ((ax3 > bx3)) {
HXLINE( 234)						if ((ax3 > dx3)) {
HXLINE( 234)							int min20;
HXDLIN( 234)							if ((bx3 > dx3)) {
HXLINE( 234)								min20 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE( 234)								min20 = ::Math_obj::floor(bx3);
            							}
HXDLIN( 234)							int ii_min36 = min20;
HXDLIN( 234)							int ii_max36 = ::Math_obj::ceil(ax3);
HXDLIN( 234)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            						}
            						else {
HXLINE( 234)							int ii_min37 = ::Math_obj::floor(bx3);
HXDLIN( 234)							int ii_max37 = ::Math_obj::ceil(dx3);
HXDLIN( 234)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            						}
            					}
            					else {
HXLINE( 234)						if ((bx3 > dx3)) {
HXLINE( 234)							int min21;
HXDLIN( 234)							if ((ax3 > dx3)) {
HXLINE( 234)								min21 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE( 234)								min21 = ::Math_obj::ceil(ax3);
            							}
HXDLIN( 234)							int ii_min38 = min21;
HXDLIN( 234)							int ii_max38 = ::Math_obj::ceil(bx3);
HXDLIN( 234)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            						}
            						else {
HXLINE( 234)							int ii_min39 = ::Math_obj::floor(ax3);
HXDLIN( 234)							int ii_max39 = ::Math_obj::ceil(dx3);
HXDLIN( 234)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            						}
            					}
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 234)					if ((ay3 > by3)) {
HXLINE( 234)						if ((ay3 > dy3)) {
HXLINE( 234)							int min22;
HXDLIN( 234)							if ((by3 > dy3)) {
HXLINE( 234)								min22 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE( 234)								min22 = ::Math_obj::floor(by3);
            							}
HXDLIN( 234)							int ii_min40 = min22;
HXDLIN( 234)							int ii_max40 = ::Math_obj::ceil(ay3);
HXDLIN( 234)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            						}
            						else {
HXLINE( 234)							int ii_min41 = ::Math_obj::floor(by3);
HXDLIN( 234)							int ii_max41 = ::Math_obj::ceil(dy3);
HXDLIN( 234)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            					}
            					else {
HXLINE( 234)						if ((by3 > dy3)) {
HXLINE( 234)							int min23;
HXDLIN( 234)							if ((ay3 > dy3)) {
HXLINE( 234)								min23 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE( 234)								min23 = ::Math_obj::ceil(ay3);
            							}
HXDLIN( 234)							int ii_min42 = min23;
HXDLIN( 234)							int ii_max42 = ::Math_obj::ceil(by3);
HXDLIN( 234)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            						}
            						else {
HXLINE( 234)							int ii_min43 = ::Math_obj::floor(ay3);
HXDLIN( 234)							int ii_max43 = ::Math_obj::ceil(dy3);
HXDLIN( 234)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            						}
            					}
HXDLIN( 234)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 234)					if (hasUndo2) {
HXLINE( 234)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 234)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 234)						 ::Dynamic imageType4 = null();
HXDLIN( 234)						 ::pi_xy::ImageStruct this76 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 234)						if (::hx::IsNull( imageType4 )) {
HXLINE(  54)							imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 234)						::Dynamic undoImage7;
HXDLIN( 234)						switch((int)(( (int)(imageType4) ))){
            							case (int)0: {
HXLINE( 234)								 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::BytesImg b28 = byt4;
HXDLIN( 234)								{
HXLINE( 234)									b28->width = width2;
HXDLIN( 234)									b28->height = height2;
HXDLIN( 234)									b28->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 234)									b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN( 234)									{
HXLINE( 234)										int len8 = b28->length;
HXDLIN( 234)										int w4 = 0;
HXDLIN( 234)										{
HXLINE( 234)											int _g72 = 0;
HXDLIN( 234)											int _g73 = b28->height;
HXDLIN( 234)											while((_g72 < _g73)){
HXLINE( 234)												_g72 = (_g72 + 1);
HXDLIN( 234)												int y10 = (_g72 - 1);
HXDLIN( 234)												{
HXLINE( 234)													int _g74 = 0;
HXDLIN( 234)													int _g75 = b28->width;
HXDLIN( 234)													while((_g74 < _g75)){
HXLINE( 234)														_g74 = (_g74 + 1);
HXDLIN( 234)														int x10 = (_g74 - 1);
HXDLIN( 234)														{
HXLINE( 234)															w4 = (w4 + 1);
HXDLIN( 234)															b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w4 = (w4 + 1);
HXDLIN( 234)															b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w4 = (w4 + 1);
HXDLIN( 234)															b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w4 = (w4 + 1);
HXDLIN( 234)															b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage7 = b28;
            							}
            							break;
            							case (int)1: {
HXLINE( 234)								 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::ArrIntImg a18 = arrI4;
HXDLIN( 234)								{
HXLINE( 234)									a18->width = width2;
HXDLIN( 234)									a18->height = height2;
HXDLIN( 234)									a18->data = ::Array_obj< int >::__new(0);
HXDLIN( 234)									a18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 234)									{
HXLINE( 234)										int _g76 = 0;
HXDLIN( 234)										int _g77 = a18->length;
HXDLIN( 234)										while((_g76 < _g77)){
HXLINE( 234)											_g76 = (_g76 + 1);
HXDLIN( 234)											int i24 = (_g76 - 1);
HXDLIN( 234)											a18->data[i24] = 0;
            										}
            									}
            								}
HXDLIN( 234)								undoImage7 = a18;
            							}
            							break;
            							case (int)2: {
HXLINE( 234)								 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::U32ArrImg b29 = u32a4;
HXDLIN( 234)								{
HXLINE( 234)									b29->width = width2;
HXDLIN( 234)									b29->height = height2;
HXDLIN( 234)									b29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 234)									int size4 = (b29->length * 4);
HXDLIN( 234)									b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 234)									{
HXLINE( 234)										int _g78 = 0;
HXDLIN( 234)										int _g79 = b29->length;
HXDLIN( 234)										while((_g78 < _g79)){
HXLINE( 234)											_g78 = (_g78 + 1);
HXDLIN( 234)											int i25 = (_g78 - 1);
HXDLIN( 234)											{
HXLINE( 234)												 ::haxe::io::ArrayBufferViewImpl this77 = b29->data;
HXDLIN( 234)												bool undoImage8;
HXDLIN( 234)												if ((i25 >= 0)) {
HXLINE( 234)													undoImage8 = (i25 < (this77->byteLength >> 2));
            												}
            												else {
HXLINE( 234)													undoImage8 = false;
            												}
HXDLIN( 234)												if (undoImage8) {
HXLINE( 234)													 ::haxe::io::Bytes _this4 = this77->bytes;
HXDLIN( 234)													int pos4 = ((i25 << 2) + this77->byteOffset);
HXDLIN( 234)													_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 234)													_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 234)													_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 234)													_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage7 = b29;
            							}
            							break;
            							case (int)3: {
HXLINE( 234)								 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::VecIntImg v8 = vec4;
HXDLIN( 234)								{
HXLINE( 234)									v8->width = width2;
HXDLIN( 234)									v8->height = height2;
HXDLIN( 234)									v8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 234)									v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 234)									{
HXLINE( 234)										int _g80 = 0;
HXDLIN( 234)										int _g81 = v8->length;
HXDLIN( 234)										while((_g80 < _g81)){
HXLINE( 234)											_g80 = (_g80 + 1);
HXDLIN( 234)											int i26 = (_g80 - 1);
HXDLIN( 234)											v8->data->__unsafe_set(i26,0);
            										}
            									}
            								}
HXDLIN( 234)								undoImage7 = v8;
            							}
            							break;
            							case (int)4: {
HXLINE( 234)								 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::StackIntImg b30 = sInt4;
HXDLIN( 234)								{
HXLINE( 234)									b30->width = width2;
HXDLIN( 234)									b30->height = height2;
HXDLIN( 234)									b30->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 234)									b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 234)									{
HXLINE( 234)										int len9 = b30->length;
HXDLIN( 234)										 ::haxe::ds::GenericStack_Int d4 = b30->data;
HXDLIN( 234)										if (::hx::IsNull( d4->head )) {
HXLINE( 234)											int _g82 = 0;
HXDLIN( 234)											int _g83 = len9;
HXDLIN( 234)											while((_g82 < _g83)){
HXLINE( 234)												_g82 = (_g82 + 1);
HXDLIN( 234)												int i27 = (_g82 - 1);
HXDLIN( 234)												d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            											}
            										}
            										else {
HXLINE( 234)											int _g84 = 0;
HXDLIN( 234)											int _g85 = len9;
HXDLIN( 234)											while((_g84 < _g85)){
HXLINE( 234)												_g84 = (_g84 + 1);
HXDLIN( 234)												int i28 = (_g84 - 1);
HXDLIN( 234)												{
HXLINE( 234)													 ::haxe::ds::GenericCell_Int l4 = b30->data->head;
HXDLIN( 234)													 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 234)													{
HXLINE( 234)														int _g86 = 0;
HXDLIN( 234)														int _g87 = i28;
HXDLIN( 234)														while((_g86 < _g87)){
HXLINE( 234)															_g86 = (_g86 + 1);
HXDLIN( 234)															int i29 = (_g86 - 1);
HXLINE( 345)															prev4 = l4;
HXLINE( 346)															l4 = l4->next;
            														}
            													}
HXLINE( 234)													if (::hx::IsNull( prev4 )) {
HXLINE( 234)														b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 234)														l4 = null();
            													}
            													else {
HXLINE( 234)														prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 234)														l4 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage7 = b30;
            							}
            							break;
            						}
HXDLIN( 234)						this76->image = undoImage7;
HXDLIN( 234)						this76->width = width2;
HXDLIN( 234)						this76->height = height2;
HXDLIN( 234)						this76->imageType = ( (int)(imageType4) );
HXDLIN( 234)						undoImage6 = this76;
HXDLIN( 234)						{
HXLINE( 234)							int rectLeft2 = xIter32->start;
HXDLIN( 234)							int rectTop2 = yIter32->start;
HXDLIN( 234)							int rectRight2 = xIter32->max;
HXDLIN( 234)							bool forceClear2 = false;
HXDLIN( 234)							{
HXLINE( 234)								int _g88 = rectTop2;
HXDLIN( 234)								int _g89 = yIter32->max;
HXDLIN( 234)								while((_g88 < _g89)){
HXLINE( 234)									_g88 = (_g88 + 1);
HXDLIN( 234)									int dy4 = (_g88 - 1);
HXDLIN( 234)									{
HXLINE( 234)										int _g90 = rectLeft2;
HXDLIN( 234)										int _g91 = rectRight2;
HXDLIN( 234)										while((_g90 < _g91)){
HXLINE( 234)											_g90 = (_g90 + 1);
HXDLIN( 234)											int dx4 = (_g90 - 1);
HXDLIN( 234)											::Dynamic this78 = this75->image;
HXDLIN( 234)											int index12;
HXDLIN( 234)											if (this75->useVirtualPos) {
HXLINE( 234)												index12 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this75->virtualY) * ( (Float)(this75->width) )) + dx4) - this75->virtualX));
            											}
            											else {
HXLINE( 234)												index12 = ::Std_obj::_hx_int(( (Float)(((dy4 * this75->width) + dx4)) ));
            											}
HXDLIN( 234)											int c14 = ::iterMagic::Iimg_obj::get(this78,index12);
HXDLIN( 234)											int col4;
HXDLIN( 234)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)												col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXLINE( 234)												col4 = c14;
            											}
HXDLIN( 234)											bool _hx_tmp23;
HXDLIN( 234)											if (this75->useMask) {
HXLINE( 234)												_hx_tmp23 = ::hx::IsNotNull( this75->mask );
            											}
            											else {
HXLINE( 234)												_hx_tmp23 = false;
            											}
HXDLIN( 234)											if (_hx_tmp23) {
HXLINE( 234)												 ::pi_xy::ImageStruct this79 = this75->mask;
HXDLIN( 234)												::Dynamic this80 = this79->image;
HXDLIN( 234)												int index13;
HXDLIN( 234)												if (this79->useVirtualPos) {
HXLINE( 234)													index13 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this79->virtualY) * ( (Float)(this79->width) )) + dx4) - this79->virtualX));
            												}
            												else {
HXLINE( 234)													index13 = ::Std_obj::_hx_int(( (Float)(((dy4 * this79->width) + dx4)) ));
            												}
HXDLIN( 234)												int c15 = ::iterMagic::Iimg_obj::get(this80,index13);
HXDLIN( 234)												int v9;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													v9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													v9 = c15;
            												}
HXDLIN( 234)												int maskPixel2 = v9;
HXDLIN( 234)												int this81 = col4;
HXDLIN( 234)												if ((maskPixel2 == 0)) {
HXLINE( 234)													col4 = this81;
            												}
            												else {
HXLINE( 234)													Float m02;
HXDLIN( 234)													int this82 = ((maskPixel2 >> 24) & 255);
HXDLIN( 234)													if ((this82 == 0)) {
HXLINE( 234)														m02 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m02 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m12;
HXDLIN( 234)													int this83 = ((maskPixel2 >> 16) & 255);
HXDLIN( 234)													if ((this83 == 0)) {
HXLINE( 234)														m12 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m12 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m22;
HXDLIN( 234)													int this84 = ((maskPixel2 >> 8) & 255);
HXDLIN( 234)													if ((this84 == 0)) {
HXLINE( 234)														m22 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m22 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m32;
HXDLIN( 234)													int this85 = (maskPixel2 & 255);
HXDLIN( 234)													if ((this85 == 0)) {
HXLINE( 234)														m32 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m32 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this81 >> 24) & 255)) )));
HXDLIN( 234)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this81 >> 16) & 255)) )));
HXDLIN( 234)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this81 >> 8) & 255)) )));
HXDLIN( 234)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this81 & 255)) )));
HXDLIN( 234)													col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 234)											if ((col4 != 0)) {
HXLINE( 234)												int x11 = (dx4 - rectLeft2);
HXDLIN( 234)												int y11 = (dy4 - rectTop2);
HXDLIN( 234)												int c16 = col4;
HXDLIN( 234)												bool _hx_tmp24;
HXDLIN( 234)												if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 234)													_hx_tmp24 = undoImage6->transparent;
            												}
            												else {
HXLINE( 234)													_hx_tmp24 = false;
            												}
HXDLIN( 234)												if (_hx_tmp24) {
HXLINE( 234)													int location4;
HXDLIN( 234)													if (undoImage6->useVirtualPos) {
HXLINE( 234)														location4 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            													}
            													else {
HXLINE( 234)														location4 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            													}
HXDLIN( 234)													int this86 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 234)													int this87;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														this87 = ((((((this86 >> 24) & 255) << 24) | ((this86 & 255) << 16)) | (((this86 >> 8) & 255) << 8)) | ((this86 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														this87 = this86;
            													}
HXDLIN( 234)													Float a19;
HXDLIN( 234)													int this88 = ((this87 >> 24) & 255);
HXDLIN( 234)													if ((this88 == 0)) {
HXLINE( 234)														a19 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														a19 = (( (Float)(this88) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float r14;
HXDLIN( 234)													int this89 = ((this87 >> 16) & 255);
HXDLIN( 234)													if ((this89 == 0)) {
HXLINE( 234)														r14 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														r14 = (( (Float)(this89) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float g14;
HXDLIN( 234)													int this90 = ((this87 >> 8) & 255);
HXDLIN( 234)													if ((this90 == 0)) {
HXLINE( 234)														g14 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														g14 = (( (Float)(this90) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float b110;
HXDLIN( 234)													int this91 = (this87 & 255);
HXDLIN( 234)													if ((this91 == 0)) {
HXLINE( 234)														b110 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														b110 = (( (Float)(this91) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float a24;
HXDLIN( 234)													int this92 = ((col4 >> 24) & 255);
HXDLIN( 234)													if ((this92 == 0)) {
HXLINE( 234)														a24 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														a24 = (( (Float)(this92) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float r24;
HXDLIN( 234)													int this93 = ((col4 >> 16) & 255);
HXDLIN( 234)													if ((this93 == 0)) {
HXLINE( 234)														r24 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														r24 = (( (Float)(this93) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float g24;
HXDLIN( 234)													int this94 = ((col4 >> 8) & 255);
HXDLIN( 234)													if ((this94 == 0)) {
HXLINE( 234)														g24 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														g24 = (( (Float)(this94) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float b210;
HXDLIN( 234)													int this95 = (col4 & 255);
HXDLIN( 234)													if ((this95 == 0)) {
HXLINE( 234)														b210 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														b210 = (( (Float)(this95) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float a34 = (a19 * (( (Float)(1) ) - a24));
HXDLIN( 234)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 234)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 234)													int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b210 * a24))));
HXDLIN( 234)													int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 234)													int blended4 = ((((a20 << 24) | (r6 << 16)) | (g6 << 8)) | b31);
HXDLIN( 234)													{
HXLINE( 234)														int _hx_tmp25;
HXDLIN( 234)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)															_hx_tmp25 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE( 234)															_hx_tmp25 = blended4;
            														}
HXDLIN( 234)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp25);
            													}
            												}
            												else {
HXLINE( 234)													::Dynamic this96 = undoImage6->image;
HXDLIN( 234)													int index14;
HXDLIN( 234)													if (undoImage6->useVirtualPos) {
HXLINE( 234)														index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            													}
            													else {
HXLINE( 234)														index14 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            													}
HXDLIN( 234)													int _hx_tmp26;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														_hx_tmp26 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														_hx_tmp26 = c16;
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this96,index14,_hx_tmp26);
            												}
            											}
            											else {
HXLINE( 234)												if (forceClear2) {
HXLINE( 234)													::Dynamic this97 = undoImage6->image;
HXDLIN( 234)													int x12 = (dx4 - rectLeft2);
HXDLIN( 234)													int y12 = (dy4 - rectTop2);
HXDLIN( 234)													int index15;
HXDLIN( 234)													if (undoImage6->useVirtualPos) {
HXLINE( 234)														index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            													}
            													else {
HXLINE( 234)														index15 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this97,index15,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					{
HXLINE( 234)						int _g_min4 = xIter32->start;
HXDLIN( 234)						int _g_max4 = xIter32->max;
HXDLIN( 234)						while((_g_min4 < _g_max4)){
HXLINE( 234)							_g_min4 = (_g_min4 + 1);
HXDLIN( 234)							int px2 = (_g_min4 - 1);
HXDLIN( 234)							Float pcx2 = (( (Float)(px2) ) - dx3);
HXDLIN( 234)							{
HXLINE( 234)								int _g_min5 = yIter32->start;
HXDLIN( 234)								int _g_max5 = yIter32->max;
HXDLIN( 234)								while((_g_min5 < _g_max5)){
HXLINE( 234)									_g_min5 = (_g_min5 + 1);
HXDLIN( 234)									int py2 = (_g_min5 - 1);
HXDLIN( 234)									Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN( 234)									Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 234)									Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 234)									Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 234)									Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 234)									Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 234)									bool _hx_tmp27;
HXDLIN( 234)									bool _hx_tmp28;
HXDLIN( 234)									if ((ratioA2 >= 0)) {
HXLINE( 234)										_hx_tmp28 = (ratioB2 >= 0);
            									}
            									else {
HXLINE( 234)										_hx_tmp28 = false;
            									}
HXDLIN( 234)									if (_hx_tmp28) {
HXLINE( 234)										_hx_tmp27 = (ratioC2 >= 0);
            									}
            									else {
HXLINE( 234)										_hx_tmp27 = false;
            									}
HXDLIN( 234)									if (_hx_tmp27) {
HXLINE( 234)										Float u2 = (((au2 * ratioA2) + (bu4 * ratioB2)) + (du1 * ratioC2));
HXDLIN( 234)										Float v10 = (((av2 * ratioA2) + (bv4 * ratioB2)) + (dv1 * ratioC2));
HXDLIN( 234)										int x13 = ::Std_obj::_hx_int(((u2 * win_width1) + win_x1));
HXDLIN( 234)										int y13 = ::Std_obj::_hx_int(((v10 * win_height1) + win_y1));
HXDLIN( 234)										::Dynamic this98 = this72->image;
HXDLIN( 234)										int index16;
HXDLIN( 234)										if (this72->useVirtualPos) {
HXLINE( 234)											index16 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this72->virtualY) * ( (Float)(this72->width) )) + x13) - this72->virtualX));
            										}
            										else {
HXLINE( 234)											index16 = ::Std_obj::_hx_int(( (Float)(((y13 * this72->width) + x13)) ));
            										}
HXDLIN( 234)										int c17 = ::iterMagic::Iimg_obj::get(this98,index16);
HXDLIN( 234)										int col5;
HXDLIN( 234)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)											col5 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            										}
            										else {
HXLINE( 234)											col5 = c17;
            										}
HXDLIN( 234)										{
HXLINE( 234)											int c18 = col5;
HXDLIN( 234)											bool _hx_tmp29;
HXDLIN( 234)											if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 234)												_hx_tmp29 = this75->transparent;
            											}
            											else {
HXLINE( 234)												_hx_tmp29 = false;
            											}
HXDLIN( 234)											if (_hx_tmp29) {
HXLINE( 234)												int location5;
HXDLIN( 234)												if (this75->useVirtualPos) {
HXLINE( 234)													location5 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this75->virtualY) * ( (Float)(this75->width) )) + px2) - this75->virtualX));
            												}
            												else {
HXLINE( 234)													location5 = ::Std_obj::_hx_int(( (Float)(((py2 * this75->width) + px2)) ));
            												}
HXDLIN( 234)												int this99 = ::iterMagic::Iimg_obj::get(this75->image,location5);
HXDLIN( 234)												int this100;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													this100 = ((((((this99 >> 24) & 255) << 24) | ((this99 & 255) << 16)) | (((this99 >> 8) & 255) << 8)) | ((this99 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													this100 = this99;
            												}
HXDLIN( 234)												Float a110;
HXDLIN( 234)												int this101 = ((this100 >> 24) & 255);
HXDLIN( 234)												if ((this101 == 0)) {
HXLINE( 234)													a110 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													a110 = (( (Float)(this101) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float r15;
HXDLIN( 234)												int this102 = ((this100 >> 16) & 255);
HXDLIN( 234)												if ((this102 == 0)) {
HXLINE( 234)													r15 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													r15 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float g15;
HXDLIN( 234)												int this103 = ((this100 >> 8) & 255);
HXDLIN( 234)												if ((this103 == 0)) {
HXLINE( 234)													g15 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													g15 = (( (Float)(this103) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float b111;
HXDLIN( 234)												int this104 = (this100 & 255);
HXDLIN( 234)												if ((this104 == 0)) {
HXLINE( 234)													b111 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													b111 = (( (Float)(this104) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float a25;
HXDLIN( 234)												int this105 = ((col5 >> 24) & 255);
HXDLIN( 234)												if ((this105 == 0)) {
HXLINE( 234)													a25 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													a25 = (( (Float)(this105) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float r25;
HXDLIN( 234)												int this106 = ((col5 >> 16) & 255);
HXDLIN( 234)												if ((this106 == 0)) {
HXLINE( 234)													r25 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													r25 = (( (Float)(this106) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float g25;
HXDLIN( 234)												int this107 = ((col5 >> 8) & 255);
HXDLIN( 234)												if ((this107 == 0)) {
HXLINE( 234)													g25 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													g25 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float b211;
HXDLIN( 234)												int this108 = (col5 & 255);
HXDLIN( 234)												if ((this108 == 0)) {
HXLINE( 234)													b211 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													b211 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 234)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 234)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 234)												int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b211 * a25))));
HXDLIN( 234)												int a26 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 234)												int blended5 = ((((a26 << 24) | (r7 << 16)) | (g7 << 8)) | b32);
HXDLIN( 234)												{
HXLINE( 234)													int _hx_tmp30;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														_hx_tmp30 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														_hx_tmp30 = blended5;
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this75->image,location5,_hx_tmp30);
            												}
            											}
            											else {
HXLINE( 234)												::Dynamic this109 = this75->image;
HXDLIN( 234)												int index17;
HXDLIN( 234)												if (this75->useVirtualPos) {
HXLINE( 234)													index17 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this75->virtualY) * ( (Float)(this75->width) )) + px2) - this75->virtualX));
            												}
            												else {
HXLINE( 234)													index17 = ::Std_obj::_hx_int(( (Float)(((py2 * this75->width) + px2)) ));
            												}
HXDLIN( 234)												int _hx_tmp31;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													_hx_tmp31 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													_hx_tmp31 = c18;
            												}
HXDLIN( 234)												::iterMagic::Iimg_obj::set(this109,index17,_hx_tmp31);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN( 234)					int v_undoY2;
HXDLIN( 234)					int v_undoX2;
HXDLIN( 234)					Float v_ty2;
HXDLIN( 234)					Float v_tx2;
HXDLIN( 234)					Float v_t02;
HXDLIN( 234)					Float v_sy2;
HXDLIN( 234)					Float v_sx2;
HXDLIN( 234)					Float v_s02;
HXDLIN( 234)					Float v_A2;
HXDLIN( 234)					Float ax4 = ax3;
HXDLIN( 234)					Float ay4 = ay3;
HXDLIN( 234)					 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN( 234)					Float bx4 = bx3;
HXDLIN( 234)					Float by4 = by3;
HXDLIN( 234)					Float cx4 = dx3;
HXDLIN( 234)					Float cy4 = dy3;
HXDLIN( 234)					bool adjustWinding2 = (((((ax4 * by4) - (bx4 * ay4)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay4) - (ax4 * cy4))) > 0);
HXDLIN( 234)					if (!(adjustWinding2)) {
HXLINE( 234)						Float bx_2 = bx4;
HXDLIN( 234)						Float by_2 = by4;
HXLINE(  24)						bx4 = cx4;
HXLINE(  25)						by4 = cy4;
HXLINE(  26)						cx4 = bx_2;
HXLINE(  27)						cy4 = by_2;
            					}
HXLINE( 234)					Float v_ax2 = ax4;
HXDLIN( 234)					Float v_ay2 = ay4;
HXDLIN( 234)					Float v_bx2 = bx4;
HXDLIN( 234)					Float v_by2 = by4;
HXDLIN( 234)					Float v_cx2 = cx4;
HXDLIN( 234)					Float v_cy2 = cy4;
HXDLIN( 234)					bool v_preCalculated2 = true;
HXDLIN( 234)					{
HXLINE(  93)						v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  93)						v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  93)						v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  93)						v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  93)						v_tx2 = (v_ay2 - v_by2);
HXDLIN(  93)						v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  93)						v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXLINE( 234)						Float a27 = v_ax2;
HXDLIN( 234)						Float b33 = v_bx2;
HXDLIN( 234)						Float c19 = v_cx2;
HXDLIN( 234)						if ((a27 > b33)) {
HXLINE( 234)							if ((a27 > c19)) {
HXLINE( 234)								int min24;
HXDLIN( 234)								if ((b33 > c19)) {
HXLINE( 234)									min24 = ::Math_obj::floor(c19);
            								}
            								else {
HXLINE( 234)									min24 = ::Math_obj::floor(b33);
            								}
HXDLIN( 234)								int ii_min44 = min24;
HXDLIN( 234)								int ii_max44 = ::Math_obj::ceil(a27);
HXDLIN( 234)								v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            							}
            							else {
HXLINE( 234)								int ii_min45 = ::Math_obj::floor(b33);
HXDLIN( 234)								int ii_max45 = ::Math_obj::ceil(c19);
HXDLIN( 234)								v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            							}
            						}
            						else {
HXLINE( 234)							if ((b33 > c19)) {
HXLINE( 234)								int min25;
HXDLIN( 234)								if ((a27 > c19)) {
HXLINE( 234)									min25 = ::Math_obj::floor(c19);
            								}
            								else {
HXLINE( 234)									min25 = ::Math_obj::ceil(a27);
            								}
HXDLIN( 234)								int ii_min46 = min25;
HXDLIN( 234)								int ii_max46 = ::Math_obj::ceil(b33);
HXDLIN( 234)								v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            							}
            							else {
HXLINE( 234)								int ii_min47 = ::Math_obj::floor(a27);
HXDLIN( 234)								int ii_max47 = ::Math_obj::ceil(c19);
HXDLIN( 234)								v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            							}
            						}
HXDLIN( 234)						Float a28 = v_ay2;
HXDLIN( 234)						Float b34 = v_by2;
HXDLIN( 234)						Float c20 = v_cy2;
HXDLIN( 234)						if ((a28 > b34)) {
HXLINE( 234)							if ((a28 > c20)) {
HXLINE( 234)								int min26;
HXDLIN( 234)								if ((b34 > c20)) {
HXLINE( 234)									min26 = ::Math_obj::floor(c20);
            								}
            								else {
HXLINE( 234)									min26 = ::Math_obj::floor(b34);
            								}
HXDLIN( 234)								int ii_min48 = min26;
HXDLIN( 234)								int ii_max48 = ::Math_obj::ceil(a28);
HXDLIN( 234)								v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            							}
            							else {
HXLINE( 234)								int ii_min49 = ::Math_obj::floor(b34);
HXDLIN( 234)								int ii_max49 = ::Math_obj::ceil(c20);
HXDLIN( 234)								v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            							}
            						}
            						else {
HXLINE( 234)							if ((b34 > c20)) {
HXLINE( 234)								int min27;
HXDLIN( 234)								if ((a28 > c20)) {
HXLINE( 234)									min27 = ::Math_obj::floor(c20);
            								}
            								else {
HXLINE( 234)									min27 = ::Math_obj::ceil(a28);
            								}
HXDLIN( 234)								int ii_min50 = min27;
HXDLIN( 234)								int ii_max50 = ::Math_obj::ceil(b34);
HXDLIN( 234)								v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            							}
            							else {
HXLINE( 234)								int ii_min51 = ::Math_obj::floor(a28);
HXDLIN( 234)								int ii_max51 = ::Math_obj::ceil(c20);
HXDLIN( 234)								v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            							}
            						}
            					}
HXDLIN( 234)					if (hasUndo2) {
HXLINE(  93)						v_undoImage2 = undoImage6;
HXDLIN(  93)						v_undoX2 = xIter32->start;
HXDLIN(  93)						v_undoY2 = yIter32->start;
            					}
HXLINE( 234)					Float au3 = bu3;
HXDLIN( 234)					Float av3 = bv3;
HXDLIN( 234)					Float bu5 = cu1;
HXDLIN( 234)					Float bv5 = cv1;
HXDLIN( 234)					bool hasUndo3 = false;
HXDLIN( 234)					Float temp11 = au3;
HXLINE( 422)					au3 = bu5;
HXLINE( 423)					bu5 = temp11;
HXLINE( 424)					temp11 = av3;
HXLINE( 425)					av3 = bv5;
HXLINE( 426)					bv5 = temp11;
HXLINE( 234)					Float bcx3 = (cx3 - dx3);
HXDLIN( 234)					Float bcy3 = (cy3 - dy3);
HXDLIN( 234)					Float acx3 = (bx3 - dx3);
HXDLIN( 234)					Float acy3 = (by3 - dy3);
HXDLIN( 234)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 234)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 234)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 234)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 234)					if ((bx3 > cx3)) {
HXLINE( 234)						if ((bx3 > dx3)) {
HXLINE( 234)							int min28;
HXDLIN( 234)							if ((cx3 > dx3)) {
HXLINE( 234)								min28 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE( 234)								min28 = ::Math_obj::floor(cx3);
            							}
HXDLIN( 234)							int ii_min52 = min28;
HXDLIN( 234)							int ii_max52 = ::Math_obj::ceil(bx3);
HXDLIN( 234)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            						}
            						else {
HXLINE( 234)							int ii_min53 = ::Math_obj::floor(cx3);
HXDLIN( 234)							int ii_max53 = ::Math_obj::ceil(dx3);
HXDLIN( 234)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            						}
            					}
            					else {
HXLINE( 234)						if ((cx3 > dx3)) {
HXLINE( 234)							int min29;
HXDLIN( 234)							if ((bx3 > dx3)) {
HXLINE( 234)								min29 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE( 234)								min29 = ::Math_obj::ceil(bx3);
            							}
HXDLIN( 234)							int ii_min54 = min29;
HXDLIN( 234)							int ii_max54 = ::Math_obj::ceil(cx3);
HXDLIN( 234)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            						}
            						else {
HXLINE( 234)							int ii_min55 = ::Math_obj::floor(bx3);
HXDLIN( 234)							int ii_max55 = ::Math_obj::ceil(dx3);
HXDLIN( 234)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            						}
            					}
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 234)					if ((by3 > cy3)) {
HXLINE( 234)						if ((by3 > dy3)) {
HXLINE( 234)							int min30;
HXDLIN( 234)							if ((cy3 > dy3)) {
HXLINE( 234)								min30 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE( 234)								min30 = ::Math_obj::floor(cy3);
            							}
HXDLIN( 234)							int ii_min56 = min30;
HXDLIN( 234)							int ii_max56 = ::Math_obj::ceil(by3);
HXDLIN( 234)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            						}
            						else {
HXLINE( 234)							int ii_min57 = ::Math_obj::floor(cy3);
HXDLIN( 234)							int ii_max57 = ::Math_obj::ceil(dy3);
HXDLIN( 234)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            						}
            					}
            					else {
HXLINE( 234)						if ((cy3 > dy3)) {
HXLINE( 234)							int min31;
HXDLIN( 234)							if ((by3 > dy3)) {
HXLINE( 234)								min31 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE( 234)								min31 = ::Math_obj::ceil(by3);
            							}
HXDLIN( 234)							int ii_min58 = min31;
HXDLIN( 234)							int ii_max58 = ::Math_obj::ceil(cy3);
HXDLIN( 234)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            						}
            						else {
HXLINE( 234)							int ii_min59 = ::Math_obj::floor(by3);
HXDLIN( 234)							int ii_max59 = ::Math_obj::ceil(dy3);
HXDLIN( 234)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            						}
            					}
HXDLIN( 234)					 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 234)					if (hasUndo3) {
HXLINE( 234)						int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 234)						int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 234)						 ::Dynamic imageType5 = null();
HXDLIN( 234)						 ::pi_xy::ImageStruct this110 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 234)						if (::hx::IsNull( imageType5 )) {
HXLINE(  54)							imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 234)						::Dynamic undoImage10;
HXDLIN( 234)						switch((int)(( (int)(imageType5) ))){
            							case (int)0: {
HXLINE( 234)								 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::BytesImg b35 = byt5;
HXDLIN( 234)								{
HXLINE( 234)									b35->width = width3;
HXDLIN( 234)									b35->height = height3;
HXDLIN( 234)									b35->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 234)									b35->data = ::haxe::io::Bytes_obj::alloc((b35->length * 4));
HXDLIN( 234)									{
HXLINE( 234)										int len10 = b35->length;
HXDLIN( 234)										int w5 = 0;
HXDLIN( 234)										{
HXLINE( 234)											int _g92 = 0;
HXDLIN( 234)											int _g93 = b35->height;
HXDLIN( 234)											while((_g92 < _g93)){
HXLINE( 234)												_g92 = (_g92 + 1);
HXDLIN( 234)												int y14 = (_g92 - 1);
HXDLIN( 234)												{
HXLINE( 234)													int _g94 = 0;
HXDLIN( 234)													int _g95 = b35->width;
HXDLIN( 234)													while((_g94 < _g95)){
HXLINE( 234)														_g94 = (_g94 + 1);
HXDLIN( 234)														int x14 = (_g94 - 1);
HXDLIN( 234)														{
HXLINE( 234)															w5 = (w5 + 1);
HXDLIN( 234)															b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w5 = (w5 + 1);
HXDLIN( 234)															b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w5 = (w5 + 1);
HXDLIN( 234)															b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 234)														{
HXLINE( 234)															w5 = (w5 + 1);
HXDLIN( 234)															b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage10 = b35;
            							}
            							break;
            							case (int)1: {
HXLINE( 234)								 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::ArrIntImg a29 = arrI5;
HXDLIN( 234)								{
HXLINE( 234)									a29->width = width3;
HXDLIN( 234)									a29->height = height3;
HXDLIN( 234)									a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 234)									a29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 234)									{
HXLINE( 234)										int _g96 = 0;
HXDLIN( 234)										int _g97 = a29->length;
HXDLIN( 234)										while((_g96 < _g97)){
HXLINE( 234)											_g96 = (_g96 + 1);
HXDLIN( 234)											int i30 = (_g96 - 1);
HXDLIN( 234)											a29->data[i30] = 0;
            										}
            									}
            								}
HXDLIN( 234)								undoImage10 = a29;
            							}
            							break;
            							case (int)2: {
HXLINE( 234)								 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::U32ArrImg b36 = u32a5;
HXDLIN( 234)								{
HXLINE( 234)									b36->width = width3;
HXDLIN( 234)									b36->height = height3;
HXDLIN( 234)									b36->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 234)									int size5 = (b36->length * 4);
HXDLIN( 234)									b36->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 234)									{
HXLINE( 234)										int _g98 = 0;
HXDLIN( 234)										int _g99 = b36->length;
HXDLIN( 234)										while((_g98 < _g99)){
HXLINE( 234)											_g98 = (_g98 + 1);
HXDLIN( 234)											int i31 = (_g98 - 1);
HXDLIN( 234)											{
HXLINE( 234)												 ::haxe::io::ArrayBufferViewImpl this111 = b36->data;
HXDLIN( 234)												bool undoImage11;
HXDLIN( 234)												if ((i31 >= 0)) {
HXLINE( 234)													undoImage11 = (i31 < (this111->byteLength >> 2));
            												}
            												else {
HXLINE( 234)													undoImage11 = false;
            												}
HXDLIN( 234)												if (undoImage11) {
HXLINE( 234)													 ::haxe::io::Bytes _this5 = this111->bytes;
HXDLIN( 234)													int pos5 = ((i31 << 2) + this111->byteOffset);
HXDLIN( 234)													_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 234)													_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 234)													_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 234)													_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage10 = b36;
            							}
            							break;
            							case (int)3: {
HXLINE( 234)								 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::VecIntImg v11 = vec5;
HXDLIN( 234)								{
HXLINE( 234)									v11->width = width3;
HXDLIN( 234)									v11->height = height3;
HXDLIN( 234)									v11->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 234)									v11->data = ::Array_obj< int >::__new(v11->length);
HXDLIN( 234)									{
HXLINE( 234)										int _g100 = 0;
HXDLIN( 234)										int _g101 = v11->length;
HXDLIN( 234)										while((_g100 < _g101)){
HXLINE( 234)											_g100 = (_g100 + 1);
HXDLIN( 234)											int i32 = (_g100 - 1);
HXDLIN( 234)											v11->data->__unsafe_set(i32,0);
            										}
            									}
            								}
HXDLIN( 234)								undoImage10 = v11;
            							}
            							break;
            							case (int)4: {
HXLINE( 234)								 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 234)								 ::iterMagic::StackIntImg b37 = sInt5;
HXDLIN( 234)								{
HXLINE( 234)									b37->width = width3;
HXDLIN( 234)									b37->height = height3;
HXDLIN( 234)									b37->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 234)									b37->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 234)									{
HXLINE( 234)										int len11 = b37->length;
HXDLIN( 234)										 ::haxe::ds::GenericStack_Int d5 = b37->data;
HXDLIN( 234)										if (::hx::IsNull( d5->head )) {
HXLINE( 234)											int _g102 = 0;
HXDLIN( 234)											int _g103 = len11;
HXDLIN( 234)											while((_g102 < _g103)){
HXLINE( 234)												_g102 = (_g102 + 1);
HXDLIN( 234)												int i33 = (_g102 - 1);
HXDLIN( 234)												d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            											}
            										}
            										else {
HXLINE( 234)											int _g104 = 0;
HXDLIN( 234)											int _g105 = len11;
HXDLIN( 234)											while((_g104 < _g105)){
HXLINE( 234)												_g104 = (_g104 + 1);
HXDLIN( 234)												int i34 = (_g104 - 1);
HXDLIN( 234)												{
HXLINE( 234)													 ::haxe::ds::GenericCell_Int l5 = b37->data->head;
HXDLIN( 234)													 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 234)													{
HXLINE( 234)														int _g106 = 0;
HXDLIN( 234)														int _g107 = i34;
HXDLIN( 234)														while((_g106 < _g107)){
HXLINE( 234)															_g106 = (_g106 + 1);
HXDLIN( 234)															int i35 = (_g106 - 1);
HXLINE( 345)															prev5 = l5;
HXLINE( 346)															l5 = l5->next;
            														}
            													}
HXLINE( 234)													if (::hx::IsNull( prev5 )) {
HXLINE( 234)														b37->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 234)														l5 = null();
            													}
            													else {
HXLINE( 234)														prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 234)														l5 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 234)								undoImage10 = b37;
            							}
            							break;
            						}
HXDLIN( 234)						this110->image = undoImage10;
HXDLIN( 234)						this110->width = width3;
HXDLIN( 234)						this110->height = height3;
HXDLIN( 234)						this110->imageType = ( (int)(imageType5) );
HXDLIN( 234)						undoImage9 = this110;
HXDLIN( 234)						{
HXLINE( 234)							int rectLeft3 = xIter33->start;
HXDLIN( 234)							int rectTop3 = yIter33->start;
HXDLIN( 234)							int rectRight3 = xIter33->max;
HXDLIN( 234)							bool forceClear3 = false;
HXDLIN( 234)							{
HXLINE( 234)								int _g108 = rectTop3;
HXDLIN( 234)								int _g109 = yIter33->max;
HXDLIN( 234)								while((_g108 < _g109)){
HXLINE( 234)									_g108 = (_g108 + 1);
HXDLIN( 234)									int dy5 = (_g108 - 1);
HXDLIN( 234)									{
HXLINE( 234)										int _g110 = rectLeft3;
HXDLIN( 234)										int _g111 = rectRight3;
HXDLIN( 234)										while((_g110 < _g111)){
HXLINE( 234)											_g110 = (_g110 + 1);
HXDLIN( 234)											int dx5 = (_g110 - 1);
HXDLIN( 234)											::Dynamic this112 = this75->image;
HXDLIN( 234)											int index18;
HXDLIN( 234)											if (this75->useVirtualPos) {
HXLINE( 234)												index18 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this75->virtualY) * ( (Float)(this75->width) )) + dx5) - this75->virtualX));
            											}
            											else {
HXLINE( 234)												index18 = ::Std_obj::_hx_int(( (Float)(((dy5 * this75->width) + dx5)) ));
            											}
HXDLIN( 234)											int c21 = ::iterMagic::Iimg_obj::get(this112,index18);
HXDLIN( 234)											int col6;
HXDLIN( 234)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)												col6 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXLINE( 234)												col6 = c21;
            											}
HXDLIN( 234)											bool _hx_tmp32;
HXDLIN( 234)											if (this75->useMask) {
HXLINE( 234)												_hx_tmp32 = ::hx::IsNotNull( this75->mask );
            											}
            											else {
HXLINE( 234)												_hx_tmp32 = false;
            											}
HXDLIN( 234)											if (_hx_tmp32) {
HXLINE( 234)												 ::pi_xy::ImageStruct this113 = this75->mask;
HXDLIN( 234)												::Dynamic this114 = this113->image;
HXDLIN( 234)												int index19;
HXDLIN( 234)												if (this113->useVirtualPos) {
HXLINE( 234)													index19 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this113->virtualY) * ( (Float)(this113->width) )) + dx5) - this113->virtualX));
            												}
            												else {
HXLINE( 234)													index19 = ::Std_obj::_hx_int(( (Float)(((dy5 * this113->width) + dx5)) ));
            												}
HXDLIN( 234)												int c22 = ::iterMagic::Iimg_obj::get(this114,index19);
HXDLIN( 234)												int v12;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													v12 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													v12 = c22;
            												}
HXDLIN( 234)												int maskPixel3 = v12;
HXDLIN( 234)												int this115 = col6;
HXDLIN( 234)												if ((maskPixel3 == 0)) {
HXLINE( 234)													col6 = this115;
            												}
            												else {
HXLINE( 234)													Float m03;
HXDLIN( 234)													int this116 = ((maskPixel3 >> 24) & 255);
HXDLIN( 234)													if ((this116 == 0)) {
HXLINE( 234)														m03 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m03 = (( (Float)(this116) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m13;
HXDLIN( 234)													int this117 = ((maskPixel3 >> 16) & 255);
HXDLIN( 234)													if ((this117 == 0)) {
HXLINE( 234)														m13 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m13 = (( (Float)(this117) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m23;
HXDLIN( 234)													int this118 = ((maskPixel3 >> 8) & 255);
HXDLIN( 234)													if ((this118 == 0)) {
HXLINE( 234)														m23 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m23 = (( (Float)(this118) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float m33;
HXDLIN( 234)													int this119 = (maskPixel3 & 255);
HXDLIN( 234)													if ((this119 == 0)) {
HXLINE( 234)														m33 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														m33 = (( (Float)(this119) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this115 >> 24) & 255)) )));
HXDLIN( 234)													int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this115 >> 16) & 255)) )));
HXDLIN( 234)													int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this115 >> 8) & 255)) )));
HXDLIN( 234)													int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this115 & 255)) )));
HXDLIN( 234)													col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 234)											if ((col6 != 0)) {
HXLINE( 234)												int x15 = (dx5 - rectLeft3);
HXDLIN( 234)												int y15 = (dy5 - rectTop3);
HXDLIN( 234)												int c23 = col6;
HXDLIN( 234)												bool _hx_tmp33;
HXDLIN( 234)												if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 234)													_hx_tmp33 = undoImage9->transparent;
            												}
            												else {
HXLINE( 234)													_hx_tmp33 = false;
            												}
HXDLIN( 234)												if (_hx_tmp33) {
HXLINE( 234)													int location6;
HXDLIN( 234)													if (undoImage9->useVirtualPos) {
HXLINE( 234)														location6 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            													}
            													else {
HXLINE( 234)														location6 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            													}
HXDLIN( 234)													int this120 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 234)													int this121;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														this121 = ((((((this120 >> 24) & 255) << 24) | ((this120 & 255) << 16)) | (((this120 >> 8) & 255) << 8)) | ((this120 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														this121 = this120;
            													}
HXDLIN( 234)													Float a111;
HXDLIN( 234)													int this122 = ((this121 >> 24) & 255);
HXDLIN( 234)													if ((this122 == 0)) {
HXLINE( 234)														a111 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														a111 = (( (Float)(this122) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float r16;
HXDLIN( 234)													int this123 = ((this121 >> 16) & 255);
HXDLIN( 234)													if ((this123 == 0)) {
HXLINE( 234)														r16 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														r16 = (( (Float)(this123) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float g16;
HXDLIN( 234)													int this124 = ((this121 >> 8) & 255);
HXDLIN( 234)													if ((this124 == 0)) {
HXLINE( 234)														g16 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														g16 = (( (Float)(this124) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float b112;
HXDLIN( 234)													int this125 = (this121 & 255);
HXDLIN( 234)													if ((this125 == 0)) {
HXLINE( 234)														b112 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														b112 = (( (Float)(this125) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float a210;
HXDLIN( 234)													int this126 = ((col6 >> 24) & 255);
HXDLIN( 234)													if ((this126 == 0)) {
HXLINE( 234)														a210 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														a210 = (( (Float)(this126) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float r26;
HXDLIN( 234)													int this127 = ((col6 >> 16) & 255);
HXDLIN( 234)													if ((this127 == 0)) {
HXLINE( 234)														r26 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														r26 = (( (Float)(this127) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float g26;
HXDLIN( 234)													int this128 = ((col6 >> 8) & 255);
HXDLIN( 234)													if ((this128 == 0)) {
HXLINE( 234)														g26 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														g26 = (( (Float)(this128) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float b212;
HXDLIN( 234)													int this129 = (col6 & 255);
HXDLIN( 234)													if ((this129 == 0)) {
HXLINE( 234)														b212 = ((Float)0.);
            													}
            													else {
HXLINE( 234)														b212 = (( (Float)(this129) ) / ( (Float)(255) ));
            													}
HXDLIN( 234)													Float a36 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 234)													int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a210))));
HXDLIN( 234)													int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a210))));
HXDLIN( 234)													int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b212 * a210))));
HXDLIN( 234)													int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a210)));
HXDLIN( 234)													int blended6 = ((((a30 << 24) | (r8 << 16)) | (g8 << 8)) | b38);
HXDLIN( 234)													{
HXLINE( 234)														int _hx_tmp34;
HXDLIN( 234)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)															_hx_tmp34 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            														}
            														else {
HXLINE( 234)															_hx_tmp34 = blended6;
            														}
HXDLIN( 234)														::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp34);
            													}
            												}
            												else {
HXLINE( 234)													::Dynamic this130 = undoImage9->image;
HXDLIN( 234)													int index20;
HXDLIN( 234)													if (undoImage9->useVirtualPos) {
HXLINE( 234)														index20 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            													}
            													else {
HXLINE( 234)														index20 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            													}
HXDLIN( 234)													int _hx_tmp35;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														_hx_tmp35 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														_hx_tmp35 = c23;
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this130,index20,_hx_tmp35);
            												}
            											}
            											else {
HXLINE( 234)												if (forceClear3) {
HXLINE( 234)													::Dynamic this131 = undoImage9->image;
HXDLIN( 234)													int x16 = (dx5 - rectLeft3);
HXDLIN( 234)													int y16 = (dy5 - rectTop3);
HXDLIN( 234)													int index21;
HXDLIN( 234)													if (undoImage9->useVirtualPos) {
HXLINE( 234)														index21 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x16) - undoImage9->virtualX));
            													}
            													else {
HXLINE( 234)														index21 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage9->width) + x16)) ));
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this131,index21,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					{
HXLINE( 234)						int _g_min6 = xIter33->start;
HXDLIN( 234)						int _g_max6 = xIter33->max;
HXDLIN( 234)						while((_g_min6 < _g_max6)){
HXLINE( 234)							_g_min6 = (_g_min6 + 1);
HXDLIN( 234)							int px3 = (_g_min6 - 1);
HXDLIN( 234)							Float pcx3 = (( (Float)(px3) ) - dx3);
HXDLIN( 234)							{
HXLINE( 234)								int _g_min7 = yIter33->start;
HXDLIN( 234)								int _g_max7 = yIter33->max;
HXDLIN( 234)								while((_g_min7 < _g_max7)){
HXLINE( 234)									_g_min7 = (_g_min7 + 1);
HXDLIN( 234)									int py3 = (_g_min7 - 1);
HXDLIN( 234)									Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN( 234)									Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 234)									Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 234)									Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 234)									Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 234)									Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 234)									bool _hx_tmp36;
HXDLIN( 234)									bool _hx_tmp37;
HXDLIN( 234)									if ((ratioA3 >= 0)) {
HXLINE( 234)										_hx_tmp37 = (ratioB3 >= 0);
            									}
            									else {
HXLINE( 234)										_hx_tmp37 = false;
            									}
HXDLIN( 234)									if (_hx_tmp37) {
HXLINE( 234)										_hx_tmp36 = (ratioC3 >= 0);
            									}
            									else {
HXLINE( 234)										_hx_tmp36 = false;
            									}
HXDLIN( 234)									if (_hx_tmp36) {
HXLINE( 234)										Float u3 = (((au3 * ratioA3) + (bu5 * ratioB3)) + (du1 * ratioC3));
HXDLIN( 234)										Float v13 = (((av3 * ratioA3) + (bv5 * ratioB3)) + (dv1 * ratioC3));
HXDLIN( 234)										int x17 = ::Std_obj::_hx_int(((u3 * win_width1) + win_x1));
HXDLIN( 234)										int y17 = ::Std_obj::_hx_int(((v13 * win_height1) + win_y1));
HXDLIN( 234)										::Dynamic this132 = this72->image;
HXDLIN( 234)										int index22;
HXDLIN( 234)										if (this72->useVirtualPos) {
HXLINE( 234)											index22 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this72->virtualY) * ( (Float)(this72->width) )) + x17) - this72->virtualX));
            										}
            										else {
HXLINE( 234)											index22 = ::Std_obj::_hx_int(( (Float)(((y17 * this72->width) + x17)) ));
            										}
HXDLIN( 234)										int c24 = ::iterMagic::Iimg_obj::get(this132,index22);
HXDLIN( 234)										int col7;
HXDLIN( 234)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)											col7 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            										}
            										else {
HXLINE( 234)											col7 = c24;
            										}
HXDLIN( 234)										{
HXLINE( 234)											int c25 = col7;
HXDLIN( 234)											bool _hx_tmp38;
HXDLIN( 234)											if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 234)												_hx_tmp38 = this75->transparent;
            											}
            											else {
HXLINE( 234)												_hx_tmp38 = false;
            											}
HXDLIN( 234)											if (_hx_tmp38) {
HXLINE( 234)												int location7;
HXDLIN( 234)												if (this75->useVirtualPos) {
HXLINE( 234)													location7 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this75->virtualY) * ( (Float)(this75->width) )) + px3) - this75->virtualX));
            												}
            												else {
HXLINE( 234)													location7 = ::Std_obj::_hx_int(( (Float)(((py3 * this75->width) + px3)) ));
            												}
HXDLIN( 234)												int this133 = ::iterMagic::Iimg_obj::get(this75->image,location7);
HXDLIN( 234)												int this134;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													this134 = ((((((this133 >> 24) & 255) << 24) | ((this133 & 255) << 16)) | (((this133 >> 8) & 255) << 8)) | ((this133 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													this134 = this133;
            												}
HXDLIN( 234)												Float a112;
HXDLIN( 234)												int this135 = ((this134 >> 24) & 255);
HXDLIN( 234)												if ((this135 == 0)) {
HXLINE( 234)													a112 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													a112 = (( (Float)(this135) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float r17;
HXDLIN( 234)												int this136 = ((this134 >> 16) & 255);
HXDLIN( 234)												if ((this136 == 0)) {
HXLINE( 234)													r17 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													r17 = (( (Float)(this136) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float g17;
HXDLIN( 234)												int this137 = ((this134 >> 8) & 255);
HXDLIN( 234)												if ((this137 == 0)) {
HXLINE( 234)													g17 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													g17 = (( (Float)(this137) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float b113;
HXDLIN( 234)												int this138 = (this134 & 255);
HXDLIN( 234)												if ((this138 == 0)) {
HXLINE( 234)													b113 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													b113 = (( (Float)(this138) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float a211;
HXDLIN( 234)												int this139 = ((col7 >> 24) & 255);
HXDLIN( 234)												if ((this139 == 0)) {
HXLINE( 234)													a211 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													a211 = (( (Float)(this139) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float r27;
HXDLIN( 234)												int this140 = ((col7 >> 16) & 255);
HXDLIN( 234)												if ((this140 == 0)) {
HXLINE( 234)													r27 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													r27 = (( (Float)(this140) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float g27;
HXDLIN( 234)												int this141 = ((col7 >> 8) & 255);
HXDLIN( 234)												if ((this141 == 0)) {
HXLINE( 234)													g27 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													g27 = (( (Float)(this141) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float b213;
HXDLIN( 234)												int this142 = (col7 & 255);
HXDLIN( 234)												if ((this142 == 0)) {
HXLINE( 234)													b213 = ((Float)0.);
            												}
            												else {
HXLINE( 234)													b213 = (( (Float)(this142) ) / ( (Float)(255) ));
            												}
HXDLIN( 234)												Float a37 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 234)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a211))));
HXDLIN( 234)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a211))));
HXDLIN( 234)												int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b213 * a211))));
HXDLIN( 234)												int a38 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a211)));
HXDLIN( 234)												int blended7 = ((((a38 << 24) | (r9 << 16)) | (g9 << 8)) | b39);
HXDLIN( 234)												{
HXLINE( 234)													int _hx_tmp39;
HXDLIN( 234)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)														_hx_tmp39 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE( 234)														_hx_tmp39 = blended7;
            													}
HXDLIN( 234)													::iterMagic::Iimg_obj::set(this75->image,location7,_hx_tmp39);
            												}
            											}
            											else {
HXLINE( 234)												::Dynamic this143 = this75->image;
HXDLIN( 234)												int index23;
HXDLIN( 234)												if (this75->useVirtualPos) {
HXLINE( 234)													index23 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this75->virtualY) * ( (Float)(this75->width) )) + px3) - this75->virtualX));
            												}
            												else {
HXLINE( 234)													index23 = ::Std_obj::_hx_int(( (Float)(((py3 * this75->width) + px3)) ));
            												}
HXDLIN( 234)												int _hx_tmp40;
HXDLIN( 234)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)													_hx_tmp40 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            												}
            												else {
HXLINE( 234)													_hx_tmp40 = c25;
            												}
HXDLIN( 234)												::iterMagic::Iimg_obj::set(this143,index23,_hx_tmp40);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN( 234)					 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN( 234)					int v_undoY3;
HXDLIN( 234)					int v_undoX3;
HXDLIN( 234)					Float v_ty3;
HXDLIN( 234)					Float v_tx3;
HXDLIN( 234)					Float v_t03;
HXDLIN( 234)					Float v_sy3;
HXDLIN( 234)					Float v_sx3;
HXDLIN( 234)					Float v_s03;
HXDLIN( 234)					Float v_A3;
HXDLIN( 234)					Float ax5 = bx3;
HXDLIN( 234)					Float ay5 = by3;
HXDLIN( 234)					 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN( 234)					Float bx5 = cx3;
HXDLIN( 234)					Float by5 = cy3;
HXDLIN( 234)					Float cx5 = dx3;
HXDLIN( 234)					Float cy5 = dy3;
HXDLIN( 234)					bool adjustWinding3 = (((((ax5 * by5) - (bx5 * ay5)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay5) - (ax5 * cy5))) > 0);
HXDLIN( 234)					if (!(adjustWinding3)) {
HXLINE( 234)						Float bx_3 = bx5;
HXDLIN( 234)						Float by_3 = by5;
HXLINE(  24)						bx5 = cx5;
HXLINE(  25)						by5 = cy5;
HXLINE(  26)						cx5 = bx_3;
HXLINE(  27)						cy5 = by_3;
            					}
HXLINE( 234)					Float v_ax3 = ax5;
HXDLIN( 234)					Float v_ay3 = ay5;
HXDLIN( 234)					Float v_bx3 = bx5;
HXDLIN( 234)					Float v_by3 = by5;
HXDLIN( 234)					Float v_cx3 = cx5;
HXDLIN( 234)					Float v_cy3 = cy5;
HXDLIN( 234)					bool v_preCalculated3 = true;
HXDLIN( 234)					{
HXLINE(  93)						v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN(  93)						v_sx3 = (v_cy3 - v_ay3);
HXDLIN(  93)						v_sy3 = (v_ax3 - v_cx3);
HXDLIN(  93)						v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN(  93)						v_tx3 = (v_ay3 - v_by3);
HXDLIN(  93)						v_ty3 = (v_bx3 - v_ax3);
HXDLIN(  93)						v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXLINE( 234)						Float a39 = v_ax3;
HXDLIN( 234)						Float b40 = v_bx3;
HXDLIN( 234)						Float c26 = v_cx3;
HXDLIN( 234)						if ((a39 > b40)) {
HXLINE( 234)							if ((a39 > c26)) {
HXLINE( 234)								int min32;
HXDLIN( 234)								if ((b40 > c26)) {
HXLINE( 234)									min32 = ::Math_obj::floor(c26);
            								}
            								else {
HXLINE( 234)									min32 = ::Math_obj::floor(b40);
            								}
HXDLIN( 234)								int ii_min60 = min32;
HXDLIN( 234)								int ii_max60 = ::Math_obj::ceil(a39);
HXDLIN( 234)								v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            							}
            							else {
HXLINE( 234)								int ii_min61 = ::Math_obj::floor(b40);
HXDLIN( 234)								int ii_max61 = ::Math_obj::ceil(c26);
HXDLIN( 234)								v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            							}
            						}
            						else {
HXLINE( 234)							if ((b40 > c26)) {
HXLINE( 234)								int min33;
HXDLIN( 234)								if ((a39 > c26)) {
HXLINE( 234)									min33 = ::Math_obj::floor(c26);
            								}
            								else {
HXLINE( 234)									min33 = ::Math_obj::ceil(a39);
            								}
HXDLIN( 234)								int ii_min62 = min33;
HXDLIN( 234)								int ii_max62 = ::Math_obj::ceil(b40);
HXDLIN( 234)								v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            							}
            							else {
HXLINE( 234)								int ii_min63 = ::Math_obj::floor(a39);
HXDLIN( 234)								int ii_max63 = ::Math_obj::ceil(c26);
HXDLIN( 234)								v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            							}
            						}
HXDLIN( 234)						Float a40 = v_ay3;
HXDLIN( 234)						Float b41 = v_by3;
HXDLIN( 234)						Float c27 = v_cy3;
HXDLIN( 234)						if ((a40 > b41)) {
HXLINE( 234)							if ((a40 > c27)) {
HXLINE( 234)								int min34;
HXDLIN( 234)								if ((b41 > c27)) {
HXLINE( 234)									min34 = ::Math_obj::floor(c27);
            								}
            								else {
HXLINE( 234)									min34 = ::Math_obj::floor(b41);
            								}
HXDLIN( 234)								int ii_min64 = min34;
HXDLIN( 234)								int ii_max64 = ::Math_obj::ceil(a40);
HXDLIN( 234)								v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            							}
            							else {
HXLINE( 234)								int ii_min65 = ::Math_obj::floor(b41);
HXDLIN( 234)								int ii_max65 = ::Math_obj::ceil(c27);
HXDLIN( 234)								v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            							}
            						}
            						else {
HXLINE( 234)							if ((b41 > c27)) {
HXLINE( 234)								int min35;
HXDLIN( 234)								if ((a40 > c27)) {
HXLINE( 234)									min35 = ::Math_obj::floor(c27);
            								}
            								else {
HXLINE( 234)									min35 = ::Math_obj::ceil(a40);
            								}
HXDLIN( 234)								int ii_min66 = min35;
HXDLIN( 234)								int ii_max66 = ::Math_obj::ceil(b41);
HXDLIN( 234)								v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            							}
            							else {
HXLINE( 234)								int ii_min67 = ::Math_obj::floor(a40);
HXDLIN( 234)								int ii_max67 = ::Math_obj::ceil(c27);
HXDLIN( 234)								v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            							}
            						}
            					}
HXDLIN( 234)					if (hasUndo3) {
HXLINE(  93)						v_undoImage3 = undoImage9;
HXDLIN(  93)						v_undoX3 = xIter33->start;
HXDLIN(  93)						v_undoY3 = yIter33->start;
            					}
            				}
            			}
HXLINE( 234)			bool _hx_tmp41;
HXDLIN( 234)			if (::hx::IsNotNull( nextImage1->mask )) {
HXLINE( 234)				_hx_tmp41 = includeMask;
            			}
            			else {
HXLINE( 234)				_hx_tmp41 = false;
            			}
HXDLIN( 234)			if (_hx_tmp41) {
HXLINE( 234)				 ::pi_xy::ImageStruct v14 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this72->mask,theta,centreX1,centreY1,this72->mask->transparent,includeMask);
HXDLIN( 234)				nextImage1->useMask = true;
HXDLIN( 234)				nextImage1->mask = v14;
            			}
HXDLIN( 234)			 ::pi_xy::ImageStruct v15 = nextImage1;
HXDLIN( 234)			nextImage->useMask = true;
HXDLIN( 234)			nextImage->mask = v15;
            		}
HXLINE( 236)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(SpinImage_Fields__obj,rotating,return )


SpinImage_Fields__obj::SpinImage_Fields__obj()
{
}

bool SpinImage_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"spin180") ) { outValue = spin180_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"rotating") ) { outValue = rotating_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"spinClock90") ) { outValue = spinClock90_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"spinAntiClock90") ) { outValue = spinAntiClock90_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"rotatingClockwiseDegrees") ) { outValue = rotatingClockwiseDegrees_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotatingClockwiseRadians") ) { outValue = rotatingClockwiseRadians_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *SpinImage_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *SpinImage_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class SpinImage_Fields__obj::__mClass;

static ::String SpinImage_Fields__obj_sStaticFields[] = {
	HX_("spinClock90",83,ad,14,59),
	HX_("spinAntiClock90",01,e5,83,94),
	HX_("spin180",e7,82,0a,34),
	HX_("rotatingClockwiseDegrees",4d,58,df,17),
	HX_("rotatingClockwiseRadians",18,bb,74,04),
	HX_("rotating",58,3c,86,08),
	::String(null())
};

void SpinImage_Fields__obj::__register()
{
	SpinImage_Fields__obj _hx_dummy;
	SpinImage_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.transformation._SpinImage.SpinImage_Fields_",4a,84,18,20);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &SpinImage_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(SpinImage_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< SpinImage_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SpinImage_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SpinImage_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace transformation
} // end namespace _SpinImage
