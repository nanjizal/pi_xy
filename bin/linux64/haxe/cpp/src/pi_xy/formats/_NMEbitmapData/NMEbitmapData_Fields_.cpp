// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_nme_display_BitmapData
#include <nme/display/BitmapData.h>
#endif
#ifndef INCLUDED_nme_display_IBitmapDrawable
#include <nme/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_nme_geom_Rectangle
#include <nme/geom/Rectangle.h>
#endif
#ifndef INCLUDED_nme_utils_ByteArray
#include <nme/utils/ByteArray.h>
#endif
#ifndef INCLUDED_nme_utils_IDataInput
#include <nme/utils/IDataInput.h>
#endif
#ifndef INCLUDED_nme_utils_IDataOutput
#include <nme/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_nme_utils_IMemoryRange
#include <nme/utils/IMemoryRange.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_formats__NMEbitmapData_NMEbitmapData_Fields_
#include <pi_xy/formats/_NMEbitmapData/NMEbitmapData_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_08d965221cab88a9_19_toNmeBitmapData,"pi_xy.formats._NMEbitmapData.NMEbitmapData_Fields_","toNmeBitmapData",0xb4ac1847,"pi_xy.formats._NMEbitmapData.NMEbitmapData_Fields_.toNmeBitmapData","pi_xy/formats/NMEbitmapData.hx",19,0x20b1209a)
namespace pi_xy{
namespace formats{
namespace _NMEbitmapData{

void NMEbitmapData_Fields__obj::__construct() { }

Dynamic NMEbitmapData_Fields__obj::__CreateEmpty() { return new NMEbitmapData_Fields__obj; }

void *NMEbitmapData_Fields__obj::_hx_vtable = 0;

Dynamic NMEbitmapData_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NMEbitmapData_Fields__obj > _hx_result = new NMEbitmapData_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NMEbitmapData_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7a95b1dd;
}

 ::nme::display::BitmapData NMEbitmapData_Fields__obj::toNmeBitmapData( ::pi_xy::ImageStruct pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_08d965221cab88a9_19_toNmeBitmapData)
HXLINE(  20)		int lh = pixelImage->height;
HXLINE(  21)		int lw = pixelImage->width;
HXLINE(  23)		 ::nme::geom::Rectangle rect =  ::nme::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,lw,lh);
HXLINE(  24)		 ::nme::display::BitmapData bitmapData =  ::nme::display::BitmapData_obj::__alloc( HX_CTX ,lw,lh,true,-1,1);
HXLINE(  25)		 ::haxe::io::Bytes argb = ::haxe::io::Bytes_obj::alloc(((lw * lh) * 4));
HXLINE(  26)		int p = 0;
HXLINE(  27)		{
HXLINE(  27)			int _g = 0;
HXDLIN(  27)			int _g1 = lh;
HXDLIN(  27)			while((_g < _g1)){
HXLINE(  27)				_g = (_g + 1);
HXDLIN(  27)				int y = (_g - 1);
HXLINE(  28)				{
HXLINE(  28)					int _g2 = 0;
HXDLIN(  28)					int _g3 = lw;
HXDLIN(  28)					while((_g2 < _g3)){
HXLINE(  28)						_g2 = (_g2 + 1);
HXDLIN(  28)						int x = (_g2 - 1);
HXLINE(  29)						::Dynamic this1 = pixelImage->image;
HXDLIN(  29)						int index;
HXDLIN(  29)						if (pixelImage->useVirtualPos) {
HXLINE(  29)							index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            						}
            						else {
HXLINE(  29)							index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            						}
HXDLIN(  29)						int c = ::iterMagic::Iimg_obj::get(this1,index);
HXDLIN(  29)						int v;
HXDLIN(  29)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)							v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE(  29)							v = c;
            						}
HXDLIN(  29)						int col = v;
HXLINE(  30)						int a = ((col >> 24) & 255);
HXLINE(  31)						int r = ((col >> 16) & 255);
HXLINE(  32)						int g = ((col >> 8) & 255);
HXLINE(  33)						int b = (col & 255);
HXLINE(  34)						{
HXLINE(  34)							p = (p + 1);
HXDLIN(  34)							argb->b[(p - 1)] = ( (unsigned char)(a) );
            						}
HXLINE(  35)						{
HXLINE(  35)							p = (p + 1);
HXDLIN(  35)							argb->b[(p - 1)] = ( (unsigned char)(r) );
            						}
HXLINE(  36)						{
HXLINE(  36)							p = (p + 1);
HXDLIN(  36)							argb->b[(p - 1)] = ( (unsigned char)(g) );
            						}
HXLINE(  37)						{
HXLINE(  37)							p = (p + 1);
HXDLIN(  37)							argb->b[(p - 1)] = ( (unsigned char)(b) );
            						}
            					}
            				}
            			}
            		}
HXLINE(  40)		bitmapData->setPixels(rect,::nme::utils::ByteArray_obj::fromBytes(argb));
HXLINE(  41)		return bitmapData;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(NMEbitmapData_Fields__obj,toNmeBitmapData,return )


NMEbitmapData_Fields__obj::NMEbitmapData_Fields__obj()
{
}

bool NMEbitmapData_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"toNmeBitmapData") ) { outValue = toNmeBitmapData_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *NMEbitmapData_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *NMEbitmapData_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class NMEbitmapData_Fields__obj::__mClass;

static ::String NMEbitmapData_Fields__obj_sStaticFields[] = {
	HX_("toNmeBitmapData",24,7e,85,2c),
	::String(null())
};

void NMEbitmapData_Fields__obj::__register()
{
	NMEbitmapData_Fields__obj _hx_dummy;
	NMEbitmapData_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.formats._NMEbitmapData.NMEbitmapData_Fields_",91,44,9d,03);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &NMEbitmapData_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(NMEbitmapData_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< NMEbitmapData_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NMEbitmapData_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NMEbitmapData_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace formats
} // end namespace _NMEbitmapData
