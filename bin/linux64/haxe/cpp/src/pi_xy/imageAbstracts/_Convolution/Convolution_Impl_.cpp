// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts_Mat3x3data
#include <pi_xy/imageAbstracts/Mat3x3data.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts_Mat5x5data
#include <pi_xy/imageAbstracts/Mat5x5data.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__Convolution_Convolution_Impl_
#include <pi_xy/imageAbstracts/_Convolution/Convolution_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_114__new,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","_new",0xc200ac1b,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_._new","pi_xy/imageAbstracts/Convolution.hx",114,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_126_convolute3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","convolute3x3",0xd89f6dd3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.convolute3x3","pi_xy/imageAbstracts/Convolution.hx",126,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_270_convolute5x5,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","convolute5x5",0xd8a0f257,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.convolute5x5","pi_xy/imageAbstracts/Convolution.hx",270,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_553_sharpen0_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","sharpen0_3x3",0x7d5990e6,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.sharpen0_3x3","pi_xy/imageAbstracts/Convolution.hx",553,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_563_boxBlur0_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","boxBlur0_3x3",0xad206207,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.boxBlur0_3x3","pi_xy/imageAbstracts/Convolution.hx",563,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_571_gussianBlur_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","gussianBlur_3x3",0x1e989684,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.gussianBlur_3x3","pi_xy/imageAbstracts/Convolution.hx",571,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_579_gussianBlur55data,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","gussianBlur55data",0xb589499f,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.gussianBlur55data","pi_xy/imageAbstracts/Convolution.hx",579,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_588_gussianBlur_5x5,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","gussianBlur_5x5",0x1e9a1b08,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.gussianBlur_5x5","pi_xy/imageAbstracts/Convolution.hx",588,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_593_unsharpenMask055data,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","unsharpenMask055data",0x542d8f8e,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.unsharpenMask055data","pi_xy/imageAbstracts/Convolution.hx",593,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_602_unsharpenMask0_5x5,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","unsharpenMask0_5x5",0x4c7bb737,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.unsharpenMask0_5x5","pi_xy/imageAbstracts/Convolution.hx",602,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_608_edgeEnhance0_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","edgeEnhance0_3x3",0xf9563388,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.edgeEnhance0_3x3","pi_xy/imageAbstracts/Convolution.hx",608,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_614_edgeDetect0_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","edgeDetect0_3x3",0x712489e5,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.edgeDetect0_3x3","pi_xy/imageAbstracts/Convolution.hx",614,0x505c58f7)
HX_LOCAL_STACK_FRAME(_hx_pos_b1b62e405f06e9e2_623_emboss0_3x3,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_","emboss0_3x3",0xf8e02d30,"pi_xy.imageAbstracts._Convolution.Convolution_Impl_.emboss0_3x3","pi_xy/imageAbstracts/Convolution.hx",623,0x505c58f7)
namespace pi_xy{
namespace imageAbstracts{
namespace _Convolution{

void Convolution_Impl__obj::__construct() { }

Dynamic Convolution_Impl__obj::__CreateEmpty() { return new Convolution_Impl__obj; }

void *Convolution_Impl__obj::_hx_vtable = 0;

Dynamic Convolution_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Convolution_Impl__obj > _hx_result = new Convolution_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Convolution_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7ca41ce2;
}

 ::pi_xy::ImageStruct Convolution_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_114__new)
HXLINE( 116)		 ::Dynamic imageType = null();
HXDLIN( 116)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 116)		if (::hx::IsNull( imageType )) {
HXLINE( 116)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 116)		::Dynamic this2;
HXDLIN( 116)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 116)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 116)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 116)				{
HXLINE( 116)					b->width = w;
HXDLIN( 116)					b->height = h;
HXDLIN( 116)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN( 116)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 116)					{
HXLINE( 116)						int len = b->length;
HXDLIN( 116)						int w1 = 0;
HXDLIN( 116)						{
HXLINE( 116)							int _g = 0;
HXDLIN( 116)							int _g1 = b->height;
HXDLIN( 116)							while((_g < _g1)){
HXLINE( 116)								_g = (_g + 1);
HXDLIN( 116)								int y = (_g - 1);
HXDLIN( 116)								{
HXLINE( 116)									int _g2 = 0;
HXDLIN( 116)									int _g3 = b->width;
HXDLIN( 116)									while((_g2 < _g3)){
HXLINE( 116)										_g2 = (_g2 + 1);
HXDLIN( 116)										int x = (_g2 - 1);
HXDLIN( 116)										{
HXLINE( 116)											w1 = (w1 + 1);
HXDLIN( 116)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 116)										{
HXLINE( 116)											w1 = (w1 + 1);
HXDLIN( 116)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 116)										{
HXLINE( 116)											w1 = (w1 + 1);
HXDLIN( 116)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 116)										{
HXLINE( 116)											w1 = (w1 + 1);
HXDLIN( 116)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 116)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 116)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 116)				{
HXLINE( 116)					a->width = w;
HXDLIN( 116)					a->height = h;
HXDLIN( 116)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 116)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN( 116)					{
HXLINE( 116)						int _g4 = 0;
HXDLIN( 116)						int _g5 = a->length;
HXDLIN( 116)						while((_g4 < _g5)){
HXLINE( 116)							_g4 = (_g4 + 1);
HXDLIN( 116)							int i = (_g4 - 1);
HXDLIN( 116)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 116)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 116)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 116)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 116)				{
HXLINE( 116)					b1->width = w;
HXDLIN( 116)					b1->height = h;
HXDLIN( 116)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN( 116)					int size = (b1->length * 4);
HXDLIN( 116)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 116)					{
HXLINE( 116)						int _g6 = 0;
HXDLIN( 116)						int _g7 = b1->length;
HXDLIN( 116)						while((_g6 < _g7)){
HXLINE( 116)							_g6 = (_g6 + 1);
HXDLIN( 116)							int i1 = (_g6 - 1);
HXDLIN( 116)							{
HXLINE( 116)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 116)								bool this4;
HXDLIN( 116)								if ((i1 >= 0)) {
HXLINE( 116)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 116)									this4 = false;
            								}
HXDLIN( 116)								if (this4) {
HXLINE( 116)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 116)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 116)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 116)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 116)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 116)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 116)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 116)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 116)				{
HXLINE( 116)					v->width = w;
HXDLIN( 116)					v->height = h;
HXDLIN( 116)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN( 116)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 116)					{
HXLINE( 116)						int _g8 = 0;
HXDLIN( 116)						int _g9 = v->length;
HXDLIN( 116)						while((_g8 < _g9)){
HXLINE( 116)							_g8 = (_g8 + 1);
HXDLIN( 116)							int i2 = (_g8 - 1);
HXDLIN( 116)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 116)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 116)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 116)				{
HXLINE( 116)					b2->width = w;
HXDLIN( 116)					b2->height = h;
HXDLIN( 116)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN( 116)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 116)					{
HXLINE( 116)						int len1 = b2->length;
HXDLIN( 116)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 116)						if (::hx::IsNull( d->head )) {
HXLINE( 116)							int _g10 = 0;
HXDLIN( 116)							int _g11 = len1;
HXDLIN( 116)							while((_g10 < _g11)){
HXLINE( 116)								_g10 = (_g10 + 1);
HXDLIN( 116)								int i3 = (_g10 - 1);
HXDLIN( 116)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 116)							int _g12 = 0;
HXDLIN( 116)							int _g13 = len1;
HXDLIN( 116)							while((_g12 < _g13)){
HXLINE( 116)								_g12 = (_g12 + 1);
HXDLIN( 116)								int i4 = (_g12 - 1);
HXDLIN( 116)								{
HXLINE( 116)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 116)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 116)									{
HXLINE( 116)										int _g14 = 0;
HXDLIN( 116)										int _g15 = i4;
HXDLIN( 116)										while((_g14 < _g15)){
HXLINE( 116)											_g14 = (_g14 + 1);
HXDLIN( 116)											int i5 = (_g14 - 1);
HXDLIN( 116)											prev = l;
HXDLIN( 116)											l = l->next;
            										}
            									}
HXDLIN( 116)									if (::hx::IsNull( prev )) {
HXLINE( 116)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)										l = null();
            									}
            									else {
HXLINE( 116)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 116)				this2 = b2;
            			}
            			break;
            		}
HXDLIN( 116)		this1->image = this2;
HXDLIN( 116)		this1->width = w;
HXDLIN( 116)		this1->height = h;
HXDLIN( 116)		this1->imageType = ( (int)(imageType) );
HXLINE( 114)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Convolution_Impl__obj,_new,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::convolute3x3( ::pi_xy::ImageStruct this1, ::pi_xy::imageAbstracts::Mat3x3data m33,int borderMode,::hx::Null< bool >  __o_adjustAlpha,::hx::Null< bool >  __o_adjustRed,::hx::Null< bool >  __o_adjustGreen,::hx::Null< bool >  __o_adjustBlue){
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            		bool adjustRed = __o_adjustRed.Default(true);
            		bool adjustGreen = __o_adjustGreen.Default(true);
            		bool adjustBlue = __o_adjustBlue.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_126_convolute3x3)
HXLINE( 127)		int a0 = 0;
HXLINE( 128)		int b0 = 0;
HXLINE( 129)		int c0 = 0;
HXLINE( 130)		int d0 = 0;
HXLINE( 131)		int e0 = 0;
HXLINE( 132)		int f0 = 0;
HXLINE( 133)		int g0 = 0;
HXLINE( 134)		int h0 = 0;
HXLINE( 135)		int i0 = 0;
HXLINE( 136)		Float r_ = ((Float)0.);
HXLINE( 137)		Float g_ = ((Float)0.);
HXLINE( 138)		Float b_ = ((Float)0.);
HXLINE( 139)		Float a_ = ((Float)0.);
HXLINE( 140)		int width = this1->width;
HXDLIN( 140)		int height = this1->height;
HXDLIN( 140)		 ::Dynamic imageType = null();
HXDLIN( 140)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 140)		if (::hx::IsNull( imageType )) {
HXLINE( 140)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 140)		::Dynamic _hx_tmp;
HXDLIN( 140)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 140)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 140)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 140)				{
HXLINE( 140)					b->width = width;
HXDLIN( 140)					b->height = height;
HXDLIN( 140)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 140)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 140)					{
HXLINE( 140)						int len = b->length;
HXDLIN( 140)						int w = 0;
HXDLIN( 140)						{
HXLINE( 140)							int _g = 0;
HXDLIN( 140)							int _g1 = b->height;
HXDLIN( 140)							while((_g < _g1)){
HXLINE( 140)								_g = (_g + 1);
HXDLIN( 140)								int y = (_g - 1);
HXDLIN( 140)								{
HXLINE( 140)									int _g2 = 0;
HXDLIN( 140)									int _g3 = b->width;
HXDLIN( 140)									while((_g2 < _g3)){
HXLINE( 140)										_g2 = (_g2 + 1);
HXDLIN( 140)										int x = (_g2 - 1);
HXDLIN( 140)										{
HXLINE( 140)											w = (w + 1);
HXDLIN( 140)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 140)										{
HXLINE( 140)											w = (w + 1);
HXDLIN( 140)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 140)										{
HXLINE( 140)											w = (w + 1);
HXDLIN( 140)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 140)										{
HXLINE( 140)											w = (w + 1);
HXDLIN( 140)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 140)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 140)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 140)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 140)				{
HXLINE( 140)					a->width = width;
HXDLIN( 140)					a->height = height;
HXDLIN( 140)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 140)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 140)					{
HXLINE( 140)						int _g4 = 0;
HXDLIN( 140)						int _g5 = a->length;
HXDLIN( 140)						while((_g4 < _g5)){
HXLINE( 140)							_g4 = (_g4 + 1);
HXDLIN( 140)							int i = (_g4 - 1);
HXDLIN( 140)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 140)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 140)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 140)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 140)				{
HXLINE( 140)					b1->width = width;
HXDLIN( 140)					b1->height = height;
HXDLIN( 140)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 140)					int size = (b1->length * 4);
HXDLIN( 140)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 140)					{
HXLINE( 140)						int _g6 = 0;
HXDLIN( 140)						int _g7 = b1->length;
HXDLIN( 140)						while((_g6 < _g7)){
HXLINE( 140)							_g6 = (_g6 + 1);
HXDLIN( 140)							int i1 = (_g6 - 1);
HXDLIN( 140)							{
HXLINE( 140)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 140)								bool _hx_tmp1;
HXDLIN( 140)								if ((i1 >= 0)) {
HXLINE( 140)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 140)									_hx_tmp1 = false;
            								}
HXDLIN( 140)								if (_hx_tmp1) {
HXLINE( 140)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 140)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 140)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 140)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 140)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 140)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 140)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 140)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 140)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 140)				{
HXLINE( 140)					v->width = width;
HXDLIN( 140)					v->height = height;
HXDLIN( 140)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 140)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 140)					{
HXLINE( 140)						int _g8 = 0;
HXDLIN( 140)						int _g9 = v->length;
HXDLIN( 140)						while((_g8 < _g9)){
HXLINE( 140)							_g8 = (_g8 + 1);
HXDLIN( 140)							int i2 = (_g8 - 1);
HXDLIN( 140)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 140)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 140)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 140)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 140)				{
HXLINE( 140)					b2->width = width;
HXDLIN( 140)					b2->height = height;
HXDLIN( 140)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 140)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 140)					{
HXLINE( 140)						int len1 = b2->length;
HXDLIN( 140)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 140)						if (::hx::IsNull( d->head )) {
HXLINE( 140)							int _g10 = 0;
HXDLIN( 140)							int _g11 = len1;
HXDLIN( 140)							while((_g10 < _g11)){
HXLINE( 140)								_g10 = (_g10 + 1);
HXDLIN( 140)								int i3 = (_g10 - 1);
HXDLIN( 140)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 140)							int _g12 = 0;
HXDLIN( 140)							int _g13 = len1;
HXDLIN( 140)							while((_g12 < _g13)){
HXLINE( 140)								_g12 = (_g12 + 1);
HXDLIN( 140)								int i4 = (_g12 - 1);
HXDLIN( 140)								{
HXLINE( 140)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 140)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 140)									{
HXLINE( 140)										int _g14 = 0;
HXDLIN( 140)										int _g15 = i4;
HXDLIN( 140)										while((_g14 < _g15)){
HXLINE( 140)											_g14 = (_g14 + 1);
HXDLIN( 140)											int i5 = (_g14 - 1);
HXDLIN( 140)											prev = l;
HXDLIN( 140)											l = l->next;
            										}
            									}
HXDLIN( 140)									if (::hx::IsNull( prev )) {
HXLINE( 140)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 140)										l = null();
            									}
            									else {
HXLINE( 140)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 140)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 140)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 140)		this2->image = _hx_tmp;
HXDLIN( 140)		this2->width = width;
HXDLIN( 140)		this2->height = height;
HXDLIN( 140)		this2->imageType = ( (int)(imageType) );
HXDLIN( 140)		 ::pi_xy::ImageStruct out = this2;
HXLINE( 141)		 ::pi_xy::ImageStruct here = this1;
HXLINE( 144)		switch((int)(borderMode)){
            			case (int)0: {
HXLINE( 146)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 146)				int width1 = (this4->width + 2);
HXDLIN( 146)				int height1 = (this4->height + 2);
HXDLIN( 146)				 ::Dynamic imageType1 = null();
HXDLIN( 146)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 146)				if (::hx::IsNull( imageType1 )) {
HXLINE( 146)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXDLIN( 146)				::Dynamic here1;
HXDLIN( 146)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 146)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 146)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 146)						{
HXLINE( 146)							b3->width = width1;
HXDLIN( 146)							b3->height = height1;
HXDLIN( 146)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 146)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 146)							{
HXLINE( 146)								int len2 = b3->length;
HXDLIN( 146)								int w1 = 0;
HXDLIN( 146)								{
HXLINE( 146)									int _g16 = 0;
HXDLIN( 146)									int _g17 = b3->height;
HXDLIN( 146)									while((_g16 < _g17)){
HXLINE( 146)										_g16 = (_g16 + 1);
HXDLIN( 146)										int y1 = (_g16 - 1);
HXDLIN( 146)										{
HXLINE( 146)											int _g18 = 0;
HXDLIN( 146)											int _g19 = b3->width;
HXDLIN( 146)											while((_g18 < _g19)){
HXLINE( 146)												_g18 = (_g18 + 1);
HXDLIN( 146)												int x1 = (_g18 - 1);
HXDLIN( 146)												{
HXLINE( 146)													w1 = (w1 + 1);
HXDLIN( 146)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 146)												{
HXLINE( 146)													w1 = (w1 + 1);
HXDLIN( 146)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 146)												{
HXLINE( 146)													w1 = (w1 + 1);
HXDLIN( 146)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 146)												{
HXLINE( 146)													w1 = (w1 + 1);
HXDLIN( 146)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 146)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXLINE( 146)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 146)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 146)						{
HXLINE( 146)							a1->width = width1;
HXDLIN( 146)							a1->height = height1;
HXDLIN( 146)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 146)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 146)							{
HXLINE( 146)								int _g20 = 0;
HXDLIN( 146)								int _g21 = a1->length;
HXDLIN( 146)								while((_g20 < _g21)){
HXLINE( 146)									_g20 = (_g20 + 1);
HXDLIN( 146)									int i6 = (_g20 - 1);
HXDLIN( 146)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 146)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXLINE( 146)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 146)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 146)						{
HXLINE( 146)							b4->width = width1;
HXDLIN( 146)							b4->height = height1;
HXDLIN( 146)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 146)							int size1 = (b4->length * 4);
HXDLIN( 146)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 146)							{
HXLINE( 146)								int _g22 = 0;
HXDLIN( 146)								int _g23 = b4->length;
HXDLIN( 146)								while((_g22 < _g23)){
HXLINE( 146)									_g22 = (_g22 + 1);
HXDLIN( 146)									int i7 = (_g22 - 1);
HXDLIN( 146)									{
HXLINE( 146)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 146)										bool here2;
HXDLIN( 146)										if ((i7 >= 0)) {
HXLINE( 146)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXLINE( 146)											here2 = false;
            										}
HXDLIN( 146)										if (here2) {
HXLINE( 146)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 146)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 146)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 146)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 146)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 146)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 146)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXLINE( 146)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 146)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 146)						{
HXLINE( 146)							v1->width = width1;
HXDLIN( 146)							v1->height = height1;
HXDLIN( 146)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 146)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 146)							{
HXLINE( 146)								int _g24 = 0;
HXDLIN( 146)								int _g25 = v1->length;
HXDLIN( 146)								while((_g24 < _g25)){
HXLINE( 146)									_g24 = (_g24 + 1);
HXDLIN( 146)									int i8 = (_g24 - 1);
HXDLIN( 146)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 146)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXLINE( 146)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 146)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 146)						{
HXLINE( 146)							b5->width = width1;
HXDLIN( 146)							b5->height = height1;
HXDLIN( 146)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 146)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 146)							{
HXLINE( 146)								int len3 = b5->length;
HXDLIN( 146)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 146)								if (::hx::IsNull( d1->head )) {
HXLINE( 146)									int _g26 = 0;
HXDLIN( 146)									int _g27 = len3;
HXDLIN( 146)									while((_g26 < _g27)){
HXLINE( 146)										_g26 = (_g26 + 1);
HXDLIN( 146)										int i9 = (_g26 - 1);
HXDLIN( 146)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 146)									int _g28 = 0;
HXDLIN( 146)									int _g29 = len3;
HXDLIN( 146)									while((_g28 < _g29)){
HXLINE( 146)										_g28 = (_g28 + 1);
HXDLIN( 146)										int i10 = (_g28 - 1);
HXDLIN( 146)										{
HXLINE( 146)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 146)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 146)											{
HXLINE( 146)												int _g30 = 0;
HXDLIN( 146)												int _g31 = i10;
HXDLIN( 146)												while((_g30 < _g31)){
HXLINE( 146)													_g30 = (_g30 + 1);
HXDLIN( 146)													int i11 = (_g30 - 1);
HXDLIN( 146)													prev1 = l1;
HXDLIN( 146)													l1 = l1->next;
            												}
            											}
HXDLIN( 146)											if (::hx::IsNull( prev1 )) {
HXLINE( 146)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 146)												l1 = null();
            											}
            											else {
HXLINE( 146)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 146)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 146)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 146)				this5->image = here1;
HXDLIN( 146)				this5->width = width1;
HXDLIN( 146)				this5->height = height1;
HXDLIN( 146)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 146)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 146)				{
HXLINE( 146)					bool forceClear = false;
HXDLIN( 146)					{
HXLINE( 146)						int _g32 = 0;
HXDLIN( 146)						int _g33 = this4->height;
HXDLIN( 146)						while((_g32 < _g33)){
HXLINE( 146)							_g32 = (_g32 + 1);
HXDLIN( 146)							int dy = (_g32 - 1);
HXDLIN( 146)							{
HXLINE( 146)								int _g34 = 0;
HXDLIN( 146)								int _g35 = this4->width;
HXDLIN( 146)								while((_g34 < _g35)){
HXLINE( 146)									_g34 = (_g34 + 1);
HXDLIN( 146)									int dx = (_g34 - 1);
HXDLIN( 146)									::Dynamic this7 = this4->image;
HXDLIN( 146)									int index;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 146)									int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 146)									int col;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 146)										col = c;
            									}
HXDLIN( 146)									bool here3;
HXDLIN( 146)									if (this4->useMask) {
HXLINE( 146)										here3 = ::hx::IsNotNull( this4->mask );
            									}
            									else {
HXLINE( 146)										here3 = false;
            									}
HXDLIN( 146)									if (here3) {
HXLINE( 146)										 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 146)										::Dynamic this9 = this8->image;
HXDLIN( 146)										int index1;
HXDLIN( 146)										if (this8->useVirtualPos) {
HXLINE( 146)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            										}
            										else {
HXLINE( 146)											index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            										}
HXDLIN( 146)										int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 146)										int v2;
HXDLIN( 146)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)											v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 146)											v2 = c1;
            										}
HXDLIN( 146)										int maskPixel = v2;
HXDLIN( 146)										int this10 = col;
HXDLIN( 146)										if ((maskPixel == 0)) {
HXLINE( 146)											col = this10;
            										}
            										else {
HXLINE( 146)											Float m0;
HXDLIN( 146)											int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 146)											if ((this11 == 0)) {
HXLINE( 146)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float m1;
HXDLIN( 146)											int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 146)											if ((this12 == 0)) {
HXLINE( 146)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float m2;
HXDLIN( 146)											int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 146)											if ((this13 == 0)) {
HXLINE( 146)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float m3;
HXDLIN( 146)											int this14 = (maskPixel & 255);
HXDLIN( 146)											if ((this14 == 0)) {
HXLINE( 146)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 146)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 146)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 146)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 146)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 146)									if ((col != 0)) {
HXLINE( 146)										int x2 = (1 + dx);
HXDLIN( 146)										int y2 = (1 + dy);
HXDLIN( 146)										int c2 = col;
HXDLIN( 146)										bool here4;
HXDLIN( 146)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 146)											here4 = img->transparent;
            										}
            										else {
HXLINE( 146)											here4 = false;
            										}
HXDLIN( 146)										if (here4) {
HXLINE( 146)											int location;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            											}
HXDLIN( 146)											int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 146)											int this16;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this16 = this15;
            											}
HXDLIN( 146)											Float a11;
HXDLIN( 146)											int this17 = ((this16 >> 24) & 255);
HXDLIN( 146)											if ((this17 == 0)) {
HXLINE( 146)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r1;
HXDLIN( 146)											int this18 = ((this16 >> 16) & 255);
HXDLIN( 146)											if ((this18 == 0)) {
HXLINE( 146)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g1;
HXDLIN( 146)											int this19 = ((this16 >> 8) & 255);
HXDLIN( 146)											if ((this19 == 0)) {
HXLINE( 146)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b11;
HXDLIN( 146)											int this20 = (this16 & 255);
HXDLIN( 146)											if ((this20 == 0)) {
HXLINE( 146)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a2;
HXDLIN( 146)											int this21 = ((col >> 24) & 255);
HXDLIN( 146)											if ((this21 == 0)) {
HXLINE( 146)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r2;
HXDLIN( 146)											int this22 = ((col >> 16) & 255);
HXDLIN( 146)											if ((this22 == 0)) {
HXLINE( 146)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g2;
HXDLIN( 146)											int this23 = ((col >> 8) & 255);
HXDLIN( 146)											if ((this23 == 0)) {
HXLINE( 146)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b21;
HXDLIN( 146)											int this24 = (col & 255);
HXDLIN( 146)											if ((this24 == 0)) {
HXLINE( 146)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 146)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 146)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 146)											int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 146)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 146)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 146)											{
HXLINE( 146)												int here5;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here5 = blended;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location,here5);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this25 = img->image;
HXDLIN( 146)											int index2;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            											}
HXDLIN( 146)											int here6;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here6 = c2;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this25,index2,here6);
            										}
            									}
            									else {
HXLINE( 146)										if (forceClear) {
HXLINE( 146)											::Dynamic this26 = img->image;
HXDLIN( 146)											int x3 = (1 + dx);
HXDLIN( 146)											int y3 = (1 + dy);
HXDLIN( 146)											int index3;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this26,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 146)				{
HXLINE( 146)					int _g36 = 0;
HXDLIN( 146)					int _g37 = this4->width;
HXDLIN( 146)					while((_g36 < _g37)){
HXLINE( 146)						_g36 = (_g36 + 1);
HXDLIN( 146)						int x4 = (_g36 - 1);
HXDLIN( 146)						{
HXLINE( 146)							int _g38 = 0;
HXDLIN( 146)							int _g39 = 1;
HXDLIN( 146)							while((_g38 < _g39)){
HXLINE( 146)								_g38 = (_g38 + 1);
HXDLIN( 146)								int y4 = (_g38 - 1);
HXDLIN( 146)								{
HXLINE( 146)									int x5 = (x4 + 1);
HXDLIN( 146)									::Dynamic this27 = this4->image;
HXDLIN( 146)									int index4;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            									}
HXDLIN( 146)									int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 146)									int color;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color = c3;
            									}
HXDLIN( 146)									int color1 = color;
HXDLIN( 146)									{
HXLINE( 146)										int c4 = color1;
HXDLIN( 146)										bool here7;
HXDLIN( 146)										if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 146)											here7 = img->transparent;
            										}
            										else {
HXLINE( 146)											here7 = false;
            										}
HXDLIN( 146)										if (here7) {
HXLINE( 146)											int location1;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            											}
HXDLIN( 146)											int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 146)											int this29;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this29 = this28;
            											}
HXDLIN( 146)											Float a12;
HXDLIN( 146)											int this30 = ((this29 >> 24) & 255);
HXDLIN( 146)											if ((this30 == 0)) {
HXLINE( 146)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r11;
HXDLIN( 146)											int this31 = ((this29 >> 16) & 255);
HXDLIN( 146)											if ((this31 == 0)) {
HXLINE( 146)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g11;
HXDLIN( 146)											int this32 = ((this29 >> 8) & 255);
HXDLIN( 146)											if ((this32 == 0)) {
HXLINE( 146)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b12;
HXDLIN( 146)											int this33 = (this29 & 255);
HXDLIN( 146)											if ((this33 == 0)) {
HXLINE( 146)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a21;
HXDLIN( 146)											int this34 = ((color1 >> 24) & 255);
HXDLIN( 146)											if ((this34 == 0)) {
HXLINE( 146)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r21;
HXDLIN( 146)											int this35 = ((color1 >> 16) & 255);
HXDLIN( 146)											if ((this35 == 0)) {
HXLINE( 146)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g21;
HXDLIN( 146)											int this36 = ((color1 >> 8) & 255);
HXDLIN( 146)											if ((this36 == 0)) {
HXLINE( 146)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b22;
HXDLIN( 146)											int this37 = (color1 & 255);
HXDLIN( 146)											if ((this37 == 0)) {
HXLINE( 146)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 146)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 146)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 146)											int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 146)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 146)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 146)											{
HXLINE( 146)												int here8;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here8 = blended1;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location1,here8);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this38 = img->image;
HXDLIN( 146)											int index5;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            											}
HXDLIN( 146)											int here9;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here9 = c4;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this38,index5,here9);
            										}
            									}
            								}
HXDLIN( 146)								{
HXLINE( 146)									int x6 = (x4 + 1);
HXDLIN( 146)									int y5 = ((img->height - y4) - 1);
HXDLIN( 146)									int y6 = (this4->height - 1);
HXDLIN( 146)									::Dynamic this39 = this4->image;
HXDLIN( 146)									int index6;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            									}
HXDLIN( 146)									int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 146)									int color2;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color2 = c5;
            									}
HXDLIN( 146)									{
HXLINE( 146)										int c6 = color2;
HXDLIN( 146)										bool here10;
HXDLIN( 146)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 146)											here10 = img->transparent;
            										}
            										else {
HXLINE( 146)											here10 = false;
            										}
HXDLIN( 146)										if (here10) {
HXLINE( 146)											int location2;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            											}
HXDLIN( 146)											int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 146)											int this41;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this41 = this40;
            											}
HXDLIN( 146)											Float a13;
HXDLIN( 146)											int this42 = ((this41 >> 24) & 255);
HXDLIN( 146)											if ((this42 == 0)) {
HXLINE( 146)												a13 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r12;
HXDLIN( 146)											int this43 = ((this41 >> 16) & 255);
HXDLIN( 146)											if ((this43 == 0)) {
HXLINE( 146)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g12;
HXDLIN( 146)											int this44 = ((this41 >> 8) & 255);
HXDLIN( 146)											if ((this44 == 0)) {
HXLINE( 146)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b13;
HXDLIN( 146)											int this45 = (this41 & 255);
HXDLIN( 146)											if ((this45 == 0)) {
HXLINE( 146)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a22;
HXDLIN( 146)											int this46 = ((color2 >> 24) & 255);
HXDLIN( 146)											if ((this46 == 0)) {
HXLINE( 146)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r22;
HXDLIN( 146)											int this47 = ((color2 >> 16) & 255);
HXDLIN( 146)											if ((this47 == 0)) {
HXLINE( 146)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g22;
HXDLIN( 146)											int this48 = ((color2 >> 8) & 255);
HXDLIN( 146)											if ((this48 == 0)) {
HXLINE( 146)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b23;
HXDLIN( 146)											int this49 = (color2 & 255);
HXDLIN( 146)											if ((this49 == 0)) {
HXLINE( 146)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 146)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 146)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 146)											int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 146)											int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 146)											int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 146)											{
HXLINE( 146)												int here11;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here11 = blended2;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location2,here11);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this50 = img->image;
HXDLIN( 146)											int index7;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            											}
HXDLIN( 146)											int here12;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here12 = c6;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this50,index7,here12);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 146)				{
HXLINE( 146)					int _g40 = 0;
HXDLIN( 146)					int _g41 = this4->height;
HXDLIN( 146)					while((_g40 < _g41)){
HXLINE( 146)						_g40 = (_g40 + 1);
HXDLIN( 146)						int y7 = (_g40 - 1);
HXDLIN( 146)						{
HXLINE( 146)							int _g42 = 0;
HXDLIN( 146)							int _g43 = 1;
HXDLIN( 146)							while((_g42 < _g43)){
HXLINE( 146)								_g42 = (_g42 + 1);
HXDLIN( 146)								int x7 = (_g42 - 1);
HXDLIN( 146)								{
HXLINE( 146)									int y8 = (y7 + 1);
HXDLIN( 146)									::Dynamic this51 = this4->image;
HXDLIN( 146)									int index8;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            									}
HXDLIN( 146)									int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 146)									int color3;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color3 = c7;
            									}
HXDLIN( 146)									int color4 = color3;
HXDLIN( 146)									{
HXLINE( 146)										int c8 = color4;
HXDLIN( 146)										bool here13;
HXDLIN( 146)										if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 146)											here13 = img->transparent;
            										}
            										else {
HXLINE( 146)											here13 = false;
            										}
HXDLIN( 146)										if (here13) {
HXLINE( 146)											int location3;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            											}
HXDLIN( 146)											int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 146)											int this53;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this53 = this52;
            											}
HXDLIN( 146)											Float a14;
HXDLIN( 146)											int this54 = ((this53 >> 24) & 255);
HXDLIN( 146)											if ((this54 == 0)) {
HXLINE( 146)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r13;
HXDLIN( 146)											int this55 = ((this53 >> 16) & 255);
HXDLIN( 146)											if ((this55 == 0)) {
HXLINE( 146)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g13;
HXDLIN( 146)											int this56 = ((this53 >> 8) & 255);
HXDLIN( 146)											if ((this56 == 0)) {
HXLINE( 146)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b14;
HXDLIN( 146)											int this57 = (this53 & 255);
HXDLIN( 146)											if ((this57 == 0)) {
HXLINE( 146)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a23;
HXDLIN( 146)											int this58 = ((color4 >> 24) & 255);
HXDLIN( 146)											if ((this58 == 0)) {
HXLINE( 146)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r23;
HXDLIN( 146)											int this59 = ((color4 >> 16) & 255);
HXDLIN( 146)											if ((this59 == 0)) {
HXLINE( 146)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g23;
HXDLIN( 146)											int this60 = ((color4 >> 8) & 255);
HXDLIN( 146)											if ((this60 == 0)) {
HXLINE( 146)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b24;
HXDLIN( 146)											int this61 = (color4 & 255);
HXDLIN( 146)											if ((this61 == 0)) {
HXLINE( 146)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 146)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 146)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 146)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 146)											int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 146)											int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 146)											{
HXLINE( 146)												int here14;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here14 = blended3;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location3,here14);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this62 = img->image;
HXDLIN( 146)											int index9;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            											}
HXDLIN( 146)											int here15;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here15 = c8;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this62,index9,here15);
            										}
            									}
            								}
HXDLIN( 146)								{
HXLINE( 146)									int x8 = ((img->width - x7) - 1);
HXDLIN( 146)									int y9 = (y7 + 1);
HXDLIN( 146)									int x9 = (this4->width - 1);
HXDLIN( 146)									::Dynamic this63 = this4->image;
HXDLIN( 146)									int index10;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            									}
HXDLIN( 146)									int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 146)									int color5;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color5 = c9;
            									}
HXDLIN( 146)									{
HXLINE( 146)										int c10 = color5;
HXDLIN( 146)										bool here16;
HXDLIN( 146)										if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 146)											here16 = img->transparent;
            										}
            										else {
HXLINE( 146)											here16 = false;
            										}
HXDLIN( 146)										if (here16) {
HXLINE( 146)											int location4;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            											}
HXDLIN( 146)											int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 146)											int this65;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this65 = this64;
            											}
HXDLIN( 146)											Float a15;
HXDLIN( 146)											int this66 = ((this65 >> 24) & 255);
HXDLIN( 146)											if ((this66 == 0)) {
HXLINE( 146)												a15 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r14;
HXDLIN( 146)											int this67 = ((this65 >> 16) & 255);
HXDLIN( 146)											if ((this67 == 0)) {
HXLINE( 146)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g14;
HXDLIN( 146)											int this68 = ((this65 >> 8) & 255);
HXDLIN( 146)											if ((this68 == 0)) {
HXLINE( 146)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b15;
HXDLIN( 146)											int this69 = (this65 & 255);
HXDLIN( 146)											if ((this69 == 0)) {
HXLINE( 146)												b15 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a24;
HXDLIN( 146)											int this70 = ((color5 >> 24) & 255);
HXDLIN( 146)											if ((this70 == 0)) {
HXLINE( 146)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r24;
HXDLIN( 146)											int this71 = ((color5 >> 16) & 255);
HXDLIN( 146)											if ((this71 == 0)) {
HXLINE( 146)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g24;
HXDLIN( 146)											int this72 = ((color5 >> 8) & 255);
HXDLIN( 146)											if ((this72 == 0)) {
HXLINE( 146)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b25;
HXDLIN( 146)											int this73 = (color5 & 255);
HXDLIN( 146)											if ((this73 == 0)) {
HXLINE( 146)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 146)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 146)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 146)											int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 146)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 146)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 146)											{
HXLINE( 146)												int here17;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here17 = blended4;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location4,here17);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this74 = img->image;
HXDLIN( 146)											int index11;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            											}
HXDLIN( 146)											int here18;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here18 = c10;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this74,index11,here18);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 146)				{
HXLINE( 146)					int _g44 = 0;
HXDLIN( 146)					int _g45 = 1;
HXDLIN( 146)					while((_g44 < _g45)){
HXLINE( 146)						_g44 = (_g44 + 1);
HXDLIN( 146)						int x10 = (_g44 - 1);
HXDLIN( 146)						{
HXLINE( 146)							int _g46 = 0;
HXDLIN( 146)							int _g47 = 1;
HXDLIN( 146)							while((_g46 < _g47)){
HXLINE( 146)								_g46 = (_g46 + 1);
HXDLIN( 146)								int y10 = (_g46 - 1);
HXDLIN( 146)								{
HXLINE( 146)									::Dynamic this75 = this4->image;
HXDLIN( 146)									int index12;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            									}
HXDLIN( 146)									int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 146)									int color6;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color6 = c11;
            									}
HXDLIN( 146)									int color7 = color6;
HXDLIN( 146)									{
HXLINE( 146)										int c12 = color7;
HXDLIN( 146)										bool here19;
HXDLIN( 146)										if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 146)											here19 = img->transparent;
            										}
            										else {
HXLINE( 146)											here19 = false;
            										}
HXDLIN( 146)										if (here19) {
HXLINE( 146)											int location5;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            											}
HXDLIN( 146)											int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 146)											int this77;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this77 = this76;
            											}
HXDLIN( 146)											Float a16;
HXDLIN( 146)											int this78 = ((this77 >> 24) & 255);
HXDLIN( 146)											if ((this78 == 0)) {
HXLINE( 146)												a16 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r15;
HXDLIN( 146)											int this79 = ((this77 >> 16) & 255);
HXDLIN( 146)											if ((this79 == 0)) {
HXLINE( 146)												r15 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g15;
HXDLIN( 146)											int this80 = ((this77 >> 8) & 255);
HXDLIN( 146)											if ((this80 == 0)) {
HXLINE( 146)												g15 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b16;
HXDLIN( 146)											int this81 = (this77 & 255);
HXDLIN( 146)											if ((this81 == 0)) {
HXLINE( 146)												b16 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a25;
HXDLIN( 146)											int this82 = ((color7 >> 24) & 255);
HXDLIN( 146)											if ((this82 == 0)) {
HXLINE( 146)												a25 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r25;
HXDLIN( 146)											int this83 = ((color7 >> 16) & 255);
HXDLIN( 146)											if ((this83 == 0)) {
HXLINE( 146)												r25 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g25;
HXDLIN( 146)											int this84 = ((color7 >> 8) & 255);
HXDLIN( 146)											if ((this84 == 0)) {
HXLINE( 146)												g25 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b26;
HXDLIN( 146)											int this85 = (color7 & 255);
HXDLIN( 146)											if ((this85 == 0)) {
HXLINE( 146)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 146)											int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 146)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 146)											int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 146)											int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 146)											int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 146)											{
HXLINE( 146)												int here20;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here20 = blended5;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location5,here20);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this86 = img->image;
HXDLIN( 146)											int index13;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            											}
HXDLIN( 146)											int here21;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here21 = c12;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this86,index13,here21);
            										}
            									}
            								}
HXDLIN( 146)								{
HXLINE( 146)									int x11 = ((x10 + 1) + this4->width);
HXDLIN( 146)									int x12 = (this4->width - 1);
HXDLIN( 146)									::Dynamic this87 = this4->image;
HXDLIN( 146)									int index14;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            									}
HXDLIN( 146)									int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 146)									int color8;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color8 = c13;
            									}
HXDLIN( 146)									{
HXLINE( 146)										int c14 = color8;
HXDLIN( 146)										bool here22;
HXDLIN( 146)										if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 146)											here22 = img->transparent;
            										}
            										else {
HXLINE( 146)											here22 = false;
            										}
HXDLIN( 146)										if (here22) {
HXLINE( 146)											int location6;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            											}
HXDLIN( 146)											int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 146)											int this89;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this89 = this88;
            											}
HXDLIN( 146)											Float a17;
HXDLIN( 146)											int this90 = ((this89 >> 24) & 255);
HXDLIN( 146)											if ((this90 == 0)) {
HXLINE( 146)												a17 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r16;
HXDLIN( 146)											int this91 = ((this89 >> 16) & 255);
HXDLIN( 146)											if ((this91 == 0)) {
HXLINE( 146)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g16;
HXDLIN( 146)											int this92 = ((this89 >> 8) & 255);
HXDLIN( 146)											if ((this92 == 0)) {
HXLINE( 146)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b18;
HXDLIN( 146)											int this93 = (this89 & 255);
HXDLIN( 146)											if ((this93 == 0)) {
HXLINE( 146)												b18 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a26;
HXDLIN( 146)											int this94 = ((color8 >> 24) & 255);
HXDLIN( 146)											if ((this94 == 0)) {
HXLINE( 146)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r26;
HXDLIN( 146)											int this95 = ((color8 >> 16) & 255);
HXDLIN( 146)											if ((this95 == 0)) {
HXLINE( 146)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g26;
HXDLIN( 146)											int this96 = ((color8 >> 8) & 255);
HXDLIN( 146)											if ((this96 == 0)) {
HXLINE( 146)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b27;
HXDLIN( 146)											int this97 = (color8 & 255);
HXDLIN( 146)											if ((this97 == 0)) {
HXLINE( 146)												b27 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 146)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 146)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 146)											int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 146)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 146)											int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 146)											{
HXLINE( 146)												int here23;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here23 = blended6;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location6,here23);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this98 = img->image;
HXDLIN( 146)											int index15;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            											}
HXDLIN( 146)											int here24;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here24 = c14;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this98,index15,here24);
            										}
            									}
            								}
HXDLIN( 146)								{
HXLINE( 146)									int x13 = ((x10 + 1) + this4->width);
HXDLIN( 146)									int y11 = ((y10 + 1) + this4->height);
HXDLIN( 146)									int x14 = (this4->width - 1);
HXDLIN( 146)									int y12 = (this4->height - 1);
HXDLIN( 146)									::Dynamic this99 = this4->image;
HXDLIN( 146)									int index16;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            									}
HXDLIN( 146)									int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 146)									int color9;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color9 = c15;
            									}
HXDLIN( 146)									{
HXLINE( 146)										int c16 = color9;
HXDLIN( 146)										bool here25;
HXDLIN( 146)										if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 146)											here25 = img->transparent;
            										}
            										else {
HXLINE( 146)											here25 = false;
            										}
HXDLIN( 146)										if (here25) {
HXLINE( 146)											int location7;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            											}
HXDLIN( 146)											int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 146)											int this101;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this101 = this100;
            											}
HXDLIN( 146)											Float a18;
HXDLIN( 146)											int this102 = ((this101 >> 24) & 255);
HXDLIN( 146)											if ((this102 == 0)) {
HXLINE( 146)												a18 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r17;
HXDLIN( 146)											int this103 = ((this101 >> 16) & 255);
HXDLIN( 146)											if ((this103 == 0)) {
HXLINE( 146)												r17 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g17;
HXDLIN( 146)											int this104 = ((this101 >> 8) & 255);
HXDLIN( 146)											if ((this104 == 0)) {
HXLINE( 146)												g17 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b110;
HXDLIN( 146)											int this105 = (this101 & 255);
HXDLIN( 146)											if ((this105 == 0)) {
HXLINE( 146)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a27;
HXDLIN( 146)											int this106 = ((color9 >> 24) & 255);
HXDLIN( 146)											if ((this106 == 0)) {
HXLINE( 146)												a27 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r27;
HXDLIN( 146)											int this107 = ((color9 >> 16) & 255);
HXDLIN( 146)											if ((this107 == 0)) {
HXLINE( 146)												r27 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g27;
HXDLIN( 146)											int this108 = ((color9 >> 8) & 255);
HXDLIN( 146)											if ((this108 == 0)) {
HXLINE( 146)												g27 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b28;
HXDLIN( 146)											int this109 = (color9 & 255);
HXDLIN( 146)											if ((this109 == 0)) {
HXLINE( 146)												b28 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 146)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 146)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 146)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 146)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 146)											int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 146)											{
HXLINE( 146)												int here26;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here26 = blended7;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location7,here26);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this110 = img->image;
HXDLIN( 146)											int index17;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            											}
HXDLIN( 146)											int here27;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here27 = c16;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this110,index17,here27);
            										}
            									}
            								}
HXDLIN( 146)								{
HXLINE( 146)									int y13 = ((y10 + 1) + this4->width);
HXDLIN( 146)									int y14 = (this4->height - 1);
HXDLIN( 146)									::Dynamic this111 = this4->image;
HXDLIN( 146)									int index18;
HXDLIN( 146)									if (this4->useVirtualPos) {
HXLINE( 146)										index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 146)										index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            									}
HXDLIN( 146)									int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 146)									int color10;
HXDLIN( 146)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)										color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            									}
            									else {
HXLINE( 146)										color10 = c17;
            									}
HXDLIN( 146)									{
HXLINE( 146)										int c18 = color10;
HXDLIN( 146)										bool here28;
HXDLIN( 146)										if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 146)											here28 = img->transparent;
            										}
            										else {
HXLINE( 146)											here28 = false;
            										}
HXDLIN( 146)										if (here28) {
HXLINE( 146)											int location8;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 146)												location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            											}
HXDLIN( 146)											int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 146)											int this113;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												this113 = this112;
            											}
HXDLIN( 146)											Float a110;
HXDLIN( 146)											int this114 = ((this113 >> 24) & 255);
HXDLIN( 146)											if ((this114 == 0)) {
HXLINE( 146)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r18;
HXDLIN( 146)											int this115 = ((this113 >> 16) & 255);
HXDLIN( 146)											if ((this115 == 0)) {
HXLINE( 146)												r18 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g18;
HXDLIN( 146)											int this116 = ((this113 >> 8) & 255);
HXDLIN( 146)											if ((this116 == 0)) {
HXLINE( 146)												g18 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b111;
HXDLIN( 146)											int this117 = (this113 & 255);
HXDLIN( 146)											if ((this117 == 0)) {
HXLINE( 146)												b111 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a28;
HXDLIN( 146)											int this118 = ((color10 >> 24) & 255);
HXDLIN( 146)											if ((this118 == 0)) {
HXLINE( 146)												a28 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float r28;
HXDLIN( 146)											int this119 = ((color10 >> 16) & 255);
HXDLIN( 146)											if ((this119 == 0)) {
HXLINE( 146)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float g28;
HXDLIN( 146)											int this120 = ((color10 >> 8) & 255);
HXDLIN( 146)											if ((this120 == 0)) {
HXLINE( 146)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float b29;
HXDLIN( 146)											int this121 = (color10 & 255);
HXDLIN( 146)											if ((this121 == 0)) {
HXLINE( 146)												b29 = ((Float)0.);
            											}
            											else {
HXLINE( 146)												b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            											}
HXDLIN( 146)											Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 146)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 146)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 146)											int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 146)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 146)											int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 146)											{
HXLINE( 146)												int here29;
HXDLIN( 146)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)													here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 146)													here29 = blended8;
            												}
HXDLIN( 146)												::iterMagic::Iimg_obj::set(img->image,location8,here29);
            											}
            										}
            										else {
HXLINE( 146)											::Dynamic this122 = img->image;
HXDLIN( 146)											int index19;
HXDLIN( 146)											if (img->useVirtualPos) {
HXLINE( 146)												index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 146)												index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            											}
HXDLIN( 146)											int here30;
HXDLIN( 146)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 146)												here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE( 146)												here30 = c18;
            											}
HXDLIN( 146)											::iterMagic::Iimg_obj::set(this122,index19,here30);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 146)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXLINE( 150)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 150)				int width2 = (this123->width + 2);
HXDLIN( 150)				int height2 = (this123->height + 2);
HXDLIN( 150)				 ::Dynamic imageType2 = null();
HXDLIN( 150)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 150)				if (::hx::IsNull( imageType2 )) {
HXLINE( 150)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXDLIN( 150)				::Dynamic here31;
HXDLIN( 150)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 150)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 150)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 150)						{
HXLINE( 150)							b31->width = width2;
HXDLIN( 150)							b31->height = height2;
HXDLIN( 150)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 150)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 150)							{
HXLINE( 150)								int len4 = b31->length;
HXDLIN( 150)								int w2 = 0;
HXDLIN( 150)								{
HXLINE( 150)									int _g48 = 0;
HXDLIN( 150)									int _g49 = b31->height;
HXDLIN( 150)									while((_g48 < _g49)){
HXLINE( 150)										_g48 = (_g48 + 1);
HXDLIN( 150)										int y15 = (_g48 - 1);
HXDLIN( 150)										{
HXLINE( 150)											int _g50 = 0;
HXDLIN( 150)											int _g51 = b31->width;
HXDLIN( 150)											while((_g50 < _g51)){
HXLINE( 150)												_g50 = (_g50 + 1);
HXDLIN( 150)												int x15 = (_g50 - 1);
HXDLIN( 150)												{
HXLINE( 150)													w2 = (w2 + 1);
HXDLIN( 150)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 150)												{
HXLINE( 150)													w2 = (w2 + 1);
HXDLIN( 150)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 150)												{
HXLINE( 150)													w2 = (w2 + 1);
HXDLIN( 150)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 150)												{
HXLINE( 150)													w2 = (w2 + 1);
HXDLIN( 150)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 150)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXLINE( 150)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 150)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 150)						{
HXLINE( 150)							a29->width = width2;
HXDLIN( 150)							a29->height = height2;
HXDLIN( 150)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 150)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 150)							{
HXLINE( 150)								int _g52 = 0;
HXDLIN( 150)								int _g53 = a29->length;
HXDLIN( 150)								while((_g52 < _g53)){
HXLINE( 150)									_g52 = (_g52 + 1);
HXDLIN( 150)									int i12 = (_g52 - 1);
HXDLIN( 150)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 150)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 150)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 150)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 150)						{
HXLINE( 150)							b32->width = width2;
HXDLIN( 150)							b32->height = height2;
HXDLIN( 150)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 150)							int size2 = (b32->length * 4);
HXDLIN( 150)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 150)							{
HXLINE( 150)								int _g54 = 0;
HXDLIN( 150)								int _g55 = b32->length;
HXDLIN( 150)								while((_g54 < _g55)){
HXLINE( 150)									_g54 = (_g54 + 1);
HXDLIN( 150)									int i13 = (_g54 - 1);
HXDLIN( 150)									{
HXLINE( 150)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 150)										bool here32;
HXDLIN( 150)										if ((i13 >= 0)) {
HXLINE( 150)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXLINE( 150)											here32 = false;
            										}
HXDLIN( 150)										if (here32) {
HXLINE( 150)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 150)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 150)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 150)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 150)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 150)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 150)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXLINE( 150)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 150)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 150)						{
HXLINE( 150)							v3->width = width2;
HXDLIN( 150)							v3->height = height2;
HXDLIN( 150)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 150)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 150)							{
HXLINE( 150)								int _g56 = 0;
HXDLIN( 150)								int _g57 = v3->length;
HXDLIN( 150)								while((_g56 < _g57)){
HXLINE( 150)									_g56 = (_g56 + 1);
HXDLIN( 150)									int i14 = (_g56 - 1);
HXDLIN( 150)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 150)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 150)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 150)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 150)						{
HXLINE( 150)							b33->width = width2;
HXDLIN( 150)							b33->height = height2;
HXDLIN( 150)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 150)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 150)							{
HXLINE( 150)								int len5 = b33->length;
HXDLIN( 150)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 150)								if (::hx::IsNull( d2->head )) {
HXLINE( 150)									int _g58 = 0;
HXDLIN( 150)									int _g59 = len5;
HXDLIN( 150)									while((_g58 < _g59)){
HXLINE( 150)										_g58 = (_g58 + 1);
HXDLIN( 150)										int i15 = (_g58 - 1);
HXDLIN( 150)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 150)									int _g60 = 0;
HXDLIN( 150)									int _g61 = len5;
HXDLIN( 150)									while((_g60 < _g61)){
HXLINE( 150)										_g60 = (_g60 + 1);
HXDLIN( 150)										int i16 = (_g60 - 1);
HXDLIN( 150)										{
HXLINE( 150)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 150)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 150)											{
HXLINE( 150)												int _g62 = 0;
HXDLIN( 150)												int _g63 = i16;
HXDLIN( 150)												while((_g62 < _g63)){
HXLINE( 150)													_g62 = (_g62 + 1);
HXDLIN( 150)													int i17 = (_g62 - 1);
HXDLIN( 150)													prev2 = l2;
HXDLIN( 150)													l2 = l2->next;
            												}
            											}
HXDLIN( 150)											if (::hx::IsNull( prev2 )) {
HXLINE( 150)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 150)												l2 = null();
            											}
            											else {
HXLINE( 150)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 150)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 150)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 150)				this124->image = here31;
HXDLIN( 150)				this124->width = width2;
HXDLIN( 150)				this124->height = height2;
HXDLIN( 150)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 150)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 150)				{
HXLINE( 150)					bool forceClear1 = false;
HXDLIN( 150)					{
HXLINE( 150)						int _g64 = 0;
HXDLIN( 150)						int _g65 = this123->height;
HXDLIN( 150)						while((_g64 < _g65)){
HXLINE( 150)							_g64 = (_g64 + 1);
HXDLIN( 150)							int dy1 = (_g64 - 1);
HXDLIN( 150)							{
HXLINE( 150)								int _g66 = 0;
HXDLIN( 150)								int _g67 = this123->width;
HXDLIN( 150)								while((_g66 < _g67)){
HXLINE( 150)									_g66 = (_g66 + 1);
HXDLIN( 150)									int dx1 = (_g66 - 1);
HXDLIN( 150)									::Dynamic this126 = this123->image;
HXDLIN( 150)									int index20;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            									}
HXDLIN( 150)									int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 150)									int col1;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										col1 = c19;
            									}
HXDLIN( 150)									bool here33;
HXDLIN( 150)									if (this123->useMask) {
HXLINE( 150)										here33 = ::hx::IsNotNull( this123->mask );
            									}
            									else {
HXLINE( 150)										here33 = false;
            									}
HXDLIN( 150)									if (here33) {
HXLINE( 150)										 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 150)										::Dynamic this128 = this127->image;
HXDLIN( 150)										int index21;
HXDLIN( 150)										if (this127->useVirtualPos) {
HXLINE( 150)											index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            										}
            										else {
HXLINE( 150)											index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            										}
HXDLIN( 150)										int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 150)										int v4;
HXDLIN( 150)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)											v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXLINE( 150)											v4 = c20;
            										}
HXDLIN( 150)										int maskPixel1 = v4;
HXDLIN( 150)										int this129 = col1;
HXDLIN( 150)										if ((maskPixel1 == 0)) {
HXLINE( 150)											col1 = this129;
            										}
            										else {
HXLINE( 150)											Float m01;
HXDLIN( 150)											int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 150)											if ((this130 == 0)) {
HXLINE( 150)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float m11;
HXDLIN( 150)											int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 150)											if ((this131 == 0)) {
HXLINE( 150)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float m21;
HXDLIN( 150)											int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 150)											if ((this132 == 0)) {
HXLINE( 150)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float m31;
HXDLIN( 150)											int this133 = (maskPixel1 & 255);
HXDLIN( 150)											if ((this133 == 0)) {
HXLINE( 150)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 150)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 150)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 150)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 150)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 150)									if ((col1 != 0)) {
HXLINE( 150)										int x16 = (1 + dx1);
HXDLIN( 150)										int y16 = (1 + dy1);
HXDLIN( 150)										int c21 = col1;
HXDLIN( 150)										bool here34;
HXDLIN( 150)										if ((((c21 >> 24) & 255) < 254)) {
HXLINE( 150)											here34 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here34 = false;
            										}
HXDLIN( 150)										if (here34) {
HXLINE( 150)											int location9;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            											}
HXDLIN( 150)											int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 150)											int this135;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this135 = this134;
            											}
HXDLIN( 150)											Float a111;
HXDLIN( 150)											int this136 = ((this135 >> 24) & 255);
HXDLIN( 150)											if ((this136 == 0)) {
HXLINE( 150)												a111 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r19;
HXDLIN( 150)											int this137 = ((this135 >> 16) & 255);
HXDLIN( 150)											if ((this137 == 0)) {
HXLINE( 150)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g19;
HXDLIN( 150)											int this138 = ((this135 >> 8) & 255);
HXDLIN( 150)											if ((this138 == 0)) {
HXLINE( 150)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b112;
HXDLIN( 150)											int this139 = (this135 & 255);
HXDLIN( 150)											if ((this139 == 0)) {
HXLINE( 150)												b112 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a210;
HXDLIN( 150)											int this140 = ((col1 >> 24) & 255);
HXDLIN( 150)											if ((this140 == 0)) {
HXLINE( 150)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r29;
HXDLIN( 150)											int this141 = ((col1 >> 16) & 255);
HXDLIN( 150)											if ((this141 == 0)) {
HXLINE( 150)												r29 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g29;
HXDLIN( 150)											int this142 = ((col1 >> 8) & 255);
HXDLIN( 150)											if ((this142 == 0)) {
HXLINE( 150)												g29 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b210;
HXDLIN( 150)											int this143 = (col1 & 255);
HXDLIN( 150)											if ((this143 == 0)) {
HXLINE( 150)												b210 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 150)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 150)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 150)											int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 150)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 150)											int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 150)											{
HXLINE( 150)												int here35;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here35 = blended9;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this144 = img1->image;
HXDLIN( 150)											int index22;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            											}
HXDLIN( 150)											int here36;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here36 = c21;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this144,index22,here36);
            										}
            									}
            									else {
HXLINE( 150)										if (forceClear1) {
HXLINE( 150)											::Dynamic this145 = img1->image;
HXDLIN( 150)											int x17 = (1 + dx1);
HXDLIN( 150)											int y17 = (1 + dy1);
HXDLIN( 150)											int index23;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this145,index23,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 150)				{
HXLINE( 150)					int _g68 = 0;
HXDLIN( 150)					int _g69 = this123->width;
HXDLIN( 150)					while((_g68 < _g69)){
HXLINE( 150)						_g68 = (_g68 + 1);
HXDLIN( 150)						int x18 = (_g68 - 1);
HXDLIN( 150)						{
HXLINE( 150)							int _g70 = 0;
HXDLIN( 150)							int _g71 = 1;
HXDLIN( 150)							while((_g70 < _g71)){
HXLINE( 150)								_g70 = (_g70 + 1);
HXDLIN( 150)								int y18 = (_g70 - 1);
HXDLIN( 150)								{
HXLINE( 150)									int x19 = (x18 + 1);
HXDLIN( 150)									int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 150)									::Dynamic this146 = this123->image;
HXDLIN( 150)									int index24;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            									}
HXDLIN( 150)									int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 150)									int color11;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color11 = c22;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c23 = color11;
HXDLIN( 150)										bool here37;
HXDLIN( 150)										if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 150)											here37 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here37 = false;
            										}
HXDLIN( 150)										if (here37) {
HXLINE( 150)											int location10;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            											}
HXDLIN( 150)											int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 150)											int this148;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this148 = this147;
            											}
HXDLIN( 150)											Float a112;
HXDLIN( 150)											int this149 = ((this148 >> 24) & 255);
HXDLIN( 150)											if ((this149 == 0)) {
HXLINE( 150)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r110;
HXDLIN( 150)											int this150 = ((this148 >> 16) & 255);
HXDLIN( 150)											if ((this150 == 0)) {
HXLINE( 150)												r110 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g110;
HXDLIN( 150)											int this151 = ((this148 >> 8) & 255);
HXDLIN( 150)											if ((this151 == 0)) {
HXLINE( 150)												g110 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b113;
HXDLIN( 150)											int this152 = (this148 & 255);
HXDLIN( 150)											if ((this152 == 0)) {
HXLINE( 150)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a211;
HXDLIN( 150)											int this153 = ((color11 >> 24) & 255);
HXDLIN( 150)											if ((this153 == 0)) {
HXLINE( 150)												a211 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r210;
HXDLIN( 150)											int this154 = ((color11 >> 16) & 255);
HXDLIN( 150)											if ((this154 == 0)) {
HXLINE( 150)												r210 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g210;
HXDLIN( 150)											int this155 = ((color11 >> 8) & 255);
HXDLIN( 150)											if ((this155 == 0)) {
HXLINE( 150)												g210 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b211;
HXDLIN( 150)											int this156 = (color11 & 255);
HXDLIN( 150)											if ((this156 == 0)) {
HXLINE( 150)												b211 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 150)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 150)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 150)											int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 150)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 150)											int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 150)											{
HXLINE( 150)												int here38;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here38 = blended10;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this157 = img1->image;
HXDLIN( 150)											int index25;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            											}
HXDLIN( 150)											int here39;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here39 = c23;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this157,index25,here39);
            										}
            									}
            								}
HXDLIN( 150)								{
HXLINE( 150)									int x20 = (x18 + 1);
HXDLIN( 150)									int y20 = ((img1->height - y18) - 1);
HXDLIN( 150)									int y21 = (1 - y18);
HXDLIN( 150)									::Dynamic this158 = this123->image;
HXDLIN( 150)									int index26;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            									}
HXDLIN( 150)									int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 150)									int color12;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color12 = c24;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c25 = color12;
HXDLIN( 150)										bool here40;
HXDLIN( 150)										if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 150)											here40 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here40 = false;
            										}
HXDLIN( 150)										if (here40) {
HXLINE( 150)											int location11;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            											}
HXDLIN( 150)											int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 150)											int this160;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this160 = this159;
            											}
HXDLIN( 150)											Float a113;
HXDLIN( 150)											int this161 = ((this160 >> 24) & 255);
HXDLIN( 150)											if ((this161 == 0)) {
HXLINE( 150)												a113 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r111;
HXDLIN( 150)											int this162 = ((this160 >> 16) & 255);
HXDLIN( 150)											if ((this162 == 0)) {
HXLINE( 150)												r111 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g111;
HXDLIN( 150)											int this163 = ((this160 >> 8) & 255);
HXDLIN( 150)											if ((this163 == 0)) {
HXLINE( 150)												g111 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b114;
HXDLIN( 150)											int this164 = (this160 & 255);
HXDLIN( 150)											if ((this164 == 0)) {
HXLINE( 150)												b114 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a212;
HXDLIN( 150)											int this165 = ((color12 >> 24) & 255);
HXDLIN( 150)											if ((this165 == 0)) {
HXLINE( 150)												a212 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r211;
HXDLIN( 150)											int this166 = ((color12 >> 16) & 255);
HXDLIN( 150)											if ((this166 == 0)) {
HXLINE( 150)												r211 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g211;
HXDLIN( 150)											int this167 = ((color12 >> 8) & 255);
HXDLIN( 150)											if ((this167 == 0)) {
HXLINE( 150)												g211 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b212;
HXDLIN( 150)											int this168 = (color12 & 255);
HXDLIN( 150)											if ((this168 == 0)) {
HXLINE( 150)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 150)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 150)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 150)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 150)											int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 150)											int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 150)											{
HXLINE( 150)												int here41;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here41 = blended11;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this169 = img1->image;
HXDLIN( 150)											int index27;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            											}
HXDLIN( 150)											int here42;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here42 = c25;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this169,index27,here42);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 150)				{
HXLINE( 150)					int _g72 = 0;
HXDLIN( 150)					int _g73 = this123->height;
HXDLIN( 150)					while((_g72 < _g73)){
HXLINE( 150)						_g72 = (_g72 + 1);
HXDLIN( 150)						int y22 = (_g72 - 1);
HXDLIN( 150)						{
HXLINE( 150)							int _g74 = 0;
HXDLIN( 150)							int _g75 = 1;
HXDLIN( 150)							while((_g74 < _g75)){
HXLINE( 150)								_g74 = (_g74 + 1);
HXDLIN( 150)								int x21 = (_g74 - 1);
HXDLIN( 150)								{
HXLINE( 150)									int y23 = (y22 + 1);
HXDLIN( 150)									int x22 = (((this123->width - 1) - 1) + x21);
HXDLIN( 150)									::Dynamic this170 = this123->image;
HXDLIN( 150)									int index28;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            									}
HXDLIN( 150)									int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 150)									int color13;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color13 = c26;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c27 = color13;
HXDLIN( 150)										bool here43;
HXDLIN( 150)										if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 150)											here43 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here43 = false;
            										}
HXDLIN( 150)										if (here43) {
HXLINE( 150)											int location12;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            											}
HXDLIN( 150)											int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 150)											int this172;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this172 = this171;
            											}
HXDLIN( 150)											Float a114;
HXDLIN( 150)											int this173 = ((this172 >> 24) & 255);
HXDLIN( 150)											if ((this173 == 0)) {
HXLINE( 150)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r112;
HXDLIN( 150)											int this174 = ((this172 >> 16) & 255);
HXDLIN( 150)											if ((this174 == 0)) {
HXLINE( 150)												r112 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g112;
HXDLIN( 150)											int this175 = ((this172 >> 8) & 255);
HXDLIN( 150)											if ((this175 == 0)) {
HXLINE( 150)												g112 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b115;
HXDLIN( 150)											int this176 = (this172 & 255);
HXDLIN( 150)											if ((this176 == 0)) {
HXLINE( 150)												b115 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a213;
HXDLIN( 150)											int this177 = ((color13 >> 24) & 255);
HXDLIN( 150)											if ((this177 == 0)) {
HXLINE( 150)												a213 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r212;
HXDLIN( 150)											int this178 = ((color13 >> 16) & 255);
HXDLIN( 150)											if ((this178 == 0)) {
HXLINE( 150)												r212 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g212;
HXDLIN( 150)											int this179 = ((color13 >> 8) & 255);
HXDLIN( 150)											if ((this179 == 0)) {
HXLINE( 150)												g212 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b213;
HXDLIN( 150)											int this180 = (color13 & 255);
HXDLIN( 150)											if ((this180 == 0)) {
HXLINE( 150)												b213 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 150)											int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 150)											int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 150)											int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 150)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 150)											int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 150)											{
HXLINE( 150)												int here44;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here44 = blended12;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this181 = img1->image;
HXDLIN( 150)											int index29;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            											}
HXDLIN( 150)											int here45;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here45 = c27;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this181,index29,here45);
            										}
            									}
            								}
HXDLIN( 150)								{
HXLINE( 150)									int x23 = ((img1->width - x21) - 1);
HXDLIN( 150)									int y24 = (y22 + 1);
HXDLIN( 150)									int x24 = (1 - x21);
HXDLIN( 150)									::Dynamic this182 = this123->image;
HXDLIN( 150)									int index30;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            									}
HXDLIN( 150)									int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 150)									int color14;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color14 = c28;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c29 = color14;
HXDLIN( 150)										bool here46;
HXDLIN( 150)										if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 150)											here46 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here46 = false;
            										}
HXDLIN( 150)										if (here46) {
HXLINE( 150)											int location13;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            											}
HXDLIN( 150)											int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 150)											int this184;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this184 = this183;
            											}
HXDLIN( 150)											Float a115;
HXDLIN( 150)											int this185 = ((this184 >> 24) & 255);
HXDLIN( 150)											if ((this185 == 0)) {
HXLINE( 150)												a115 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r113;
HXDLIN( 150)											int this186 = ((this184 >> 16) & 255);
HXDLIN( 150)											if ((this186 == 0)) {
HXLINE( 150)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g113;
HXDLIN( 150)											int this187 = ((this184 >> 8) & 255);
HXDLIN( 150)											if ((this187 == 0)) {
HXLINE( 150)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b116;
HXDLIN( 150)											int this188 = (this184 & 255);
HXDLIN( 150)											if ((this188 == 0)) {
HXLINE( 150)												b116 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a214;
HXDLIN( 150)											int this189 = ((color14 >> 24) & 255);
HXDLIN( 150)											if ((this189 == 0)) {
HXLINE( 150)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r213;
HXDLIN( 150)											int this190 = ((color14 >> 16) & 255);
HXDLIN( 150)											if ((this190 == 0)) {
HXLINE( 150)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g213;
HXDLIN( 150)											int this191 = ((color14 >> 8) & 255);
HXDLIN( 150)											if ((this191 == 0)) {
HXLINE( 150)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b214;
HXDLIN( 150)											int this192 = (color14 & 255);
HXDLIN( 150)											if ((this192 == 0)) {
HXLINE( 150)												b214 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 150)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 150)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 150)											int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 150)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 150)											int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 150)											{
HXLINE( 150)												int here47;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here47 = blended13;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this193 = img1->image;
HXDLIN( 150)											int index31;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            											}
HXDLIN( 150)											int here48;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here48 = c29;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this193,index31,here48);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 150)				{
HXLINE( 150)					int _g76 = 0;
HXDLIN( 150)					int _g77 = 1;
HXDLIN( 150)					while((_g76 < _g77)){
HXLINE( 150)						_g76 = (_g76 + 1);
HXDLIN( 150)						int x25 = (_g76 - 1);
HXDLIN( 150)						{
HXLINE( 150)							int _g78 = 0;
HXDLIN( 150)							int _g79 = 1;
HXDLIN( 150)							while((_g78 < _g79)){
HXLINE( 150)								_g78 = (_g78 + 1);
HXDLIN( 150)								int y25 = (_g78 - 1);
HXDLIN( 150)								{
HXLINE( 150)									int x26 = (((this123->width - 1) - 1) + x25);
HXDLIN( 150)									int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 150)									::Dynamic this194 = this123->image;
HXDLIN( 150)									int index32;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            									}
HXDLIN( 150)									int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 150)									int color15;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color15 = c30;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c31 = color15;
HXDLIN( 150)										bool here49;
HXDLIN( 150)										if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 150)											here49 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here49 = false;
            										}
HXDLIN( 150)										if (here49) {
HXLINE( 150)											int location14;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            											}
HXDLIN( 150)											int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 150)											int this196;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this196 = this195;
            											}
HXDLIN( 150)											Float a116;
HXDLIN( 150)											int this197 = ((this196 >> 24) & 255);
HXDLIN( 150)											if ((this197 == 0)) {
HXLINE( 150)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r114;
HXDLIN( 150)											int this198 = ((this196 >> 16) & 255);
HXDLIN( 150)											if ((this198 == 0)) {
HXLINE( 150)												r114 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g114;
HXDLIN( 150)											int this199 = ((this196 >> 8) & 255);
HXDLIN( 150)											if ((this199 == 0)) {
HXLINE( 150)												g114 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b117;
HXDLIN( 150)											int this200 = (this196 & 255);
HXDLIN( 150)											if ((this200 == 0)) {
HXLINE( 150)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a215;
HXDLIN( 150)											int this201 = ((color15 >> 24) & 255);
HXDLIN( 150)											if ((this201 == 0)) {
HXLINE( 150)												a215 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r214;
HXDLIN( 150)											int this202 = ((color15 >> 16) & 255);
HXDLIN( 150)											if ((this202 == 0)) {
HXLINE( 150)												r214 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g214;
HXDLIN( 150)											int this203 = ((color15 >> 8) & 255);
HXDLIN( 150)											if ((this203 == 0)) {
HXLINE( 150)												g214 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b215;
HXDLIN( 150)											int this204 = (color15 & 255);
HXDLIN( 150)											if ((this204 == 0)) {
HXLINE( 150)												b215 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 150)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 150)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 150)											int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 150)											int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 150)											int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 150)											{
HXLINE( 150)												int here50;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here50 = blended14;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this205 = img1->image;
HXDLIN( 150)											int index33;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            											}
HXDLIN( 150)											int here51;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here51 = c31;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this205,index33,here51);
            										}
            									}
            								}
HXDLIN( 150)								{
HXLINE( 150)									int x27 = ((x25 + 1) + this123->width);
HXDLIN( 150)									int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 150)									::Dynamic this206 = this123->image;
HXDLIN( 150)									int index34;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            									}
HXDLIN( 150)									int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 150)									int color16;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color16 = c32;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c33 = color16;
HXDLIN( 150)										bool here52;
HXDLIN( 150)										if ((((c33 >> 24) & 255) < 254)) {
HXLINE( 150)											here52 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here52 = false;
            										}
HXDLIN( 150)										if (here52) {
HXLINE( 150)											int location15;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            											}
HXDLIN( 150)											int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 150)											int this208;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this208 = this207;
            											}
HXDLIN( 150)											Float a117;
HXDLIN( 150)											int this209 = ((this208 >> 24) & 255);
HXDLIN( 150)											if ((this209 == 0)) {
HXLINE( 150)												a117 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r115;
HXDLIN( 150)											int this210 = ((this208 >> 16) & 255);
HXDLIN( 150)											if ((this210 == 0)) {
HXLINE( 150)												r115 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g115;
HXDLIN( 150)											int this211 = ((this208 >> 8) & 255);
HXDLIN( 150)											if ((this211 == 0)) {
HXLINE( 150)												g115 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b118;
HXDLIN( 150)											int this212 = (this208 & 255);
HXDLIN( 150)											if ((this212 == 0)) {
HXLINE( 150)												b118 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a216;
HXDLIN( 150)											int this213 = ((color16 >> 24) & 255);
HXDLIN( 150)											if ((this213 == 0)) {
HXLINE( 150)												a216 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r215;
HXDLIN( 150)											int this214 = ((color16 >> 16) & 255);
HXDLIN( 150)											if ((this214 == 0)) {
HXLINE( 150)												r215 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g215;
HXDLIN( 150)											int this215 = ((color16 >> 8) & 255);
HXDLIN( 150)											if ((this215 == 0)) {
HXLINE( 150)												g215 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b216;
HXDLIN( 150)											int this216 = (color16 & 255);
HXDLIN( 150)											if ((this216 == 0)) {
HXLINE( 150)												b216 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 150)											int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 150)											int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 150)											int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 150)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 150)											int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 150)											{
HXLINE( 150)												int here53;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here53 = blended15;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this217 = img1->image;
HXDLIN( 150)											int index35;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            											}
HXDLIN( 150)											int here54;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here54 = c33;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this217,index35,here54);
            										}
            									}
            								}
HXDLIN( 150)								{
HXLINE( 150)									int x28 = ((x25 + 1) + this123->width);
HXDLIN( 150)									int y28 = ((y25 + 1) + this123->height);
HXDLIN( 150)									::Dynamic this218 = this123->image;
HXDLIN( 150)									int index36;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            									}
HXDLIN( 150)									int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 150)									int color17;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color17 = c34;
            									}
HXDLIN( 150)									int color18 = color17;
HXDLIN( 150)									{
HXLINE( 150)										int c35 = color18;
HXDLIN( 150)										bool here55;
HXDLIN( 150)										if ((((c35 >> 24) & 255) < 254)) {
HXLINE( 150)											here55 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here55 = false;
            										}
HXDLIN( 150)										if (here55) {
HXLINE( 150)											int location16;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            											}
HXDLIN( 150)											int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 150)											int this220;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this220 = this219;
            											}
HXDLIN( 150)											Float a118;
HXDLIN( 150)											int this221 = ((this220 >> 24) & 255);
HXDLIN( 150)											if ((this221 == 0)) {
HXLINE( 150)												a118 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r116;
HXDLIN( 150)											int this222 = ((this220 >> 16) & 255);
HXDLIN( 150)											if ((this222 == 0)) {
HXLINE( 150)												r116 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g116;
HXDLIN( 150)											int this223 = ((this220 >> 8) & 255);
HXDLIN( 150)											if ((this223 == 0)) {
HXLINE( 150)												g116 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b119;
HXDLIN( 150)											int this224 = (this220 & 255);
HXDLIN( 150)											if ((this224 == 0)) {
HXLINE( 150)												b119 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a217;
HXDLIN( 150)											int this225 = ((color18 >> 24) & 255);
HXDLIN( 150)											if ((this225 == 0)) {
HXLINE( 150)												a217 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r216;
HXDLIN( 150)											int this226 = ((color18 >> 16) & 255);
HXDLIN( 150)											if ((this226 == 0)) {
HXLINE( 150)												r216 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g216;
HXDLIN( 150)											int this227 = ((color18 >> 8) & 255);
HXDLIN( 150)											if ((this227 == 0)) {
HXLINE( 150)												g216 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b217;
HXDLIN( 150)											int this228 = (color18 & 255);
HXDLIN( 150)											if ((this228 == 0)) {
HXLINE( 150)												b217 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 150)											int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 150)											int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 150)											int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 150)											int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 150)											int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 150)											{
HXLINE( 150)												int here56;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here56 = blended16;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this229 = img1->image;
HXDLIN( 150)											int index37;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            											}
HXDLIN( 150)											int here57;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here57 = c35;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this229,index37,here57);
            										}
            									}
            								}
HXDLIN( 150)								{
HXLINE( 150)									int y29 = ((y25 + 1) + this123->width);
HXDLIN( 150)									int x29 = (((this123->width - 1) - 1) + x25);
HXDLIN( 150)									::Dynamic this230 = this123->image;
HXDLIN( 150)									int index38;
HXDLIN( 150)									if (this123->useVirtualPos) {
HXLINE( 150)										index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            									}
            									else {
HXLINE( 150)										index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            									}
HXDLIN( 150)									int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 150)									int color19;
HXDLIN( 150)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)										color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            									}
            									else {
HXLINE( 150)										color19 = c36;
            									}
HXDLIN( 150)									{
HXLINE( 150)										int c37 = color19;
HXDLIN( 150)										bool here58;
HXDLIN( 150)										if ((((c37 >> 24) & 255) < 254)) {
HXLINE( 150)											here58 = img1->transparent;
            										}
            										else {
HXLINE( 150)											here58 = false;
            										}
HXDLIN( 150)										if (here58) {
HXLINE( 150)											int location17;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            											}
HXDLIN( 150)											int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 150)											int this232;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												this232 = this231;
            											}
HXDLIN( 150)											Float a119;
HXDLIN( 150)											int this233 = ((this232 >> 24) & 255);
HXDLIN( 150)											if ((this233 == 0)) {
HXLINE( 150)												a119 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r117;
HXDLIN( 150)											int this234 = ((this232 >> 16) & 255);
HXDLIN( 150)											if ((this234 == 0)) {
HXLINE( 150)												r117 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g117;
HXDLIN( 150)											int this235 = ((this232 >> 8) & 255);
HXDLIN( 150)											if ((this235 == 0)) {
HXLINE( 150)												g117 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b120;
HXDLIN( 150)											int this236 = (this232 & 255);
HXDLIN( 150)											if ((this236 == 0)) {
HXLINE( 150)												b120 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a218;
HXDLIN( 150)											int this237 = ((color19 >> 24) & 255);
HXDLIN( 150)											if ((this237 == 0)) {
HXLINE( 150)												a218 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float r217;
HXDLIN( 150)											int this238 = ((color19 >> 16) & 255);
HXDLIN( 150)											if ((this238 == 0)) {
HXLINE( 150)												r217 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float g217;
HXDLIN( 150)											int this239 = ((color19 >> 8) & 255);
HXDLIN( 150)											if ((this239 == 0)) {
HXLINE( 150)												g217 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float b218;
HXDLIN( 150)											int this240 = (color19 & 255);
HXDLIN( 150)											if ((this240 == 0)) {
HXLINE( 150)												b218 = ((Float)0.);
            											}
            											else {
HXLINE( 150)												b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            											}
HXDLIN( 150)											Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 150)											int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 150)											int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 150)											int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 150)											int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 150)											int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 150)											{
HXLINE( 150)												int here59;
HXDLIN( 150)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)													here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            												}
            												else {
HXLINE( 150)													here59 = blended17;
            												}
HXDLIN( 150)												::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            											}
            										}
            										else {
HXLINE( 150)											::Dynamic this241 = img1->image;
HXDLIN( 150)											int index39;
HXDLIN( 150)											if (img1->useVirtualPos) {
HXLINE( 150)												index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 150)												index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            											}
HXDLIN( 150)											int here60;
HXDLIN( 150)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 150)												here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            											}
            											else {
HXLINE( 150)												here60 = c37;
            											}
HXDLIN( 150)											::iterMagic::Iimg_obj::set(this241,index39,here60);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 150)				here = img1;
            			}
            			break;
            		}
HXLINE( 153)		{
HXLINE( 153)			int _g80 = 1;
HXDLIN( 153)			int _g81 = (this1->height - 2);
HXDLIN( 153)			while((_g80 < _g81)){
HXLINE( 153)				_g80 = (_g80 + 1);
HXDLIN( 153)				int y30 = (_g80 - 1);
HXLINE( 155)				{
HXLINE( 155)					int _g82 = 1;
HXDLIN( 155)					int _g83 = (this1->width - 2);
HXDLIN( 155)					while((_g82 < _g83)){
HXLINE( 155)						_g82 = (_g82 + 1);
HXDLIN( 155)						int x30 = (_g82 - 1);
HXLINE( 156)						if ((x30 == 1)) {
HXLINE( 158)							int x31 = (x30 - 1);
HXDLIN( 158)							int y31 = (y30 - 1);
HXDLIN( 158)							::Dynamic this242 = here->image;
HXDLIN( 158)							int index40;
HXDLIN( 158)							if (here->useVirtualPos) {
HXLINE( 158)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 158)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 158)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 158)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXLINE( 158)								a0 = c38;
            							}
HXLINE( 159)							int y32 = (y30 - 1);
HXDLIN( 159)							::Dynamic this243 = here->image;
HXDLIN( 159)							int index41;
HXDLIN( 159)							if (here->useVirtualPos) {
HXLINE( 159)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 159)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x30)) ));
            							}
HXDLIN( 159)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 159)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 159)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXLINE( 159)								b0 = c39;
            							}
HXLINE( 160)							int x32 = (x30 + 1);
HXDLIN( 160)							int y33 = (y30 - 1);
HXDLIN( 160)							::Dynamic this244 = here->image;
HXDLIN( 160)							int index42;
HXDLIN( 160)							if (here->useVirtualPos) {
HXLINE( 160)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXLINE( 160)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x32)) ));
            							}
HXDLIN( 160)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 160)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 160)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXLINE( 160)								c0 = c40;
            							}
HXLINE( 162)							int x33 = (x30 - 1);
HXDLIN( 162)							::Dynamic this245 = here->image;
HXDLIN( 162)							int index43;
HXDLIN( 162)							if (here->useVirtualPos) {
HXLINE( 162)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXLINE( 162)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x33)) ));
            							}
HXDLIN( 162)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 162)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXLINE( 162)								d0 = c41;
            							}
HXLINE( 163)							::Dynamic this246 = here->image;
HXDLIN( 163)							int index44;
HXDLIN( 163)							if (here->useVirtualPos) {
HXLINE( 163)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 163)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 163)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 163)							int e01;
HXDLIN( 163)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXLINE( 163)								e01 = c42;
            							}
HXDLIN( 163)							e0 = e01;
HXLINE( 164)							int x34 = (x30 + 1);
HXDLIN( 164)							::Dynamic this247 = here->image;
HXDLIN( 164)							int index45;
HXDLIN( 164)							if (here->useVirtualPos) {
HXLINE( 164)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXLINE( 164)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 164)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 164)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXLINE( 164)								f0 = c43;
            							}
HXLINE( 166)							int x35 = (x30 - 1);
HXDLIN( 166)							int y34 = (y30 + 1);
HXDLIN( 166)							::Dynamic this248 = here->image;
HXDLIN( 166)							int index46;
HXDLIN( 166)							if (here->useVirtualPos) {
HXLINE( 166)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXLINE( 166)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x35)) ));
            							}
HXDLIN( 166)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 166)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXLINE( 166)								g0 = c44;
            							}
HXLINE( 167)							int y35 = (y30 + 1);
HXDLIN( 167)							::Dynamic this249 = here->image;
HXDLIN( 167)							int index47;
HXDLIN( 167)							if (here->useVirtualPos) {
HXLINE( 167)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 167)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x30)) ));
            							}
HXDLIN( 167)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 167)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXLINE( 167)								h0 = c45;
            							}
HXLINE( 168)							int x36 = (x30 + 1);
HXDLIN( 168)							int y36 = (y30 + 1);
HXDLIN( 168)							::Dynamic this250 = here->image;
HXDLIN( 168)							int index48;
HXDLIN( 168)							if (here->useVirtualPos) {
HXLINE( 168)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXLINE( 168)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x36)) ));
            							}
HXDLIN( 168)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 168)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXLINE( 168)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 173)							int x37 = (x30 + 1);
HXDLIN( 173)							int y37 = (y30 - 1);
HXDLIN( 173)							::Dynamic this251 = here->image;
HXDLIN( 173)							int index49;
HXDLIN( 173)							if (here->useVirtualPos) {
HXLINE( 173)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXLINE( 173)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x37)) ));
            							}
HXDLIN( 173)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 173)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXLINE( 173)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 176)							int x38 = (x30 + 1);
HXDLIN( 176)							::Dynamic this252 = here->image;
HXDLIN( 176)							int index50;
HXDLIN( 176)							if (here->useVirtualPos) {
HXLINE( 176)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXLINE( 176)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x38)) ));
            							}
HXDLIN( 176)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 176)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 176)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXLINE( 176)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 179)							int x39 = (x30 + 1);
HXDLIN( 179)							int y38 = (y30 + 1);
HXDLIN( 179)							::Dynamic this253 = here->image;
HXDLIN( 179)							int index51;
HXDLIN( 179)							if (here->useVirtualPos) {
HXLINE( 179)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXLINE( 179)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x39)) ));
            							}
HXDLIN( 179)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 179)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 179)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXLINE( 179)								i0 = c49;
            							}
            						}
HXLINE( 181)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 183)							bool _hx_tmp2;
HXDLIN( 183)							if ((m33->a != ((Float)0.))) {
HXLINE( 183)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXLINE( 183)								_hx_tmp2 = false;
            							}
HXDLIN( 183)							if (_hx_tmp2) {
HXLINE( 183)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->a));
            							}
HXLINE( 184)							bool _hx_tmp3;
HXDLIN( 184)							if ((m33->b != ((Float)0.))) {
HXLINE( 184)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXLINE( 184)								_hx_tmp3 = false;
            							}
HXDLIN( 184)							if (_hx_tmp3) {
HXLINE( 184)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->b));
            							}
HXLINE( 185)							bool _hx_tmp4;
HXDLIN( 185)							if ((m33->c != ((Float)0.))) {
HXLINE( 185)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXLINE( 185)								_hx_tmp4 = false;
            							}
HXDLIN( 185)							if (_hx_tmp4) {
HXLINE( 185)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->c));
            							}
HXLINE( 186)							bool _hx_tmp5;
HXDLIN( 186)							if ((m33->d != ((Float)0.))) {
HXLINE( 186)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXLINE( 186)								_hx_tmp5 = false;
            							}
HXDLIN( 186)							if (_hx_tmp5) {
HXLINE( 186)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->d));
            							}
HXLINE( 187)							bool _hx_tmp6;
HXDLIN( 187)							if ((m33->e != ((Float)0.))) {
HXLINE( 187)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXLINE( 187)								_hx_tmp6 = false;
            							}
HXDLIN( 187)							if (_hx_tmp6) {
HXLINE( 187)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->e));
            							}
HXLINE( 188)							bool _hx_tmp7;
HXDLIN( 188)							if ((m33->f != ((Float)0.))) {
HXLINE( 188)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXLINE( 188)								_hx_tmp7 = false;
            							}
HXDLIN( 188)							if (_hx_tmp7) {
HXLINE( 188)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->f));
            							}
HXLINE( 189)							bool _hx_tmp8;
HXDLIN( 189)							if ((m33->g != ((Float)0.))) {
HXLINE( 189)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXLINE( 189)								_hx_tmp8 = false;
            							}
HXDLIN( 189)							if (_hx_tmp8) {
HXLINE( 189)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->g));
            							}
HXLINE( 190)							bool _hx_tmp9;
HXDLIN( 190)							if ((m33->h != ((Float)0.))) {
HXLINE( 190)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXLINE( 190)								_hx_tmp9 = false;
            							}
HXDLIN( 190)							if (_hx_tmp9) {
HXLINE( 190)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->h));
            							}
HXLINE( 191)							bool _hx_tmp10;
HXDLIN( 191)							if ((m33->i != ((Float)0.))) {
HXLINE( 191)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXLINE( 191)								_hx_tmp10 = false;
            							}
HXDLIN( 191)							if (_hx_tmp10) {
HXLINE( 191)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33->i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 195)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 197)							bool _hx_tmp11;
HXDLIN( 197)							if ((m33->a != ((Float)0.))) {
HXLINE( 197)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXLINE( 197)								_hx_tmp11 = false;
            							}
HXDLIN( 197)							if (_hx_tmp11) {
HXLINE( 197)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->a));
            							}
HXLINE( 198)							bool _hx_tmp12;
HXDLIN( 198)							if ((m33->b != ((Float)0.))) {
HXLINE( 198)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXLINE( 198)								_hx_tmp12 = false;
            							}
HXDLIN( 198)							if (_hx_tmp12) {
HXLINE( 198)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->b));
            							}
HXLINE( 199)							bool _hx_tmp13;
HXDLIN( 199)							if ((m33->c != ((Float)0.))) {
HXLINE( 199)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXLINE( 199)								_hx_tmp13 = false;
            							}
HXDLIN( 199)							if (_hx_tmp13) {
HXLINE( 199)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->c));
            							}
HXLINE( 200)							bool _hx_tmp14;
HXDLIN( 200)							if ((m33->d != ((Float)0.))) {
HXLINE( 200)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXLINE( 200)								_hx_tmp14 = false;
            							}
HXDLIN( 200)							if (_hx_tmp14) {
HXLINE( 200)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->d));
            							}
HXLINE( 201)							bool _hx_tmp15;
HXDLIN( 201)							if ((m33->e != ((Float)0.))) {
HXLINE( 201)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXLINE( 201)								_hx_tmp15 = false;
            							}
HXDLIN( 201)							if (_hx_tmp15) {
HXLINE( 201)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->e));
            							}
HXLINE( 202)							bool _hx_tmp16;
HXDLIN( 202)							if ((m33->f != ((Float)0.))) {
HXLINE( 202)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXLINE( 202)								_hx_tmp16 = false;
            							}
HXDLIN( 202)							if (_hx_tmp16) {
HXLINE( 202)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->f));
            							}
HXLINE( 203)							bool _hx_tmp17;
HXDLIN( 203)							if ((m33->g != ((Float)0.))) {
HXLINE( 203)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXLINE( 203)								_hx_tmp17 = false;
            							}
HXDLIN( 203)							if (_hx_tmp17) {
HXLINE( 203)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->g));
            							}
HXLINE( 204)							bool _hx_tmp18;
HXDLIN( 204)							if ((m33->h != ((Float)0.))) {
HXLINE( 204)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXLINE( 204)								_hx_tmp18 = false;
            							}
HXDLIN( 204)							if (_hx_tmp18) {
HXLINE( 204)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->h));
            							}
HXLINE( 205)							bool _hx_tmp19;
HXDLIN( 205)							if ((m33->i != ((Float)0.))) {
HXLINE( 205)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXLINE( 205)								_hx_tmp19 = false;
            							}
HXDLIN( 205)							if (_hx_tmp19) {
HXLINE( 205)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33->i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 209)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 211)							bool _hx_tmp20;
HXDLIN( 211)							if ((m33->a != ((Float)0.))) {
HXLINE( 211)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXLINE( 211)								_hx_tmp20 = false;
            							}
HXDLIN( 211)							if (_hx_tmp20) {
HXLINE( 211)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33->a));
            							}
HXLINE( 212)							bool _hx_tmp21;
HXDLIN( 212)							if ((m33->b != ((Float)0.))) {
HXLINE( 212)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXLINE( 212)								_hx_tmp21 = false;
            							}
HXDLIN( 212)							if (_hx_tmp21) {
HXLINE( 212)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33->b));
            							}
HXLINE( 213)							bool _hx_tmp22;
HXDLIN( 213)							if ((m33->c != ((Float)0.))) {
HXLINE( 213)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXLINE( 213)								_hx_tmp22 = false;
            							}
HXDLIN( 213)							if (_hx_tmp22) {
HXLINE( 213)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33->c));
            							}
HXLINE( 214)							bool _hx_tmp23;
HXDLIN( 214)							if ((m33->d != ((Float)0.))) {
HXLINE( 214)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXLINE( 214)								_hx_tmp23 = false;
            							}
HXDLIN( 214)							if (_hx_tmp23) {
HXLINE( 214)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33->d));
            							}
HXLINE( 215)							bool _hx_tmp24;
HXDLIN( 215)							if ((m33->e != ((Float)0.))) {
HXLINE( 215)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXLINE( 215)								_hx_tmp24 = false;
            							}
HXDLIN( 215)							if (_hx_tmp24) {
HXLINE( 215)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33->e));
            							}
HXLINE( 216)							bool _hx_tmp25;
HXDLIN( 216)							if ((m33->f != ((Float)0.))) {
HXLINE( 216)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXLINE( 216)								_hx_tmp25 = false;
            							}
HXDLIN( 216)							if (_hx_tmp25) {
HXLINE( 216)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33->f));
            							}
HXLINE( 217)							bool _hx_tmp26;
HXDLIN( 217)							if ((m33->g != ((Float)0.))) {
HXLINE( 217)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXLINE( 217)								_hx_tmp26 = false;
            							}
HXDLIN( 217)							if (_hx_tmp26) {
HXLINE( 217)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33->g));
            							}
HXLINE( 218)							bool _hx_tmp27;
HXDLIN( 218)							if ((m33->h != ((Float)0.))) {
HXLINE( 218)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXLINE( 218)								_hx_tmp27 = false;
            							}
HXDLIN( 218)							if (_hx_tmp27) {
HXLINE( 218)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33->h));
            							}
HXLINE( 219)							bool _hx_tmp28;
HXDLIN( 219)							if ((m33->i != ((Float)0.))) {
HXLINE( 219)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXLINE( 219)								_hx_tmp28 = false;
            							}
HXDLIN( 219)							if (_hx_tmp28) {
HXLINE( 219)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33->i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 223)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 225)							bool _hx_tmp29;
HXDLIN( 225)							if ((m33->a != ((Float)0.))) {
HXLINE( 225)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXLINE( 225)								_hx_tmp29 = false;
            							}
HXDLIN( 225)							if (_hx_tmp29) {
HXLINE( 225)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->a));
            							}
HXLINE( 226)							bool _hx_tmp30;
HXDLIN( 226)							if ((m33->b != ((Float)0.))) {
HXLINE( 226)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXLINE( 226)								_hx_tmp30 = false;
            							}
HXDLIN( 226)							if (_hx_tmp30) {
HXLINE( 226)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->b));
            							}
HXLINE( 227)							bool _hx_tmp31;
HXDLIN( 227)							if ((m33->c != ((Float)0.))) {
HXLINE( 227)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXLINE( 227)								_hx_tmp31 = false;
            							}
HXDLIN( 227)							if (_hx_tmp31) {
HXLINE( 227)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->c));
            							}
HXLINE( 228)							bool _hx_tmp32;
HXDLIN( 228)							if ((m33->d != ((Float)0.))) {
HXLINE( 228)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXLINE( 228)								_hx_tmp32 = false;
            							}
HXDLIN( 228)							if (_hx_tmp32) {
HXLINE( 228)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->d));
            							}
HXLINE( 229)							bool _hx_tmp33;
HXDLIN( 229)							if ((m33->e != ((Float)0.))) {
HXLINE( 229)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXLINE( 229)								_hx_tmp33 = false;
            							}
HXDLIN( 229)							if (_hx_tmp33) {
HXLINE( 229)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->e));
            							}
HXLINE( 230)							bool _hx_tmp34;
HXDLIN( 230)							if ((m33->f != ((Float)0.))) {
HXLINE( 230)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXLINE( 230)								_hx_tmp34 = false;
            							}
HXDLIN( 230)							if (_hx_tmp34) {
HXLINE( 230)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->f));
            							}
HXLINE( 231)							bool _hx_tmp35;
HXDLIN( 231)							if ((m33->g != ((Float)0.))) {
HXLINE( 231)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXLINE( 231)								_hx_tmp35 = false;
            							}
HXDLIN( 231)							if (_hx_tmp35) {
HXLINE( 231)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->g));
            							}
HXLINE( 232)							bool _hx_tmp36;
HXDLIN( 232)							if ((m33->h != ((Float)0.))) {
HXLINE( 232)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXLINE( 232)								_hx_tmp36 = false;
            							}
HXDLIN( 232)							if (_hx_tmp36) {
HXLINE( 232)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->h));
            							}
HXLINE( 233)							bool _hx_tmp37;
HXDLIN( 233)							if ((m33->i != ((Float)0.))) {
HXLINE( 233)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXLINE( 233)								_hx_tmp37 = false;
            							}
HXDLIN( 233)							if (_hx_tmp37) {
HXLINE( 233)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33->i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 237)						bool _hx_tmp38;
HXDLIN( 237)						if ((borderMode != 0)) {
HXLINE( 237)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXLINE( 237)							_hx_tmp38 = true;
            						}
HXDLIN( 237)						if (_hx_tmp38) {
HXLINE( 238)							int x40 = (x30 - 1);
HXDLIN( 238)							int y39 = (y30 - 1);
HXDLIN( 238)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 238)							{
HXLINE( 238)								int c50 = color20;
HXDLIN( 238)								bool _hx_tmp39;
HXDLIN( 238)								if ((((c50 >> 24) & 255) < 254)) {
HXLINE( 238)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXLINE( 238)									_hx_tmp39 = false;
            								}
HXDLIN( 238)								if (_hx_tmp39) {
HXLINE( 238)									int location18;
HXDLIN( 238)									if (out->useVirtualPos) {
HXLINE( 238)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXLINE( 238)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 238)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 238)									int this255;
HXDLIN( 238)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXLINE( 238)										this255 = this254;
            									}
HXDLIN( 238)									Float a120;
HXDLIN( 238)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 238)									if ((this256 == 0)) {
HXLINE( 238)										a120 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float r118;
HXDLIN( 238)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 238)									if ((this257 == 0)) {
HXLINE( 238)										r118 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float g118;
HXDLIN( 238)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 238)									if ((this258 == 0)) {
HXLINE( 238)										g118 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float b121;
HXDLIN( 238)									int this259 = (this255 & 255);
HXDLIN( 238)									if ((this259 == 0)) {
HXLINE( 238)										b121 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float a219;
HXDLIN( 238)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 238)									if ((this260 == 0)) {
HXLINE( 238)										a219 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float r218;
HXDLIN( 238)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 238)									if ((this261 == 0)) {
HXLINE( 238)										r218 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float g218;
HXDLIN( 238)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 238)									if ((this262 == 0)) {
HXLINE( 238)										g218 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float b219;
HXDLIN( 238)									int this263 = (color20 & 255);
HXDLIN( 238)									if ((this263 == 0)) {
HXLINE( 238)										b219 = ((Float)0.);
            									}
            									else {
HXLINE( 238)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 238)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 238)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 238)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 238)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 238)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 238)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 238)									{
HXLINE( 238)										int _hx_tmp40;
HXDLIN( 238)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXLINE( 238)											_hx_tmp40 = blended18;
            										}
HXDLIN( 238)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXLINE( 238)									::Dynamic this264 = out->image;
HXDLIN( 238)									int index52;
HXDLIN( 238)									if (out->useVirtualPos) {
HXLINE( 238)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXLINE( 238)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 238)									int _hx_tmp41;
HXDLIN( 238)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXLINE( 238)										_hx_tmp41 = c50;
            									}
HXDLIN( 238)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXLINE( 241)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 241)							{
HXLINE( 241)								int c51 = color21;
HXDLIN( 241)								bool _hx_tmp42;
HXDLIN( 241)								if ((((c51 >> 24) & 255) < 254)) {
HXLINE( 241)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXLINE( 241)									_hx_tmp42 = false;
            								}
HXDLIN( 241)								if (_hx_tmp42) {
HXLINE( 241)									int location19;
HXDLIN( 241)									if (out->useVirtualPos) {
HXLINE( 241)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXLINE( 241)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 241)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 241)									int this266;
HXDLIN( 241)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 241)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXLINE( 241)										this266 = this265;
            									}
HXDLIN( 241)									Float a121;
HXDLIN( 241)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 241)									if ((this267 == 0)) {
HXLINE( 241)										a121 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float r119;
HXDLIN( 241)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 241)									if ((this268 == 0)) {
HXLINE( 241)										r119 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float g119;
HXDLIN( 241)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 241)									if ((this269 == 0)) {
HXLINE( 241)										g119 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float b122;
HXDLIN( 241)									int this270 = (this266 & 255);
HXDLIN( 241)									if ((this270 == 0)) {
HXLINE( 241)										b122 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float a220;
HXDLIN( 241)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 241)									if ((this271 == 0)) {
HXLINE( 241)										a220 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float r219;
HXDLIN( 241)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 241)									if ((this272 == 0)) {
HXLINE( 241)										r219 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float g219;
HXDLIN( 241)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 241)									if ((this273 == 0)) {
HXLINE( 241)										g219 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float b220;
HXDLIN( 241)									int this274 = (color21 & 255);
HXDLIN( 241)									if ((this274 == 0)) {
HXLINE( 241)										b220 = ((Float)0.);
            									}
            									else {
HXLINE( 241)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 241)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 241)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 241)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 241)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 241)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 241)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 241)									{
HXLINE( 241)										int _hx_tmp43;
HXDLIN( 241)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 241)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXLINE( 241)											_hx_tmp43 = blended19;
            										}
HXDLIN( 241)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXLINE( 241)									::Dynamic this275 = out->image;
HXDLIN( 241)									int index53;
HXDLIN( 241)									if (out->useVirtualPos) {
HXLINE( 241)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXLINE( 241)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 241)									int _hx_tmp44;
HXDLIN( 241)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 241)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXLINE( 241)										_hx_tmp44 = c51;
            									}
HXDLIN( 241)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 245)		if ((borderMode == 1)) {
HXLINE( 247)			{
HXLINE( 247)				int _g84 = 0;
HXDLIN( 247)				int _g85 = (this1->width - 1);
HXDLIN( 247)				while((_g84 < _g85)){
HXLINE( 247)					_g84 = (_g84 + 1);
HXDLIN( 247)					int x41 = (_g84 - 1);
HXLINE( 249)					{
HXLINE( 249)						::Dynamic this276 = here->image;
HXDLIN( 249)						int index54;
HXDLIN( 249)						if (here->useVirtualPos) {
HXLINE( 249)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXLINE( 249)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x41)) ));
            						}
HXDLIN( 249)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 249)						int color22;
HXDLIN( 249)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 249)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXLINE( 249)							color22 = c52;
            						}
HXDLIN( 249)						int color23 = color22;
HXDLIN( 249)						{
HXLINE( 249)							int c53 = color23;
HXDLIN( 249)							bool _hx_tmp45;
HXDLIN( 249)							if ((((c53 >> 24) & 255) < 254)) {
HXLINE( 249)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXLINE( 249)								_hx_tmp45 = false;
            							}
HXDLIN( 249)							if (_hx_tmp45) {
HXLINE( 249)								int location20;
HXDLIN( 249)								if (out->useVirtualPos) {
HXLINE( 249)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXLINE( 249)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 249)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 249)								int this278;
HXDLIN( 249)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 249)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXLINE( 249)									this278 = this277;
            								}
HXDLIN( 249)								Float a122;
HXDLIN( 249)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 249)								if ((this279 == 0)) {
HXLINE( 249)									a122 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float r120;
HXDLIN( 249)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 249)								if ((this280 == 0)) {
HXLINE( 249)									r120 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float g120;
HXDLIN( 249)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 249)								if ((this281 == 0)) {
HXLINE( 249)									g120 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float b123;
HXDLIN( 249)								int this282 = (this278 & 255);
HXDLIN( 249)								if ((this282 == 0)) {
HXLINE( 249)									b123 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float a221;
HXDLIN( 249)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 249)								if ((this283 == 0)) {
HXLINE( 249)									a221 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float r220;
HXDLIN( 249)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 249)								if ((this284 == 0)) {
HXLINE( 249)									r220 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float g220;
HXDLIN( 249)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 249)								if ((this285 == 0)) {
HXLINE( 249)									g220 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float b221;
HXDLIN( 249)								int this286 = (color23 & 255);
HXDLIN( 249)								if ((this286 == 0)) {
HXLINE( 249)									b221 = ((Float)0.);
            								}
            								else {
HXLINE( 249)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 249)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 249)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 249)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 249)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 249)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 249)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 249)								{
HXLINE( 249)									int _hx_tmp46;
HXDLIN( 249)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 249)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXLINE( 249)										_hx_tmp46 = blended20;
            									}
HXDLIN( 249)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXLINE( 249)								::Dynamic this287 = out->image;
HXDLIN( 249)								int index55;
HXDLIN( 249)								if (out->useVirtualPos) {
HXLINE( 249)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXLINE( 249)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 249)								int _hx_tmp47;
HXDLIN( 249)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 249)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXLINE( 249)									_hx_tmp47 = c53;
            								}
HXDLIN( 249)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXLINE( 251)					{
HXLINE( 251)						int y40 = (this1->height - 1);
HXDLIN( 251)						int y41 = (this1->height - 1);
HXDLIN( 251)						::Dynamic this288 = here->image;
HXDLIN( 251)						int index56;
HXDLIN( 251)						if (here->useVirtualPos) {
HXLINE( 251)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXLINE( 251)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x41)) ));
            						}
HXDLIN( 251)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 251)						int color24;
HXDLIN( 251)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 251)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXLINE( 251)							color24 = c54;
            						}
HXDLIN( 251)						{
HXLINE( 251)							int c55 = color24;
HXDLIN( 251)							bool _hx_tmp48;
HXDLIN( 251)							if ((((c55 >> 24) & 255) < 254)) {
HXLINE( 251)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXLINE( 251)								_hx_tmp48 = false;
            							}
HXDLIN( 251)							if (_hx_tmp48) {
HXLINE( 251)								int location21;
HXDLIN( 251)								if (out->useVirtualPos) {
HXLINE( 251)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXLINE( 251)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 251)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 251)								int this290;
HXDLIN( 251)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 251)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXLINE( 251)									this290 = this289;
            								}
HXDLIN( 251)								Float a123;
HXDLIN( 251)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 251)								if ((this291 == 0)) {
HXLINE( 251)									a123 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float r121;
HXDLIN( 251)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 251)								if ((this292 == 0)) {
HXLINE( 251)									r121 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float g121;
HXDLIN( 251)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 251)								if ((this293 == 0)) {
HXLINE( 251)									g121 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float b124;
HXDLIN( 251)								int this294 = (this290 & 255);
HXDLIN( 251)								if ((this294 == 0)) {
HXLINE( 251)									b124 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float a222;
HXDLIN( 251)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 251)								if ((this295 == 0)) {
HXLINE( 251)									a222 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float r221;
HXDLIN( 251)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 251)								if ((this296 == 0)) {
HXLINE( 251)									r221 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float g221;
HXDLIN( 251)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 251)								if ((this297 == 0)) {
HXLINE( 251)									g221 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float b222;
HXDLIN( 251)								int this298 = (color24 & 255);
HXDLIN( 251)								if ((this298 == 0)) {
HXLINE( 251)									b222 = ((Float)0.);
            								}
            								else {
HXLINE( 251)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 251)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 251)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 251)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 251)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 251)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 251)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 251)								{
HXLINE( 251)									int _hx_tmp49;
HXDLIN( 251)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 251)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXLINE( 251)										_hx_tmp49 = blended21;
            									}
HXDLIN( 251)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXLINE( 251)								::Dynamic this299 = out->image;
HXDLIN( 251)								int index57;
HXDLIN( 251)								if (out->useVirtualPos) {
HXLINE( 251)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXLINE( 251)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 251)								int _hx_tmp50;
HXDLIN( 251)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 251)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXLINE( 251)									_hx_tmp50 = c55;
            								}
HXDLIN( 251)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXLINE( 253)			{
HXLINE( 253)				int _g86 = 1;
HXDLIN( 253)				int _g87 = (this1->height - 2);
HXDLIN( 253)				while((_g86 < _g87)){
HXLINE( 253)					_g86 = (_g86 + 1);
HXDLIN( 253)					int y42 = (_g86 - 1);
HXLINE( 255)					{
HXLINE( 255)						::Dynamic this300 = here->image;
HXDLIN( 255)						int index58;
HXDLIN( 255)						if (here->useVirtualPos) {
HXLINE( 255)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXLINE( 255)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 255)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 255)						int color25;
HXDLIN( 255)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 255)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXLINE( 255)							color25 = c56;
            						}
HXDLIN( 255)						int color26 = color25;
HXDLIN( 255)						{
HXLINE( 255)							int c57 = color26;
HXDLIN( 255)							bool _hx_tmp51;
HXDLIN( 255)							if ((((c57 >> 24) & 255) < 254)) {
HXLINE( 255)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXLINE( 255)								_hx_tmp51 = false;
            							}
HXDLIN( 255)							if (_hx_tmp51) {
HXLINE( 255)								int location22;
HXDLIN( 255)								if (out->useVirtualPos) {
HXLINE( 255)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 255)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 255)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 255)								int this302;
HXDLIN( 255)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 255)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXLINE( 255)									this302 = this301;
            								}
HXDLIN( 255)								Float a124;
HXDLIN( 255)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 255)								if ((this303 == 0)) {
HXLINE( 255)									a124 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float r122;
HXDLIN( 255)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 255)								if ((this304 == 0)) {
HXLINE( 255)									r122 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float g122;
HXDLIN( 255)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 255)								if ((this305 == 0)) {
HXLINE( 255)									g122 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float b125;
HXDLIN( 255)								int this306 = (this302 & 255);
HXDLIN( 255)								if ((this306 == 0)) {
HXLINE( 255)									b125 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float a223;
HXDLIN( 255)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 255)								if ((this307 == 0)) {
HXLINE( 255)									a223 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float r222;
HXDLIN( 255)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 255)								if ((this308 == 0)) {
HXLINE( 255)									r222 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float g222;
HXDLIN( 255)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 255)								if ((this309 == 0)) {
HXLINE( 255)									g222 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float b223;
HXDLIN( 255)								int this310 = (color26 & 255);
HXDLIN( 255)								if ((this310 == 0)) {
HXLINE( 255)									b223 = ((Float)0.);
            								}
            								else {
HXLINE( 255)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 255)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 255)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 255)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 255)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 255)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 255)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 255)								{
HXLINE( 255)									int _hx_tmp52;
HXDLIN( 255)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 255)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXLINE( 255)										_hx_tmp52 = blended22;
            									}
HXDLIN( 255)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXLINE( 255)								::Dynamic this311 = out->image;
HXDLIN( 255)								int index59;
HXDLIN( 255)								if (out->useVirtualPos) {
HXLINE( 255)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 255)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 255)								int _hx_tmp53;
HXDLIN( 255)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 255)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXLINE( 255)									_hx_tmp53 = c57;
            								}
HXDLIN( 255)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXLINE( 257)					{
HXLINE( 257)						int x42 = (this1->width - 1);
HXDLIN( 257)						int x43 = (this1->width - 1);
HXDLIN( 257)						::Dynamic this312 = here->image;
HXDLIN( 257)						int index60;
HXDLIN( 257)						if (here->useVirtualPos) {
HXLINE( 257)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            						}
            						else {
HXLINE( 257)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x43)) ));
            						}
HXDLIN( 257)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 257)						int color27;
HXDLIN( 257)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 257)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXLINE( 257)							color27 = c58;
            						}
HXDLIN( 257)						{
HXLINE( 257)							int c59 = color27;
HXDLIN( 257)							bool _hx_tmp54;
HXDLIN( 257)							if ((((c59 >> 24) & 255) < 254)) {
HXLINE( 257)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXLINE( 257)								_hx_tmp54 = false;
            							}
HXDLIN( 257)							if (_hx_tmp54) {
HXLINE( 257)								int location23;
HXDLIN( 257)								if (out->useVirtualPos) {
HXLINE( 257)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 257)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 257)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 257)								int this314;
HXDLIN( 257)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 257)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXLINE( 257)									this314 = this313;
            								}
HXDLIN( 257)								Float a125;
HXDLIN( 257)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 257)								if ((this315 == 0)) {
HXLINE( 257)									a125 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float r123;
HXDLIN( 257)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 257)								if ((this316 == 0)) {
HXLINE( 257)									r123 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float g123;
HXDLIN( 257)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 257)								if ((this317 == 0)) {
HXLINE( 257)									g123 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float b126;
HXDLIN( 257)								int this318 = (this314 & 255);
HXDLIN( 257)								if ((this318 == 0)) {
HXLINE( 257)									b126 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float a224;
HXDLIN( 257)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 257)								if ((this319 == 0)) {
HXLINE( 257)									a224 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float r223;
HXDLIN( 257)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 257)								if ((this320 == 0)) {
HXLINE( 257)									r223 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float g223;
HXDLIN( 257)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 257)								if ((this321 == 0)) {
HXLINE( 257)									g223 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float b224;
HXDLIN( 257)								int this322 = (color27 & 255);
HXDLIN( 257)								if ((this322 == 0)) {
HXLINE( 257)									b224 = ((Float)0.);
            								}
            								else {
HXLINE( 257)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 257)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 257)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 257)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 257)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 257)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 257)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 257)								{
HXLINE( 257)									int _hx_tmp55;
HXDLIN( 257)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 257)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXLINE( 257)										_hx_tmp55 = blended23;
            									}
HXDLIN( 257)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXLINE( 257)								::Dynamic this323 = out->image;
HXDLIN( 257)								int index61;
HXDLIN( 257)								if (out->useVirtualPos) {
HXLINE( 257)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 257)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 257)								int _hx_tmp56;
HXDLIN( 257)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 257)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXLINE( 257)									_hx_tmp56 = c59;
            								}
HXDLIN( 257)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 260)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Convolution_Impl__obj,convolute3x3,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::convolute5x5( ::pi_xy::ImageStruct this1, ::pi_xy::imageAbstracts::Mat5x5data m55,int borderMode,::hx::Null< bool >  __o_adjustAlpha,::hx::Null< bool >  __o_adjustRed,::hx::Null< bool >  __o_adjustGreen,::hx::Null< bool >  __o_adjustBlue){
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            		bool adjustRed = __o_adjustRed.Default(true);
            		bool adjustGreen = __o_adjustGreen.Default(true);
            		bool adjustBlue = __o_adjustBlue.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_270_convolute5x5)
HXLINE( 271)		int a0 = 0;
HXLINE( 272)		int b0 = 0;
HXLINE( 273)		int c0 = 0;
HXLINE( 274)		int d0 = 0;
HXLINE( 275)		int e0 = 0;
HXLINE( 277)		int f0 = 0;
HXLINE( 278)		int g0 = 0;
HXLINE( 279)		int h0 = 0;
HXLINE( 280)		int i0 = 0;
HXLINE( 281)		int j0 = 0;
HXLINE( 283)		int k0 = 0;
HXLINE( 284)		int l0 = 0;
HXLINE( 285)		int m0 = 0;
HXLINE( 286)		int n0 = 0;
HXLINE( 287)		int o0 = 0;
HXLINE( 289)		int p0 = 0;
HXLINE( 290)		int q0 = 0;
HXLINE( 291)		int r0 = 0;
HXLINE( 292)		int s0 = 0;
HXLINE( 293)		int t0 = 0;
HXLINE( 295)		int u0 = 0;
HXLINE( 296)		int v0 = 0;
HXLINE( 297)		int w0 = 0;
HXLINE( 298)		int x0 = 0;
HXLINE( 299)		int y0 = 0;
HXLINE( 301)		Float r_ = ((Float)0.);
HXLINE( 302)		Float g_ = ((Float)0.);
HXLINE( 303)		Float b_ = ((Float)0.);
HXLINE( 304)		Float a_ = ((Float)0.);
HXLINE( 305)		int width = this1->width;
HXDLIN( 305)		int height = this1->height;
HXDLIN( 305)		 ::Dynamic imageType = null();
HXDLIN( 305)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 305)		if (::hx::IsNull( imageType )) {
HXLINE( 305)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 305)		::Dynamic _hx_tmp;
HXDLIN( 305)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 305)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 305)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 305)				{
HXLINE( 305)					b->width = width;
HXDLIN( 305)					b->height = height;
HXDLIN( 305)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 305)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 305)					{
HXLINE( 305)						int len = b->length;
HXDLIN( 305)						int w = 0;
HXDLIN( 305)						{
HXLINE( 305)							int _g = 0;
HXDLIN( 305)							int _g1 = b->height;
HXDLIN( 305)							while((_g < _g1)){
HXLINE( 305)								_g = (_g + 1);
HXDLIN( 305)								int y = (_g - 1);
HXDLIN( 305)								{
HXLINE( 305)									int _g2 = 0;
HXDLIN( 305)									int _g3 = b->width;
HXDLIN( 305)									while((_g2 < _g3)){
HXLINE( 305)										_g2 = (_g2 + 1);
HXDLIN( 305)										int x = (_g2 - 1);
HXDLIN( 305)										{
HXLINE( 305)											w = (w + 1);
HXDLIN( 305)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 305)										{
HXLINE( 305)											w = (w + 1);
HXDLIN( 305)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 305)										{
HXLINE( 305)											w = (w + 1);
HXDLIN( 305)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 305)										{
HXLINE( 305)											w = (w + 1);
HXDLIN( 305)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 305)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 305)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 305)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 305)				{
HXLINE( 305)					a->width = width;
HXDLIN( 305)					a->height = height;
HXDLIN( 305)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 305)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 305)					{
HXLINE( 305)						int _g4 = 0;
HXDLIN( 305)						int _g5 = a->length;
HXDLIN( 305)						while((_g4 < _g5)){
HXLINE( 305)							_g4 = (_g4 + 1);
HXDLIN( 305)							int i = (_g4 - 1);
HXDLIN( 305)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 305)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 305)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 305)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 305)				{
HXLINE( 305)					b1->width = width;
HXDLIN( 305)					b1->height = height;
HXDLIN( 305)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 305)					int size = (b1->length * 4);
HXDLIN( 305)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 305)					{
HXLINE( 305)						int _g6 = 0;
HXDLIN( 305)						int _g7 = b1->length;
HXDLIN( 305)						while((_g6 < _g7)){
HXLINE( 305)							_g6 = (_g6 + 1);
HXDLIN( 305)							int i1 = (_g6 - 1);
HXDLIN( 305)							{
HXLINE( 305)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 305)								bool _hx_tmp1;
HXDLIN( 305)								if ((i1 >= 0)) {
HXLINE( 305)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 305)									_hx_tmp1 = false;
            								}
HXDLIN( 305)								if (_hx_tmp1) {
HXLINE( 305)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 305)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 305)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 305)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 305)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 305)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 305)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 305)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 305)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 305)				{
HXLINE( 305)					v->width = width;
HXDLIN( 305)					v->height = height;
HXDLIN( 305)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 305)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 305)					{
HXLINE( 305)						int _g8 = 0;
HXDLIN( 305)						int _g9 = v->length;
HXDLIN( 305)						while((_g8 < _g9)){
HXLINE( 305)							_g8 = (_g8 + 1);
HXDLIN( 305)							int i2 = (_g8 - 1);
HXDLIN( 305)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 305)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 305)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 305)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 305)				{
HXLINE( 305)					b2->width = width;
HXDLIN( 305)					b2->height = height;
HXDLIN( 305)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 305)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 305)					{
HXLINE( 305)						int len1 = b2->length;
HXDLIN( 305)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 305)						if (::hx::IsNull( d->head )) {
HXLINE( 305)							int _g10 = 0;
HXDLIN( 305)							int _g11 = len1;
HXDLIN( 305)							while((_g10 < _g11)){
HXLINE( 305)								_g10 = (_g10 + 1);
HXDLIN( 305)								int i3 = (_g10 - 1);
HXDLIN( 305)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 305)							int _g12 = 0;
HXDLIN( 305)							int _g13 = len1;
HXDLIN( 305)							while((_g12 < _g13)){
HXLINE( 305)								_g12 = (_g12 + 1);
HXDLIN( 305)								int i4 = (_g12 - 1);
HXDLIN( 305)								{
HXLINE( 305)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 305)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 305)									{
HXLINE( 305)										int _g14 = 0;
HXDLIN( 305)										int _g15 = i4;
HXDLIN( 305)										while((_g14 < _g15)){
HXLINE( 305)											_g14 = (_g14 + 1);
HXDLIN( 305)											int i5 = (_g14 - 1);
HXDLIN( 305)											prev = l;
HXDLIN( 305)											l = l->next;
            										}
            									}
HXDLIN( 305)									if (::hx::IsNull( prev )) {
HXLINE( 305)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 305)										l = null();
            									}
            									else {
HXLINE( 305)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 305)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 305)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 305)		this2->image = _hx_tmp;
HXDLIN( 305)		this2->width = width;
HXDLIN( 305)		this2->height = height;
HXDLIN( 305)		this2->imageType = ( (int)(imageType) );
HXDLIN( 305)		 ::pi_xy::ImageStruct out = this2;
HXLINE( 306)		 ::pi_xy::ImageStruct here = this1;
HXLINE( 309)		switch((int)(borderMode)){
            			case (int)0: {
HXLINE( 311)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 311)				int width1 = (this4->width + 4);
HXDLIN( 311)				int height1 = (this4->height + 4);
HXDLIN( 311)				 ::Dynamic imageType1 = null();
HXDLIN( 311)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 311)				if (::hx::IsNull( imageType1 )) {
HXLINE( 311)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXDLIN( 311)				::Dynamic here1;
HXDLIN( 311)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 311)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 311)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 311)						{
HXLINE( 311)							b3->width = width1;
HXDLIN( 311)							b3->height = height1;
HXDLIN( 311)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 311)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 311)							{
HXLINE( 311)								int len2 = b3->length;
HXDLIN( 311)								int w1 = 0;
HXDLIN( 311)								{
HXLINE( 311)									int _g16 = 0;
HXDLIN( 311)									int _g17 = b3->height;
HXDLIN( 311)									while((_g16 < _g17)){
HXLINE( 311)										_g16 = (_g16 + 1);
HXDLIN( 311)										int y1 = (_g16 - 1);
HXDLIN( 311)										{
HXLINE( 311)											int _g18 = 0;
HXDLIN( 311)											int _g19 = b3->width;
HXDLIN( 311)											while((_g18 < _g19)){
HXLINE( 311)												_g18 = (_g18 + 1);
HXDLIN( 311)												int x1 = (_g18 - 1);
HXDLIN( 311)												{
HXLINE( 311)													w1 = (w1 + 1);
HXDLIN( 311)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 311)												{
HXLINE( 311)													w1 = (w1 + 1);
HXDLIN( 311)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 311)												{
HXLINE( 311)													w1 = (w1 + 1);
HXDLIN( 311)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 311)												{
HXLINE( 311)													w1 = (w1 + 1);
HXDLIN( 311)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 311)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXLINE( 311)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 311)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 311)						{
HXLINE( 311)							a1->width = width1;
HXDLIN( 311)							a1->height = height1;
HXDLIN( 311)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 311)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 311)							{
HXLINE( 311)								int _g20 = 0;
HXDLIN( 311)								int _g21 = a1->length;
HXDLIN( 311)								while((_g20 < _g21)){
HXLINE( 311)									_g20 = (_g20 + 1);
HXDLIN( 311)									int i6 = (_g20 - 1);
HXDLIN( 311)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 311)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXLINE( 311)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 311)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 311)						{
HXLINE( 311)							b4->width = width1;
HXDLIN( 311)							b4->height = height1;
HXDLIN( 311)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 311)							int size1 = (b4->length * 4);
HXDLIN( 311)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 311)							{
HXLINE( 311)								int _g22 = 0;
HXDLIN( 311)								int _g23 = b4->length;
HXDLIN( 311)								while((_g22 < _g23)){
HXLINE( 311)									_g22 = (_g22 + 1);
HXDLIN( 311)									int i7 = (_g22 - 1);
HXDLIN( 311)									{
HXLINE( 311)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 311)										bool here2;
HXDLIN( 311)										if ((i7 >= 0)) {
HXLINE( 311)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXLINE( 311)											here2 = false;
            										}
HXDLIN( 311)										if (here2) {
HXLINE( 311)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 311)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 311)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 311)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 311)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 311)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 311)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXLINE( 311)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 311)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 311)						{
HXLINE( 311)							v1->width = width1;
HXDLIN( 311)							v1->height = height1;
HXDLIN( 311)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 311)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 311)							{
HXLINE( 311)								int _g24 = 0;
HXDLIN( 311)								int _g25 = v1->length;
HXDLIN( 311)								while((_g24 < _g25)){
HXLINE( 311)									_g24 = (_g24 + 1);
HXDLIN( 311)									int i8 = (_g24 - 1);
HXDLIN( 311)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 311)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXLINE( 311)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 311)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 311)						{
HXLINE( 311)							b5->width = width1;
HXDLIN( 311)							b5->height = height1;
HXDLIN( 311)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 311)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 311)							{
HXLINE( 311)								int len3 = b5->length;
HXDLIN( 311)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 311)								if (::hx::IsNull( d1->head )) {
HXLINE( 311)									int _g26 = 0;
HXDLIN( 311)									int _g27 = len3;
HXDLIN( 311)									while((_g26 < _g27)){
HXLINE( 311)										_g26 = (_g26 + 1);
HXDLIN( 311)										int i9 = (_g26 - 1);
HXDLIN( 311)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 311)									int _g28 = 0;
HXDLIN( 311)									int _g29 = len3;
HXDLIN( 311)									while((_g28 < _g29)){
HXLINE( 311)										_g28 = (_g28 + 1);
HXDLIN( 311)										int i10 = (_g28 - 1);
HXDLIN( 311)										{
HXLINE( 311)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 311)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 311)											{
HXLINE( 311)												int _g30 = 0;
HXDLIN( 311)												int _g31 = i10;
HXDLIN( 311)												while((_g30 < _g31)){
HXLINE( 311)													_g30 = (_g30 + 1);
HXDLIN( 311)													int i11 = (_g30 - 1);
HXDLIN( 311)													prev1 = l1;
HXDLIN( 311)													l1 = l1->next;
            												}
            											}
HXDLIN( 311)											if (::hx::IsNull( prev1 )) {
HXLINE( 311)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 311)												l1 = null();
            											}
            											else {
HXLINE( 311)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 311)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 311)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 311)				this5->image = here1;
HXDLIN( 311)				this5->width = width1;
HXDLIN( 311)				this5->height = height1;
HXDLIN( 311)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 311)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 311)				{
HXLINE( 311)					bool forceClear = false;
HXDLIN( 311)					{
HXLINE( 311)						int _g32 = 0;
HXDLIN( 311)						int _g33 = this4->height;
HXDLIN( 311)						while((_g32 < _g33)){
HXLINE( 311)							_g32 = (_g32 + 1);
HXDLIN( 311)							int dy = (_g32 - 1);
HXDLIN( 311)							{
HXLINE( 311)								int _g34 = 0;
HXDLIN( 311)								int _g35 = this4->width;
HXDLIN( 311)								while((_g34 < _g35)){
HXLINE( 311)									_g34 = (_g34 + 1);
HXDLIN( 311)									int dx = (_g34 - 1);
HXDLIN( 311)									::Dynamic this7 = this4->image;
HXDLIN( 311)									int index;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 311)									int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 311)									int col;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 311)										col = c;
            									}
HXDLIN( 311)									bool here3;
HXDLIN( 311)									if (this4->useMask) {
HXLINE( 311)										here3 = ::hx::IsNotNull( this4->mask );
            									}
            									else {
HXLINE( 311)										here3 = false;
            									}
HXDLIN( 311)									if (here3) {
HXLINE( 311)										 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 311)										::Dynamic this9 = this8->image;
HXDLIN( 311)										int index1;
HXDLIN( 311)										if (this8->useVirtualPos) {
HXLINE( 311)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            										}
            										else {
HXLINE( 311)											index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            										}
HXDLIN( 311)										int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 311)										int v2;
HXDLIN( 311)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)											v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 311)											v2 = c1;
            										}
HXDLIN( 311)										int maskPixel = v2;
HXDLIN( 311)										int this10 = col;
HXDLIN( 311)										if ((maskPixel == 0)) {
HXLINE( 311)											col = this10;
            										}
            										else {
HXLINE( 311)											Float m01;
HXDLIN( 311)											int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 311)											if ((this11 == 0)) {
HXLINE( 311)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												m01 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float m1;
HXDLIN( 311)											int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 311)											if ((this12 == 0)) {
HXLINE( 311)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float m2;
HXDLIN( 311)											int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 311)											if ((this13 == 0)) {
HXLINE( 311)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float m3;
HXDLIN( 311)											int this14 = (maskPixel & 255);
HXDLIN( 311)											if ((this14 == 0)) {
HXLINE( 311)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 311)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 311)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 311)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 311)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 311)									if ((col != 0)) {
HXLINE( 311)										int x2 = (2 + dx);
HXDLIN( 311)										int y2 = (2 + dy);
HXDLIN( 311)										int c2 = col;
HXDLIN( 311)										bool here4;
HXDLIN( 311)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 311)											here4 = img->transparent;
            										}
            										else {
HXLINE( 311)											here4 = false;
            										}
HXDLIN( 311)										if (here4) {
HXLINE( 311)											int location;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            											}
HXDLIN( 311)											int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 311)											int this16;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this16 = this15;
            											}
HXDLIN( 311)											Float a11;
HXDLIN( 311)											int this17 = ((this16 >> 24) & 255);
HXDLIN( 311)											if ((this17 == 0)) {
HXLINE( 311)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r1;
HXDLIN( 311)											int this18 = ((this16 >> 16) & 255);
HXDLIN( 311)											if ((this18 == 0)) {
HXLINE( 311)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g1;
HXDLIN( 311)											int this19 = ((this16 >> 8) & 255);
HXDLIN( 311)											if ((this19 == 0)) {
HXLINE( 311)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b11;
HXDLIN( 311)											int this20 = (this16 & 255);
HXDLIN( 311)											if ((this20 == 0)) {
HXLINE( 311)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a2;
HXDLIN( 311)											int this21 = ((col >> 24) & 255);
HXDLIN( 311)											if ((this21 == 0)) {
HXLINE( 311)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r2;
HXDLIN( 311)											int this22 = ((col >> 16) & 255);
HXDLIN( 311)											if ((this22 == 0)) {
HXLINE( 311)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g2;
HXDLIN( 311)											int this23 = ((col >> 8) & 255);
HXDLIN( 311)											if ((this23 == 0)) {
HXLINE( 311)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b21;
HXDLIN( 311)											int this24 = (col & 255);
HXDLIN( 311)											if ((this24 == 0)) {
HXLINE( 311)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 311)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 311)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 311)											int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 311)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 311)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 311)											{
HXLINE( 311)												int here5;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here5 = blended;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location,here5);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this25 = img->image;
HXDLIN( 311)											int index2;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            											}
HXDLIN( 311)											int here6;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here6 = c2;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this25,index2,here6);
            										}
            									}
            									else {
HXLINE( 311)										if (forceClear) {
HXLINE( 311)											::Dynamic this26 = img->image;
HXDLIN( 311)											int x3 = (2 + dx);
HXDLIN( 311)											int y3 = (2 + dy);
HXDLIN( 311)											int index3;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this26,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 311)				{
HXLINE( 311)					int _g36 = 0;
HXDLIN( 311)					int _g37 = this4->width;
HXDLIN( 311)					while((_g36 < _g37)){
HXLINE( 311)						_g36 = (_g36 + 1);
HXDLIN( 311)						int x4 = (_g36 - 1);
HXDLIN( 311)						{
HXLINE( 311)							int _g38 = 0;
HXDLIN( 311)							int _g39 = 2;
HXDLIN( 311)							while((_g38 < _g39)){
HXLINE( 311)								_g38 = (_g38 + 1);
HXDLIN( 311)								int y4 = (_g38 - 1);
HXDLIN( 311)								{
HXLINE( 311)									int x5 = (x4 + 2);
HXDLIN( 311)									::Dynamic this27 = this4->image;
HXDLIN( 311)									int index4;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            									}
HXDLIN( 311)									int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 311)									int color;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color = c3;
            									}
HXDLIN( 311)									int color1 = color;
HXDLIN( 311)									{
HXLINE( 311)										int c4 = color1;
HXDLIN( 311)										bool here7;
HXDLIN( 311)										if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 311)											here7 = img->transparent;
            										}
            										else {
HXLINE( 311)											here7 = false;
            										}
HXDLIN( 311)										if (here7) {
HXLINE( 311)											int location1;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            											}
HXDLIN( 311)											int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 311)											int this29;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this29 = this28;
            											}
HXDLIN( 311)											Float a12;
HXDLIN( 311)											int this30 = ((this29 >> 24) & 255);
HXDLIN( 311)											if ((this30 == 0)) {
HXLINE( 311)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r11;
HXDLIN( 311)											int this31 = ((this29 >> 16) & 255);
HXDLIN( 311)											if ((this31 == 0)) {
HXLINE( 311)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g11;
HXDLIN( 311)											int this32 = ((this29 >> 8) & 255);
HXDLIN( 311)											if ((this32 == 0)) {
HXLINE( 311)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b12;
HXDLIN( 311)											int this33 = (this29 & 255);
HXDLIN( 311)											if ((this33 == 0)) {
HXLINE( 311)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a21;
HXDLIN( 311)											int this34 = ((color1 >> 24) & 255);
HXDLIN( 311)											if ((this34 == 0)) {
HXLINE( 311)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r21;
HXDLIN( 311)											int this35 = ((color1 >> 16) & 255);
HXDLIN( 311)											if ((this35 == 0)) {
HXLINE( 311)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g21;
HXDLIN( 311)											int this36 = ((color1 >> 8) & 255);
HXDLIN( 311)											if ((this36 == 0)) {
HXLINE( 311)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b22;
HXDLIN( 311)											int this37 = (color1 & 255);
HXDLIN( 311)											if ((this37 == 0)) {
HXLINE( 311)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 311)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 311)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 311)											int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 311)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 311)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 311)											{
HXLINE( 311)												int here8;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here8 = blended1;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location1,here8);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this38 = img->image;
HXDLIN( 311)											int index5;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            											}
HXDLIN( 311)											int here9;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here9 = c4;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this38,index5,here9);
            										}
            									}
            								}
HXDLIN( 311)								{
HXLINE( 311)									int x6 = (x4 + 2);
HXDLIN( 311)									int y5 = ((img->height - y4) - 1);
HXDLIN( 311)									int y6 = (this4->height - 1);
HXDLIN( 311)									::Dynamic this39 = this4->image;
HXDLIN( 311)									int index6;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            									}
HXDLIN( 311)									int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 311)									int color2;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color2 = c5;
            									}
HXDLIN( 311)									{
HXLINE( 311)										int c6 = color2;
HXDLIN( 311)										bool here10;
HXDLIN( 311)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 311)											here10 = img->transparent;
            										}
            										else {
HXLINE( 311)											here10 = false;
            										}
HXDLIN( 311)										if (here10) {
HXLINE( 311)											int location2;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            											}
HXDLIN( 311)											int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 311)											int this41;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this41 = this40;
            											}
HXDLIN( 311)											Float a13;
HXDLIN( 311)											int this42 = ((this41 >> 24) & 255);
HXDLIN( 311)											if ((this42 == 0)) {
HXLINE( 311)												a13 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r12;
HXDLIN( 311)											int this43 = ((this41 >> 16) & 255);
HXDLIN( 311)											if ((this43 == 0)) {
HXLINE( 311)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g12;
HXDLIN( 311)											int this44 = ((this41 >> 8) & 255);
HXDLIN( 311)											if ((this44 == 0)) {
HXLINE( 311)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b13;
HXDLIN( 311)											int this45 = (this41 & 255);
HXDLIN( 311)											if ((this45 == 0)) {
HXLINE( 311)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a22;
HXDLIN( 311)											int this46 = ((color2 >> 24) & 255);
HXDLIN( 311)											if ((this46 == 0)) {
HXLINE( 311)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r22;
HXDLIN( 311)											int this47 = ((color2 >> 16) & 255);
HXDLIN( 311)											if ((this47 == 0)) {
HXLINE( 311)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g22;
HXDLIN( 311)											int this48 = ((color2 >> 8) & 255);
HXDLIN( 311)											if ((this48 == 0)) {
HXLINE( 311)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b23;
HXDLIN( 311)											int this49 = (color2 & 255);
HXDLIN( 311)											if ((this49 == 0)) {
HXLINE( 311)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 311)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 311)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 311)											int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 311)											int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 311)											int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 311)											{
HXLINE( 311)												int here11;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here11 = blended2;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location2,here11);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this50 = img->image;
HXDLIN( 311)											int index7;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            											}
HXDLIN( 311)											int here12;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here12 = c6;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this50,index7,here12);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 311)				{
HXLINE( 311)					int _g40 = 0;
HXDLIN( 311)					int _g41 = this4->height;
HXDLIN( 311)					while((_g40 < _g41)){
HXLINE( 311)						_g40 = (_g40 + 1);
HXDLIN( 311)						int y7 = (_g40 - 1);
HXDLIN( 311)						{
HXLINE( 311)							int _g42 = 0;
HXDLIN( 311)							int _g43 = 2;
HXDLIN( 311)							while((_g42 < _g43)){
HXLINE( 311)								_g42 = (_g42 + 1);
HXDLIN( 311)								int x7 = (_g42 - 1);
HXDLIN( 311)								{
HXLINE( 311)									int y8 = (y7 + 2);
HXDLIN( 311)									::Dynamic this51 = this4->image;
HXDLIN( 311)									int index8;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            									}
HXDLIN( 311)									int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 311)									int color3;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color3 = c7;
            									}
HXDLIN( 311)									int color4 = color3;
HXDLIN( 311)									{
HXLINE( 311)										int c8 = color4;
HXDLIN( 311)										bool here13;
HXDLIN( 311)										if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 311)											here13 = img->transparent;
            										}
            										else {
HXLINE( 311)											here13 = false;
            										}
HXDLIN( 311)										if (here13) {
HXLINE( 311)											int location3;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            											}
HXDLIN( 311)											int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 311)											int this53;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this53 = this52;
            											}
HXDLIN( 311)											Float a14;
HXDLIN( 311)											int this54 = ((this53 >> 24) & 255);
HXDLIN( 311)											if ((this54 == 0)) {
HXLINE( 311)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r13;
HXDLIN( 311)											int this55 = ((this53 >> 16) & 255);
HXDLIN( 311)											if ((this55 == 0)) {
HXLINE( 311)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g13;
HXDLIN( 311)											int this56 = ((this53 >> 8) & 255);
HXDLIN( 311)											if ((this56 == 0)) {
HXLINE( 311)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b14;
HXDLIN( 311)											int this57 = (this53 & 255);
HXDLIN( 311)											if ((this57 == 0)) {
HXLINE( 311)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a23;
HXDLIN( 311)											int this58 = ((color4 >> 24) & 255);
HXDLIN( 311)											if ((this58 == 0)) {
HXLINE( 311)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r23;
HXDLIN( 311)											int this59 = ((color4 >> 16) & 255);
HXDLIN( 311)											if ((this59 == 0)) {
HXLINE( 311)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g23;
HXDLIN( 311)											int this60 = ((color4 >> 8) & 255);
HXDLIN( 311)											if ((this60 == 0)) {
HXLINE( 311)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b24;
HXDLIN( 311)											int this61 = (color4 & 255);
HXDLIN( 311)											if ((this61 == 0)) {
HXLINE( 311)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 311)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 311)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 311)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 311)											int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 311)											int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 311)											{
HXLINE( 311)												int here14;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here14 = blended3;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location3,here14);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this62 = img->image;
HXDLIN( 311)											int index9;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            											}
HXDLIN( 311)											int here15;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here15 = c8;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this62,index9,here15);
            										}
            									}
            								}
HXDLIN( 311)								{
HXLINE( 311)									int x8 = ((img->width - x7) - 1);
HXDLIN( 311)									int y9 = (y7 + 2);
HXDLIN( 311)									int x9 = (this4->width - 1);
HXDLIN( 311)									::Dynamic this63 = this4->image;
HXDLIN( 311)									int index10;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            									}
HXDLIN( 311)									int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 311)									int color5;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color5 = c9;
            									}
HXDLIN( 311)									{
HXLINE( 311)										int c10 = color5;
HXDLIN( 311)										bool here16;
HXDLIN( 311)										if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 311)											here16 = img->transparent;
            										}
            										else {
HXLINE( 311)											here16 = false;
            										}
HXDLIN( 311)										if (here16) {
HXLINE( 311)											int location4;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            											}
HXDLIN( 311)											int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 311)											int this65;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this65 = this64;
            											}
HXDLIN( 311)											Float a15;
HXDLIN( 311)											int this66 = ((this65 >> 24) & 255);
HXDLIN( 311)											if ((this66 == 0)) {
HXLINE( 311)												a15 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r14;
HXDLIN( 311)											int this67 = ((this65 >> 16) & 255);
HXDLIN( 311)											if ((this67 == 0)) {
HXLINE( 311)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g14;
HXDLIN( 311)											int this68 = ((this65 >> 8) & 255);
HXDLIN( 311)											if ((this68 == 0)) {
HXLINE( 311)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b15;
HXDLIN( 311)											int this69 = (this65 & 255);
HXDLIN( 311)											if ((this69 == 0)) {
HXLINE( 311)												b15 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a24;
HXDLIN( 311)											int this70 = ((color5 >> 24) & 255);
HXDLIN( 311)											if ((this70 == 0)) {
HXLINE( 311)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r24;
HXDLIN( 311)											int this71 = ((color5 >> 16) & 255);
HXDLIN( 311)											if ((this71 == 0)) {
HXLINE( 311)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g24;
HXDLIN( 311)											int this72 = ((color5 >> 8) & 255);
HXDLIN( 311)											if ((this72 == 0)) {
HXLINE( 311)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b25;
HXDLIN( 311)											int this73 = (color5 & 255);
HXDLIN( 311)											if ((this73 == 0)) {
HXLINE( 311)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 311)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 311)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 311)											int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 311)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 311)											int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 311)											{
HXLINE( 311)												int here17;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here17 = blended4;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location4,here17);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this74 = img->image;
HXDLIN( 311)											int index11;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            											}
HXDLIN( 311)											int here18;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here18 = c10;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this74,index11,here18);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 311)				{
HXLINE( 311)					int _g44 = 0;
HXDLIN( 311)					int _g45 = 2;
HXDLIN( 311)					while((_g44 < _g45)){
HXLINE( 311)						_g44 = (_g44 + 1);
HXDLIN( 311)						int x10 = (_g44 - 1);
HXDLIN( 311)						{
HXLINE( 311)							int _g46 = 0;
HXDLIN( 311)							int _g47 = 2;
HXDLIN( 311)							while((_g46 < _g47)){
HXLINE( 311)								_g46 = (_g46 + 1);
HXDLIN( 311)								int y10 = (_g46 - 1);
HXDLIN( 311)								{
HXLINE( 311)									::Dynamic this75 = this4->image;
HXDLIN( 311)									int index12;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            									}
HXDLIN( 311)									int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 311)									int color6;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color6 = c11;
            									}
HXDLIN( 311)									int color7 = color6;
HXDLIN( 311)									{
HXLINE( 311)										int c12 = color7;
HXDLIN( 311)										bool here19;
HXDLIN( 311)										if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 311)											here19 = img->transparent;
            										}
            										else {
HXLINE( 311)											here19 = false;
            										}
HXDLIN( 311)										if (here19) {
HXLINE( 311)											int location5;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            											}
HXDLIN( 311)											int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 311)											int this77;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this77 = this76;
            											}
HXDLIN( 311)											Float a16;
HXDLIN( 311)											int this78 = ((this77 >> 24) & 255);
HXDLIN( 311)											if ((this78 == 0)) {
HXLINE( 311)												a16 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r15;
HXDLIN( 311)											int this79 = ((this77 >> 16) & 255);
HXDLIN( 311)											if ((this79 == 0)) {
HXLINE( 311)												r15 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g15;
HXDLIN( 311)											int this80 = ((this77 >> 8) & 255);
HXDLIN( 311)											if ((this80 == 0)) {
HXLINE( 311)												g15 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b16;
HXDLIN( 311)											int this81 = (this77 & 255);
HXDLIN( 311)											if ((this81 == 0)) {
HXLINE( 311)												b16 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a25;
HXDLIN( 311)											int this82 = ((color7 >> 24) & 255);
HXDLIN( 311)											if ((this82 == 0)) {
HXLINE( 311)												a25 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r25;
HXDLIN( 311)											int this83 = ((color7 >> 16) & 255);
HXDLIN( 311)											if ((this83 == 0)) {
HXLINE( 311)												r25 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g25;
HXDLIN( 311)											int this84 = ((color7 >> 8) & 255);
HXDLIN( 311)											if ((this84 == 0)) {
HXLINE( 311)												g25 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b26;
HXDLIN( 311)											int this85 = (color7 & 255);
HXDLIN( 311)											if ((this85 == 0)) {
HXLINE( 311)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 311)											int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 311)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 311)											int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 311)											int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 311)											int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 311)											{
HXLINE( 311)												int here20;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here20 = blended5;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location5,here20);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this86 = img->image;
HXDLIN( 311)											int index13;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            											}
HXDLIN( 311)											int here21;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here21 = c12;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this86,index13,here21);
            										}
            									}
            								}
HXDLIN( 311)								{
HXLINE( 311)									int x11 = ((x10 + 2) + this4->width);
HXDLIN( 311)									int x12 = (this4->width - 1);
HXDLIN( 311)									::Dynamic this87 = this4->image;
HXDLIN( 311)									int index14;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            									}
HXDLIN( 311)									int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 311)									int color8;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color8 = c13;
            									}
HXDLIN( 311)									{
HXLINE( 311)										int c14 = color8;
HXDLIN( 311)										bool here22;
HXDLIN( 311)										if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 311)											here22 = img->transparent;
            										}
            										else {
HXLINE( 311)											here22 = false;
            										}
HXDLIN( 311)										if (here22) {
HXLINE( 311)											int location6;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            											}
HXDLIN( 311)											int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 311)											int this89;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this89 = this88;
            											}
HXDLIN( 311)											Float a17;
HXDLIN( 311)											int this90 = ((this89 >> 24) & 255);
HXDLIN( 311)											if ((this90 == 0)) {
HXLINE( 311)												a17 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r16;
HXDLIN( 311)											int this91 = ((this89 >> 16) & 255);
HXDLIN( 311)											if ((this91 == 0)) {
HXLINE( 311)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g16;
HXDLIN( 311)											int this92 = ((this89 >> 8) & 255);
HXDLIN( 311)											if ((this92 == 0)) {
HXLINE( 311)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b18;
HXDLIN( 311)											int this93 = (this89 & 255);
HXDLIN( 311)											if ((this93 == 0)) {
HXLINE( 311)												b18 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a26;
HXDLIN( 311)											int this94 = ((color8 >> 24) & 255);
HXDLIN( 311)											if ((this94 == 0)) {
HXLINE( 311)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r26;
HXDLIN( 311)											int this95 = ((color8 >> 16) & 255);
HXDLIN( 311)											if ((this95 == 0)) {
HXLINE( 311)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g26;
HXDLIN( 311)											int this96 = ((color8 >> 8) & 255);
HXDLIN( 311)											if ((this96 == 0)) {
HXLINE( 311)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b27;
HXDLIN( 311)											int this97 = (color8 & 255);
HXDLIN( 311)											if ((this97 == 0)) {
HXLINE( 311)												b27 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 311)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 311)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 311)											int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 311)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 311)											int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 311)											{
HXLINE( 311)												int here23;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here23 = blended6;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location6,here23);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this98 = img->image;
HXDLIN( 311)											int index15;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            											}
HXDLIN( 311)											int here24;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here24 = c14;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this98,index15,here24);
            										}
            									}
            								}
HXDLIN( 311)								{
HXLINE( 311)									int x13 = ((x10 + 2) + this4->width);
HXDLIN( 311)									int y11 = ((y10 + 2) + this4->height);
HXDLIN( 311)									int x14 = (this4->width - 1);
HXDLIN( 311)									int y12 = (this4->height - 1);
HXDLIN( 311)									::Dynamic this99 = this4->image;
HXDLIN( 311)									int index16;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            									}
HXDLIN( 311)									int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 311)									int color9;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color9 = c15;
            									}
HXDLIN( 311)									{
HXLINE( 311)										int c16 = color9;
HXDLIN( 311)										bool here25;
HXDLIN( 311)										if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 311)											here25 = img->transparent;
            										}
            										else {
HXLINE( 311)											here25 = false;
            										}
HXDLIN( 311)										if (here25) {
HXLINE( 311)											int location7;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            											}
HXDLIN( 311)											int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 311)											int this101;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this101 = this100;
            											}
HXDLIN( 311)											Float a18;
HXDLIN( 311)											int this102 = ((this101 >> 24) & 255);
HXDLIN( 311)											if ((this102 == 0)) {
HXLINE( 311)												a18 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r17;
HXDLIN( 311)											int this103 = ((this101 >> 16) & 255);
HXDLIN( 311)											if ((this103 == 0)) {
HXLINE( 311)												r17 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g17;
HXDLIN( 311)											int this104 = ((this101 >> 8) & 255);
HXDLIN( 311)											if ((this104 == 0)) {
HXLINE( 311)												g17 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b110;
HXDLIN( 311)											int this105 = (this101 & 255);
HXDLIN( 311)											if ((this105 == 0)) {
HXLINE( 311)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a27;
HXDLIN( 311)											int this106 = ((color9 >> 24) & 255);
HXDLIN( 311)											if ((this106 == 0)) {
HXLINE( 311)												a27 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r27;
HXDLIN( 311)											int this107 = ((color9 >> 16) & 255);
HXDLIN( 311)											if ((this107 == 0)) {
HXLINE( 311)												r27 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g27;
HXDLIN( 311)											int this108 = ((color9 >> 8) & 255);
HXDLIN( 311)											if ((this108 == 0)) {
HXLINE( 311)												g27 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b28;
HXDLIN( 311)											int this109 = (color9 & 255);
HXDLIN( 311)											if ((this109 == 0)) {
HXLINE( 311)												b28 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 311)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 311)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 311)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 311)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 311)											int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 311)											{
HXLINE( 311)												int here26;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here26 = blended7;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location7,here26);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this110 = img->image;
HXDLIN( 311)											int index17;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            											}
HXDLIN( 311)											int here27;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here27 = c16;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this110,index17,here27);
            										}
            									}
            								}
HXDLIN( 311)								{
HXLINE( 311)									int y13 = ((y10 + 2) + this4->width);
HXDLIN( 311)									int y14 = (this4->height - 1);
HXDLIN( 311)									::Dynamic this111 = this4->image;
HXDLIN( 311)									int index18;
HXDLIN( 311)									if (this4->useVirtualPos) {
HXLINE( 311)										index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            									}
            									else {
HXLINE( 311)										index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            									}
HXDLIN( 311)									int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 311)									int color10;
HXDLIN( 311)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)										color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            									}
            									else {
HXLINE( 311)										color10 = c17;
            									}
HXDLIN( 311)									{
HXLINE( 311)										int c18 = color10;
HXDLIN( 311)										bool here28;
HXDLIN( 311)										if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 311)											here28 = img->transparent;
            										}
            										else {
HXLINE( 311)											here28 = false;
            										}
HXDLIN( 311)										if (here28) {
HXLINE( 311)											int location8;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 311)												location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            											}
HXDLIN( 311)											int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 311)											int this113;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												this113 = this112;
            											}
HXDLIN( 311)											Float a110;
HXDLIN( 311)											int this114 = ((this113 >> 24) & 255);
HXDLIN( 311)											if ((this114 == 0)) {
HXLINE( 311)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r18;
HXDLIN( 311)											int this115 = ((this113 >> 16) & 255);
HXDLIN( 311)											if ((this115 == 0)) {
HXLINE( 311)												r18 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g18;
HXDLIN( 311)											int this116 = ((this113 >> 8) & 255);
HXDLIN( 311)											if ((this116 == 0)) {
HXLINE( 311)												g18 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b111;
HXDLIN( 311)											int this117 = (this113 & 255);
HXDLIN( 311)											if ((this117 == 0)) {
HXLINE( 311)												b111 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a28;
HXDLIN( 311)											int this118 = ((color10 >> 24) & 255);
HXDLIN( 311)											if ((this118 == 0)) {
HXLINE( 311)												a28 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float r28;
HXDLIN( 311)											int this119 = ((color10 >> 16) & 255);
HXDLIN( 311)											if ((this119 == 0)) {
HXLINE( 311)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float g28;
HXDLIN( 311)											int this120 = ((color10 >> 8) & 255);
HXDLIN( 311)											if ((this120 == 0)) {
HXLINE( 311)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float b29;
HXDLIN( 311)											int this121 = (color10 & 255);
HXDLIN( 311)											if ((this121 == 0)) {
HXLINE( 311)												b29 = ((Float)0.);
            											}
            											else {
HXLINE( 311)												b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            											}
HXDLIN( 311)											Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 311)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 311)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 311)											int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 311)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 311)											int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 311)											{
HXLINE( 311)												int here29;
HXDLIN( 311)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)													here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 311)													here29 = blended8;
            												}
HXDLIN( 311)												::iterMagic::Iimg_obj::set(img->image,location8,here29);
            											}
            										}
            										else {
HXLINE( 311)											::Dynamic this122 = img->image;
HXDLIN( 311)											int index19;
HXDLIN( 311)											if (img->useVirtualPos) {
HXLINE( 311)												index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            											}
            											else {
HXLINE( 311)												index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            											}
HXDLIN( 311)											int here30;
HXDLIN( 311)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 311)												here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE( 311)												here30 = c18;
            											}
HXDLIN( 311)											::iterMagic::Iimg_obj::set(this122,index19,here30);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 311)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXLINE( 315)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 315)				int width2 = (this123->width + 4);
HXDLIN( 315)				int height2 = (this123->height + 4);
HXDLIN( 315)				 ::Dynamic imageType2 = null();
HXDLIN( 315)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 315)				if (::hx::IsNull( imageType2 )) {
HXLINE( 315)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXDLIN( 315)				::Dynamic here31;
HXDLIN( 315)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 315)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 315)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 315)						{
HXLINE( 315)							b31->width = width2;
HXDLIN( 315)							b31->height = height2;
HXDLIN( 315)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 315)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 315)							{
HXLINE( 315)								int len4 = b31->length;
HXDLIN( 315)								int w2 = 0;
HXDLIN( 315)								{
HXLINE( 315)									int _g48 = 0;
HXDLIN( 315)									int _g49 = b31->height;
HXDLIN( 315)									while((_g48 < _g49)){
HXLINE( 315)										_g48 = (_g48 + 1);
HXDLIN( 315)										int y15 = (_g48 - 1);
HXDLIN( 315)										{
HXLINE( 315)											int _g50 = 0;
HXDLIN( 315)											int _g51 = b31->width;
HXDLIN( 315)											while((_g50 < _g51)){
HXLINE( 315)												_g50 = (_g50 + 1);
HXDLIN( 315)												int x15 = (_g50 - 1);
HXDLIN( 315)												{
HXLINE( 315)													w2 = (w2 + 1);
HXDLIN( 315)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 315)												{
HXLINE( 315)													w2 = (w2 + 1);
HXDLIN( 315)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 315)												{
HXLINE( 315)													w2 = (w2 + 1);
HXDLIN( 315)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 315)												{
HXLINE( 315)													w2 = (w2 + 1);
HXDLIN( 315)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 315)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXLINE( 315)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 315)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 315)						{
HXLINE( 315)							a29->width = width2;
HXDLIN( 315)							a29->height = height2;
HXDLIN( 315)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 315)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 315)							{
HXLINE( 315)								int _g52 = 0;
HXDLIN( 315)								int _g53 = a29->length;
HXDLIN( 315)								while((_g52 < _g53)){
HXLINE( 315)									_g52 = (_g52 + 1);
HXDLIN( 315)									int i12 = (_g52 - 1);
HXDLIN( 315)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 315)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 315)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 315)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 315)						{
HXLINE( 315)							b32->width = width2;
HXDLIN( 315)							b32->height = height2;
HXDLIN( 315)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 315)							int size2 = (b32->length * 4);
HXDLIN( 315)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 315)							{
HXLINE( 315)								int _g54 = 0;
HXDLIN( 315)								int _g55 = b32->length;
HXDLIN( 315)								while((_g54 < _g55)){
HXLINE( 315)									_g54 = (_g54 + 1);
HXDLIN( 315)									int i13 = (_g54 - 1);
HXDLIN( 315)									{
HXLINE( 315)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 315)										bool here32;
HXDLIN( 315)										if ((i13 >= 0)) {
HXLINE( 315)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXLINE( 315)											here32 = false;
            										}
HXDLIN( 315)										if (here32) {
HXLINE( 315)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 315)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 315)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 315)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 315)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 315)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 315)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXLINE( 315)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 315)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 315)						{
HXLINE( 315)							v3->width = width2;
HXDLIN( 315)							v3->height = height2;
HXDLIN( 315)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 315)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 315)							{
HXLINE( 315)								int _g56 = 0;
HXDLIN( 315)								int _g57 = v3->length;
HXDLIN( 315)								while((_g56 < _g57)){
HXLINE( 315)									_g56 = (_g56 + 1);
HXDLIN( 315)									int i14 = (_g56 - 1);
HXDLIN( 315)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 315)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 315)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 315)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 315)						{
HXLINE( 315)							b33->width = width2;
HXDLIN( 315)							b33->height = height2;
HXDLIN( 315)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 315)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 315)							{
HXLINE( 315)								int len5 = b33->length;
HXDLIN( 315)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 315)								if (::hx::IsNull( d2->head )) {
HXLINE( 315)									int _g58 = 0;
HXDLIN( 315)									int _g59 = len5;
HXDLIN( 315)									while((_g58 < _g59)){
HXLINE( 315)										_g58 = (_g58 + 1);
HXDLIN( 315)										int i15 = (_g58 - 1);
HXDLIN( 315)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 315)									int _g60 = 0;
HXDLIN( 315)									int _g61 = len5;
HXDLIN( 315)									while((_g60 < _g61)){
HXLINE( 315)										_g60 = (_g60 + 1);
HXDLIN( 315)										int i16 = (_g60 - 1);
HXDLIN( 315)										{
HXLINE( 315)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 315)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 315)											{
HXLINE( 315)												int _g62 = 0;
HXDLIN( 315)												int _g63 = i16;
HXDLIN( 315)												while((_g62 < _g63)){
HXLINE( 315)													_g62 = (_g62 + 1);
HXDLIN( 315)													int i17 = (_g62 - 1);
HXDLIN( 315)													prev2 = l2;
HXDLIN( 315)													l2 = l2->next;
            												}
            											}
HXDLIN( 315)											if (::hx::IsNull( prev2 )) {
HXLINE( 315)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 315)												l2 = null();
            											}
            											else {
HXLINE( 315)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 315)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 315)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 315)				this124->image = here31;
HXDLIN( 315)				this124->width = width2;
HXDLIN( 315)				this124->height = height2;
HXDLIN( 315)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 315)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 315)				{
HXLINE( 315)					bool forceClear1 = false;
HXDLIN( 315)					{
HXLINE( 315)						int _g64 = 0;
HXDLIN( 315)						int _g65 = this123->height;
HXDLIN( 315)						while((_g64 < _g65)){
HXLINE( 315)							_g64 = (_g64 + 1);
HXDLIN( 315)							int dy1 = (_g64 - 1);
HXDLIN( 315)							{
HXLINE( 315)								int _g66 = 0;
HXDLIN( 315)								int _g67 = this123->width;
HXDLIN( 315)								while((_g66 < _g67)){
HXLINE( 315)									_g66 = (_g66 + 1);
HXDLIN( 315)									int dx1 = (_g66 - 1);
HXDLIN( 315)									::Dynamic this126 = this123->image;
HXDLIN( 315)									int index20;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            									}
HXDLIN( 315)									int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 315)									int col1;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										col1 = c19;
            									}
HXDLIN( 315)									bool here33;
HXDLIN( 315)									if (this123->useMask) {
HXLINE( 315)										here33 = ::hx::IsNotNull( this123->mask );
            									}
            									else {
HXLINE( 315)										here33 = false;
            									}
HXDLIN( 315)									if (here33) {
HXLINE( 315)										 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 315)										::Dynamic this128 = this127->image;
HXDLIN( 315)										int index21;
HXDLIN( 315)										if (this127->useVirtualPos) {
HXLINE( 315)											index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            										}
            										else {
HXLINE( 315)											index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            										}
HXDLIN( 315)										int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 315)										int v4;
HXDLIN( 315)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)											v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXLINE( 315)											v4 = c20;
            										}
HXDLIN( 315)										int maskPixel1 = v4;
HXDLIN( 315)										int this129 = col1;
HXDLIN( 315)										if ((maskPixel1 == 0)) {
HXLINE( 315)											col1 = this129;
            										}
            										else {
HXLINE( 315)											Float m02;
HXDLIN( 315)											int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 315)											if ((this130 == 0)) {
HXLINE( 315)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												m02 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float m11;
HXDLIN( 315)											int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 315)											if ((this131 == 0)) {
HXLINE( 315)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float m21;
HXDLIN( 315)											int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 315)											if ((this132 == 0)) {
HXLINE( 315)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float m31;
HXDLIN( 315)											int this133 = (maskPixel1 & 255);
HXDLIN( 315)											if ((this133 == 0)) {
HXLINE( 315)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 315)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 315)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 315)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 315)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 315)									if ((col1 != 0)) {
HXLINE( 315)										int x16 = (2 + dx1);
HXDLIN( 315)										int y16 = (2 + dy1);
HXDLIN( 315)										int c21 = col1;
HXDLIN( 315)										bool here34;
HXDLIN( 315)										if ((((c21 >> 24) & 255) < 254)) {
HXLINE( 315)											here34 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here34 = false;
            										}
HXDLIN( 315)										if (here34) {
HXLINE( 315)											int location9;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            											}
HXDLIN( 315)											int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 315)											int this135;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this135 = this134;
            											}
HXDLIN( 315)											Float a111;
HXDLIN( 315)											int this136 = ((this135 >> 24) & 255);
HXDLIN( 315)											if ((this136 == 0)) {
HXLINE( 315)												a111 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r19;
HXDLIN( 315)											int this137 = ((this135 >> 16) & 255);
HXDLIN( 315)											if ((this137 == 0)) {
HXLINE( 315)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g19;
HXDLIN( 315)											int this138 = ((this135 >> 8) & 255);
HXDLIN( 315)											if ((this138 == 0)) {
HXLINE( 315)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b112;
HXDLIN( 315)											int this139 = (this135 & 255);
HXDLIN( 315)											if ((this139 == 0)) {
HXLINE( 315)												b112 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a210;
HXDLIN( 315)											int this140 = ((col1 >> 24) & 255);
HXDLIN( 315)											if ((this140 == 0)) {
HXLINE( 315)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r29;
HXDLIN( 315)											int this141 = ((col1 >> 16) & 255);
HXDLIN( 315)											if ((this141 == 0)) {
HXLINE( 315)												r29 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g29;
HXDLIN( 315)											int this142 = ((col1 >> 8) & 255);
HXDLIN( 315)											if ((this142 == 0)) {
HXLINE( 315)												g29 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b210;
HXDLIN( 315)											int this143 = (col1 & 255);
HXDLIN( 315)											if ((this143 == 0)) {
HXLINE( 315)												b210 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 315)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 315)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 315)											int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 315)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 315)											int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 315)											{
HXLINE( 315)												int here35;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here35 = blended9;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this144 = img1->image;
HXDLIN( 315)											int index22;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            											}
HXDLIN( 315)											int here36;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here36 = c21;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this144,index22,here36);
            										}
            									}
            									else {
HXLINE( 315)										if (forceClear1) {
HXLINE( 315)											::Dynamic this145 = img1->image;
HXDLIN( 315)											int x17 = (2 + dx1);
HXDLIN( 315)											int y17 = (2 + dy1);
HXDLIN( 315)											int index23;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this145,index23,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 315)				{
HXLINE( 315)					int _g68 = 0;
HXDLIN( 315)					int _g69 = this123->width;
HXDLIN( 315)					while((_g68 < _g69)){
HXLINE( 315)						_g68 = (_g68 + 1);
HXDLIN( 315)						int x18 = (_g68 - 1);
HXDLIN( 315)						{
HXLINE( 315)							int _g70 = 0;
HXDLIN( 315)							int _g71 = 2;
HXDLIN( 315)							while((_g70 < _g71)){
HXLINE( 315)								_g70 = (_g70 + 1);
HXDLIN( 315)								int y18 = (_g70 - 1);
HXDLIN( 315)								{
HXLINE( 315)									int x19 = (x18 + 2);
HXDLIN( 315)									int y19 = (((this123->height - 1) - 2) + y18);
HXDLIN( 315)									::Dynamic this146 = this123->image;
HXDLIN( 315)									int index24;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            									}
HXDLIN( 315)									int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 315)									int color11;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color11 = c22;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c23 = color11;
HXDLIN( 315)										bool here37;
HXDLIN( 315)										if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 315)											here37 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here37 = false;
            										}
HXDLIN( 315)										if (here37) {
HXLINE( 315)											int location10;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            											}
HXDLIN( 315)											int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 315)											int this148;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this148 = this147;
            											}
HXDLIN( 315)											Float a112;
HXDLIN( 315)											int this149 = ((this148 >> 24) & 255);
HXDLIN( 315)											if ((this149 == 0)) {
HXLINE( 315)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r110;
HXDLIN( 315)											int this150 = ((this148 >> 16) & 255);
HXDLIN( 315)											if ((this150 == 0)) {
HXLINE( 315)												r110 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g110;
HXDLIN( 315)											int this151 = ((this148 >> 8) & 255);
HXDLIN( 315)											if ((this151 == 0)) {
HXLINE( 315)												g110 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b113;
HXDLIN( 315)											int this152 = (this148 & 255);
HXDLIN( 315)											if ((this152 == 0)) {
HXLINE( 315)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a211;
HXDLIN( 315)											int this153 = ((color11 >> 24) & 255);
HXDLIN( 315)											if ((this153 == 0)) {
HXLINE( 315)												a211 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r210;
HXDLIN( 315)											int this154 = ((color11 >> 16) & 255);
HXDLIN( 315)											if ((this154 == 0)) {
HXLINE( 315)												r210 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g210;
HXDLIN( 315)											int this155 = ((color11 >> 8) & 255);
HXDLIN( 315)											if ((this155 == 0)) {
HXLINE( 315)												g210 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b211;
HXDLIN( 315)											int this156 = (color11 & 255);
HXDLIN( 315)											if ((this156 == 0)) {
HXLINE( 315)												b211 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 315)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 315)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 315)											int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 315)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 315)											int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 315)											{
HXLINE( 315)												int here38;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here38 = blended10;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this157 = img1->image;
HXDLIN( 315)											int index25;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            											}
HXDLIN( 315)											int here39;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here39 = c23;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this157,index25,here39);
            										}
            									}
            								}
HXDLIN( 315)								{
HXLINE( 315)									int x20 = (x18 + 2);
HXDLIN( 315)									int y20 = ((img1->height - y18) - 1);
HXDLIN( 315)									int y21 = (2 - y18);
HXDLIN( 315)									::Dynamic this158 = this123->image;
HXDLIN( 315)									int index26;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            									}
HXDLIN( 315)									int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 315)									int color12;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color12 = c24;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c25 = color12;
HXDLIN( 315)										bool here40;
HXDLIN( 315)										if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 315)											here40 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here40 = false;
            										}
HXDLIN( 315)										if (here40) {
HXLINE( 315)											int location11;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            											}
HXDLIN( 315)											int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 315)											int this160;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this160 = this159;
            											}
HXDLIN( 315)											Float a113;
HXDLIN( 315)											int this161 = ((this160 >> 24) & 255);
HXDLIN( 315)											if ((this161 == 0)) {
HXLINE( 315)												a113 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r111;
HXDLIN( 315)											int this162 = ((this160 >> 16) & 255);
HXDLIN( 315)											if ((this162 == 0)) {
HXLINE( 315)												r111 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g111;
HXDLIN( 315)											int this163 = ((this160 >> 8) & 255);
HXDLIN( 315)											if ((this163 == 0)) {
HXLINE( 315)												g111 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b114;
HXDLIN( 315)											int this164 = (this160 & 255);
HXDLIN( 315)											if ((this164 == 0)) {
HXLINE( 315)												b114 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a212;
HXDLIN( 315)											int this165 = ((color12 >> 24) & 255);
HXDLIN( 315)											if ((this165 == 0)) {
HXLINE( 315)												a212 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r211;
HXDLIN( 315)											int this166 = ((color12 >> 16) & 255);
HXDLIN( 315)											if ((this166 == 0)) {
HXLINE( 315)												r211 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g211;
HXDLIN( 315)											int this167 = ((color12 >> 8) & 255);
HXDLIN( 315)											if ((this167 == 0)) {
HXLINE( 315)												g211 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b212;
HXDLIN( 315)											int this168 = (color12 & 255);
HXDLIN( 315)											if ((this168 == 0)) {
HXLINE( 315)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 315)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 315)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 315)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 315)											int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 315)											int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 315)											{
HXLINE( 315)												int here41;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here41 = blended11;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this169 = img1->image;
HXDLIN( 315)											int index27;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            											}
HXDLIN( 315)											int here42;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here42 = c25;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this169,index27,here42);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 315)				{
HXLINE( 315)					int _g72 = 0;
HXDLIN( 315)					int _g73 = this123->height;
HXDLIN( 315)					while((_g72 < _g73)){
HXLINE( 315)						_g72 = (_g72 + 1);
HXDLIN( 315)						int y22 = (_g72 - 1);
HXDLIN( 315)						{
HXLINE( 315)							int _g74 = 0;
HXDLIN( 315)							int _g75 = 2;
HXDLIN( 315)							while((_g74 < _g75)){
HXLINE( 315)								_g74 = (_g74 + 1);
HXDLIN( 315)								int x21 = (_g74 - 1);
HXDLIN( 315)								{
HXLINE( 315)									int y23 = (y22 + 2);
HXDLIN( 315)									int x22 = (((this123->width - 1) - 2) + x21);
HXDLIN( 315)									::Dynamic this170 = this123->image;
HXDLIN( 315)									int index28;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            									}
HXDLIN( 315)									int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 315)									int color13;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color13 = c26;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c27 = color13;
HXDLIN( 315)										bool here43;
HXDLIN( 315)										if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 315)											here43 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here43 = false;
            										}
HXDLIN( 315)										if (here43) {
HXLINE( 315)											int location12;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            											}
HXDLIN( 315)											int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 315)											int this172;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this172 = this171;
            											}
HXDLIN( 315)											Float a114;
HXDLIN( 315)											int this173 = ((this172 >> 24) & 255);
HXDLIN( 315)											if ((this173 == 0)) {
HXLINE( 315)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r112;
HXDLIN( 315)											int this174 = ((this172 >> 16) & 255);
HXDLIN( 315)											if ((this174 == 0)) {
HXLINE( 315)												r112 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g112;
HXDLIN( 315)											int this175 = ((this172 >> 8) & 255);
HXDLIN( 315)											if ((this175 == 0)) {
HXLINE( 315)												g112 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b115;
HXDLIN( 315)											int this176 = (this172 & 255);
HXDLIN( 315)											if ((this176 == 0)) {
HXLINE( 315)												b115 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a213;
HXDLIN( 315)											int this177 = ((color13 >> 24) & 255);
HXDLIN( 315)											if ((this177 == 0)) {
HXLINE( 315)												a213 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r212;
HXDLIN( 315)											int this178 = ((color13 >> 16) & 255);
HXDLIN( 315)											if ((this178 == 0)) {
HXLINE( 315)												r212 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g212;
HXDLIN( 315)											int this179 = ((color13 >> 8) & 255);
HXDLIN( 315)											if ((this179 == 0)) {
HXLINE( 315)												g212 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b213;
HXDLIN( 315)											int this180 = (color13 & 255);
HXDLIN( 315)											if ((this180 == 0)) {
HXLINE( 315)												b213 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 315)											int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 315)											int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 315)											int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 315)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 315)											int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 315)											{
HXLINE( 315)												int here44;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here44 = blended12;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this181 = img1->image;
HXDLIN( 315)											int index29;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            											}
HXDLIN( 315)											int here45;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here45 = c27;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this181,index29,here45);
            										}
            									}
            								}
HXDLIN( 315)								{
HXLINE( 315)									int x23 = ((img1->width - x21) - 1);
HXDLIN( 315)									int y24 = (y22 + 2);
HXDLIN( 315)									int x24 = (2 - x21);
HXDLIN( 315)									::Dynamic this182 = this123->image;
HXDLIN( 315)									int index30;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            									}
HXDLIN( 315)									int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 315)									int color14;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color14 = c28;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c29 = color14;
HXDLIN( 315)										bool here46;
HXDLIN( 315)										if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 315)											here46 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here46 = false;
            										}
HXDLIN( 315)										if (here46) {
HXLINE( 315)											int location13;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            											}
HXDLIN( 315)											int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 315)											int this184;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this184 = this183;
            											}
HXDLIN( 315)											Float a115;
HXDLIN( 315)											int this185 = ((this184 >> 24) & 255);
HXDLIN( 315)											if ((this185 == 0)) {
HXLINE( 315)												a115 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r113;
HXDLIN( 315)											int this186 = ((this184 >> 16) & 255);
HXDLIN( 315)											if ((this186 == 0)) {
HXLINE( 315)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g113;
HXDLIN( 315)											int this187 = ((this184 >> 8) & 255);
HXDLIN( 315)											if ((this187 == 0)) {
HXLINE( 315)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b116;
HXDLIN( 315)											int this188 = (this184 & 255);
HXDLIN( 315)											if ((this188 == 0)) {
HXLINE( 315)												b116 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a214;
HXDLIN( 315)											int this189 = ((color14 >> 24) & 255);
HXDLIN( 315)											if ((this189 == 0)) {
HXLINE( 315)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r213;
HXDLIN( 315)											int this190 = ((color14 >> 16) & 255);
HXDLIN( 315)											if ((this190 == 0)) {
HXLINE( 315)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g213;
HXDLIN( 315)											int this191 = ((color14 >> 8) & 255);
HXDLIN( 315)											if ((this191 == 0)) {
HXLINE( 315)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b214;
HXDLIN( 315)											int this192 = (color14 & 255);
HXDLIN( 315)											if ((this192 == 0)) {
HXLINE( 315)												b214 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 315)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 315)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 315)											int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 315)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 315)											int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 315)											{
HXLINE( 315)												int here47;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here47 = blended13;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this193 = img1->image;
HXDLIN( 315)											int index31;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            											}
HXDLIN( 315)											int here48;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here48 = c29;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this193,index31,here48);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 315)				{
HXLINE( 315)					int _g76 = 0;
HXDLIN( 315)					int _g77 = 2;
HXDLIN( 315)					while((_g76 < _g77)){
HXLINE( 315)						_g76 = (_g76 + 1);
HXDLIN( 315)						int x25 = (_g76 - 1);
HXDLIN( 315)						{
HXLINE( 315)							int _g78 = 0;
HXDLIN( 315)							int _g79 = 2;
HXDLIN( 315)							while((_g78 < _g79)){
HXLINE( 315)								_g78 = (_g78 + 1);
HXDLIN( 315)								int y25 = (_g78 - 1);
HXDLIN( 315)								{
HXLINE( 315)									int x26 = (((this123->width - 1) - 2) + x25);
HXDLIN( 315)									int y26 = (((this123->height - 1) - 2) + y25);
HXDLIN( 315)									::Dynamic this194 = this123->image;
HXDLIN( 315)									int index32;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            									}
HXDLIN( 315)									int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 315)									int color15;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color15 = c30;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c31 = color15;
HXDLIN( 315)										bool here49;
HXDLIN( 315)										if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 315)											here49 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here49 = false;
            										}
HXDLIN( 315)										if (here49) {
HXLINE( 315)											int location14;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            											}
HXDLIN( 315)											int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 315)											int this196;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this196 = this195;
            											}
HXDLIN( 315)											Float a116;
HXDLIN( 315)											int this197 = ((this196 >> 24) & 255);
HXDLIN( 315)											if ((this197 == 0)) {
HXLINE( 315)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r114;
HXDLIN( 315)											int this198 = ((this196 >> 16) & 255);
HXDLIN( 315)											if ((this198 == 0)) {
HXLINE( 315)												r114 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g114;
HXDLIN( 315)											int this199 = ((this196 >> 8) & 255);
HXDLIN( 315)											if ((this199 == 0)) {
HXLINE( 315)												g114 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b117;
HXDLIN( 315)											int this200 = (this196 & 255);
HXDLIN( 315)											if ((this200 == 0)) {
HXLINE( 315)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a215;
HXDLIN( 315)											int this201 = ((color15 >> 24) & 255);
HXDLIN( 315)											if ((this201 == 0)) {
HXLINE( 315)												a215 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r214;
HXDLIN( 315)											int this202 = ((color15 >> 16) & 255);
HXDLIN( 315)											if ((this202 == 0)) {
HXLINE( 315)												r214 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g214;
HXDLIN( 315)											int this203 = ((color15 >> 8) & 255);
HXDLIN( 315)											if ((this203 == 0)) {
HXLINE( 315)												g214 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b215;
HXDLIN( 315)											int this204 = (color15 & 255);
HXDLIN( 315)											if ((this204 == 0)) {
HXLINE( 315)												b215 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 315)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 315)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 315)											int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 315)											int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 315)											int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 315)											{
HXLINE( 315)												int here50;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here50 = blended14;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this205 = img1->image;
HXDLIN( 315)											int index33;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            											}
HXDLIN( 315)											int here51;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here51 = c31;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this205,index33,here51);
            										}
            									}
            								}
HXDLIN( 315)								{
HXLINE( 315)									int x27 = ((x25 + 2) + this123->width);
HXDLIN( 315)									int y27 = (((this123->height - 1) - 2) + y25);
HXDLIN( 315)									::Dynamic this206 = this123->image;
HXDLIN( 315)									int index34;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            									}
HXDLIN( 315)									int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 315)									int color16;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color16 = c32;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c33 = color16;
HXDLIN( 315)										bool here52;
HXDLIN( 315)										if ((((c33 >> 24) & 255) < 254)) {
HXLINE( 315)											here52 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here52 = false;
            										}
HXDLIN( 315)										if (here52) {
HXLINE( 315)											int location15;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            											}
HXDLIN( 315)											int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 315)											int this208;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this208 = this207;
            											}
HXDLIN( 315)											Float a117;
HXDLIN( 315)											int this209 = ((this208 >> 24) & 255);
HXDLIN( 315)											if ((this209 == 0)) {
HXLINE( 315)												a117 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r115;
HXDLIN( 315)											int this210 = ((this208 >> 16) & 255);
HXDLIN( 315)											if ((this210 == 0)) {
HXLINE( 315)												r115 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g115;
HXDLIN( 315)											int this211 = ((this208 >> 8) & 255);
HXDLIN( 315)											if ((this211 == 0)) {
HXLINE( 315)												g115 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b118;
HXDLIN( 315)											int this212 = (this208 & 255);
HXDLIN( 315)											if ((this212 == 0)) {
HXLINE( 315)												b118 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a216;
HXDLIN( 315)											int this213 = ((color16 >> 24) & 255);
HXDLIN( 315)											if ((this213 == 0)) {
HXLINE( 315)												a216 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r215;
HXDLIN( 315)											int this214 = ((color16 >> 16) & 255);
HXDLIN( 315)											if ((this214 == 0)) {
HXLINE( 315)												r215 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g215;
HXDLIN( 315)											int this215 = ((color16 >> 8) & 255);
HXDLIN( 315)											if ((this215 == 0)) {
HXLINE( 315)												g215 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b216;
HXDLIN( 315)											int this216 = (color16 & 255);
HXDLIN( 315)											if ((this216 == 0)) {
HXLINE( 315)												b216 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 315)											int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 315)											int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 315)											int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 315)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 315)											int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 315)											{
HXLINE( 315)												int here53;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here53 = blended15;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this217 = img1->image;
HXDLIN( 315)											int index35;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            											}
HXDLIN( 315)											int here54;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here54 = c33;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this217,index35,here54);
            										}
            									}
            								}
HXDLIN( 315)								{
HXLINE( 315)									int x28 = ((x25 + 2) + this123->width);
HXDLIN( 315)									int y28 = ((y25 + 2) + this123->height);
HXDLIN( 315)									::Dynamic this218 = this123->image;
HXDLIN( 315)									int index36;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            									}
HXDLIN( 315)									int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 315)									int color17;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color17 = c34;
            									}
HXDLIN( 315)									int color18 = color17;
HXDLIN( 315)									{
HXLINE( 315)										int c35 = color18;
HXDLIN( 315)										bool here55;
HXDLIN( 315)										if ((((c35 >> 24) & 255) < 254)) {
HXLINE( 315)											here55 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here55 = false;
            										}
HXDLIN( 315)										if (here55) {
HXLINE( 315)											int location16;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            											}
HXDLIN( 315)											int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 315)											int this220;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this220 = this219;
            											}
HXDLIN( 315)											Float a118;
HXDLIN( 315)											int this221 = ((this220 >> 24) & 255);
HXDLIN( 315)											if ((this221 == 0)) {
HXLINE( 315)												a118 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r116;
HXDLIN( 315)											int this222 = ((this220 >> 16) & 255);
HXDLIN( 315)											if ((this222 == 0)) {
HXLINE( 315)												r116 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g116;
HXDLIN( 315)											int this223 = ((this220 >> 8) & 255);
HXDLIN( 315)											if ((this223 == 0)) {
HXLINE( 315)												g116 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b119;
HXDLIN( 315)											int this224 = (this220 & 255);
HXDLIN( 315)											if ((this224 == 0)) {
HXLINE( 315)												b119 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a217;
HXDLIN( 315)											int this225 = ((color18 >> 24) & 255);
HXDLIN( 315)											if ((this225 == 0)) {
HXLINE( 315)												a217 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r216;
HXDLIN( 315)											int this226 = ((color18 >> 16) & 255);
HXDLIN( 315)											if ((this226 == 0)) {
HXLINE( 315)												r216 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g216;
HXDLIN( 315)											int this227 = ((color18 >> 8) & 255);
HXDLIN( 315)											if ((this227 == 0)) {
HXLINE( 315)												g216 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b217;
HXDLIN( 315)											int this228 = (color18 & 255);
HXDLIN( 315)											if ((this228 == 0)) {
HXLINE( 315)												b217 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 315)											int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 315)											int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 315)											int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 315)											int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 315)											int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 315)											{
HXLINE( 315)												int here56;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here56 = blended16;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this229 = img1->image;
HXDLIN( 315)											int index37;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            											}
HXDLIN( 315)											int here57;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here57 = c35;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this229,index37,here57);
            										}
            									}
            								}
HXDLIN( 315)								{
HXLINE( 315)									int y29 = ((y25 + 2) + this123->width);
HXDLIN( 315)									int x29 = (((this123->width - 1) - 2) + x25);
HXDLIN( 315)									::Dynamic this230 = this123->image;
HXDLIN( 315)									int index38;
HXDLIN( 315)									if (this123->useVirtualPos) {
HXLINE( 315)										index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            									}
            									else {
HXLINE( 315)										index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            									}
HXDLIN( 315)									int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 315)									int color19;
HXDLIN( 315)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)										color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            									}
            									else {
HXLINE( 315)										color19 = c36;
            									}
HXDLIN( 315)									{
HXLINE( 315)										int c37 = color19;
HXDLIN( 315)										bool here58;
HXDLIN( 315)										if ((((c37 >> 24) & 255) < 254)) {
HXLINE( 315)											here58 = img1->transparent;
            										}
            										else {
HXLINE( 315)											here58 = false;
            										}
HXDLIN( 315)										if (here58) {
HXLINE( 315)											int location17;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            											}
HXDLIN( 315)											int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 315)											int this232;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												this232 = this231;
            											}
HXDLIN( 315)											Float a119;
HXDLIN( 315)											int this233 = ((this232 >> 24) & 255);
HXDLIN( 315)											if ((this233 == 0)) {
HXLINE( 315)												a119 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r117;
HXDLIN( 315)											int this234 = ((this232 >> 16) & 255);
HXDLIN( 315)											if ((this234 == 0)) {
HXLINE( 315)												r117 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g117;
HXDLIN( 315)											int this235 = ((this232 >> 8) & 255);
HXDLIN( 315)											if ((this235 == 0)) {
HXLINE( 315)												g117 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b120;
HXDLIN( 315)											int this236 = (this232 & 255);
HXDLIN( 315)											if ((this236 == 0)) {
HXLINE( 315)												b120 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a218;
HXDLIN( 315)											int this237 = ((color19 >> 24) & 255);
HXDLIN( 315)											if ((this237 == 0)) {
HXLINE( 315)												a218 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float r217;
HXDLIN( 315)											int this238 = ((color19 >> 16) & 255);
HXDLIN( 315)											if ((this238 == 0)) {
HXLINE( 315)												r217 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float g217;
HXDLIN( 315)											int this239 = ((color19 >> 8) & 255);
HXDLIN( 315)											if ((this239 == 0)) {
HXLINE( 315)												g217 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float b218;
HXDLIN( 315)											int this240 = (color19 & 255);
HXDLIN( 315)											if ((this240 == 0)) {
HXLINE( 315)												b218 = ((Float)0.);
            											}
            											else {
HXLINE( 315)												b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            											}
HXDLIN( 315)											Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 315)											int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 315)											int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 315)											int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 315)											int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 315)											int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 315)											{
HXLINE( 315)												int here59;
HXDLIN( 315)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)													here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            												}
            												else {
HXLINE( 315)													here59 = blended17;
            												}
HXDLIN( 315)												::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            											}
            										}
            										else {
HXLINE( 315)											::Dynamic this241 = img1->image;
HXDLIN( 315)											int index39;
HXDLIN( 315)											if (img1->useVirtualPos) {
HXLINE( 315)												index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            											}
            											else {
HXLINE( 315)												index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            											}
HXDLIN( 315)											int here60;
HXDLIN( 315)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 315)												here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            											}
            											else {
HXLINE( 315)												here60 = c37;
            											}
HXDLIN( 315)											::iterMagic::Iimg_obj::set(this241,index39,here60);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 315)				here = img1;
            			}
            			break;
            		}
HXLINE( 318)		{
HXLINE( 318)			int _g80 = 2;
HXDLIN( 318)			int _g81 = (this1->height - 3);
HXDLIN( 318)			while((_g80 < _g81)){
HXLINE( 318)				_g80 = (_g80 + 1);
HXDLIN( 318)				int y30 = (_g80 - 1);
HXLINE( 319)				{
HXLINE( 319)					int _g82 = 2;
HXDLIN( 319)					int _g83 = (this1->width - 3);
HXDLIN( 319)					while((_g82 < _g83)){
HXLINE( 319)						_g82 = (_g82 + 1);
HXDLIN( 319)						int x30 = (_g82 - 1);
HXLINE( 320)						if ((x30 == 2)) {
HXLINE( 322)							int x31 = (x30 - 2);
HXDLIN( 322)							int y31 = (y30 - 2);
HXDLIN( 322)							::Dynamic this242 = here->image;
HXDLIN( 322)							int index40;
HXDLIN( 322)							if (here->useVirtualPos) {
HXLINE( 322)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 322)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 322)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 322)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 322)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXLINE( 322)								a0 = c38;
            							}
HXLINE( 323)							int x32 = (x30 - 1);
HXDLIN( 323)							int y32 = (y30 - 2);
HXDLIN( 323)							::Dynamic this243 = here->image;
HXDLIN( 323)							int index41;
HXDLIN( 323)							if (here->useVirtualPos) {
HXLINE( 323)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXLINE( 323)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x32)) ));
            							}
HXDLIN( 323)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 323)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 323)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXLINE( 323)								b0 = c39;
            							}
HXLINE( 324)							int y33 = (y30 - 2);
HXDLIN( 324)							::Dynamic this244 = here->image;
HXDLIN( 324)							int index42;
HXDLIN( 324)							if (here->useVirtualPos) {
HXLINE( 324)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 324)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x30)) ));
            							}
HXDLIN( 324)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 324)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 324)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXLINE( 324)								c0 = c40;
            							}
HXLINE( 325)							int x33 = (x30 + 1);
HXDLIN( 325)							int y34 = (y30 - 2);
HXDLIN( 325)							::Dynamic this245 = here->image;
HXDLIN( 325)							int index43;
HXDLIN( 325)							if (here->useVirtualPos) {
HXLINE( 325)								index43 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXLINE( 325)								index43 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x33)) ));
            							}
HXDLIN( 325)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 325)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 325)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXLINE( 325)								d0 = c41;
            							}
HXLINE( 326)							int x34 = (x30 + 2);
HXDLIN( 326)							int y35 = (y30 - 2);
HXDLIN( 326)							::Dynamic this246 = here->image;
HXDLIN( 326)							int index44;
HXDLIN( 326)							if (here->useVirtualPos) {
HXLINE( 326)								index44 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXLINE( 326)								index44 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x34)) ));
            							}
HXDLIN( 326)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 326)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 326)								e0 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXLINE( 326)								e0 = c42;
            							}
HXLINE( 328)							int x35 = (x30 - 2);
HXDLIN( 328)							int y36 = (y30 - 1);
HXDLIN( 328)							::Dynamic this247 = here->image;
HXDLIN( 328)							int index45;
HXDLIN( 328)							if (here->useVirtualPos) {
HXLINE( 328)								index45 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXLINE( 328)								index45 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x35)) ));
            							}
HXDLIN( 328)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 328)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 328)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXLINE( 328)								f0 = c43;
            							}
HXLINE( 329)							int x36 = (x30 - 1);
HXDLIN( 329)							int y37 = (y30 - 1);
HXDLIN( 329)							::Dynamic this248 = here->image;
HXDLIN( 329)							int index46;
HXDLIN( 329)							if (here->useVirtualPos) {
HXLINE( 329)								index46 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXLINE( 329)								index46 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x36)) ));
            							}
HXDLIN( 329)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 329)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 329)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXLINE( 329)								g0 = c44;
            							}
HXLINE( 330)							int y38 = (y30 - 1);
HXDLIN( 330)							::Dynamic this249 = here->image;
HXDLIN( 330)							int index47;
HXDLIN( 330)							if (here->useVirtualPos) {
HXLINE( 330)								index47 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 330)								index47 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x30)) ));
            							}
HXDLIN( 330)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 330)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 330)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXLINE( 330)								h0 = c45;
            							}
HXLINE( 331)							int x37 = (x30 + 1);
HXDLIN( 331)							int y39 = (y30 - 1);
HXDLIN( 331)							::Dynamic this250 = here->image;
HXDLIN( 331)							int index48;
HXDLIN( 331)							if (here->useVirtualPos) {
HXLINE( 331)								index48 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXLINE( 331)								index48 = ::Std_obj::_hx_int(( (Float)(((y39 * here->width) + x37)) ));
            							}
HXDLIN( 331)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 331)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 331)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXLINE( 331)								i0 = c46;
            							}
HXLINE( 332)							int x38 = (x30 + 2);
HXDLIN( 332)							int y40 = (y30 - 1);
HXDLIN( 332)							::Dynamic this251 = here->image;
HXDLIN( 332)							int index49;
HXDLIN( 332)							if (here->useVirtualPos) {
HXLINE( 332)								index49 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXLINE( 332)								index49 = ::Std_obj::_hx_int(( (Float)(((y40 * here->width) + x38)) ));
            							}
HXDLIN( 332)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 332)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 332)								j0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXLINE( 332)								j0 = c47;
            							}
HXLINE( 334)							int x39 = (x30 - 2);
HXDLIN( 334)							::Dynamic this252 = here->image;
HXDLIN( 334)							int index50;
HXDLIN( 334)							if (here->useVirtualPos) {
HXLINE( 334)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXLINE( 334)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x39)) ));
            							}
HXDLIN( 334)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 334)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 334)								k0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXLINE( 334)								k0 = c48;
            							}
HXLINE( 335)							int x40 = (x30 - 1);
HXDLIN( 335)							::Dynamic this253 = here->image;
HXDLIN( 335)							int index51;
HXDLIN( 335)							if (here->useVirtualPos) {
HXLINE( 335)								index51 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x40) - here->virtualX));
            							}
            							else {
HXLINE( 335)								index51 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x40)) ));
            							}
HXDLIN( 335)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 335)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 335)								l0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXLINE( 335)								l0 = c49;
            							}
HXLINE( 336)							::Dynamic this254 = here->image;
HXDLIN( 336)							int index52;
HXDLIN( 336)							if (here->useVirtualPos) {
HXLINE( 336)								index52 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 336)								index52 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 336)							int c50 = ::iterMagic::Iimg_obj::get(this254,index52);
HXDLIN( 336)							int m03;
HXDLIN( 336)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 336)								m03 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            							}
            							else {
HXLINE( 336)								m03 = c50;
            							}
HXDLIN( 336)							m0 = m03;
HXLINE( 337)							int x41 = (x30 + 1);
HXDLIN( 337)							::Dynamic this255 = here->image;
HXDLIN( 337)							int index53;
HXDLIN( 337)							if (here->useVirtualPos) {
HXLINE( 337)								index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            							}
            							else {
HXLINE( 337)								index53 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x41)) ));
            							}
HXDLIN( 337)							int c51 = ::iterMagic::Iimg_obj::get(this255,index53);
HXDLIN( 337)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 337)								n0 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            							}
            							else {
HXLINE( 337)								n0 = c51;
            							}
HXLINE( 338)							int x42 = (x30 + 2);
HXDLIN( 338)							::Dynamic this256 = here->image;
HXDLIN( 338)							int index54;
HXDLIN( 338)							if (here->useVirtualPos) {
HXLINE( 338)								index54 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            							}
            							else {
HXLINE( 338)								index54 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x42)) ));
            							}
HXDLIN( 338)							int c52 = ::iterMagic::Iimg_obj::get(this256,index54);
HXDLIN( 338)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 338)								o0 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            							}
            							else {
HXLINE( 338)								o0 = c52;
            							}
HXLINE( 340)							int x43 = (x30 - 2);
HXDLIN( 340)							int y41 = (y30 + 1);
HXDLIN( 340)							::Dynamic this257 = here->image;
HXDLIN( 340)							int index55;
HXDLIN( 340)							if (here->useVirtualPos) {
HXLINE( 340)								index55 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            							}
            							else {
HXLINE( 340)								index55 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x43)) ));
            							}
HXDLIN( 340)							int c53 = ::iterMagic::Iimg_obj::get(this257,index55);
HXDLIN( 340)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 340)								p0 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            							}
            							else {
HXLINE( 340)								p0 = c53;
            							}
HXLINE( 341)							int x44 = (x30 - 1);
HXDLIN( 341)							int y42 = (y30 + 1);
HXDLIN( 341)							::Dynamic this258 = here->image;
HXDLIN( 341)							int index56;
HXDLIN( 341)							if (here->useVirtualPos) {
HXLINE( 341)								index56 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x44) - here->virtualX));
            							}
            							else {
HXLINE( 341)								index56 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x44)) ));
            							}
HXDLIN( 341)							int c54 = ::iterMagic::Iimg_obj::get(this258,index56);
HXDLIN( 341)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 341)								q0 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            							}
            							else {
HXLINE( 341)								q0 = c54;
            							}
HXLINE( 342)							int y43 = (y30 + 1);
HXDLIN( 342)							::Dynamic this259 = here->image;
HXDLIN( 342)							int index57;
HXDLIN( 342)							if (here->useVirtualPos) {
HXLINE( 342)								index57 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 342)								index57 = ::Std_obj::_hx_int(( (Float)(((y43 * here->width) + x30)) ));
            							}
HXDLIN( 342)							int c55 = ::iterMagic::Iimg_obj::get(this259,index57);
HXDLIN( 342)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 342)								r0 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            							}
            							else {
HXLINE( 342)								r0 = c55;
            							}
HXLINE( 343)							int x45 = (x30 + 1);
HXDLIN( 343)							int y44 = (y30 + 1);
HXDLIN( 343)							::Dynamic this260 = here->image;
HXDLIN( 343)							int index58;
HXDLIN( 343)							if (here->useVirtualPos) {
HXLINE( 343)								index58 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - here->virtualY) * ( (Float)(here->width) )) + x45) - here->virtualX));
            							}
            							else {
HXLINE( 343)								index58 = ::Std_obj::_hx_int(( (Float)(((y44 * here->width) + x45)) ));
            							}
HXDLIN( 343)							int c56 = ::iterMagic::Iimg_obj::get(this260,index58);
HXDLIN( 343)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 343)								s0 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            							}
            							else {
HXLINE( 343)								s0 = c56;
            							}
HXLINE( 344)							int x46 = (x30 + 2);
HXDLIN( 344)							int y45 = (y30 + 1);
HXDLIN( 344)							::Dynamic this261 = here->image;
HXDLIN( 344)							int index59;
HXDLIN( 344)							if (here->useVirtualPos) {
HXLINE( 344)								index59 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - here->virtualY) * ( (Float)(here->width) )) + x46) - here->virtualX));
            							}
            							else {
HXLINE( 344)								index59 = ::Std_obj::_hx_int(( (Float)(((y45 * here->width) + x46)) ));
            							}
HXDLIN( 344)							int c57 = ::iterMagic::Iimg_obj::get(this261,index59);
HXDLIN( 344)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 344)								t0 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            							}
            							else {
HXLINE( 344)								t0 = c57;
            							}
HXLINE( 346)							int x47 = (x30 - 2);
HXDLIN( 346)							int y46 = (y30 + 2);
HXDLIN( 346)							::Dynamic this262 = here->image;
HXDLIN( 346)							int index60;
HXDLIN( 346)							if (here->useVirtualPos) {
HXLINE( 346)								index60 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - here->virtualY) * ( (Float)(here->width) )) + x47) - here->virtualX));
            							}
            							else {
HXLINE( 346)								index60 = ::Std_obj::_hx_int(( (Float)(((y46 * here->width) + x47)) ));
            							}
HXDLIN( 346)							int c58 = ::iterMagic::Iimg_obj::get(this262,index60);
HXDLIN( 346)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 346)								u0 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            							}
            							else {
HXLINE( 346)								u0 = c58;
            							}
HXLINE( 347)							int x48 = (x30 - 1);
HXDLIN( 347)							int y47 = (y30 + 2);
HXDLIN( 347)							::Dynamic this263 = here->image;
HXDLIN( 347)							int index61;
HXDLIN( 347)							if (here->useVirtualPos) {
HXLINE( 347)								index61 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - here->virtualY) * ( (Float)(here->width) )) + x48) - here->virtualX));
            							}
            							else {
HXLINE( 347)								index61 = ::Std_obj::_hx_int(( (Float)(((y47 * here->width) + x48)) ));
            							}
HXDLIN( 347)							int c59 = ::iterMagic::Iimg_obj::get(this263,index61);
HXDLIN( 347)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 347)								v0 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            							}
            							else {
HXLINE( 347)								v0 = c59;
            							}
HXLINE( 348)							int y48 = (y30 + 2);
HXDLIN( 348)							::Dynamic this264 = here->image;
HXDLIN( 348)							int index62;
HXDLIN( 348)							if (here->useVirtualPos) {
HXLINE( 348)								index62 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXLINE( 348)								index62 = ::Std_obj::_hx_int(( (Float)(((y48 * here->width) + x30)) ));
            							}
HXDLIN( 348)							int c60 = ::iterMagic::Iimg_obj::get(this264,index62);
HXDLIN( 348)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 348)								w0 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            							}
            							else {
HXLINE( 348)								w0 = c60;
            							}
HXLINE( 349)							int x49 = (x30 + 1);
HXDLIN( 349)							int y49 = (y30 + 2);
HXDLIN( 349)							::Dynamic this265 = here->image;
HXDLIN( 349)							int index63;
HXDLIN( 349)							if (here->useVirtualPos) {
HXLINE( 349)								index63 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - here->virtualY) * ( (Float)(here->width) )) + x49) - here->virtualX));
            							}
            							else {
HXLINE( 349)								index63 = ::Std_obj::_hx_int(( (Float)(((y49 * here->width) + x49)) ));
            							}
HXDLIN( 349)							int c61 = ::iterMagic::Iimg_obj::get(this265,index63);
HXDLIN( 349)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 349)								x0 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            							}
            							else {
HXLINE( 349)								x0 = c61;
            							}
HXLINE( 350)							int x50 = (x30 + 2);
HXDLIN( 350)							int y50 = (y30 + 2);
HXDLIN( 350)							::Dynamic this266 = here->image;
HXDLIN( 350)							int index64;
HXDLIN( 350)							if (here->useVirtualPos) {
HXLINE( 350)								index64 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - here->virtualY) * ( (Float)(here->width) )) + x50) - here->virtualX));
            							}
            							else {
HXLINE( 350)								index64 = ::Std_obj::_hx_int(( (Float)(((y50 * here->width) + x50)) ));
            							}
HXDLIN( 350)							int c62 = ::iterMagic::Iimg_obj::get(this266,index64);
HXDLIN( 350)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 350)								y0 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            							}
            							else {
HXLINE( 350)								y0 = c62;
            							}
            						}
            						else {
HXLINE( 353)							a0 = b0;
HXLINE( 354)							b0 = c0;
HXLINE( 355)							c0 = d0;
HXLINE( 356)							d0 = e0;
HXLINE( 357)							int x51 = (x30 + 1);
HXDLIN( 357)							int y51 = (y30 - 2);
HXDLIN( 357)							::Dynamic this267 = here->image;
HXDLIN( 357)							int index65;
HXDLIN( 357)							if (here->useVirtualPos) {
HXLINE( 357)								index65 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - here->virtualY) * ( (Float)(here->width) )) + x51) - here->virtualX));
            							}
            							else {
HXLINE( 357)								index65 = ::Std_obj::_hx_int(( (Float)(((y51 * here->width) + x51)) ));
            							}
HXDLIN( 357)							int c63 = ::iterMagic::Iimg_obj::get(this267,index65);
HXDLIN( 357)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 357)								e0 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            							}
            							else {
HXLINE( 357)								e0 = c63;
            							}
HXLINE( 359)							f0 = g0;
HXLINE( 360)							g0 = h0;
HXLINE( 361)							h0 = i0;
HXLINE( 362)							i0 = h0;
HXLINE( 363)							int x52 = (x30 + 1);
HXDLIN( 363)							int y52 = (y30 - 1);
HXDLIN( 363)							::Dynamic this268 = here->image;
HXDLIN( 363)							int index66;
HXDLIN( 363)							if (here->useVirtualPos) {
HXLINE( 363)								index66 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - here->virtualY) * ( (Float)(here->width) )) + x52) - here->virtualX));
            							}
            							else {
HXLINE( 363)								index66 = ::Std_obj::_hx_int(( (Float)(((y52 * here->width) + x52)) ));
            							}
HXDLIN( 363)							int c64 = ::iterMagic::Iimg_obj::get(this268,index66);
HXDLIN( 363)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 363)								j0 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            							}
            							else {
HXLINE( 363)								j0 = c64;
            							}
HXLINE( 365)							k0 = l0;
HXLINE( 366)							l0 = m0;
HXLINE( 367)							m0 = n0;
HXLINE( 368)							n0 = o0;
HXLINE( 369)							int x53 = (x30 + 1);
HXDLIN( 369)							::Dynamic this269 = here->image;
HXDLIN( 369)							int index67;
HXDLIN( 369)							if (here->useVirtualPos) {
HXLINE( 369)								index67 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x53) - here->virtualX));
            							}
            							else {
HXLINE( 369)								index67 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x53)) ));
            							}
HXDLIN( 369)							int c65 = ::iterMagic::Iimg_obj::get(this269,index67);
HXDLIN( 369)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 369)								o0 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            							}
            							else {
HXLINE( 369)								o0 = c65;
            							}
HXLINE( 371)							p0 = q0;
HXLINE( 372)							q0 = r0;
HXLINE( 373)							r0 = s0;
HXLINE( 374)							s0 = t0;
HXLINE( 375)							int x54 = (x30 + 1);
HXDLIN( 375)							int y53 = (y30 + 1);
HXDLIN( 375)							::Dynamic this270 = here->image;
HXDLIN( 375)							int index68;
HXDLIN( 375)							if (here->useVirtualPos) {
HXLINE( 375)								index68 = ::Std_obj::_hx_int(((((( (Float)(y53) ) - here->virtualY) * ( (Float)(here->width) )) + x54) - here->virtualX));
            							}
            							else {
HXLINE( 375)								index68 = ::Std_obj::_hx_int(( (Float)(((y53 * here->width) + x54)) ));
            							}
HXDLIN( 375)							int c66 = ::iterMagic::Iimg_obj::get(this270,index68);
HXDLIN( 375)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 375)								t0 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            							}
            							else {
HXLINE( 375)								t0 = c66;
            							}
HXLINE( 377)							u0 = v0;
HXLINE( 378)							v0 = w0;
HXLINE( 379)							w0 = x0;
HXLINE( 380)							x0 = v0;
HXLINE( 381)							int x55 = (x30 + 1);
HXDLIN( 381)							int y54 = (y30 + 2);
HXDLIN( 381)							::Dynamic this271 = here->image;
HXDLIN( 381)							int index69;
HXDLIN( 381)							if (here->useVirtualPos) {
HXLINE( 381)								index69 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - here->virtualY) * ( (Float)(here->width) )) + x55) - here->virtualX));
            							}
            							else {
HXLINE( 381)								index69 = ::Std_obj::_hx_int(( (Float)(((y54 * here->width) + x55)) ));
            							}
HXDLIN( 381)							int c67 = ::iterMagic::Iimg_obj::get(this271,index69);
HXDLIN( 381)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 381)								v0 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            							}
            							else {
HXLINE( 381)								v0 = c67;
            							}
            						}
HXLINE( 383)						if (adjustRed) {
HXLINE( 384)							r_ = ((Float)0.);
HXLINE( 385)							bool _hx_tmp2;
HXDLIN( 385)							if ((m55->a != ((Float)0.))) {
HXLINE( 385)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXLINE( 385)								_hx_tmp2 = false;
            							}
HXDLIN( 385)							if (_hx_tmp2) {
HXLINE( 385)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->a));
            							}
HXLINE( 386)							bool _hx_tmp3;
HXDLIN( 386)							if ((m55->b != ((Float)0.))) {
HXLINE( 386)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXLINE( 386)								_hx_tmp3 = false;
            							}
HXDLIN( 386)							if (_hx_tmp3) {
HXLINE( 386)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->b));
            							}
HXLINE( 387)							bool _hx_tmp4;
HXDLIN( 387)							if ((m55->c != ((Float)0.))) {
HXLINE( 387)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXLINE( 387)								_hx_tmp4 = false;
            							}
HXDLIN( 387)							if (_hx_tmp4) {
HXLINE( 387)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->c));
            							}
HXLINE( 388)							bool _hx_tmp5;
HXDLIN( 388)							if ((m55->d != ((Float)0.))) {
HXLINE( 388)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXLINE( 388)								_hx_tmp5 = false;
            							}
HXDLIN( 388)							if (_hx_tmp5) {
HXLINE( 388)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->d));
            							}
HXLINE( 389)							bool _hx_tmp6;
HXDLIN( 389)							if ((m55->e != ((Float)0.))) {
HXLINE( 389)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXLINE( 389)								_hx_tmp6 = false;
            							}
HXDLIN( 389)							if (_hx_tmp6) {
HXLINE( 389)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->e));
            							}
HXLINE( 391)							bool _hx_tmp7;
HXDLIN( 391)							if ((m55->f != ((Float)0.))) {
HXLINE( 391)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXLINE( 391)								_hx_tmp7 = false;
            							}
HXDLIN( 391)							if (_hx_tmp7) {
HXLINE( 391)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->f));
            							}
HXLINE( 392)							bool _hx_tmp8;
HXDLIN( 392)							if ((m55->g != ((Float)0.))) {
HXLINE( 392)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXLINE( 392)								_hx_tmp8 = false;
            							}
HXDLIN( 392)							if (_hx_tmp8) {
HXLINE( 392)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->g));
            							}
HXLINE( 393)							bool _hx_tmp9;
HXDLIN( 393)							if ((m55->h != ((Float)0.))) {
HXLINE( 393)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXLINE( 393)								_hx_tmp9 = false;
            							}
HXDLIN( 393)							if (_hx_tmp9) {
HXLINE( 393)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->h));
            							}
HXLINE( 394)							bool _hx_tmp10;
HXDLIN( 394)							if ((m55->i != ((Float)0.))) {
HXLINE( 394)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXLINE( 394)								_hx_tmp10 = false;
            							}
HXDLIN( 394)							if (_hx_tmp10) {
HXLINE( 394)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->i));
            							}
HXLINE( 395)							bool _hx_tmp11;
HXDLIN( 395)							if ((m55->j != ((Float)0.))) {
HXLINE( 395)								_hx_tmp11 = (j0 != 0);
            							}
            							else {
HXLINE( 395)								_hx_tmp11 = false;
            							}
HXDLIN( 395)							if (_hx_tmp11) {
HXLINE( 395)								r_ = (r_ + ((( (Float)(((j0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->j));
            							}
HXLINE( 397)							bool _hx_tmp12;
HXDLIN( 397)							if ((m55->k != ((Float)0.))) {
HXLINE( 397)								_hx_tmp12 = (k0 != 0);
            							}
            							else {
HXLINE( 397)								_hx_tmp12 = false;
            							}
HXDLIN( 397)							if (_hx_tmp12) {
HXLINE( 397)								r_ = (r_ + ((( (Float)(((k0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->k));
            							}
HXLINE( 398)							bool _hx_tmp13;
HXDLIN( 398)							if ((m55->l != ((Float)0.))) {
HXLINE( 398)								_hx_tmp13 = (l0 != 0);
            							}
            							else {
HXLINE( 398)								_hx_tmp13 = false;
            							}
HXDLIN( 398)							if (_hx_tmp13) {
HXLINE( 398)								r_ = (r_ + ((( (Float)(((l0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->l));
            							}
HXLINE( 399)							bool _hx_tmp14;
HXDLIN( 399)							if ((m55->m != ((Float)0.))) {
HXLINE( 399)								_hx_tmp14 = (m0 != 0);
            							}
            							else {
HXLINE( 399)								_hx_tmp14 = false;
            							}
HXDLIN( 399)							if (_hx_tmp14) {
HXLINE( 399)								r_ = (r_ + ((( (Float)(((m0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->m));
            							}
HXLINE( 400)							bool _hx_tmp15;
HXDLIN( 400)							if ((m55->n != ((Float)0.))) {
HXLINE( 400)								_hx_tmp15 = (n0 != 0);
            							}
            							else {
HXLINE( 400)								_hx_tmp15 = false;
            							}
HXDLIN( 400)							if (_hx_tmp15) {
HXLINE( 400)								r_ = (r_ + ((( (Float)(((n0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->n));
            							}
HXLINE( 401)							bool _hx_tmp16;
HXDLIN( 401)							if ((m55->o != ((Float)0.))) {
HXLINE( 401)								_hx_tmp16 = (o0 != 0);
            							}
            							else {
HXLINE( 401)								_hx_tmp16 = false;
            							}
HXDLIN( 401)							if (_hx_tmp16) {
HXLINE( 401)								r_ = (r_ + ((( (Float)(((o0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->o));
            							}
HXLINE( 403)							bool _hx_tmp17;
HXDLIN( 403)							if ((m55->p != ((Float)0.))) {
HXLINE( 403)								_hx_tmp17 = (p0 != 0);
            							}
            							else {
HXLINE( 403)								_hx_tmp17 = false;
            							}
HXDLIN( 403)							if (_hx_tmp17) {
HXLINE( 403)								r_ = (r_ + ((( (Float)(((p0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->p));
            							}
HXLINE( 404)							bool _hx_tmp18;
HXDLIN( 404)							if ((m55->q != ((Float)0.))) {
HXLINE( 404)								_hx_tmp18 = (q0 != 0);
            							}
            							else {
HXLINE( 404)								_hx_tmp18 = false;
            							}
HXDLIN( 404)							if (_hx_tmp18) {
HXLINE( 404)								r_ = (r_ + ((( (Float)(((q0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->q));
            							}
HXLINE( 405)							bool _hx_tmp19;
HXDLIN( 405)							if ((m55->r != ((Float)0.))) {
HXLINE( 405)								_hx_tmp19 = (r0 != 0);
            							}
            							else {
HXLINE( 405)								_hx_tmp19 = false;
            							}
HXDLIN( 405)							if (_hx_tmp19) {
HXLINE( 405)								r_ = (r_ + ((( (Float)(((r0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->r));
            							}
HXLINE( 406)							bool _hx_tmp20;
HXDLIN( 406)							if ((m55->s != ((Float)0.))) {
HXLINE( 406)								_hx_tmp20 = (s0 != 0);
            							}
            							else {
HXLINE( 406)								_hx_tmp20 = false;
            							}
HXDLIN( 406)							if (_hx_tmp20) {
HXLINE( 406)								r_ = (r_ + ((( (Float)(((s0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->s));
            							}
HXLINE( 407)							bool _hx_tmp21;
HXDLIN( 407)							if ((m55->t != ((Float)0.))) {
HXLINE( 407)								_hx_tmp21 = (t0 != 0);
            							}
            							else {
HXLINE( 407)								_hx_tmp21 = false;
            							}
HXDLIN( 407)							if (_hx_tmp21) {
HXLINE( 407)								r_ = (r_ + ((( (Float)(((t0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->t));
            							}
HXLINE( 409)							bool _hx_tmp22;
HXDLIN( 409)							if ((m55->u != ((Float)0.))) {
HXLINE( 409)								_hx_tmp22 = (u0 != 0);
            							}
            							else {
HXLINE( 409)								_hx_tmp22 = false;
            							}
HXDLIN( 409)							if (_hx_tmp22) {
HXLINE( 409)								r_ = (r_ + ((( (Float)(((u0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->u));
            							}
HXLINE( 410)							bool _hx_tmp23;
HXDLIN( 410)							if ((m55->v != ((Float)0.))) {
HXLINE( 410)								_hx_tmp23 = (v0 != 0);
            							}
            							else {
HXLINE( 410)								_hx_tmp23 = false;
            							}
HXDLIN( 410)							if (_hx_tmp23) {
HXLINE( 410)								r_ = (r_ + ((( (Float)(((v0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->v));
            							}
HXLINE( 411)							bool _hx_tmp24;
HXDLIN( 411)							if ((m55->w != ((Float)0.))) {
HXLINE( 411)								_hx_tmp24 = (w0 != 0);
            							}
            							else {
HXLINE( 411)								_hx_tmp24 = false;
            							}
HXDLIN( 411)							if (_hx_tmp24) {
HXLINE( 411)								r_ = (r_ + ((( (Float)(((w0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->w));
            							}
HXLINE( 412)							bool _hx_tmp25;
HXDLIN( 412)							if ((m55->x != ((Float)0.))) {
HXLINE( 412)								_hx_tmp25 = (x0 != 0);
            							}
            							else {
HXLINE( 412)								_hx_tmp25 = false;
            							}
HXDLIN( 412)							if (_hx_tmp25) {
HXLINE( 412)								r_ = (r_ + ((( (Float)(((x0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->x));
            							}
HXLINE( 413)							bool _hx_tmp26;
HXDLIN( 413)							if ((m55->y != ((Float)0.))) {
HXLINE( 413)								_hx_tmp26 = (y0 != 0);
            							}
            							else {
HXLINE( 413)								_hx_tmp26 = false;
            							}
HXDLIN( 413)							if (_hx_tmp26) {
HXLINE( 413)								r_ = (r_ + ((( (Float)(((y0 >> 16) & 255)) ) / ( (Float)(255) )) * m55->y));
            							}
            						}
            						else {
HXLINE( 416)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 418)						if (adjustGreen) {
HXLINE( 419)							g_ = ((Float)0.);
HXLINE( 420)							bool _hx_tmp27;
HXDLIN( 420)							if ((m55->a != ((Float)0.))) {
HXLINE( 420)								_hx_tmp27 = (a0 != 0);
            							}
            							else {
HXLINE( 420)								_hx_tmp27 = false;
            							}
HXDLIN( 420)							if (_hx_tmp27) {
HXLINE( 420)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->a));
            							}
HXLINE( 421)							bool _hx_tmp28;
HXDLIN( 421)							if ((m55->b != ((Float)0.))) {
HXLINE( 421)								_hx_tmp28 = (b0 != 0);
            							}
            							else {
HXLINE( 421)								_hx_tmp28 = false;
            							}
HXDLIN( 421)							if (_hx_tmp28) {
HXLINE( 421)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->b));
            							}
HXLINE( 422)							bool _hx_tmp29;
HXDLIN( 422)							if ((m55->c != ((Float)0.))) {
HXLINE( 422)								_hx_tmp29 = (c0 != 0);
            							}
            							else {
HXLINE( 422)								_hx_tmp29 = false;
            							}
HXDLIN( 422)							if (_hx_tmp29) {
HXLINE( 422)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->c));
            							}
HXLINE( 423)							bool _hx_tmp30;
HXDLIN( 423)							if ((m55->d != ((Float)0.))) {
HXLINE( 423)								_hx_tmp30 = (d0 != 0);
            							}
            							else {
HXLINE( 423)								_hx_tmp30 = false;
            							}
HXDLIN( 423)							if (_hx_tmp30) {
HXLINE( 423)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->d));
            							}
HXLINE( 424)							bool _hx_tmp31;
HXDLIN( 424)							if ((m55->e != ((Float)0.))) {
HXLINE( 424)								_hx_tmp31 = (e0 != 0);
            							}
            							else {
HXLINE( 424)								_hx_tmp31 = false;
            							}
HXDLIN( 424)							if (_hx_tmp31) {
HXLINE( 424)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->e));
            							}
HXLINE( 426)							bool _hx_tmp32;
HXDLIN( 426)							if ((m55->f != ((Float)0.))) {
HXLINE( 426)								_hx_tmp32 = (f0 != 0);
            							}
            							else {
HXLINE( 426)								_hx_tmp32 = false;
            							}
HXDLIN( 426)							if (_hx_tmp32) {
HXLINE( 426)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->f));
            							}
HXLINE( 427)							bool _hx_tmp33;
HXDLIN( 427)							if ((m55->g != ((Float)0.))) {
HXLINE( 427)								_hx_tmp33 = (g0 != 0);
            							}
            							else {
HXLINE( 427)								_hx_tmp33 = false;
            							}
HXDLIN( 427)							if (_hx_tmp33) {
HXLINE( 427)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->g));
            							}
HXLINE( 428)							bool _hx_tmp34;
HXDLIN( 428)							if ((m55->h != ((Float)0.))) {
HXLINE( 428)								_hx_tmp34 = (h0 != 0);
            							}
            							else {
HXLINE( 428)								_hx_tmp34 = false;
            							}
HXDLIN( 428)							if (_hx_tmp34) {
HXLINE( 428)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->h));
            							}
HXLINE( 429)							bool _hx_tmp35;
HXDLIN( 429)							if ((m55->i != ((Float)0.))) {
HXLINE( 429)								_hx_tmp35 = (i0 != 0);
            							}
            							else {
HXLINE( 429)								_hx_tmp35 = false;
            							}
HXDLIN( 429)							if (_hx_tmp35) {
HXLINE( 429)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->i));
            							}
HXLINE( 430)							bool _hx_tmp36;
HXDLIN( 430)							if ((m55->j != ((Float)0.))) {
HXLINE( 430)								_hx_tmp36 = (j0 != 0);
            							}
            							else {
HXLINE( 430)								_hx_tmp36 = false;
            							}
HXDLIN( 430)							if (_hx_tmp36) {
HXLINE( 430)								g_ = (g_ + ((( (Float)(((j0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->j));
            							}
HXLINE( 432)							bool _hx_tmp37;
HXDLIN( 432)							if ((m55->k != ((Float)0.))) {
HXLINE( 432)								_hx_tmp37 = (k0 != 0);
            							}
            							else {
HXLINE( 432)								_hx_tmp37 = false;
            							}
HXDLIN( 432)							if (_hx_tmp37) {
HXLINE( 432)								g_ = (g_ + ((( (Float)(((k0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->k));
            							}
HXLINE( 433)							bool _hx_tmp38;
HXDLIN( 433)							if ((m55->l != ((Float)0.))) {
HXLINE( 433)								_hx_tmp38 = (l0 != 0);
            							}
            							else {
HXLINE( 433)								_hx_tmp38 = false;
            							}
HXDLIN( 433)							if (_hx_tmp38) {
HXLINE( 433)								g_ = (g_ + ((( (Float)(((l0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->l));
            							}
HXLINE( 434)							bool _hx_tmp39;
HXDLIN( 434)							if ((m55->m != ((Float)0.))) {
HXLINE( 434)								_hx_tmp39 = (m0 != 0);
            							}
            							else {
HXLINE( 434)								_hx_tmp39 = false;
            							}
HXDLIN( 434)							if (_hx_tmp39) {
HXLINE( 434)								g_ = (g_ + ((( (Float)(((m0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->m));
            							}
HXLINE( 435)							bool _hx_tmp40;
HXDLIN( 435)							if ((m55->n != ((Float)0.))) {
HXLINE( 435)								_hx_tmp40 = (n0 != 0);
            							}
            							else {
HXLINE( 435)								_hx_tmp40 = false;
            							}
HXDLIN( 435)							if (_hx_tmp40) {
HXLINE( 435)								g_ = (g_ + ((( (Float)(((n0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->n));
            							}
HXLINE( 436)							bool _hx_tmp41;
HXDLIN( 436)							if ((m55->o != ((Float)0.))) {
HXLINE( 436)								_hx_tmp41 = (o0 != 0);
            							}
            							else {
HXLINE( 436)								_hx_tmp41 = false;
            							}
HXDLIN( 436)							if (_hx_tmp41) {
HXLINE( 436)								g_ = (g_ + ((( (Float)(((o0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->o));
            							}
HXLINE( 438)							bool _hx_tmp42;
HXDLIN( 438)							if ((m55->p != ((Float)0.))) {
HXLINE( 438)								_hx_tmp42 = (p0 != 0);
            							}
            							else {
HXLINE( 438)								_hx_tmp42 = false;
            							}
HXDLIN( 438)							if (_hx_tmp42) {
HXLINE( 438)								g_ = (g_ + ((( (Float)(((p0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->p));
            							}
HXLINE( 439)							bool _hx_tmp43;
HXDLIN( 439)							if ((m55->q != ((Float)0.))) {
HXLINE( 439)								_hx_tmp43 = (q0 != 0);
            							}
            							else {
HXLINE( 439)								_hx_tmp43 = false;
            							}
HXDLIN( 439)							if (_hx_tmp43) {
HXLINE( 439)								g_ = (g_ + ((( (Float)(((q0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->q));
            							}
HXLINE( 440)							bool _hx_tmp44;
HXDLIN( 440)							if ((m55->r != ((Float)0.))) {
HXLINE( 440)								_hx_tmp44 = (r0 != 0);
            							}
            							else {
HXLINE( 440)								_hx_tmp44 = false;
            							}
HXDLIN( 440)							if (_hx_tmp44) {
HXLINE( 440)								g_ = (g_ + ((( (Float)(((r0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->r));
            							}
HXLINE( 441)							bool _hx_tmp45;
HXDLIN( 441)							if ((m55->s != ((Float)0.))) {
HXLINE( 441)								_hx_tmp45 = (s0 != 0);
            							}
            							else {
HXLINE( 441)								_hx_tmp45 = false;
            							}
HXDLIN( 441)							if (_hx_tmp45) {
HXLINE( 441)								g_ = (g_ + ((( (Float)(((s0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->s));
            							}
HXLINE( 442)							bool _hx_tmp46;
HXDLIN( 442)							if ((m55->t != ((Float)0.))) {
HXLINE( 442)								_hx_tmp46 = (t0 != 0);
            							}
            							else {
HXLINE( 442)								_hx_tmp46 = false;
            							}
HXDLIN( 442)							if (_hx_tmp46) {
HXLINE( 442)								g_ = (g_ + ((( (Float)(((t0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->t));
            							}
HXLINE( 444)							bool _hx_tmp47;
HXDLIN( 444)							if ((m55->u != ((Float)0.))) {
HXLINE( 444)								_hx_tmp47 = (u0 != 0);
            							}
            							else {
HXLINE( 444)								_hx_tmp47 = false;
            							}
HXDLIN( 444)							if (_hx_tmp47) {
HXLINE( 444)								g_ = (g_ + ((( (Float)(((u0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->u));
            							}
HXLINE( 445)							bool _hx_tmp48;
HXDLIN( 445)							if ((m55->v != ((Float)0.))) {
HXLINE( 445)								_hx_tmp48 = (v0 != 0);
            							}
            							else {
HXLINE( 445)								_hx_tmp48 = false;
            							}
HXDLIN( 445)							if (_hx_tmp48) {
HXLINE( 445)								g_ = (g_ + ((( (Float)(((v0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->v));
            							}
HXLINE( 446)							bool _hx_tmp49;
HXDLIN( 446)							if ((m55->w != ((Float)0.))) {
HXLINE( 446)								_hx_tmp49 = (w0 != 0);
            							}
            							else {
HXLINE( 446)								_hx_tmp49 = false;
            							}
HXDLIN( 446)							if (_hx_tmp49) {
HXLINE( 446)								g_ = (g_ + ((( (Float)(((w0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->w));
            							}
HXLINE( 447)							bool _hx_tmp50;
HXDLIN( 447)							if ((m55->y != ((Float)0.))) {
HXLINE( 447)								_hx_tmp50 = (x0 != 0);
            							}
            							else {
HXLINE( 447)								_hx_tmp50 = false;
            							}
HXDLIN( 447)							if (_hx_tmp50) {
HXLINE( 447)								g_ = (g_ + ((( (Float)(((x0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->x));
            							}
HXLINE( 448)							bool _hx_tmp51;
HXDLIN( 448)							if ((m55->y != ((Float)0.))) {
HXLINE( 448)								_hx_tmp51 = (y0 != 0);
            							}
            							else {
HXLINE( 448)								_hx_tmp51 = false;
            							}
HXDLIN( 448)							if (_hx_tmp51) {
HXLINE( 448)								g_ = (g_ + ((( (Float)(((y0 >> 8) & 255)) ) / ( (Float)(255) )) * m55->y));
            							}
            						}
            						else {
HXLINE( 450)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 452)						if (adjustBlue) {
HXLINE( 453)							b_ = ((Float)0.);
HXLINE( 454)							bool _hx_tmp52;
HXDLIN( 454)							if ((m55->a != ((Float)0.))) {
HXLINE( 454)								_hx_tmp52 = (a0 != 0);
            							}
            							else {
HXLINE( 454)								_hx_tmp52 = false;
            							}
HXDLIN( 454)							if (_hx_tmp52) {
HXLINE( 454)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m55->a));
            							}
HXLINE( 455)							bool _hx_tmp53;
HXDLIN( 455)							if ((m55->b != ((Float)0.))) {
HXLINE( 455)								_hx_tmp53 = (b0 != 0);
            							}
            							else {
HXLINE( 455)								_hx_tmp53 = false;
            							}
HXDLIN( 455)							if (_hx_tmp53) {
HXLINE( 455)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m55->b));
            							}
HXLINE( 456)							bool _hx_tmp54;
HXDLIN( 456)							if ((m55->c != ((Float)0.))) {
HXLINE( 456)								_hx_tmp54 = (c0 != 0);
            							}
            							else {
HXLINE( 456)								_hx_tmp54 = false;
            							}
HXDLIN( 456)							if (_hx_tmp54) {
HXLINE( 456)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m55->c));
            							}
HXLINE( 457)							bool _hx_tmp55;
HXDLIN( 457)							if ((m55->d != ((Float)0.))) {
HXLINE( 457)								_hx_tmp55 = (d0 != 0);
            							}
            							else {
HXLINE( 457)								_hx_tmp55 = false;
            							}
HXDLIN( 457)							if (_hx_tmp55) {
HXLINE( 457)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m55->d));
            							}
HXLINE( 458)							bool _hx_tmp56;
HXDLIN( 458)							if ((m55->e != ((Float)0.))) {
HXLINE( 458)								_hx_tmp56 = (e0 != 0);
            							}
            							else {
HXLINE( 458)								_hx_tmp56 = false;
            							}
HXDLIN( 458)							if (_hx_tmp56) {
HXLINE( 458)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m55->e));
            							}
HXLINE( 460)							bool _hx_tmp57;
HXDLIN( 460)							if ((m55->f != ((Float)0.))) {
HXLINE( 460)								_hx_tmp57 = (f0 != 0);
            							}
            							else {
HXLINE( 460)								_hx_tmp57 = false;
            							}
HXDLIN( 460)							if (_hx_tmp57) {
HXLINE( 460)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m55->f));
            							}
HXLINE( 461)							bool _hx_tmp58;
HXDLIN( 461)							if ((m55->g != ((Float)0.))) {
HXLINE( 461)								_hx_tmp58 = (g0 != 0);
            							}
            							else {
HXLINE( 461)								_hx_tmp58 = false;
            							}
HXDLIN( 461)							if (_hx_tmp58) {
HXLINE( 461)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m55->g));
            							}
HXLINE( 462)							bool _hx_tmp59;
HXDLIN( 462)							if ((m55->h != ((Float)0.))) {
HXLINE( 462)								_hx_tmp59 = (h0 != 0);
            							}
            							else {
HXLINE( 462)								_hx_tmp59 = false;
            							}
HXDLIN( 462)							if (_hx_tmp59) {
HXLINE( 462)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m55->h));
            							}
HXLINE( 463)							bool _hx_tmp60;
HXDLIN( 463)							if ((m55->i != ((Float)0.))) {
HXLINE( 463)								_hx_tmp60 = (i0 != 0);
            							}
            							else {
HXLINE( 463)								_hx_tmp60 = false;
            							}
HXDLIN( 463)							if (_hx_tmp60) {
HXLINE( 463)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m55->i));
            							}
HXLINE( 464)							bool _hx_tmp61;
HXDLIN( 464)							if ((m55->j != ((Float)0.))) {
HXLINE( 464)								_hx_tmp61 = (j0 != 0);
            							}
            							else {
HXLINE( 464)								_hx_tmp61 = false;
            							}
HXDLIN( 464)							if (_hx_tmp61) {
HXLINE( 464)								b_ = (b_ + ((( (Float)((j0 & 255)) ) / ( (Float)(255) )) * m55->j));
            							}
HXLINE( 466)							bool _hx_tmp62;
HXDLIN( 466)							if ((m55->k != ((Float)0.))) {
HXLINE( 466)								_hx_tmp62 = (k0 != 0);
            							}
            							else {
HXLINE( 466)								_hx_tmp62 = false;
            							}
HXDLIN( 466)							if (_hx_tmp62) {
HXLINE( 466)								b_ = (b_ + ((( (Float)((k0 & 255)) ) / ( (Float)(255) )) * m55->k));
            							}
HXLINE( 467)							bool _hx_tmp63;
HXDLIN( 467)							if ((m55->l != ((Float)0.))) {
HXLINE( 467)								_hx_tmp63 = (l0 != 0);
            							}
            							else {
HXLINE( 467)								_hx_tmp63 = false;
            							}
HXDLIN( 467)							if (_hx_tmp63) {
HXLINE( 467)								b_ = (b_ + ((( (Float)((l0 & 255)) ) / ( (Float)(255) )) * m55->l));
            							}
HXLINE( 468)							bool _hx_tmp64;
HXDLIN( 468)							if ((m55->m != ((Float)0.))) {
HXLINE( 468)								_hx_tmp64 = (m0 != 0);
            							}
            							else {
HXLINE( 468)								_hx_tmp64 = false;
            							}
HXDLIN( 468)							if (_hx_tmp64) {
HXLINE( 468)								b_ = (b_ + ((( (Float)((m0 & 255)) ) / ( (Float)(255) )) * m55->m));
            							}
HXLINE( 469)							bool _hx_tmp65;
HXDLIN( 469)							if ((m55->n != ((Float)0.))) {
HXLINE( 469)								_hx_tmp65 = (n0 != 0);
            							}
            							else {
HXLINE( 469)								_hx_tmp65 = false;
            							}
HXDLIN( 469)							if (_hx_tmp65) {
HXLINE( 469)								b_ = (b_ + ((( (Float)((n0 & 255)) ) / ( (Float)(255) )) * m55->n));
            							}
HXLINE( 470)							bool _hx_tmp66;
HXDLIN( 470)							if ((m55->o != ((Float)0.))) {
HXLINE( 470)								_hx_tmp66 = (o0 != 0);
            							}
            							else {
HXLINE( 470)								_hx_tmp66 = false;
            							}
HXDLIN( 470)							if (_hx_tmp66) {
HXLINE( 470)								b_ = (b_ + ((( (Float)((o0 & 255)) ) / ( (Float)(255) )) * m55->o));
            							}
HXLINE( 472)							bool _hx_tmp67;
HXDLIN( 472)							if ((m55->p != ((Float)0.))) {
HXLINE( 472)								_hx_tmp67 = (p0 != 0);
            							}
            							else {
HXLINE( 472)								_hx_tmp67 = false;
            							}
HXDLIN( 472)							if (_hx_tmp67) {
HXLINE( 472)								b_ = (b_ + ((( (Float)((p0 & 255)) ) / ( (Float)(255) )) * m55->p));
            							}
HXLINE( 473)							bool _hx_tmp68;
HXDLIN( 473)							if ((m55->q != ((Float)0.))) {
HXLINE( 473)								_hx_tmp68 = (q0 != 0);
            							}
            							else {
HXLINE( 473)								_hx_tmp68 = false;
            							}
HXDLIN( 473)							if (_hx_tmp68) {
HXLINE( 473)								b_ = (b_ + ((( (Float)((q0 & 255)) ) / ( (Float)(255) )) * m55->q));
            							}
HXLINE( 474)							bool _hx_tmp69;
HXDLIN( 474)							if ((m55->r != ((Float)0.))) {
HXLINE( 474)								_hx_tmp69 = (r0 != 0);
            							}
            							else {
HXLINE( 474)								_hx_tmp69 = false;
            							}
HXDLIN( 474)							if (_hx_tmp69) {
HXLINE( 474)								b_ = (b_ + ((( (Float)((r0 & 255)) ) / ( (Float)(255) )) * m55->r));
            							}
HXLINE( 475)							bool _hx_tmp70;
HXDLIN( 475)							if ((m55->s != ((Float)0.))) {
HXLINE( 475)								_hx_tmp70 = (s0 != 0);
            							}
            							else {
HXLINE( 475)								_hx_tmp70 = false;
            							}
HXDLIN( 475)							if (_hx_tmp70) {
HXLINE( 475)								b_ = (b_ + ((( (Float)((s0 & 255)) ) / ( (Float)(255) )) * m55->s));
            							}
HXLINE( 476)							bool _hx_tmp71;
HXDLIN( 476)							if ((m55->t != ((Float)0.))) {
HXLINE( 476)								_hx_tmp71 = (t0 != 0);
            							}
            							else {
HXLINE( 476)								_hx_tmp71 = false;
            							}
HXDLIN( 476)							if (_hx_tmp71) {
HXLINE( 476)								b_ = (b_ + ((( (Float)((t0 & 255)) ) / ( (Float)(255) )) * m55->t));
            							}
HXLINE( 478)							bool _hx_tmp72;
HXDLIN( 478)							if ((m55->u != ((Float)0.))) {
HXLINE( 478)								_hx_tmp72 = (u0 != 0);
            							}
            							else {
HXLINE( 478)								_hx_tmp72 = false;
            							}
HXDLIN( 478)							if (_hx_tmp72) {
HXLINE( 478)								b_ = (b_ + ((( (Float)((u0 & 255)) ) / ( (Float)(255) )) * m55->u));
            							}
HXLINE( 479)							bool _hx_tmp73;
HXDLIN( 479)							if ((m55->v != ((Float)0.))) {
HXLINE( 479)								_hx_tmp73 = (v0 != 0);
            							}
            							else {
HXLINE( 479)								_hx_tmp73 = false;
            							}
HXDLIN( 479)							if (_hx_tmp73) {
HXLINE( 479)								b_ = (b_ + ((( (Float)((v0 & 255)) ) / ( (Float)(255) )) * m55->v));
            							}
HXLINE( 480)							bool _hx_tmp74;
HXDLIN( 480)							if ((m55->w != ((Float)0.))) {
HXLINE( 480)								_hx_tmp74 = (w0 != 0);
            							}
            							else {
HXLINE( 480)								_hx_tmp74 = false;
            							}
HXDLIN( 480)							if (_hx_tmp74) {
HXLINE( 480)								b_ = (b_ + ((( (Float)((w0 & 255)) ) / ( (Float)(255) )) * m55->w));
            							}
HXLINE( 481)							bool _hx_tmp75;
HXDLIN( 481)							if ((m55->x != ((Float)0.))) {
HXLINE( 481)								_hx_tmp75 = (x0 != 0);
            							}
            							else {
HXLINE( 481)								_hx_tmp75 = false;
            							}
HXDLIN( 481)							if (_hx_tmp75) {
HXLINE( 481)								b_ = (b_ + ((( (Float)((x0 & 255)) ) / ( (Float)(255) )) * m55->x));
            							}
HXLINE( 482)							bool _hx_tmp76;
HXDLIN( 482)							if ((m55->y != ((Float)0.))) {
HXLINE( 482)								_hx_tmp76 = (y0 != 0);
            							}
            							else {
HXLINE( 482)								_hx_tmp76 = false;
            							}
HXDLIN( 482)							if (_hx_tmp76) {
HXLINE( 482)								b_ = (b_ + ((( (Float)((y0 & 255)) ) / ( (Float)(255) )) * m55->y));
            							}
            						}
            						else {
HXLINE( 484)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 486)						if (adjustAlpha) {
HXLINE( 487)							a_ = ((Float)0.);
HXLINE( 488)							bool _hx_tmp77;
HXDLIN( 488)							if ((m55->a != ((Float)0.))) {
HXLINE( 488)								_hx_tmp77 = (a0 != 0);
            							}
            							else {
HXLINE( 488)								_hx_tmp77 = false;
            							}
HXDLIN( 488)							if (_hx_tmp77) {
HXLINE( 488)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->a));
            							}
HXLINE( 489)							bool _hx_tmp78;
HXDLIN( 489)							if ((m55->b != ((Float)0.))) {
HXLINE( 489)								_hx_tmp78 = (b0 != 0);
            							}
            							else {
HXLINE( 489)								_hx_tmp78 = false;
            							}
HXDLIN( 489)							if (_hx_tmp78) {
HXLINE( 489)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->b));
            							}
HXLINE( 490)							bool _hx_tmp79;
HXDLIN( 490)							if ((m55->c != ((Float)0.))) {
HXLINE( 490)								_hx_tmp79 = (c0 != 0);
            							}
            							else {
HXLINE( 490)								_hx_tmp79 = false;
            							}
HXDLIN( 490)							if (_hx_tmp79) {
HXLINE( 490)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->c));
            							}
HXLINE( 491)							bool _hx_tmp80;
HXDLIN( 491)							if ((m55->d != ((Float)0.))) {
HXLINE( 491)								_hx_tmp80 = (d0 != 0);
            							}
            							else {
HXLINE( 491)								_hx_tmp80 = false;
            							}
HXDLIN( 491)							if (_hx_tmp80) {
HXLINE( 491)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->d));
            							}
HXLINE( 492)							bool _hx_tmp81;
HXDLIN( 492)							if ((m55->e != ((Float)0.))) {
HXLINE( 492)								_hx_tmp81 = (e0 != 0);
            							}
            							else {
HXLINE( 492)								_hx_tmp81 = false;
            							}
HXDLIN( 492)							if (_hx_tmp81) {
HXLINE( 492)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->e));
            							}
HXLINE( 494)							bool _hx_tmp82;
HXDLIN( 494)							if ((m55->f != ((Float)0.))) {
HXLINE( 494)								_hx_tmp82 = (f0 != 0);
            							}
            							else {
HXLINE( 494)								_hx_tmp82 = false;
            							}
HXDLIN( 494)							if (_hx_tmp82) {
HXLINE( 494)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->f));
            							}
HXLINE( 495)							bool _hx_tmp83;
HXDLIN( 495)							if ((m55->g != ((Float)0.))) {
HXLINE( 495)								_hx_tmp83 = (g0 != 0);
            							}
            							else {
HXLINE( 495)								_hx_tmp83 = false;
            							}
HXDLIN( 495)							if (_hx_tmp83) {
HXLINE( 495)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->g));
            							}
HXLINE( 496)							bool _hx_tmp84;
HXDLIN( 496)							if ((m55->h != ((Float)0.))) {
HXLINE( 496)								_hx_tmp84 = (h0 != 0);
            							}
            							else {
HXLINE( 496)								_hx_tmp84 = false;
            							}
HXDLIN( 496)							if (_hx_tmp84) {
HXLINE( 496)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->h));
            							}
HXLINE( 497)							bool _hx_tmp85;
HXDLIN( 497)							if ((m55->i != ((Float)0.))) {
HXLINE( 497)								_hx_tmp85 = (i0 != 0);
            							}
            							else {
HXLINE( 497)								_hx_tmp85 = false;
            							}
HXDLIN( 497)							if (_hx_tmp85) {
HXLINE( 497)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->i));
            							}
HXLINE( 498)							bool _hx_tmp86;
HXDLIN( 498)							if ((m55->j != ((Float)0.))) {
HXLINE( 498)								_hx_tmp86 = (j0 != 0);
            							}
            							else {
HXLINE( 498)								_hx_tmp86 = false;
            							}
HXDLIN( 498)							if (_hx_tmp86) {
HXLINE( 498)								a_ = (a_ + ((( (Float)(((j0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->j));
            							}
HXLINE( 500)							bool _hx_tmp87;
HXDLIN( 500)							if ((m55->k != ((Float)0.))) {
HXLINE( 500)								_hx_tmp87 = (k0 != 0);
            							}
            							else {
HXLINE( 500)								_hx_tmp87 = false;
            							}
HXDLIN( 500)							if (_hx_tmp87) {
HXLINE( 500)								a_ = (a_ + ((( (Float)(((k0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->k));
            							}
HXLINE( 501)							bool _hx_tmp88;
HXDLIN( 501)							if ((m55->l != ((Float)0.))) {
HXLINE( 501)								_hx_tmp88 = (l0 != 0);
            							}
            							else {
HXLINE( 501)								_hx_tmp88 = false;
            							}
HXDLIN( 501)							if (_hx_tmp88) {
HXLINE( 501)								a_ = (a_ + ((( (Float)(((l0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->l));
            							}
HXLINE( 502)							bool _hx_tmp89;
HXDLIN( 502)							if ((m55->m != ((Float)0.))) {
HXLINE( 502)								_hx_tmp89 = (m0 != 0);
            							}
            							else {
HXLINE( 502)								_hx_tmp89 = false;
            							}
HXDLIN( 502)							if (_hx_tmp89) {
HXLINE( 502)								a_ = (a_ + ((( (Float)(((m0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->m));
            							}
HXLINE( 503)							bool _hx_tmp90;
HXDLIN( 503)							if ((m55->n != ((Float)0.))) {
HXLINE( 503)								_hx_tmp90 = (n0 != 0);
            							}
            							else {
HXLINE( 503)								_hx_tmp90 = false;
            							}
HXDLIN( 503)							if (_hx_tmp90) {
HXLINE( 503)								a_ = (a_ + ((( (Float)(((n0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->n));
            							}
HXLINE( 504)							bool _hx_tmp91;
HXDLIN( 504)							if ((m55->o != ((Float)0.))) {
HXLINE( 504)								_hx_tmp91 = (o0 != 0);
            							}
            							else {
HXLINE( 504)								_hx_tmp91 = false;
            							}
HXDLIN( 504)							if (_hx_tmp91) {
HXLINE( 504)								a_ = (a_ + ((( (Float)(((o0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->o));
            							}
HXLINE( 506)							bool _hx_tmp92;
HXDLIN( 506)							if ((m55->p != ((Float)0.))) {
HXLINE( 506)								_hx_tmp92 = (p0 != 0);
            							}
            							else {
HXLINE( 506)								_hx_tmp92 = false;
            							}
HXDLIN( 506)							if (_hx_tmp92) {
HXLINE( 506)								a_ = (a_ + ((( (Float)(((p0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->p));
            							}
HXLINE( 507)							bool _hx_tmp93;
HXDLIN( 507)							if ((m55->q != ((Float)0.))) {
HXLINE( 507)								_hx_tmp93 = (q0 != 0);
            							}
            							else {
HXLINE( 507)								_hx_tmp93 = false;
            							}
HXDLIN( 507)							if (_hx_tmp93) {
HXLINE( 507)								a_ = (a_ + ((( (Float)(((q0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->q));
            							}
HXLINE( 508)							bool _hx_tmp94;
HXDLIN( 508)							if ((m55->r != ((Float)0.))) {
HXLINE( 508)								_hx_tmp94 = (r0 != 0);
            							}
            							else {
HXLINE( 508)								_hx_tmp94 = false;
            							}
HXDLIN( 508)							if (_hx_tmp94) {
HXLINE( 508)								a_ = (a_ + ((( (Float)(((r0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->r));
            							}
HXLINE( 509)							bool _hx_tmp95;
HXDLIN( 509)							if ((m55->s != ((Float)0.))) {
HXLINE( 509)								_hx_tmp95 = (s0 != 0);
            							}
            							else {
HXLINE( 509)								_hx_tmp95 = false;
            							}
HXDLIN( 509)							if (_hx_tmp95) {
HXLINE( 509)								a_ = (a_ + ((( (Float)(((s0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->s));
            							}
HXLINE( 510)							bool _hx_tmp96;
HXDLIN( 510)							if ((m55->t != ((Float)0.))) {
HXLINE( 510)								_hx_tmp96 = (t0 != 0);
            							}
            							else {
HXLINE( 510)								_hx_tmp96 = false;
            							}
HXDLIN( 510)							if (_hx_tmp96) {
HXLINE( 510)								a_ = (a_ + ((( (Float)(((t0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->t));
            							}
HXLINE( 512)							bool _hx_tmp97;
HXDLIN( 512)							if ((m55->u != ((Float)0.))) {
HXLINE( 512)								_hx_tmp97 = (u0 != 0);
            							}
            							else {
HXLINE( 512)								_hx_tmp97 = false;
            							}
HXDLIN( 512)							if (_hx_tmp97) {
HXLINE( 512)								a_ = (a_ + ((( (Float)(((u0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->u));
            							}
HXLINE( 513)							bool _hx_tmp98;
HXDLIN( 513)							if ((m55->v != ((Float)0.))) {
HXLINE( 513)								_hx_tmp98 = (v0 != 0);
            							}
            							else {
HXLINE( 513)								_hx_tmp98 = false;
            							}
HXDLIN( 513)							if (_hx_tmp98) {
HXLINE( 513)								a_ = (a_ + ((( (Float)(((v0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->v));
            							}
HXLINE( 514)							bool _hx_tmp99;
HXDLIN( 514)							if ((m55->w != ((Float)0.))) {
HXLINE( 514)								_hx_tmp99 = (w0 != 0);
            							}
            							else {
HXLINE( 514)								_hx_tmp99 = false;
            							}
HXDLIN( 514)							if (_hx_tmp99) {
HXLINE( 514)								a_ = (a_ + ((( (Float)(((w0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->w));
            							}
HXLINE( 515)							bool _hx_tmp100;
HXDLIN( 515)							if ((m55->x != ((Float)0.))) {
HXLINE( 515)								_hx_tmp100 = (x0 != 0);
            							}
            							else {
HXLINE( 515)								_hx_tmp100 = false;
            							}
HXDLIN( 515)							if (_hx_tmp100) {
HXLINE( 515)								a_ = (a_ + ((( (Float)(((x0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->x));
            							}
HXLINE( 516)							bool _hx_tmp101;
HXDLIN( 516)							if ((m55->y != ((Float)0.))) {
HXLINE( 516)								_hx_tmp101 = (y0 != 0);
            							}
            							else {
HXLINE( 516)								_hx_tmp101 = false;
            							}
HXDLIN( 516)							if (_hx_tmp101) {
HXLINE( 516)								a_ = (a_ + ((( (Float)(((y0 >> 24) & 255)) ) / ( (Float)(255) )) * m55->y));
            							}
            						}
            						else {
HXLINE( 518)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 520)						bool _hx_tmp102;
HXDLIN( 520)						if ((borderMode != 0)) {
HXLINE( 520)							_hx_tmp102 = (borderMode == 2);
            						}
            						else {
HXLINE( 520)							_hx_tmp102 = true;
            						}
HXDLIN( 520)						if (_hx_tmp102) {
HXLINE( 521)							int x56 = (x30 - 2);
HXDLIN( 521)							int y55 = (y30 - 2);
HXDLIN( 521)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 521)							{
HXLINE( 521)								int c68 = color20;
HXDLIN( 521)								bool _hx_tmp103;
HXDLIN( 521)								if ((((c68 >> 24) & 255) < 254)) {
HXLINE( 521)									_hx_tmp103 = out->transparent;
            								}
            								else {
HXLINE( 521)									_hx_tmp103 = false;
            								}
HXDLIN( 521)								if (_hx_tmp103) {
HXLINE( 521)									int location18;
HXDLIN( 521)									if (out->useVirtualPos) {
HXLINE( 521)										location18 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXLINE( 521)										location18 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 521)									int this272 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 521)									int this273;
HXDLIN( 521)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 521)										this273 = ((((((this272 >> 24) & 255) << 24) | ((this272 & 255) << 16)) | (((this272 >> 8) & 255) << 8)) | ((this272 >> 16) & 255));
            									}
            									else {
HXLINE( 521)										this273 = this272;
            									}
HXDLIN( 521)									Float a120;
HXDLIN( 521)									int this274 = ((this273 >> 24) & 255);
HXDLIN( 521)									if ((this274 == 0)) {
HXLINE( 521)										a120 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										a120 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float r118;
HXDLIN( 521)									int this275 = ((this273 >> 16) & 255);
HXDLIN( 521)									if ((this275 == 0)) {
HXLINE( 521)										r118 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										r118 = (( (Float)(this275) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float g118;
HXDLIN( 521)									int this276 = ((this273 >> 8) & 255);
HXDLIN( 521)									if ((this276 == 0)) {
HXLINE( 521)										g118 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										g118 = (( (Float)(this276) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float b121;
HXDLIN( 521)									int this277 = (this273 & 255);
HXDLIN( 521)									if ((this277 == 0)) {
HXLINE( 521)										b121 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										b121 = (( (Float)(this277) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float a219;
HXDLIN( 521)									int this278 = ((color20 >> 24) & 255);
HXDLIN( 521)									if ((this278 == 0)) {
HXLINE( 521)										a219 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										a219 = (( (Float)(this278) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float r218;
HXDLIN( 521)									int this279 = ((color20 >> 16) & 255);
HXDLIN( 521)									if ((this279 == 0)) {
HXLINE( 521)										r218 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										r218 = (( (Float)(this279) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float g218;
HXDLIN( 521)									int this280 = ((color20 >> 8) & 255);
HXDLIN( 521)									if ((this280 == 0)) {
HXLINE( 521)										g218 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										g218 = (( (Float)(this280) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float b219;
HXDLIN( 521)									int this281 = (color20 & 255);
HXDLIN( 521)									if ((this281 == 0)) {
HXLINE( 521)										b219 = ((Float)0.);
            									}
            									else {
HXLINE( 521)										b219 = (( (Float)(this281) ) / ( (Float)(255) ));
            									}
HXDLIN( 521)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 521)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 521)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 521)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 521)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 521)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 521)									{
HXLINE( 521)										int _hx_tmp104;
HXDLIN( 521)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 521)											_hx_tmp104 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXLINE( 521)											_hx_tmp104 = blended18;
            										}
HXDLIN( 521)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp104);
            									}
            								}
            								else {
HXLINE( 521)									::Dynamic this282 = out->image;
HXDLIN( 521)									int index70;
HXDLIN( 521)									if (out->useVirtualPos) {
HXLINE( 521)										index70 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXLINE( 521)										index70 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 521)									int _hx_tmp105;
HXDLIN( 521)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 521)										_hx_tmp105 = ((((((c68 >> 24) & 255) << 24) | ((c68 & 255) << 16)) | (((c68 >> 8) & 255) << 8)) | ((c68 >> 16) & 255));
            									}
            									else {
HXLINE( 521)										_hx_tmp105 = c68;
            									}
HXDLIN( 521)									::iterMagic::Iimg_obj::set(this282,index70,_hx_tmp105);
            								}
            							}
            						}
            						else {
HXLINE( 524)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 524)							{
HXLINE( 524)								int c69 = color21;
HXDLIN( 524)								bool _hx_tmp106;
HXDLIN( 524)								if ((((c69 >> 24) & 255) < 254)) {
HXLINE( 524)									_hx_tmp106 = out->transparent;
            								}
            								else {
HXLINE( 524)									_hx_tmp106 = false;
            								}
HXDLIN( 524)								if (_hx_tmp106) {
HXLINE( 524)									int location19;
HXDLIN( 524)									if (out->useVirtualPos) {
HXLINE( 524)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXLINE( 524)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 524)									int this283 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 524)									int this284;
HXDLIN( 524)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 524)										this284 = ((((((this283 >> 24) & 255) << 24) | ((this283 & 255) << 16)) | (((this283 >> 8) & 255) << 8)) | ((this283 >> 16) & 255));
            									}
            									else {
HXLINE( 524)										this284 = this283;
            									}
HXDLIN( 524)									Float a121;
HXDLIN( 524)									int this285 = ((this284 >> 24) & 255);
HXDLIN( 524)									if ((this285 == 0)) {
HXLINE( 524)										a121 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										a121 = (( (Float)(this285) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float r119;
HXDLIN( 524)									int this286 = ((this284 >> 16) & 255);
HXDLIN( 524)									if ((this286 == 0)) {
HXLINE( 524)										r119 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										r119 = (( (Float)(this286) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float g119;
HXDLIN( 524)									int this287 = ((this284 >> 8) & 255);
HXDLIN( 524)									if ((this287 == 0)) {
HXLINE( 524)										g119 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										g119 = (( (Float)(this287) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float b122;
HXDLIN( 524)									int this288 = (this284 & 255);
HXDLIN( 524)									if ((this288 == 0)) {
HXLINE( 524)										b122 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										b122 = (( (Float)(this288) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float a220;
HXDLIN( 524)									int this289 = ((color21 >> 24) & 255);
HXDLIN( 524)									if ((this289 == 0)) {
HXLINE( 524)										a220 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										a220 = (( (Float)(this289) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float r219;
HXDLIN( 524)									int this290 = ((color21 >> 16) & 255);
HXDLIN( 524)									if ((this290 == 0)) {
HXLINE( 524)										r219 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										r219 = (( (Float)(this290) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float g219;
HXDLIN( 524)									int this291 = ((color21 >> 8) & 255);
HXDLIN( 524)									if ((this291 == 0)) {
HXLINE( 524)										g219 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										g219 = (( (Float)(this291) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float b220;
HXDLIN( 524)									int this292 = (color21 & 255);
HXDLIN( 524)									if ((this292 == 0)) {
HXLINE( 524)										b220 = ((Float)0.);
            									}
            									else {
HXLINE( 524)										b220 = (( (Float)(this292) ) / ( (Float)(255) ));
            									}
HXDLIN( 524)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 524)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 524)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 524)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 524)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 524)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 524)									{
HXLINE( 524)										int _hx_tmp107;
HXDLIN( 524)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 524)											_hx_tmp107 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXLINE( 524)											_hx_tmp107 = blended19;
            										}
HXDLIN( 524)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp107);
            									}
            								}
            								else {
HXLINE( 524)									::Dynamic this293 = out->image;
HXDLIN( 524)									int index71;
HXDLIN( 524)									if (out->useVirtualPos) {
HXLINE( 524)										index71 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXLINE( 524)										index71 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 524)									int _hx_tmp108;
HXDLIN( 524)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 524)										_hx_tmp108 = ((((((c69 >> 24) & 255) << 24) | ((c69 & 255) << 16)) | (((c69 >> 8) & 255) << 8)) | ((c69 >> 16) & 255));
            									}
            									else {
HXLINE( 524)										_hx_tmp108 = c69;
            									}
HXDLIN( 524)									::iterMagic::Iimg_obj::set(this293,index71,_hx_tmp108);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 528)		if ((borderMode == 1)) {
HXLINE( 530)			{
HXLINE( 530)				int _g84 = 0;
HXDLIN( 530)				int _g85 = (this1->width - 1);
HXDLIN( 530)				while((_g84 < _g85)){
HXLINE( 530)					_g84 = (_g84 + 1);
HXDLIN( 530)					int x57 = (_g84 - 1);
HXLINE( 532)					{
HXLINE( 532)						::Dynamic this294 = here->image;
HXDLIN( 532)						int index72;
HXDLIN( 532)						if (here->useVirtualPos) {
HXLINE( 532)							index72 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXLINE( 532)							index72 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x57)) ));
            						}
HXDLIN( 532)						int c70 = ::iterMagic::Iimg_obj::get(this294,index72);
HXDLIN( 532)						int color22;
HXDLIN( 532)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 532)							color22 = ((((((c70 >> 24) & 255) << 24) | ((c70 & 255) << 16)) | (((c70 >> 8) & 255) << 8)) | ((c70 >> 16) & 255));
            						}
            						else {
HXLINE( 532)							color22 = c70;
            						}
HXDLIN( 532)						int color23 = color22;
HXDLIN( 532)						{
HXLINE( 532)							int c71 = color23;
HXDLIN( 532)							bool _hx_tmp109;
HXDLIN( 532)							if ((((c71 >> 24) & 255) < 254)) {
HXLINE( 532)								_hx_tmp109 = out->transparent;
            							}
            							else {
HXLINE( 532)								_hx_tmp109 = false;
            							}
HXDLIN( 532)							if (_hx_tmp109) {
HXLINE( 532)								int location20;
HXDLIN( 532)								if (out->useVirtualPos) {
HXLINE( 532)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 532)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 532)								int this295 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 532)								int this296;
HXDLIN( 532)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 532)									this296 = ((((((this295 >> 24) & 255) << 24) | ((this295 & 255) << 16)) | (((this295 >> 8) & 255) << 8)) | ((this295 >> 16) & 255));
            								}
            								else {
HXLINE( 532)									this296 = this295;
            								}
HXDLIN( 532)								Float a122;
HXDLIN( 532)								int this297 = ((this296 >> 24) & 255);
HXDLIN( 532)								if ((this297 == 0)) {
HXLINE( 532)									a122 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									a122 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float r120;
HXDLIN( 532)								int this298 = ((this296 >> 16) & 255);
HXDLIN( 532)								if ((this298 == 0)) {
HXLINE( 532)									r120 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									r120 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float g120;
HXDLIN( 532)								int this299 = ((this296 >> 8) & 255);
HXDLIN( 532)								if ((this299 == 0)) {
HXLINE( 532)									g120 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									g120 = (( (Float)(this299) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float b123;
HXDLIN( 532)								int this300 = (this296 & 255);
HXDLIN( 532)								if ((this300 == 0)) {
HXLINE( 532)									b123 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									b123 = (( (Float)(this300) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float a221;
HXDLIN( 532)								int this301 = ((color23 >> 24) & 255);
HXDLIN( 532)								if ((this301 == 0)) {
HXLINE( 532)									a221 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									a221 = (( (Float)(this301) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float r220;
HXDLIN( 532)								int this302 = ((color23 >> 16) & 255);
HXDLIN( 532)								if ((this302 == 0)) {
HXLINE( 532)									r220 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									r220 = (( (Float)(this302) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float g220;
HXDLIN( 532)								int this303 = ((color23 >> 8) & 255);
HXDLIN( 532)								if ((this303 == 0)) {
HXLINE( 532)									g220 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									g220 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float b221;
HXDLIN( 532)								int this304 = (color23 & 255);
HXDLIN( 532)								if ((this304 == 0)) {
HXLINE( 532)									b221 = ((Float)0.);
            								}
            								else {
HXLINE( 532)									b221 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 532)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 532)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 532)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 532)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 532)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 532)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 532)								{
HXLINE( 532)									int _hx_tmp110;
HXDLIN( 532)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 532)										_hx_tmp110 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXLINE( 532)										_hx_tmp110 = blended20;
            									}
HXDLIN( 532)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp110);
            								}
            							}
            							else {
HXLINE( 532)								::Dynamic this305 = out->image;
HXDLIN( 532)								int index73;
HXDLIN( 532)								if (out->useVirtualPos) {
HXLINE( 532)									index73 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 532)									index73 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 532)								int _hx_tmp111;
HXDLIN( 532)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 532)									_hx_tmp111 = ((((((c71 >> 24) & 255) << 24) | ((c71 & 255) << 16)) | (((c71 >> 8) & 255) << 8)) | ((c71 >> 16) & 255));
            								}
            								else {
HXLINE( 532)									_hx_tmp111 = c71;
            								}
HXDLIN( 532)								::iterMagic::Iimg_obj::set(this305,index73,_hx_tmp111);
            							}
            						}
            					}
HXLINE( 533)					{
HXLINE( 533)						int x58 = (x57 + 1);
HXDLIN( 533)						int x59 = (x57 + 1);
HXDLIN( 533)						::Dynamic this306 = here->image;
HXDLIN( 533)						int index74;
HXDLIN( 533)						if (here->useVirtualPos) {
HXLINE( 533)							index74 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x59) - here->virtualX));
            						}
            						else {
HXLINE( 533)							index74 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x59)) ));
            						}
HXDLIN( 533)						int c72 = ::iterMagic::Iimg_obj::get(this306,index74);
HXDLIN( 533)						int color24;
HXDLIN( 533)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 533)							color24 = ((((((c72 >> 24) & 255) << 24) | ((c72 & 255) << 16)) | (((c72 >> 8) & 255) << 8)) | ((c72 >> 16) & 255));
            						}
            						else {
HXLINE( 533)							color24 = c72;
            						}
HXDLIN( 533)						{
HXLINE( 533)							int c73 = color24;
HXDLIN( 533)							bool _hx_tmp112;
HXDLIN( 533)							if ((((c73 >> 24) & 255) < 254)) {
HXLINE( 533)								_hx_tmp112 = out->transparent;
            							}
            							else {
HXLINE( 533)								_hx_tmp112 = false;
            							}
HXDLIN( 533)							if (_hx_tmp112) {
HXLINE( 533)								int location21;
HXDLIN( 533)								if (out->useVirtualPos) {
HXLINE( 533)									location21 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXLINE( 533)									location21 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 533)								int this307 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 533)								int this308;
HXDLIN( 533)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 533)									this308 = ((((((this307 >> 24) & 255) << 24) | ((this307 & 255) << 16)) | (((this307 >> 8) & 255) << 8)) | ((this307 >> 16) & 255));
            								}
            								else {
HXLINE( 533)									this308 = this307;
            								}
HXDLIN( 533)								Float a123;
HXDLIN( 533)								int this309 = ((this308 >> 24) & 255);
HXDLIN( 533)								if ((this309 == 0)) {
HXLINE( 533)									a123 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									a123 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float r121;
HXDLIN( 533)								int this310 = ((this308 >> 16) & 255);
HXDLIN( 533)								if ((this310 == 0)) {
HXLINE( 533)									r121 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									r121 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float g121;
HXDLIN( 533)								int this311 = ((this308 >> 8) & 255);
HXDLIN( 533)								if ((this311 == 0)) {
HXLINE( 533)									g121 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									g121 = (( (Float)(this311) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float b124;
HXDLIN( 533)								int this312 = (this308 & 255);
HXDLIN( 533)								if ((this312 == 0)) {
HXLINE( 533)									b124 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									b124 = (( (Float)(this312) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float a222;
HXDLIN( 533)								int this313 = ((color24 >> 24) & 255);
HXDLIN( 533)								if ((this313 == 0)) {
HXLINE( 533)									a222 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									a222 = (( (Float)(this313) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float r221;
HXDLIN( 533)								int this314 = ((color24 >> 16) & 255);
HXDLIN( 533)								if ((this314 == 0)) {
HXLINE( 533)									r221 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									r221 = (( (Float)(this314) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float g221;
HXDLIN( 533)								int this315 = ((color24 >> 8) & 255);
HXDLIN( 533)								if ((this315 == 0)) {
HXLINE( 533)									g221 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									g221 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float b222;
HXDLIN( 533)								int this316 = (color24 & 255);
HXDLIN( 533)								if ((this316 == 0)) {
HXLINE( 533)									b222 = ((Float)0.);
            								}
            								else {
HXLINE( 533)									b222 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 533)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 533)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 533)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 533)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 533)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 533)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 533)								{
HXLINE( 533)									int _hx_tmp113;
HXDLIN( 533)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 533)										_hx_tmp113 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXLINE( 533)										_hx_tmp113 = blended21;
            									}
HXDLIN( 533)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp113);
            								}
            							}
            							else {
HXLINE( 533)								::Dynamic this317 = out->image;
HXDLIN( 533)								int index75;
HXDLIN( 533)								if (out->useVirtualPos) {
HXLINE( 533)									index75 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXLINE( 533)									index75 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 533)								int _hx_tmp114;
HXDLIN( 533)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 533)									_hx_tmp114 = ((((((c73 >> 24) & 255) << 24) | ((c73 & 255) << 16)) | (((c73 >> 8) & 255) << 8)) | ((c73 >> 16) & 255));
            								}
            								else {
HXLINE( 533)									_hx_tmp114 = c73;
            								}
HXDLIN( 533)								::iterMagic::Iimg_obj::set(this317,index75,_hx_tmp114);
            							}
            						}
            					}
HXLINE( 535)					{
HXLINE( 535)						int y56 = (this1->height - 1);
HXDLIN( 535)						int y57 = (this1->height - 1);
HXDLIN( 535)						::Dynamic this318 = here->image;
HXDLIN( 535)						int index76;
HXDLIN( 535)						if (here->useVirtualPos) {
HXLINE( 535)							index76 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXLINE( 535)							index76 = ::Std_obj::_hx_int(( (Float)(((y57 * here->width) + x57)) ));
            						}
HXDLIN( 535)						int c74 = ::iterMagic::Iimg_obj::get(this318,index76);
HXDLIN( 535)						int color25;
HXDLIN( 535)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 535)							color25 = ((((((c74 >> 24) & 255) << 24) | ((c74 & 255) << 16)) | (((c74 >> 8) & 255) << 8)) | ((c74 >> 16) & 255));
            						}
            						else {
HXLINE( 535)							color25 = c74;
            						}
HXDLIN( 535)						{
HXLINE( 535)							int c75 = color25;
HXDLIN( 535)							bool _hx_tmp115;
HXDLIN( 535)							if ((((c75 >> 24) & 255) < 254)) {
HXLINE( 535)								_hx_tmp115 = out->transparent;
            							}
            							else {
HXLINE( 535)								_hx_tmp115 = false;
            							}
HXDLIN( 535)							if (_hx_tmp115) {
HXLINE( 535)								int location22;
HXDLIN( 535)								if (out->useVirtualPos) {
HXLINE( 535)									location22 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 535)									location22 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 535)								int this319 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 535)								int this320;
HXDLIN( 535)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 535)									this320 = ((((((this319 >> 24) & 255) << 24) | ((this319 & 255) << 16)) | (((this319 >> 8) & 255) << 8)) | ((this319 >> 16) & 255));
            								}
            								else {
HXLINE( 535)									this320 = this319;
            								}
HXDLIN( 535)								Float a124;
HXDLIN( 535)								int this321 = ((this320 >> 24) & 255);
HXDLIN( 535)								if ((this321 == 0)) {
HXLINE( 535)									a124 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									a124 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float r122;
HXDLIN( 535)								int this322 = ((this320 >> 16) & 255);
HXDLIN( 535)								if ((this322 == 0)) {
HXLINE( 535)									r122 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									r122 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float g122;
HXDLIN( 535)								int this323 = ((this320 >> 8) & 255);
HXDLIN( 535)								if ((this323 == 0)) {
HXLINE( 535)									g122 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									g122 = (( (Float)(this323) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float b125;
HXDLIN( 535)								int this324 = (this320 & 255);
HXDLIN( 535)								if ((this324 == 0)) {
HXLINE( 535)									b125 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									b125 = (( (Float)(this324) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float a223;
HXDLIN( 535)								int this325 = ((color25 >> 24) & 255);
HXDLIN( 535)								if ((this325 == 0)) {
HXLINE( 535)									a223 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									a223 = (( (Float)(this325) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float r222;
HXDLIN( 535)								int this326 = ((color25 >> 16) & 255);
HXDLIN( 535)								if ((this326 == 0)) {
HXLINE( 535)									r222 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									r222 = (( (Float)(this326) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float g222;
HXDLIN( 535)								int this327 = ((color25 >> 8) & 255);
HXDLIN( 535)								if ((this327 == 0)) {
HXLINE( 535)									g222 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									g222 = (( (Float)(this327) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float b223;
HXDLIN( 535)								int this328 = (color25 & 255);
HXDLIN( 535)								if ((this328 == 0)) {
HXLINE( 535)									b223 = ((Float)0.);
            								}
            								else {
HXLINE( 535)									b223 = (( (Float)(this328) ) / ( (Float)(255) ));
            								}
HXDLIN( 535)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 535)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 535)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 535)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 535)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 535)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 535)								{
HXLINE( 535)									int _hx_tmp116;
HXDLIN( 535)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 535)										_hx_tmp116 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXLINE( 535)										_hx_tmp116 = blended22;
            									}
HXDLIN( 535)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp116);
            								}
            							}
            							else {
HXLINE( 535)								::Dynamic this329 = out->image;
HXDLIN( 535)								int index77;
HXDLIN( 535)								if (out->useVirtualPos) {
HXLINE( 535)									index77 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 535)									index77 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 535)								int _hx_tmp117;
HXDLIN( 535)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 535)									_hx_tmp117 = ((((((c75 >> 24) & 255) << 24) | ((c75 & 255) << 16)) | (((c75 >> 8) & 255) << 8)) | ((c75 >> 16) & 255));
            								}
            								else {
HXLINE( 535)									_hx_tmp117 = c75;
            								}
HXDLIN( 535)								::iterMagic::Iimg_obj::set(this329,index77,_hx_tmp117);
            							}
            						}
            					}
HXLINE( 536)					{
HXLINE( 536)						int y58 = (this1->height - 2);
HXDLIN( 536)						int y59 = (this1->height - 2);
HXDLIN( 536)						::Dynamic this330 = here->image;
HXDLIN( 536)						int index78;
HXDLIN( 536)						if (here->useVirtualPos) {
HXLINE( 536)							index78 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXLINE( 536)							index78 = ::Std_obj::_hx_int(( (Float)(((y59 * here->width) + x57)) ));
            						}
HXDLIN( 536)						int c76 = ::iterMagic::Iimg_obj::get(this330,index78);
HXDLIN( 536)						int color26;
HXDLIN( 536)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)							color26 = ((((((c76 >> 24) & 255) << 24) | ((c76 & 255) << 16)) | (((c76 >> 8) & 255) << 8)) | ((c76 >> 16) & 255));
            						}
            						else {
HXLINE( 536)							color26 = c76;
            						}
HXDLIN( 536)						{
HXLINE( 536)							int c77 = color26;
HXDLIN( 536)							bool _hx_tmp118;
HXDLIN( 536)							if ((((c77 >> 24) & 255) < 254)) {
HXLINE( 536)								_hx_tmp118 = out->transparent;
            							}
            							else {
HXLINE( 536)								_hx_tmp118 = false;
            							}
HXDLIN( 536)							if (_hx_tmp118) {
HXLINE( 536)								int location23;
HXDLIN( 536)								if (out->useVirtualPos) {
HXLINE( 536)									location23 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 536)									location23 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 536)								int this331 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 536)								int this332;
HXDLIN( 536)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)									this332 = ((((((this331 >> 24) & 255) << 24) | ((this331 & 255) << 16)) | (((this331 >> 8) & 255) << 8)) | ((this331 >> 16) & 255));
            								}
            								else {
HXLINE( 536)									this332 = this331;
            								}
HXDLIN( 536)								Float a125;
HXDLIN( 536)								int this333 = ((this332 >> 24) & 255);
HXDLIN( 536)								if ((this333 == 0)) {
HXLINE( 536)									a125 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									a125 = (( (Float)(this333) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float r123;
HXDLIN( 536)								int this334 = ((this332 >> 16) & 255);
HXDLIN( 536)								if ((this334 == 0)) {
HXLINE( 536)									r123 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									r123 = (( (Float)(this334) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float g123;
HXDLIN( 536)								int this335 = ((this332 >> 8) & 255);
HXDLIN( 536)								if ((this335 == 0)) {
HXLINE( 536)									g123 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									g123 = (( (Float)(this335) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float b126;
HXDLIN( 536)								int this336 = (this332 & 255);
HXDLIN( 536)								if ((this336 == 0)) {
HXLINE( 536)									b126 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									b126 = (( (Float)(this336) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float a224;
HXDLIN( 536)								int this337 = ((color26 >> 24) & 255);
HXDLIN( 536)								if ((this337 == 0)) {
HXLINE( 536)									a224 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									a224 = (( (Float)(this337) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float r223;
HXDLIN( 536)								int this338 = ((color26 >> 16) & 255);
HXDLIN( 536)								if ((this338 == 0)) {
HXLINE( 536)									r223 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									r223 = (( (Float)(this338) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float g223;
HXDLIN( 536)								int this339 = ((color26 >> 8) & 255);
HXDLIN( 536)								if ((this339 == 0)) {
HXLINE( 536)									g223 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									g223 = (( (Float)(this339) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float b224;
HXDLIN( 536)								int this340 = (color26 & 255);
HXDLIN( 536)								if ((this340 == 0)) {
HXLINE( 536)									b224 = ((Float)0.);
            								}
            								else {
HXLINE( 536)									b224 = (( (Float)(this340) ) / ( (Float)(255) ));
            								}
HXDLIN( 536)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 536)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 536)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 536)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 536)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 536)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 536)								{
HXLINE( 536)									int _hx_tmp119;
HXDLIN( 536)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)										_hx_tmp119 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXLINE( 536)										_hx_tmp119 = blended23;
            									}
HXDLIN( 536)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp119);
            								}
            							}
            							else {
HXLINE( 536)								::Dynamic this341 = out->image;
HXDLIN( 536)								int index79;
HXDLIN( 536)								if (out->useVirtualPos) {
HXLINE( 536)									index79 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXLINE( 536)									index79 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 536)								int _hx_tmp120;
HXDLIN( 536)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)									_hx_tmp120 = ((((((c77 >> 24) & 255) << 24) | ((c77 & 255) << 16)) | (((c77 >> 8) & 255) << 8)) | ((c77 >> 16) & 255));
            								}
            								else {
HXLINE( 536)									_hx_tmp120 = c77;
            								}
HXDLIN( 536)								::iterMagic::Iimg_obj::set(this341,index79,_hx_tmp120);
            							}
            						}
            					}
            				}
            			}
HXLINE( 538)			{
HXLINE( 538)				int _g86 = 2;
HXDLIN( 538)				int _g87 = (this1->height - 3);
HXDLIN( 538)				while((_g86 < _g87)){
HXLINE( 538)					_g86 = (_g86 + 1);
HXDLIN( 538)					int y60 = (_g86 - 1);
HXLINE( 540)					{
HXLINE( 540)						::Dynamic this342 = here->image;
HXDLIN( 540)						int index80;
HXDLIN( 540)						if (here->useVirtualPos) {
HXLINE( 540)							index80 = ::Std_obj::_hx_int((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXLINE( 540)							index80 = ::Std_obj::_hx_int(( (Float)((y60 * here->width)) ));
            						}
HXDLIN( 540)						int c78 = ::iterMagic::Iimg_obj::get(this342,index80);
HXDLIN( 540)						int color27;
HXDLIN( 540)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 540)							color27 = ((((((c78 >> 24) & 255) << 24) | ((c78 & 255) << 16)) | (((c78 >> 8) & 255) << 8)) | ((c78 >> 16) & 255));
            						}
            						else {
HXLINE( 540)							color27 = c78;
            						}
HXDLIN( 540)						int color28 = color27;
HXDLIN( 540)						{
HXLINE( 540)							int c79 = color28;
HXDLIN( 540)							bool _hx_tmp121;
HXDLIN( 540)							if ((((c79 >> 24) & 255) < 254)) {
HXLINE( 540)								_hx_tmp121 = out->transparent;
            							}
            							else {
HXLINE( 540)								_hx_tmp121 = false;
            							}
HXDLIN( 540)							if (_hx_tmp121) {
HXLINE( 540)								int location24;
HXDLIN( 540)								if (out->useVirtualPos) {
HXLINE( 540)									location24 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 540)									location24 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 540)								int this343 = ::iterMagic::Iimg_obj::get(out->image,location24);
HXDLIN( 540)								int this344;
HXDLIN( 540)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 540)									this344 = ((((((this343 >> 24) & 255) << 24) | ((this343 & 255) << 16)) | (((this343 >> 8) & 255) << 8)) | ((this343 >> 16) & 255));
            								}
            								else {
HXLINE( 540)									this344 = this343;
            								}
HXDLIN( 540)								Float a126;
HXDLIN( 540)								int this345 = ((this344 >> 24) & 255);
HXDLIN( 540)								if ((this345 == 0)) {
HXLINE( 540)									a126 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									a126 = (( (Float)(this345) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float r124;
HXDLIN( 540)								int this346 = ((this344 >> 16) & 255);
HXDLIN( 540)								if ((this346 == 0)) {
HXLINE( 540)									r124 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									r124 = (( (Float)(this346) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float g124;
HXDLIN( 540)								int this347 = ((this344 >> 8) & 255);
HXDLIN( 540)								if ((this347 == 0)) {
HXLINE( 540)									g124 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									g124 = (( (Float)(this347) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float b127;
HXDLIN( 540)								int this348 = (this344 & 255);
HXDLIN( 540)								if ((this348 == 0)) {
HXLINE( 540)									b127 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									b127 = (( (Float)(this348) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float a225;
HXDLIN( 540)								int this349 = ((color28 >> 24) & 255);
HXDLIN( 540)								if ((this349 == 0)) {
HXLINE( 540)									a225 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									a225 = (( (Float)(this349) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float r224;
HXDLIN( 540)								int this350 = ((color28 >> 16) & 255);
HXDLIN( 540)								if ((this350 == 0)) {
HXLINE( 540)									r224 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									r224 = (( (Float)(this350) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float g224;
HXDLIN( 540)								int this351 = ((color28 >> 8) & 255);
HXDLIN( 540)								if ((this351 == 0)) {
HXLINE( 540)									g224 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									g224 = (( (Float)(this351) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float b225;
HXDLIN( 540)								int this352 = (color28 & 255);
HXDLIN( 540)								if ((this352 == 0)) {
HXLINE( 540)									b225 = ((Float)0.);
            								}
            								else {
HXLINE( 540)									b225 = (( (Float)(this352) ) / ( (Float)(255) ));
            								}
HXDLIN( 540)								Float a324 = (a126 * (( (Float)(1) ) - a225));
HXDLIN( 540)								int r44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 540)								int g44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 540)								int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a324) + (b225 * a225))));
HXDLIN( 540)								int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 540)								int blended24 = ((((a54 << 24) | (r44 << 16)) | (g44 << 8)) | b49);
HXDLIN( 540)								{
HXLINE( 540)									int _hx_tmp122;
HXDLIN( 540)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 540)										_hx_tmp122 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            									}
            									else {
HXLINE( 540)										_hx_tmp122 = blended24;
            									}
HXDLIN( 540)									::iterMagic::Iimg_obj::set(out->image,location24,_hx_tmp122);
            								}
            							}
            							else {
HXLINE( 540)								::Dynamic this353 = out->image;
HXDLIN( 540)								int index81;
HXDLIN( 540)								if (out->useVirtualPos) {
HXLINE( 540)									index81 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 540)									index81 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 540)								int _hx_tmp123;
HXDLIN( 540)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 540)									_hx_tmp123 = ((((((c79 >> 24) & 255) << 24) | ((c79 & 255) << 16)) | (((c79 >> 8) & 255) << 8)) | ((c79 >> 16) & 255));
            								}
            								else {
HXLINE( 540)									_hx_tmp123 = c79;
            								}
HXDLIN( 540)								::iterMagic::Iimg_obj::set(this353,index81,_hx_tmp123);
            							}
            						}
            					}
HXLINE( 541)					{
HXLINE( 541)						::Dynamic this354 = here->image;
HXDLIN( 541)						int index82;
HXDLIN( 541)						if (here->useVirtualPos) {
HXLINE( 541)							index82 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + 1) - here->virtualX));
            						}
            						else {
HXLINE( 541)							index82 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + 1)) ));
            						}
HXDLIN( 541)						int c80 = ::iterMagic::Iimg_obj::get(this354,index82);
HXDLIN( 541)						int color29;
HXDLIN( 541)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)							color29 = ((((((c80 >> 24) & 255) << 24) | ((c80 & 255) << 16)) | (((c80 >> 8) & 255) << 8)) | ((c80 >> 16) & 255));
            						}
            						else {
HXLINE( 541)							color29 = c80;
            						}
HXDLIN( 541)						int color30 = color29;
HXDLIN( 541)						{
HXLINE( 541)							int c81 = color30;
HXDLIN( 541)							bool _hx_tmp124;
HXDLIN( 541)							if ((((c81 >> 24) & 255) < 254)) {
HXLINE( 541)								_hx_tmp124 = out->transparent;
            							}
            							else {
HXLINE( 541)								_hx_tmp124 = false;
            							}
HXDLIN( 541)							if (_hx_tmp124) {
HXLINE( 541)								int location25;
HXDLIN( 541)								if (out->useVirtualPos) {
HXLINE( 541)									location25 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXLINE( 541)									location25 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 541)								int this355 = ::iterMagic::Iimg_obj::get(out->image,location25);
HXDLIN( 541)								int this356;
HXDLIN( 541)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)									this356 = ((((((this355 >> 24) & 255) << 24) | ((this355 & 255) << 16)) | (((this355 >> 8) & 255) << 8)) | ((this355 >> 16) & 255));
            								}
            								else {
HXLINE( 541)									this356 = this355;
            								}
HXDLIN( 541)								Float a127;
HXDLIN( 541)								int this357 = ((this356 >> 24) & 255);
HXDLIN( 541)								if ((this357 == 0)) {
HXLINE( 541)									a127 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									a127 = (( (Float)(this357) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float r125;
HXDLIN( 541)								int this358 = ((this356 >> 16) & 255);
HXDLIN( 541)								if ((this358 == 0)) {
HXLINE( 541)									r125 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									r125 = (( (Float)(this358) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float g125;
HXDLIN( 541)								int this359 = ((this356 >> 8) & 255);
HXDLIN( 541)								if ((this359 == 0)) {
HXLINE( 541)									g125 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									g125 = (( (Float)(this359) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float b128;
HXDLIN( 541)								int this360 = (this356 & 255);
HXDLIN( 541)								if ((this360 == 0)) {
HXLINE( 541)									b128 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									b128 = (( (Float)(this360) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float a226;
HXDLIN( 541)								int this361 = ((color30 >> 24) & 255);
HXDLIN( 541)								if ((this361 == 0)) {
HXLINE( 541)									a226 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									a226 = (( (Float)(this361) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float r225;
HXDLIN( 541)								int this362 = ((color30 >> 16) & 255);
HXDLIN( 541)								if ((this362 == 0)) {
HXLINE( 541)									r225 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									r225 = (( (Float)(this362) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float g225;
HXDLIN( 541)								int this363 = ((color30 >> 8) & 255);
HXDLIN( 541)								if ((this363 == 0)) {
HXLINE( 541)									g225 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									g225 = (( (Float)(this363) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float b226;
HXDLIN( 541)								int this364 = (color30 & 255);
HXDLIN( 541)								if ((this364 == 0)) {
HXLINE( 541)									b226 = ((Float)0.);
            								}
            								else {
HXLINE( 541)									b226 = (( (Float)(this364) ) / ( (Float)(255) ));
            								}
HXDLIN( 541)								Float a325 = (a127 * (( (Float)(1) ) - a226));
HXDLIN( 541)								int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 541)								int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 541)								int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a325) + (b226 * a226))));
HXDLIN( 541)								int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 541)								int blended25 = ((((a55 << 24) | (r45 << 16)) | (g45 << 8)) | b50);
HXDLIN( 541)								{
HXLINE( 541)									int _hx_tmp125;
HXDLIN( 541)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)										_hx_tmp125 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            									}
            									else {
HXLINE( 541)										_hx_tmp125 = blended25;
            									}
HXDLIN( 541)									::iterMagic::Iimg_obj::set(out->image,location25,_hx_tmp125);
            								}
            							}
            							else {
HXLINE( 541)								::Dynamic this365 = out->image;
HXDLIN( 541)								int index83;
HXDLIN( 541)								if (out->useVirtualPos) {
HXLINE( 541)									index83 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXLINE( 541)									index83 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 541)								int _hx_tmp126;
HXDLIN( 541)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 541)									_hx_tmp126 = ((((((c81 >> 24) & 255) << 24) | ((c81 & 255) << 16)) | (((c81 >> 8) & 255) << 8)) | ((c81 >> 16) & 255));
            								}
            								else {
HXLINE( 541)									_hx_tmp126 = c81;
            								}
HXDLIN( 541)								::iterMagic::Iimg_obj::set(this365,index83,_hx_tmp126);
            							}
            						}
            					}
HXLINE( 543)					{
HXLINE( 543)						int x60 = (this1->width - 1);
HXDLIN( 543)						int x61 = (this1->width - 1);
HXDLIN( 543)						::Dynamic this366 = here->image;
HXDLIN( 543)						int index84;
HXDLIN( 543)						if (here->useVirtualPos) {
HXLINE( 543)							index84 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x61) - here->virtualX));
            						}
            						else {
HXLINE( 543)							index84 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x61)) ));
            						}
HXDLIN( 543)						int c82 = ::iterMagic::Iimg_obj::get(this366,index84);
HXDLIN( 543)						int color31;
HXDLIN( 543)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 543)							color31 = ((((((c82 >> 24) & 255) << 24) | ((c82 & 255) << 16)) | (((c82 >> 8) & 255) << 8)) | ((c82 >> 16) & 255));
            						}
            						else {
HXLINE( 543)							color31 = c82;
            						}
HXDLIN( 543)						{
HXLINE( 543)							int c83 = color31;
HXDLIN( 543)							bool _hx_tmp127;
HXDLIN( 543)							if ((((c83 >> 24) & 255) < 254)) {
HXLINE( 543)								_hx_tmp127 = out->transparent;
            							}
            							else {
HXLINE( 543)								_hx_tmp127 = false;
            							}
HXDLIN( 543)							if (_hx_tmp127) {
HXLINE( 543)								int location26;
HXDLIN( 543)								if (out->useVirtualPos) {
HXLINE( 543)									location26 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXLINE( 543)									location26 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 543)								int this367 = ::iterMagic::Iimg_obj::get(out->image,location26);
HXDLIN( 543)								int this368;
HXDLIN( 543)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 543)									this368 = ((((((this367 >> 24) & 255) << 24) | ((this367 & 255) << 16)) | (((this367 >> 8) & 255) << 8)) | ((this367 >> 16) & 255));
            								}
            								else {
HXLINE( 543)									this368 = this367;
            								}
HXDLIN( 543)								Float a128;
HXDLIN( 543)								int this369 = ((this368 >> 24) & 255);
HXDLIN( 543)								if ((this369 == 0)) {
HXLINE( 543)									a128 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									a128 = (( (Float)(this369) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float r126;
HXDLIN( 543)								int this370 = ((this368 >> 16) & 255);
HXDLIN( 543)								if ((this370 == 0)) {
HXLINE( 543)									r126 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									r126 = (( (Float)(this370) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float g126;
HXDLIN( 543)								int this371 = ((this368 >> 8) & 255);
HXDLIN( 543)								if ((this371 == 0)) {
HXLINE( 543)									g126 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									g126 = (( (Float)(this371) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float b129;
HXDLIN( 543)								int this372 = (this368 & 255);
HXDLIN( 543)								if ((this372 == 0)) {
HXLINE( 543)									b129 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									b129 = (( (Float)(this372) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float a227;
HXDLIN( 543)								int this373 = ((color31 >> 24) & 255);
HXDLIN( 543)								if ((this373 == 0)) {
HXLINE( 543)									a227 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									a227 = (( (Float)(this373) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float r226;
HXDLIN( 543)								int this374 = ((color31 >> 16) & 255);
HXDLIN( 543)								if ((this374 == 0)) {
HXLINE( 543)									r226 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									r226 = (( (Float)(this374) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float g226;
HXDLIN( 543)								int this375 = ((color31 >> 8) & 255);
HXDLIN( 543)								if ((this375 == 0)) {
HXLINE( 543)									g226 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									g226 = (( (Float)(this375) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float b227;
HXDLIN( 543)								int this376 = (color31 & 255);
HXDLIN( 543)								if ((this376 == 0)) {
HXLINE( 543)									b227 = ((Float)0.);
            								}
            								else {
HXLINE( 543)									b227 = (( (Float)(this376) ) / ( (Float)(255) ));
            								}
HXDLIN( 543)								Float a326 = (a128 * (( (Float)(1) ) - a227));
HXDLIN( 543)								int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 543)								int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 543)								int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a326) + (b227 * a227))));
HXDLIN( 543)								int a56 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 543)								int blended26 = ((((a56 << 24) | (r46 << 16)) | (g46 << 8)) | b51);
HXDLIN( 543)								{
HXLINE( 543)									int _hx_tmp128;
HXDLIN( 543)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 543)										_hx_tmp128 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            									}
            									else {
HXLINE( 543)										_hx_tmp128 = blended26;
            									}
HXDLIN( 543)									::iterMagic::Iimg_obj::set(out->image,location26,_hx_tmp128);
            								}
            							}
            							else {
HXLINE( 543)								::Dynamic this377 = out->image;
HXDLIN( 543)								int index85;
HXDLIN( 543)								if (out->useVirtualPos) {
HXLINE( 543)									index85 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXLINE( 543)									index85 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 543)								int _hx_tmp129;
HXDLIN( 543)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 543)									_hx_tmp129 = ((((((c83 >> 24) & 255) << 24) | ((c83 & 255) << 16)) | (((c83 >> 8) & 255) << 8)) | ((c83 >> 16) & 255));
            								}
            								else {
HXLINE( 543)									_hx_tmp129 = c83;
            								}
HXDLIN( 543)								::iterMagic::Iimg_obj::set(this377,index85,_hx_tmp129);
            							}
            						}
            					}
HXLINE( 544)					{
HXLINE( 544)						int x62 = (this1->width - 2);
HXDLIN( 544)						int x63 = (this1->width - 2);
HXDLIN( 544)						::Dynamic this378 = here->image;
HXDLIN( 544)						int index86;
HXDLIN( 544)						if (here->useVirtualPos) {
HXLINE( 544)							index86 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x63) - here->virtualX));
            						}
            						else {
HXLINE( 544)							index86 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x63)) ));
            						}
HXDLIN( 544)						int c84 = ::iterMagic::Iimg_obj::get(this378,index86);
HXDLIN( 544)						int color32;
HXDLIN( 544)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)							color32 = ((((((c84 >> 24) & 255) << 24) | ((c84 & 255) << 16)) | (((c84 >> 8) & 255) << 8)) | ((c84 >> 16) & 255));
            						}
            						else {
HXLINE( 544)							color32 = c84;
            						}
HXDLIN( 544)						{
HXLINE( 544)							int c85 = color32;
HXDLIN( 544)							bool _hx_tmp130;
HXDLIN( 544)							if ((((c85 >> 24) & 255) < 254)) {
HXLINE( 544)								_hx_tmp130 = out->transparent;
            							}
            							else {
HXLINE( 544)								_hx_tmp130 = false;
            							}
HXDLIN( 544)							if (_hx_tmp130) {
HXLINE( 544)								int location27;
HXDLIN( 544)								if (out->useVirtualPos) {
HXLINE( 544)									location27 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXLINE( 544)									location27 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 544)								int this379 = ::iterMagic::Iimg_obj::get(out->image,location27);
HXDLIN( 544)								int this380;
HXDLIN( 544)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)									this380 = ((((((this379 >> 24) & 255) << 24) | ((this379 & 255) << 16)) | (((this379 >> 8) & 255) << 8)) | ((this379 >> 16) & 255));
            								}
            								else {
HXLINE( 544)									this380 = this379;
            								}
HXDLIN( 544)								Float a129;
HXDLIN( 544)								int this381 = ((this380 >> 24) & 255);
HXDLIN( 544)								if ((this381 == 0)) {
HXLINE( 544)									a129 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									a129 = (( (Float)(this381) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float r127;
HXDLIN( 544)								int this382 = ((this380 >> 16) & 255);
HXDLIN( 544)								if ((this382 == 0)) {
HXLINE( 544)									r127 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									r127 = (( (Float)(this382) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float g127;
HXDLIN( 544)								int this383 = ((this380 >> 8) & 255);
HXDLIN( 544)								if ((this383 == 0)) {
HXLINE( 544)									g127 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									g127 = (( (Float)(this383) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float b130;
HXDLIN( 544)								int this384 = (this380 & 255);
HXDLIN( 544)								if ((this384 == 0)) {
HXLINE( 544)									b130 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									b130 = (( (Float)(this384) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float a228;
HXDLIN( 544)								int this385 = ((color32 >> 24) & 255);
HXDLIN( 544)								if ((this385 == 0)) {
HXLINE( 544)									a228 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									a228 = (( (Float)(this385) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float r227;
HXDLIN( 544)								int this386 = ((color32 >> 16) & 255);
HXDLIN( 544)								if ((this386 == 0)) {
HXLINE( 544)									r227 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									r227 = (( (Float)(this386) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float g227;
HXDLIN( 544)								int this387 = ((color32 >> 8) & 255);
HXDLIN( 544)								if ((this387 == 0)) {
HXLINE( 544)									g227 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									g227 = (( (Float)(this387) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float b228;
HXDLIN( 544)								int this388 = (color32 & 255);
HXDLIN( 544)								if ((this388 == 0)) {
HXLINE( 544)									b228 = ((Float)0.);
            								}
            								else {
HXLINE( 544)									b228 = (( (Float)(this388) ) / ( (Float)(255) ));
            								}
HXDLIN( 544)								Float a327 = (a129 * (( (Float)(1) ) - a228));
HXDLIN( 544)								int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 544)								int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 544)								int b52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a327) + (b228 * a228))));
HXDLIN( 544)								int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 544)								int blended27 = ((((a57 << 24) | (r47 << 16)) | (g47 << 8)) | b52);
HXDLIN( 544)								{
HXLINE( 544)									int _hx_tmp131;
HXDLIN( 544)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)										_hx_tmp131 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            									}
            									else {
HXLINE( 544)										_hx_tmp131 = blended27;
            									}
HXDLIN( 544)									::iterMagic::Iimg_obj::set(out->image,location27,_hx_tmp131);
            								}
            							}
            							else {
HXLINE( 544)								::Dynamic this389 = out->image;
HXDLIN( 544)								int index87;
HXDLIN( 544)								if (out->useVirtualPos) {
HXLINE( 544)									index87 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXLINE( 544)									index87 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 544)								int _hx_tmp132;
HXDLIN( 544)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)									_hx_tmp132 = ((((((c85 >> 24) & 255) << 24) | ((c85 & 255) << 16)) | (((c85 >> 8) & 255) << 8)) | ((c85 >> 16) & 255));
            								}
            								else {
HXLINE( 544)									_hx_tmp132 = c85;
            								}
HXDLIN( 544)								::iterMagic::Iimg_obj::set(this389,index87,_hx_tmp132);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 547)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Convolution_Impl__obj,convolute5x5,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::sharpen0_3x3( ::pi_xy::ImageStruct this1,::hx::Null< Float >  __o_strength,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		Float strength = __o_strength.Default(4);
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_553_sharpen0_3x3)
HXLINE( 554)		Float x = ((( (Float)(1) ) - strength) / ((Float)4.));
HXLINE( 555)		Float m33_a = ((Float)0.);
HXDLIN( 555)		Float m33_b = x;
HXDLIN( 555)		Float m33_c = ((Float)0.);
HXDLIN( 555)		Float m33_d = x;
HXDLIN( 555)		Float m33_e = strength;
HXDLIN( 555)		Float m33_f = x;
HXDLIN( 555)		Float m33_g = ( (Float)(0) );
HXDLIN( 555)		Float m33_h = x;
HXDLIN( 555)		Float m33_i = ((Float)0.);
HXDLIN( 555)		bool adjustRed = true;
HXDLIN( 555)		bool adjustGreen = true;
HXDLIN( 555)		bool adjustBlue = true;
HXDLIN( 555)		int a0 = 0;
HXDLIN( 555)		int b0 = 0;
HXDLIN( 555)		int c0 = 0;
HXDLIN( 555)		int d0 = 0;
HXDLIN( 555)		int e0 = 0;
HXDLIN( 555)		int f0 = 0;
HXDLIN( 555)		int g0 = 0;
HXDLIN( 555)		int h0 = 0;
HXDLIN( 555)		int i0 = 0;
HXDLIN( 555)		Float r_ = ((Float)0.);
HXDLIN( 555)		Float g_ = ((Float)0.);
HXDLIN( 555)		Float b_ = ((Float)0.);
HXDLIN( 555)		Float a_ = ((Float)0.);
HXDLIN( 555)		int width = this1->width;
HXDLIN( 555)		int height = this1->height;
HXDLIN( 555)		 ::Dynamic imageType = null();
HXDLIN( 555)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 555)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 555)		::Dynamic _hx_tmp;
HXDLIN( 555)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 555)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 555)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 555)				{
HXLINE( 555)					b->width = width;
HXDLIN( 555)					b->height = height;
HXDLIN( 555)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 555)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 555)					{
HXLINE( 555)						int len = b->length;
HXDLIN( 555)						int w = 0;
HXDLIN( 555)						{
HXLINE( 555)							int _g = 0;
HXDLIN( 555)							int _g1 = b->height;
HXDLIN( 555)							while((_g < _g1)){
HXLINE( 555)								_g = (_g + 1);
HXDLIN( 555)								int y = (_g - 1);
HXDLIN( 555)								{
HXLINE( 555)									int _g2 = 0;
HXDLIN( 555)									int _g3 = b->width;
HXDLIN( 555)									while((_g2 < _g3)){
HXLINE( 555)										_g2 = (_g2 + 1);
HXDLIN( 555)										int x1 = (_g2 - 1);
HXDLIN( 555)										{
HXLINE( 555)											w = (w + 1);
HXDLIN( 555)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 555)										{
HXLINE( 555)											w = (w + 1);
HXDLIN( 555)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 555)										{
HXLINE( 555)											w = (w + 1);
HXDLIN( 555)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 555)										{
HXLINE( 555)											w = (w + 1);
HXDLIN( 555)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 555)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 555)				{
HXLINE( 555)					a->width = width;
HXDLIN( 555)					a->height = height;
HXDLIN( 555)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 555)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 555)					{
HXLINE( 555)						int _g4 = 0;
HXDLIN( 555)						int _g5 = a->length;
HXDLIN( 555)						while((_g4 < _g5)){
HXLINE( 555)							_g4 = (_g4 + 1);
HXDLIN( 555)							int i = (_g4 - 1);
HXDLIN( 555)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 555)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 555)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 555)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 555)				{
HXLINE( 555)					b1->width = width;
HXDLIN( 555)					b1->height = height;
HXDLIN( 555)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 555)					int size = (b1->length * 4);
HXDLIN( 555)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 555)					{
HXLINE( 555)						int _g6 = 0;
HXDLIN( 555)						int _g7 = b1->length;
HXDLIN( 555)						while((_g6 < _g7)){
HXLINE( 555)							_g6 = (_g6 + 1);
HXDLIN( 555)							int i1 = (_g6 - 1);
HXDLIN( 555)							{
HXLINE( 555)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 555)								bool _hx_tmp1;
HXDLIN( 555)								if ((i1 >= 0)) {
HXLINE( 555)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 555)									_hx_tmp1 = false;
            								}
HXDLIN( 555)								if (_hx_tmp1) {
HXLINE( 555)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 555)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 555)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 555)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 555)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 555)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 555)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 555)				{
HXLINE( 555)					v->width = width;
HXDLIN( 555)					v->height = height;
HXDLIN( 555)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 555)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 555)					{
HXLINE( 555)						int _g8 = 0;
HXDLIN( 555)						int _g9 = v->length;
HXDLIN( 555)						while((_g8 < _g9)){
HXLINE( 555)							_g8 = (_g8 + 1);
HXDLIN( 555)							int i2 = (_g8 - 1);
HXDLIN( 555)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 555)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 555)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 555)				{
HXLINE( 555)					b2->width = width;
HXDLIN( 555)					b2->height = height;
HXDLIN( 555)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 555)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 555)					{
HXLINE( 555)						int len1 = b2->length;
HXDLIN( 555)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 555)						if (::hx::IsNull( d->head )) {
HXLINE( 555)							int _g10 = 0;
HXDLIN( 555)							int _g11 = len1;
HXDLIN( 555)							while((_g10 < _g11)){
HXLINE( 555)								_g10 = (_g10 + 1);
HXDLIN( 555)								int i3 = (_g10 - 1);
HXDLIN( 555)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 555)							int _g12 = 0;
HXDLIN( 555)							int _g13 = len1;
HXDLIN( 555)							while((_g12 < _g13)){
HXLINE( 555)								_g12 = (_g12 + 1);
HXDLIN( 555)								int i4 = (_g12 - 1);
HXDLIN( 555)								{
HXLINE( 555)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 555)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 555)									{
HXLINE( 555)										int _g14 = 0;
HXDLIN( 555)										int _g15 = i4;
HXDLIN( 555)										while((_g14 < _g15)){
HXLINE( 555)											_g14 = (_g14 + 1);
HXDLIN( 555)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 555)									if (::hx::IsNull( prev )) {
HXLINE( 555)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 555)										l = null();
            									}
            									else {
HXLINE( 555)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 555)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 555)		this2->image = _hx_tmp;
HXDLIN( 555)		this2->width = width;
HXDLIN( 555)		this2->height = height;
HXDLIN( 555)		this2->imageType = ( (int)(imageType) );
HXDLIN( 555)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 555)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 555)		switch((int)(borderMode)){
            			case (int)0: {
HXLINE( 555)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 555)				int width1 = (this4->width + 2);
HXDLIN( 555)				int height1 = (this4->height + 2);
HXDLIN( 555)				 ::Dynamic imageType1 = null();
HXDLIN( 555)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 555)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 555)				::Dynamic here1;
HXDLIN( 555)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 555)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 555)						{
HXLINE( 555)							b3->width = width1;
HXDLIN( 555)							b3->height = height1;
HXDLIN( 555)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 555)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 555)							{
HXLINE( 555)								int len2 = b3->length;
HXDLIN( 555)								int w1 = 0;
HXDLIN( 555)								{
HXLINE( 555)									int _g16 = 0;
HXDLIN( 555)									int _g17 = b3->height;
HXDLIN( 555)									while((_g16 < _g17)){
HXLINE( 555)										_g16 = (_g16 + 1);
HXDLIN( 555)										int y1 = (_g16 - 1);
HXDLIN( 555)										{
HXLINE( 555)											int _g18 = 0;
HXDLIN( 555)											int _g19 = b3->width;
HXDLIN( 555)											while((_g18 < _g19)){
HXLINE( 555)												_g18 = (_g18 + 1);
HXDLIN( 555)												int x2 = (_g18 - 1);
HXDLIN( 555)												{
HXLINE( 555)													w1 = (w1 + 1);
HXDLIN( 555)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w1 = (w1 + 1);
HXDLIN( 555)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w1 = (w1 + 1);
HXDLIN( 555)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w1 = (w1 + 1);
HXDLIN( 555)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXLINE( 555)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 555)						{
HXLINE( 555)							a1->width = width1;
HXDLIN( 555)							a1->height = height1;
HXDLIN( 555)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 555)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 555)							{
HXLINE( 555)								int _g20 = 0;
HXDLIN( 555)								int _g21 = a1->length;
HXDLIN( 555)								while((_g20 < _g21)){
HXLINE( 555)									_g20 = (_g20 + 1);
HXDLIN( 555)									int i6 = (_g20 - 1);
HXDLIN( 555)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 555)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXLINE( 555)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 555)						{
HXLINE( 555)							b4->width = width1;
HXDLIN( 555)							b4->height = height1;
HXDLIN( 555)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 555)							int size1 = (b4->length * 4);
HXDLIN( 555)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 555)							{
HXLINE( 555)								int _g22 = 0;
HXDLIN( 555)								int _g23 = b4->length;
HXDLIN( 555)								while((_g22 < _g23)){
HXLINE( 555)									_g22 = (_g22 + 1);
HXDLIN( 555)									int i7 = (_g22 - 1);
HXDLIN( 555)									{
HXLINE( 555)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 555)										bool here2;
HXDLIN( 555)										if ((i7 >= 0)) {
HXLINE( 555)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXLINE( 555)											here2 = false;
            										}
HXDLIN( 555)										if (here2) {
HXLINE( 555)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 555)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 555)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 555)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 555)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 555)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXLINE( 555)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 555)						{
HXLINE( 555)							v1->width = width1;
HXDLIN( 555)							v1->height = height1;
HXDLIN( 555)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 555)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 555)							{
HXLINE( 555)								int _g24 = 0;
HXDLIN( 555)								int _g25 = v1->length;
HXDLIN( 555)								while((_g24 < _g25)){
HXLINE( 555)									_g24 = (_g24 + 1);
HXDLIN( 555)									int i8 = (_g24 - 1);
HXDLIN( 555)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 555)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXLINE( 555)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 555)						{
HXLINE( 555)							b5->width = width1;
HXDLIN( 555)							b5->height = height1;
HXDLIN( 555)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 555)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 555)							{
HXLINE( 555)								int len3 = b5->length;
HXDLIN( 555)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 555)								if (::hx::IsNull( d1->head )) {
HXLINE( 555)									int _g26 = 0;
HXDLIN( 555)									int _g27 = len3;
HXDLIN( 555)									while((_g26 < _g27)){
HXLINE( 555)										_g26 = (_g26 + 1);
HXDLIN( 555)										int i9 = (_g26 - 1);
HXDLIN( 555)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 555)									int _g28 = 0;
HXDLIN( 555)									int _g29 = len3;
HXDLIN( 555)									while((_g28 < _g29)){
HXLINE( 555)										_g28 = (_g28 + 1);
HXDLIN( 555)										int i10 = (_g28 - 1);
HXDLIN( 555)										{
HXLINE( 555)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 555)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 555)											{
HXLINE( 555)												int _g30 = 0;
HXDLIN( 555)												int _g31 = i10;
HXDLIN( 555)												while((_g30 < _g31)){
HXLINE( 555)													_g30 = (_g30 + 1);
HXDLIN( 555)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 555)											if (::hx::IsNull( prev1 )) {
HXLINE( 555)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 555)												l1 = null();
            											}
            											else {
HXLINE( 555)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 555)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 555)				this5->image = here1;
HXDLIN( 555)				this5->width = width1;
HXDLIN( 555)				this5->height = height1;
HXDLIN( 555)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 555)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 555)				bool forceClear = false;
HXDLIN( 555)				int _g32 = 0;
HXDLIN( 555)				int _g33 = this4->height;
HXDLIN( 555)				while((_g32 < _g33)){
HXLINE( 555)					_g32 = (_g32 + 1);
HXDLIN( 555)					int dy = (_g32 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g34 = 0;
HXDLIN( 555)						int _g35 = this4->width;
HXDLIN( 555)						while((_g34 < _g35)){
HXLINE( 555)							_g34 = (_g34 + 1);
HXDLIN( 555)							int dx = (_g34 - 1);
HXDLIN( 555)							::Dynamic this7 = this4->image;
HXDLIN( 555)							int index;
HXDLIN( 555)							if (this4->useVirtualPos) {
HXLINE( 555)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXLINE( 555)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 555)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 555)							int col;
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 555)								col = c;
            							}
HXDLIN( 555)							bool here3;
HXDLIN( 555)							if (this4->useMask) {
HXLINE( 555)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXLINE( 555)								here3 = false;
            							}
HXDLIN( 555)							if (here3) {
HXLINE( 555)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 555)								::Dynamic this9 = this8->image;
HXDLIN( 555)								int index1;
HXDLIN( 555)								if (this8->useVirtualPos) {
HXLINE( 555)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXLINE( 555)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 555)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 555)								int v2;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									v2 = c1;
            								}
HXDLIN( 555)								int maskPixel = v2;
HXDLIN( 555)								int this10 = col;
HXDLIN( 555)								if ((maskPixel == 0)) {
HXLINE( 555)									col = this10;
            								}
            								else {
HXLINE( 555)									Float m0;
HXDLIN( 555)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 555)									if ((this11 == 0)) {
HXLINE( 555)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m1;
HXDLIN( 555)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 555)									if ((this12 == 0)) {
HXLINE( 555)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m2;
HXDLIN( 555)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 555)									if ((this13 == 0)) {
HXLINE( 555)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m3;
HXDLIN( 555)									int this14 = (maskPixel & 255);
HXDLIN( 555)									if ((this14 == 0)) {
HXLINE( 555)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 555)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 555)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 555)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 555)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 555)							if ((col != 0)) {
HXLINE( 555)								int x3 = (1 + dx);
HXDLIN( 555)								int y2 = (1 + dy);
HXDLIN( 555)								int c2 = col;
HXDLIN( 555)								bool here4;
HXDLIN( 555)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 555)									here4 = img->transparent;
            								}
            								else {
HXLINE( 555)									here4 = false;
            								}
HXDLIN( 555)								if (here4) {
HXLINE( 555)									int location;
HXDLIN( 555)									if (img->useVirtualPos) {
HXLINE( 555)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXLINE( 555)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x3)) ));
            									}
HXDLIN( 555)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 555)									int this16;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										this16 = this15;
            									}
HXDLIN( 555)									Float a11;
HXDLIN( 555)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 555)									if ((this17 == 0)) {
HXLINE( 555)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r1;
HXDLIN( 555)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 555)									if ((this18 == 0)) {
HXLINE( 555)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g1;
HXDLIN( 555)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 555)									if ((this19 == 0)) {
HXLINE( 555)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b11;
HXDLIN( 555)									int this20 = (this16 & 255);
HXDLIN( 555)									if ((this20 == 0)) {
HXLINE( 555)										b11 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a2;
HXDLIN( 555)									int this21 = ((col >> 24) & 255);
HXDLIN( 555)									if ((this21 == 0)) {
HXLINE( 555)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r2;
HXDLIN( 555)									int this22 = ((col >> 16) & 255);
HXDLIN( 555)									if ((this22 == 0)) {
HXLINE( 555)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g2;
HXDLIN( 555)									int this23 = ((col >> 8) & 255);
HXDLIN( 555)									if ((this23 == 0)) {
HXLINE( 555)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b21;
HXDLIN( 555)									int this24 = (col & 255);
HXDLIN( 555)									if ((this24 == 0)) {
HXLINE( 555)										b21 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 555)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 555)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 555)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 555)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 555)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 555)									{
HXLINE( 555)										int here5;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here5 = blended;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXLINE( 555)									::Dynamic this25 = img->image;
HXDLIN( 555)									int index2;
HXDLIN( 555)									if (img->useVirtualPos) {
HXLINE( 555)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXLINE( 555)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x3)) ));
            									}
HXDLIN( 555)									int here6;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										here6 = c2;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXLINE( 555)								if (forceClear) {
HXLINE( 555)									::Dynamic this26 = img->image;
HXDLIN( 555)									int x4 = (1 + dx);
HXDLIN( 555)									int y3 = (1 + dy);
HXDLIN( 555)									int index3;
HXDLIN( 555)									if (img->useVirtualPos) {
HXLINE( 555)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 555)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g36 = 0;
HXDLIN( 555)				int _g37 = this4->width;
HXDLIN( 555)				while((_g36 < _g37)){
HXLINE( 555)					_g36 = (_g36 + 1);
HXDLIN( 555)					int x5 = (_g36 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g38 = 0;
HXDLIN( 555)						int _g39 = 1;
HXDLIN( 555)						while((_g38 < _g39)){
HXLINE( 555)							_g38 = (_g38 + 1);
HXDLIN( 555)							int y4 = (_g38 - 1);
HXDLIN( 555)							{
HXLINE( 555)								int x6 = (x5 + 1);
HXDLIN( 555)								::Dynamic this27 = this4->image;
HXDLIN( 555)								int index4;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x5) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x5)) ));
            								}
HXDLIN( 555)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 555)								int color;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color = c3;
            								}
HXDLIN( 555)								int color1 = color;
HXDLIN( 555)								{
HXLINE( 555)									int c4 = color1;
HXDLIN( 555)									bool here7;
HXDLIN( 555)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 555)										here7 = img->transparent;
            									}
            									else {
HXLINE( 555)										here7 = false;
            									}
HXDLIN( 555)									if (here7) {
HXLINE( 555)										int location1;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x6)) ));
            										}
HXDLIN( 555)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 555)										int this29;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this29 = this28;
            										}
HXDLIN( 555)										Float a12;
HXDLIN( 555)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 555)										if ((this30 == 0)) {
HXLINE( 555)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r11;
HXDLIN( 555)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 555)										if ((this31 == 0)) {
HXLINE( 555)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g11;
HXDLIN( 555)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 555)										if ((this32 == 0)) {
HXLINE( 555)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b12;
HXDLIN( 555)										int this33 = (this29 & 255);
HXDLIN( 555)										if ((this33 == 0)) {
HXLINE( 555)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a21;
HXDLIN( 555)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 555)										if ((this34 == 0)) {
HXLINE( 555)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r21;
HXDLIN( 555)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 555)										if ((this35 == 0)) {
HXLINE( 555)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g21;
HXDLIN( 555)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 555)										if ((this36 == 0)) {
HXLINE( 555)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b22;
HXDLIN( 555)										int this37 = (color1 & 255);
HXDLIN( 555)										if ((this37 == 0)) {
HXLINE( 555)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 555)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 555)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 555)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 555)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 555)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 555)										{
HXLINE( 555)											int here8;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here8 = blended1;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this38 = img->image;
HXDLIN( 555)										int index5;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x6)) ));
            										}
HXDLIN( 555)										int here9;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here9 = c4;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x7 = (x5 + 1);
HXDLIN( 555)								int y5 = ((img->height - y4) - 1);
HXDLIN( 555)								int y6 = (this4->height - 1);
HXDLIN( 555)								::Dynamic this39 = this4->image;
HXDLIN( 555)								int index6;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x5) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x5)) ));
            								}
HXDLIN( 555)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 555)								int color2;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color2 = c5;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c6 = color2;
HXDLIN( 555)									bool here10;
HXDLIN( 555)									if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 555)										here10 = img->transparent;
            									}
            									else {
HXLINE( 555)										here10 = false;
            									}
HXDLIN( 555)									if (here10) {
HXLINE( 555)										int location2;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x7)) ));
            										}
HXDLIN( 555)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 555)										int this41;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this41 = this40;
            										}
HXDLIN( 555)										Float a13;
HXDLIN( 555)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 555)										if ((this42 == 0)) {
HXLINE( 555)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r12;
HXDLIN( 555)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 555)										if ((this43 == 0)) {
HXLINE( 555)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g12;
HXDLIN( 555)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 555)										if ((this44 == 0)) {
HXLINE( 555)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b13;
HXDLIN( 555)										int this45 = (this41 & 255);
HXDLIN( 555)										if ((this45 == 0)) {
HXLINE( 555)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a22;
HXDLIN( 555)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 555)										if ((this46 == 0)) {
HXLINE( 555)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r22;
HXDLIN( 555)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 555)										if ((this47 == 0)) {
HXLINE( 555)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g22;
HXDLIN( 555)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 555)										if ((this48 == 0)) {
HXLINE( 555)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b23;
HXDLIN( 555)										int this49 = (color2 & 255);
HXDLIN( 555)										if ((this49 == 0)) {
HXLINE( 555)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 555)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 555)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 555)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 555)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 555)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 555)										{
HXLINE( 555)											int here11;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here11 = blended2;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this50 = img->image;
HXDLIN( 555)										int index7;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x7)) ));
            										}
HXDLIN( 555)										int here12;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here12 = c6;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g40 = 0;
HXDLIN( 555)				int _g41 = this4->height;
HXDLIN( 555)				while((_g40 < _g41)){
HXLINE( 555)					_g40 = (_g40 + 1);
HXDLIN( 555)					int y7 = (_g40 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g42 = 0;
HXDLIN( 555)						int _g43 = 1;
HXDLIN( 555)						while((_g42 < _g43)){
HXLINE( 555)							_g42 = (_g42 + 1);
HXDLIN( 555)							int x8 = (_g42 - 1);
HXDLIN( 555)							{
HXLINE( 555)								int y8 = (y7 + 1);
HXDLIN( 555)								::Dynamic this51 = this4->image;
HXDLIN( 555)								int index8;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 555)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 555)								int color3;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color3 = c7;
            								}
HXDLIN( 555)								int color4 = color3;
HXDLIN( 555)								{
HXLINE( 555)									int c8 = color4;
HXDLIN( 555)									bool here13;
HXDLIN( 555)									if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 555)										here13 = img->transparent;
            									}
            									else {
HXLINE( 555)										here13 = false;
            									}
HXDLIN( 555)									if (here13) {
HXLINE( 555)										int location3;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            										}
HXDLIN( 555)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 555)										int this53;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this53 = this52;
            										}
HXDLIN( 555)										Float a14;
HXDLIN( 555)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 555)										if ((this54 == 0)) {
HXLINE( 555)											a14 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r13;
HXDLIN( 555)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 555)										if ((this55 == 0)) {
HXLINE( 555)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g13;
HXDLIN( 555)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 555)										if ((this56 == 0)) {
HXLINE( 555)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b14;
HXDLIN( 555)										int this57 = (this53 & 255);
HXDLIN( 555)										if ((this57 == 0)) {
HXLINE( 555)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a23;
HXDLIN( 555)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 555)										if ((this58 == 0)) {
HXLINE( 555)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r23;
HXDLIN( 555)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 555)										if ((this59 == 0)) {
HXLINE( 555)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g23;
HXDLIN( 555)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 555)										if ((this60 == 0)) {
HXLINE( 555)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b24;
HXDLIN( 555)										int this61 = (color4 & 255);
HXDLIN( 555)										if ((this61 == 0)) {
HXLINE( 555)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 555)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 555)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 555)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 555)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 555)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 555)										{
HXLINE( 555)											int here14;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here14 = blended3;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this62 = img->image;
HXDLIN( 555)										int index9;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            										}
HXDLIN( 555)										int here15;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here15 = c8;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x9 = ((img->width - x8) - 1);
HXDLIN( 555)								int y9 = (y7 + 1);
HXDLIN( 555)								int x10 = (this4->width - 1);
HXDLIN( 555)								::Dynamic this63 = this4->image;
HXDLIN( 555)								int index10;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x10) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x10)) ));
            								}
HXDLIN( 555)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 555)								int color5;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color5 = c9;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c10 = color5;
HXDLIN( 555)									bool here16;
HXDLIN( 555)									if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 555)										here16 = img->transparent;
            									}
            									else {
HXLINE( 555)										here16 = false;
            									}
HXDLIN( 555)									if (here16) {
HXLINE( 555)										int location4;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            										}
HXDLIN( 555)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 555)										int this65;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this65 = this64;
            										}
HXDLIN( 555)										Float a15;
HXDLIN( 555)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 555)										if ((this66 == 0)) {
HXLINE( 555)											a15 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r14;
HXDLIN( 555)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 555)										if ((this67 == 0)) {
HXLINE( 555)											r14 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g14;
HXDLIN( 555)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 555)										if ((this68 == 0)) {
HXLINE( 555)											g14 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b15;
HXDLIN( 555)										int this69 = (this65 & 255);
HXDLIN( 555)										if ((this69 == 0)) {
HXLINE( 555)											b15 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a24;
HXDLIN( 555)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 555)										if ((this70 == 0)) {
HXLINE( 555)											a24 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r24;
HXDLIN( 555)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 555)										if ((this71 == 0)) {
HXLINE( 555)											r24 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g24;
HXDLIN( 555)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 555)										if ((this72 == 0)) {
HXLINE( 555)											g24 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b25;
HXDLIN( 555)										int this73 = (color5 & 255);
HXDLIN( 555)										if ((this73 == 0)) {
HXLINE( 555)											b25 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 555)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 555)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 555)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 555)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 555)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 555)										{
HXLINE( 555)											int here17;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here17 = blended4;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this74 = img->image;
HXDLIN( 555)										int index11;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            										}
HXDLIN( 555)										int here18;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here18 = c10;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g44 = 0;
HXDLIN( 555)				int _g45 = 1;
HXDLIN( 555)				while((_g44 < _g45)){
HXLINE( 555)					_g44 = (_g44 + 1);
HXDLIN( 555)					int x11 = (_g44 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g46 = 0;
HXDLIN( 555)						int _g47 = 1;
HXDLIN( 555)						while((_g46 < _g47)){
HXLINE( 555)							_g46 = (_g46 + 1);
HXDLIN( 555)							int y10 = (_g46 - 1);
HXDLIN( 555)							{
HXLINE( 555)								::Dynamic this75 = this4->image;
HXDLIN( 555)								int index12;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 555)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 555)								int color6;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color6 = c11;
            								}
HXDLIN( 555)								int color7 = color6;
HXDLIN( 555)								{
HXLINE( 555)									int c12 = color7;
HXDLIN( 555)									bool here19;
HXDLIN( 555)									if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 555)										here19 = img->transparent;
            									}
            									else {
HXLINE( 555)										here19 = false;
            									}
HXDLIN( 555)									if (here19) {
HXLINE( 555)										int location5;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 555)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 555)										int this77;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this77 = this76;
            										}
HXDLIN( 555)										Float a16;
HXDLIN( 555)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 555)										if ((this78 == 0)) {
HXLINE( 555)											a16 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r15;
HXDLIN( 555)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 555)										if ((this79 == 0)) {
HXLINE( 555)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g15;
HXDLIN( 555)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 555)										if ((this80 == 0)) {
HXLINE( 555)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b16;
HXDLIN( 555)										int this81 = (this77 & 255);
HXDLIN( 555)										if ((this81 == 0)) {
HXLINE( 555)											b16 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a25;
HXDLIN( 555)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 555)										if ((this82 == 0)) {
HXLINE( 555)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r25;
HXDLIN( 555)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 555)										if ((this83 == 0)) {
HXLINE( 555)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g25;
HXDLIN( 555)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 555)										if ((this84 == 0)) {
HXLINE( 555)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b26;
HXDLIN( 555)										int this85 = (color7 & 255);
HXDLIN( 555)										if ((this85 == 0)) {
HXLINE( 555)											b26 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 555)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 555)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 555)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 555)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 555)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 555)										{
HXLINE( 555)											int here20;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here20 = blended5;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this86 = img->image;
HXDLIN( 555)										int index13;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 555)										int here21;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here21 = c12;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x12 = ((x11 + 1) + this4->width);
HXDLIN( 555)								int x13 = (this4->width - 1);
HXDLIN( 555)								::Dynamic this87 = this4->image;
HXDLIN( 555)								int index14;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x13) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x13)) ));
            								}
HXDLIN( 555)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 555)								int color8;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color8 = c13;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c14 = color8;
HXDLIN( 555)									bool here22;
HXDLIN( 555)									if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 555)										here22 = img->transparent;
            									}
            									else {
HXLINE( 555)										here22 = false;
            									}
HXDLIN( 555)									if (here22) {
HXLINE( 555)										int location6;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            										}
HXDLIN( 555)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 555)										int this89;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this89 = this88;
            										}
HXDLIN( 555)										Float a17;
HXDLIN( 555)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 555)										if ((this90 == 0)) {
HXLINE( 555)											a17 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r16;
HXDLIN( 555)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 555)										if ((this91 == 0)) {
HXLINE( 555)											r16 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g16;
HXDLIN( 555)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 555)										if ((this92 == 0)) {
HXLINE( 555)											g16 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b18;
HXDLIN( 555)										int this93 = (this89 & 255);
HXDLIN( 555)										if ((this93 == 0)) {
HXLINE( 555)											b18 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a26;
HXDLIN( 555)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 555)										if ((this94 == 0)) {
HXLINE( 555)											a26 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r26;
HXDLIN( 555)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 555)										if ((this95 == 0)) {
HXLINE( 555)											r26 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g26;
HXDLIN( 555)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 555)										if ((this96 == 0)) {
HXLINE( 555)											g26 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b27;
HXDLIN( 555)										int this97 = (color8 & 255);
HXDLIN( 555)										if ((this97 == 0)) {
HXLINE( 555)											b27 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 555)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 555)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 555)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 555)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 555)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 555)										{
HXLINE( 555)											int here23;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here23 = blended6;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this98 = img->image;
HXDLIN( 555)										int index15;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            										}
HXDLIN( 555)										int here24;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here24 = c14;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x14 = ((x11 + 1) + this4->width);
HXDLIN( 555)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 555)								int x15 = (this4->width - 1);
HXDLIN( 555)								int y12 = (this4->height - 1);
HXDLIN( 555)								::Dynamic this99 = this4->image;
HXDLIN( 555)								int index16;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x15) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x15)) ));
            								}
HXDLIN( 555)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 555)								int color9;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color9 = c15;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c16 = color9;
HXDLIN( 555)									bool here25;
HXDLIN( 555)									if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 555)										here25 = img->transparent;
            									}
            									else {
HXLINE( 555)										here25 = false;
            									}
HXDLIN( 555)									if (here25) {
HXLINE( 555)										int location7;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x14) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x14)) ));
            										}
HXDLIN( 555)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 555)										int this101;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this101 = this100;
            										}
HXDLIN( 555)										Float a18;
HXDLIN( 555)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 555)										if ((this102 == 0)) {
HXLINE( 555)											a18 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r17;
HXDLIN( 555)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 555)										if ((this103 == 0)) {
HXLINE( 555)											r17 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g17;
HXDLIN( 555)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 555)										if ((this104 == 0)) {
HXLINE( 555)											g17 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b110;
HXDLIN( 555)										int this105 = (this101 & 255);
HXDLIN( 555)										if ((this105 == 0)) {
HXLINE( 555)											b110 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a27;
HXDLIN( 555)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 555)										if ((this106 == 0)) {
HXLINE( 555)											a27 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r27;
HXDLIN( 555)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 555)										if ((this107 == 0)) {
HXLINE( 555)											r27 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g27;
HXDLIN( 555)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 555)										if ((this108 == 0)) {
HXLINE( 555)											g27 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b28;
HXDLIN( 555)										int this109 = (color9 & 255);
HXDLIN( 555)										if ((this109 == 0)) {
HXLINE( 555)											b28 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 555)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 555)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 555)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 555)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 555)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 555)										{
HXLINE( 555)											int here26;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here26 = blended7;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this110 = img->image;
HXDLIN( 555)										int index17;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x14) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x14)) ));
            										}
HXDLIN( 555)										int here27;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here27 = c16;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 555)								int y14 = (this4->height - 1);
HXDLIN( 555)								::Dynamic this111 = this4->image;
HXDLIN( 555)								int index18;
HXDLIN( 555)								if (this4->useVirtualPos) {
HXLINE( 555)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 555)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 555)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 555)								int color10;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color10 = c17;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c18 = color10;
HXDLIN( 555)									bool here28;
HXDLIN( 555)									if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 555)										here28 = img->transparent;
            									}
            									else {
HXLINE( 555)										here28 = false;
            									}
HXDLIN( 555)									if (here28) {
HXLINE( 555)										int location8;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 555)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x11)) ));
            										}
HXDLIN( 555)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 555)										int this113;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this113 = this112;
            										}
HXDLIN( 555)										Float a110;
HXDLIN( 555)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 555)										if ((this114 == 0)) {
HXLINE( 555)											a110 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r18;
HXDLIN( 555)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 555)										if ((this115 == 0)) {
HXLINE( 555)											r18 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g18;
HXDLIN( 555)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 555)										if ((this116 == 0)) {
HXLINE( 555)											g18 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b111;
HXDLIN( 555)										int this117 = (this113 & 255);
HXDLIN( 555)										if ((this117 == 0)) {
HXLINE( 555)											b111 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a28;
HXDLIN( 555)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 555)										if ((this118 == 0)) {
HXLINE( 555)											a28 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r28;
HXDLIN( 555)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 555)										if ((this119 == 0)) {
HXLINE( 555)											r28 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g28;
HXDLIN( 555)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 555)										if ((this120 == 0)) {
HXLINE( 555)											g28 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b29;
HXDLIN( 555)										int this121 = (color10 & 255);
HXDLIN( 555)										if ((this121 == 0)) {
HXLINE( 555)											b29 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 555)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 555)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 555)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 555)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 555)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 555)										{
HXLINE( 555)											int here29;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here29 = blended8;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this122 = img->image;
HXDLIN( 555)										int index19;
HXDLIN( 555)										if (img->useVirtualPos) {
HXLINE( 555)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 555)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x11)) ));
            										}
HXDLIN( 555)										int here30;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here30 = c18;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXLINE( 555)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 555)				int width2 = (this123->width + 2);
HXDLIN( 555)				int height2 = (this123->height + 2);
HXDLIN( 555)				 ::Dynamic imageType2 = null();
HXDLIN( 555)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 555)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 555)				::Dynamic here31;
HXDLIN( 555)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 555)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 555)						{
HXLINE( 555)							b31->width = width2;
HXDLIN( 555)							b31->height = height2;
HXDLIN( 555)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 555)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 555)							{
HXLINE( 555)								int len4 = b31->length;
HXDLIN( 555)								int w2 = 0;
HXDLIN( 555)								{
HXLINE( 555)									int _g48 = 0;
HXDLIN( 555)									int _g49 = b31->height;
HXDLIN( 555)									while((_g48 < _g49)){
HXLINE( 555)										_g48 = (_g48 + 1);
HXDLIN( 555)										int y15 = (_g48 - 1);
HXDLIN( 555)										{
HXLINE( 555)											int _g50 = 0;
HXDLIN( 555)											int _g51 = b31->width;
HXDLIN( 555)											while((_g50 < _g51)){
HXLINE( 555)												_g50 = (_g50 + 1);
HXDLIN( 555)												int x16 = (_g50 - 1);
HXDLIN( 555)												{
HXLINE( 555)													w2 = (w2 + 1);
HXDLIN( 555)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w2 = (w2 + 1);
HXDLIN( 555)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w2 = (w2 + 1);
HXDLIN( 555)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 555)												{
HXLINE( 555)													w2 = (w2 + 1);
HXDLIN( 555)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXLINE( 555)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 555)						{
HXLINE( 555)							a29->width = width2;
HXDLIN( 555)							a29->height = height2;
HXDLIN( 555)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 555)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 555)							{
HXLINE( 555)								int _g52 = 0;
HXDLIN( 555)								int _g53 = a29->length;
HXDLIN( 555)								while((_g52 < _g53)){
HXLINE( 555)									_g52 = (_g52 + 1);
HXDLIN( 555)									int i12 = (_g52 - 1);
HXDLIN( 555)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 555)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 555)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 555)						{
HXLINE( 555)							b32->width = width2;
HXDLIN( 555)							b32->height = height2;
HXDLIN( 555)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 555)							int size2 = (b32->length * 4);
HXDLIN( 555)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 555)							{
HXLINE( 555)								int _g54 = 0;
HXDLIN( 555)								int _g55 = b32->length;
HXDLIN( 555)								while((_g54 < _g55)){
HXLINE( 555)									_g54 = (_g54 + 1);
HXDLIN( 555)									int i13 = (_g54 - 1);
HXDLIN( 555)									{
HXLINE( 555)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 555)										bool here32;
HXDLIN( 555)										if ((i13 >= 0)) {
HXLINE( 555)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXLINE( 555)											here32 = false;
            										}
HXDLIN( 555)										if (here32) {
HXLINE( 555)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 555)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 555)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 555)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 555)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 555)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXLINE( 555)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 555)						{
HXLINE( 555)							v3->width = width2;
HXDLIN( 555)							v3->height = height2;
HXDLIN( 555)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 555)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 555)							{
HXLINE( 555)								int _g56 = 0;
HXDLIN( 555)								int _g57 = v3->length;
HXDLIN( 555)								while((_g56 < _g57)){
HXLINE( 555)									_g56 = (_g56 + 1);
HXDLIN( 555)									int i14 = (_g56 - 1);
HXDLIN( 555)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 555)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 555)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 555)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 555)						{
HXLINE( 555)							b33->width = width2;
HXDLIN( 555)							b33->height = height2;
HXDLIN( 555)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 555)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 555)							{
HXLINE( 555)								int len5 = b33->length;
HXDLIN( 555)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 555)								if (::hx::IsNull( d2->head )) {
HXLINE( 555)									int _g58 = 0;
HXDLIN( 555)									int _g59 = len5;
HXDLIN( 555)									while((_g58 < _g59)){
HXLINE( 555)										_g58 = (_g58 + 1);
HXDLIN( 555)										int i15 = (_g58 - 1);
HXDLIN( 555)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 555)									int _g60 = 0;
HXDLIN( 555)									int _g61 = len5;
HXDLIN( 555)									while((_g60 < _g61)){
HXLINE( 555)										_g60 = (_g60 + 1);
HXDLIN( 555)										int i16 = (_g60 - 1);
HXDLIN( 555)										{
HXLINE( 555)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 555)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 555)											{
HXLINE( 555)												int _g62 = 0;
HXDLIN( 555)												int _g63 = i16;
HXDLIN( 555)												while((_g62 < _g63)){
HXLINE( 555)													_g62 = (_g62 + 1);
HXDLIN( 555)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 555)											if (::hx::IsNull( prev2 )) {
HXLINE( 555)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 555)												l2 = null();
            											}
            											else {
HXLINE( 555)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 555)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 555)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 555)				this124->image = here31;
HXDLIN( 555)				this124->width = width2;
HXDLIN( 555)				this124->height = height2;
HXDLIN( 555)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 555)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 555)				bool forceClear1 = false;
HXDLIN( 555)				int _g64 = 0;
HXDLIN( 555)				int _g65 = this123->height;
HXDLIN( 555)				while((_g64 < _g65)){
HXLINE( 555)					_g64 = (_g64 + 1);
HXDLIN( 555)					int dy1 = (_g64 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g66 = 0;
HXDLIN( 555)						int _g67 = this123->width;
HXDLIN( 555)						while((_g66 < _g67)){
HXLINE( 555)							_g66 = (_g66 + 1);
HXDLIN( 555)							int dx1 = (_g66 - 1);
HXDLIN( 555)							::Dynamic this126 = this123->image;
HXDLIN( 555)							int index20;
HXDLIN( 555)							if (this123->useVirtualPos) {
HXLINE( 555)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXLINE( 555)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 555)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 555)							int col1;
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								col1 = c19;
            							}
HXDLIN( 555)							bool here33;
HXDLIN( 555)							if (this123->useMask) {
HXLINE( 555)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXLINE( 555)								here33 = false;
            							}
HXDLIN( 555)							if (here33) {
HXLINE( 555)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 555)								::Dynamic this128 = this127->image;
HXDLIN( 555)								int index21;
HXDLIN( 555)								if (this127->useVirtualPos) {
HXLINE( 555)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXLINE( 555)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 555)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 555)								int v4;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									v4 = c20;
            								}
HXDLIN( 555)								int maskPixel1 = v4;
HXDLIN( 555)								int this129 = col1;
HXDLIN( 555)								if ((maskPixel1 == 0)) {
HXLINE( 555)									col1 = this129;
            								}
            								else {
HXLINE( 555)									Float m01;
HXDLIN( 555)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 555)									if ((this130 == 0)) {
HXLINE( 555)										m01 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m11;
HXDLIN( 555)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 555)									if ((this131 == 0)) {
HXLINE( 555)										m11 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m21;
HXDLIN( 555)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 555)									if ((this132 == 0)) {
HXLINE( 555)										m21 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float m31;
HXDLIN( 555)									int this133 = (maskPixel1 & 255);
HXDLIN( 555)									if ((this133 == 0)) {
HXLINE( 555)										m31 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 555)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 555)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 555)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 555)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 555)							if ((col1 != 0)) {
HXLINE( 555)								int x17 = (1 + dx1);
HXDLIN( 555)								int y16 = (1 + dy1);
HXDLIN( 555)								int c21 = col1;
HXDLIN( 555)								bool here34;
HXDLIN( 555)								if ((((c21 >> 24) & 255) < 254)) {
HXLINE( 555)									here34 = img1->transparent;
            								}
            								else {
HXLINE( 555)									here34 = false;
            								}
HXDLIN( 555)								if (here34) {
HXLINE( 555)									int location9;
HXDLIN( 555)									if (img1->useVirtualPos) {
HXLINE( 555)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXLINE( 555)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x17)) ));
            									}
HXDLIN( 555)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 555)									int this135;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										this135 = this134;
            									}
HXDLIN( 555)									Float a111;
HXDLIN( 555)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 555)									if ((this136 == 0)) {
HXLINE( 555)										a111 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r19;
HXDLIN( 555)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 555)									if ((this137 == 0)) {
HXLINE( 555)										r19 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g19;
HXDLIN( 555)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 555)									if ((this138 == 0)) {
HXLINE( 555)										g19 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b112;
HXDLIN( 555)									int this139 = (this135 & 255);
HXDLIN( 555)									if ((this139 == 0)) {
HXLINE( 555)										b112 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a210;
HXDLIN( 555)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 555)									if ((this140 == 0)) {
HXLINE( 555)										a210 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r29;
HXDLIN( 555)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 555)									if ((this141 == 0)) {
HXLINE( 555)										r29 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g29;
HXDLIN( 555)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 555)									if ((this142 == 0)) {
HXLINE( 555)										g29 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b210;
HXDLIN( 555)									int this143 = (col1 & 255);
HXDLIN( 555)									if ((this143 == 0)) {
HXLINE( 555)										b210 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 555)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 555)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 555)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 555)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 555)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 555)									{
HXLINE( 555)										int here35;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here35 = blended9;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXLINE( 555)									::Dynamic this144 = img1->image;
HXDLIN( 555)									int index22;
HXDLIN( 555)									if (img1->useVirtualPos) {
HXLINE( 555)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXLINE( 555)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x17)) ));
            									}
HXDLIN( 555)									int here36;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										here36 = c21;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXLINE( 555)								if (forceClear1) {
HXLINE( 555)									::Dynamic this145 = img1->image;
HXDLIN( 555)									int x18 = (1 + dx1);
HXDLIN( 555)									int y17 = (1 + dy1);
HXDLIN( 555)									int index23;
HXDLIN( 555)									if (img1->useVirtualPos) {
HXLINE( 555)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x18) - img1->virtualX));
            									}
            									else {
HXLINE( 555)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x18)) ));
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g68 = 0;
HXDLIN( 555)				int _g69 = this123->width;
HXDLIN( 555)				while((_g68 < _g69)){
HXLINE( 555)					_g68 = (_g68 + 1);
HXDLIN( 555)					int x19 = (_g68 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g70 = 0;
HXDLIN( 555)						int _g71 = 1;
HXDLIN( 555)						while((_g70 < _g71)){
HXLINE( 555)							_g70 = (_g70 + 1);
HXDLIN( 555)							int y18 = (_g70 - 1);
HXDLIN( 555)							{
HXLINE( 555)								int x20 = (x19 + 1);
HXDLIN( 555)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 555)								::Dynamic this146 = this123->image;
HXDLIN( 555)								int index24;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x19) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x19)) ));
            								}
HXDLIN( 555)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 555)								int color11;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color11 = c22;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c23 = color11;
HXDLIN( 555)									bool here37;
HXDLIN( 555)									if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 555)										here37 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here37 = false;
            									}
HXDLIN( 555)									if (here37) {
HXLINE( 555)										int location10;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x20)) ));
            										}
HXDLIN( 555)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 555)										int this148;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this148 = this147;
            										}
HXDLIN( 555)										Float a112;
HXDLIN( 555)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 555)										if ((this149 == 0)) {
HXLINE( 555)											a112 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r110;
HXDLIN( 555)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 555)										if ((this150 == 0)) {
HXLINE( 555)											r110 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g110;
HXDLIN( 555)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 555)										if ((this151 == 0)) {
HXLINE( 555)											g110 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b113;
HXDLIN( 555)										int this152 = (this148 & 255);
HXDLIN( 555)										if ((this152 == 0)) {
HXLINE( 555)											b113 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a211;
HXDLIN( 555)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 555)										if ((this153 == 0)) {
HXLINE( 555)											a211 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r210;
HXDLIN( 555)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 555)										if ((this154 == 0)) {
HXLINE( 555)											r210 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g210;
HXDLIN( 555)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 555)										if ((this155 == 0)) {
HXLINE( 555)											g210 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b211;
HXDLIN( 555)										int this156 = (color11 & 255);
HXDLIN( 555)										if ((this156 == 0)) {
HXLINE( 555)											b211 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 555)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 555)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 555)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 555)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 555)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 555)										{
HXLINE( 555)											int here38;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here38 = blended10;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this157 = img1->image;
HXDLIN( 555)										int index25;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x20)) ));
            										}
HXDLIN( 555)										int here39;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here39 = c23;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x21 = (x19 + 1);
HXDLIN( 555)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 555)								int y21 = (1 - y18);
HXDLIN( 555)								::Dynamic this158 = this123->image;
HXDLIN( 555)								int index26;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x19) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x19)) ));
            								}
HXDLIN( 555)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 555)								int color12;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color12 = c24;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c25 = color12;
HXDLIN( 555)									bool here40;
HXDLIN( 555)									if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 555)										here40 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here40 = false;
            									}
HXDLIN( 555)									if (here40) {
HXLINE( 555)										int location11;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x21)) ));
            										}
HXDLIN( 555)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 555)										int this160;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this160 = this159;
            										}
HXDLIN( 555)										Float a113;
HXDLIN( 555)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 555)										if ((this161 == 0)) {
HXLINE( 555)											a113 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r111;
HXDLIN( 555)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 555)										if ((this162 == 0)) {
HXLINE( 555)											r111 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g111;
HXDLIN( 555)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 555)										if ((this163 == 0)) {
HXLINE( 555)											g111 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b114;
HXDLIN( 555)										int this164 = (this160 & 255);
HXDLIN( 555)										if ((this164 == 0)) {
HXLINE( 555)											b114 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a212;
HXDLIN( 555)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 555)										if ((this165 == 0)) {
HXLINE( 555)											a212 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r211;
HXDLIN( 555)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 555)										if ((this166 == 0)) {
HXLINE( 555)											r211 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g211;
HXDLIN( 555)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 555)										if ((this167 == 0)) {
HXLINE( 555)											g211 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b212;
HXDLIN( 555)										int this168 = (color12 & 255);
HXDLIN( 555)										if ((this168 == 0)) {
HXLINE( 555)											b212 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 555)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 555)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 555)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 555)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 555)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 555)										{
HXLINE( 555)											int here41;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here41 = blended11;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this169 = img1->image;
HXDLIN( 555)										int index27;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x21)) ));
            										}
HXDLIN( 555)										int here42;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here42 = c25;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g72 = 0;
HXDLIN( 555)				int _g73 = this123->height;
HXDLIN( 555)				while((_g72 < _g73)){
HXLINE( 555)					_g72 = (_g72 + 1);
HXDLIN( 555)					int y22 = (_g72 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g74 = 0;
HXDLIN( 555)						int _g75 = 1;
HXDLIN( 555)						while((_g74 < _g75)){
HXLINE( 555)							_g74 = (_g74 + 1);
HXDLIN( 555)							int x22 = (_g74 - 1);
HXDLIN( 555)							{
HXLINE( 555)								int y23 = (y22 + 1);
HXDLIN( 555)								int x23 = (((this123->width - 1) - 1) + x22);
HXDLIN( 555)								::Dynamic this170 = this123->image;
HXDLIN( 555)								int index28;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x23) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x23)) ));
            								}
HXDLIN( 555)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 555)								int color13;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color13 = c26;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c27 = color13;
HXDLIN( 555)									bool here43;
HXDLIN( 555)									if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 555)										here43 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here43 = false;
            									}
HXDLIN( 555)									if (here43) {
HXLINE( 555)										int location12;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x22) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x22)) ));
            										}
HXDLIN( 555)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 555)										int this172;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this172 = this171;
            										}
HXDLIN( 555)										Float a114;
HXDLIN( 555)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 555)										if ((this173 == 0)) {
HXLINE( 555)											a114 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r112;
HXDLIN( 555)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 555)										if ((this174 == 0)) {
HXLINE( 555)											r112 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g112;
HXDLIN( 555)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 555)										if ((this175 == 0)) {
HXLINE( 555)											g112 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b115;
HXDLIN( 555)										int this176 = (this172 & 255);
HXDLIN( 555)										if ((this176 == 0)) {
HXLINE( 555)											b115 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a213;
HXDLIN( 555)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 555)										if ((this177 == 0)) {
HXLINE( 555)											a213 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r212;
HXDLIN( 555)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 555)										if ((this178 == 0)) {
HXLINE( 555)											r212 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g212;
HXDLIN( 555)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 555)										if ((this179 == 0)) {
HXLINE( 555)											g212 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b213;
HXDLIN( 555)										int this180 = (color13 & 255);
HXDLIN( 555)										if ((this180 == 0)) {
HXLINE( 555)											b213 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 555)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 555)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 555)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 555)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 555)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 555)										{
HXLINE( 555)											int here44;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here44 = blended12;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this181 = img1->image;
HXDLIN( 555)										int index29;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x22) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x22)) ));
            										}
HXDLIN( 555)										int here45;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here45 = c27;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x24 = ((img1->width - x22) - 1);
HXDLIN( 555)								int y24 = (y22 + 1);
HXDLIN( 555)								int x25 = (1 - x22);
HXDLIN( 555)								::Dynamic this182 = this123->image;
HXDLIN( 555)								int index30;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x25)) ));
            								}
HXDLIN( 555)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 555)								int color14;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color14 = c28;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c29 = color14;
HXDLIN( 555)									bool here46;
HXDLIN( 555)									if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 555)										here46 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here46 = false;
            									}
HXDLIN( 555)									if (here46) {
HXLINE( 555)										int location13;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x24) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x24)) ));
            										}
HXDLIN( 555)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 555)										int this184;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this184 = this183;
            										}
HXDLIN( 555)										Float a115;
HXDLIN( 555)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 555)										if ((this185 == 0)) {
HXLINE( 555)											a115 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r113;
HXDLIN( 555)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 555)										if ((this186 == 0)) {
HXLINE( 555)											r113 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g113;
HXDLIN( 555)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 555)										if ((this187 == 0)) {
HXLINE( 555)											g113 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b116;
HXDLIN( 555)										int this188 = (this184 & 255);
HXDLIN( 555)										if ((this188 == 0)) {
HXLINE( 555)											b116 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a214;
HXDLIN( 555)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 555)										if ((this189 == 0)) {
HXLINE( 555)											a214 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r213;
HXDLIN( 555)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 555)										if ((this190 == 0)) {
HXLINE( 555)											r213 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g213;
HXDLIN( 555)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 555)										if ((this191 == 0)) {
HXLINE( 555)											g213 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b214;
HXDLIN( 555)										int this192 = (color14 & 255);
HXDLIN( 555)										if ((this192 == 0)) {
HXLINE( 555)											b214 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 555)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 555)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 555)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 555)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 555)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 555)										{
HXLINE( 555)											int here47;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here47 = blended13;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this193 = img1->image;
HXDLIN( 555)										int index31;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x24) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x24)) ));
            										}
HXDLIN( 555)										int here48;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here48 = c29;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				int _g76 = 0;
HXDLIN( 555)				int _g77 = 1;
HXDLIN( 555)				while((_g76 < _g77)){
HXLINE( 555)					_g76 = (_g76 + 1);
HXDLIN( 555)					int x26 = (_g76 - 1);
HXDLIN( 555)					{
HXLINE( 555)						int _g78 = 0;
HXDLIN( 555)						int _g79 = 1;
HXDLIN( 555)						while((_g78 < _g79)){
HXLINE( 555)							_g78 = (_g78 + 1);
HXDLIN( 555)							int y25 = (_g78 - 1);
HXDLIN( 555)							{
HXLINE( 555)								int x27 = (((this123->width - 1) - 1) + x26);
HXDLIN( 555)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 555)								::Dynamic this194 = this123->image;
HXDLIN( 555)								int index32;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x27) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x27)) ));
            								}
HXDLIN( 555)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 555)								int color15;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color15 = c30;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c31 = color15;
HXDLIN( 555)									bool here49;
HXDLIN( 555)									if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 555)										here49 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here49 = false;
            									}
HXDLIN( 555)									if (here49) {
HXLINE( 555)										int location14;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x26)) ));
            										}
HXDLIN( 555)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 555)										int this196;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this196 = this195;
            										}
HXDLIN( 555)										Float a116;
HXDLIN( 555)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 555)										if ((this197 == 0)) {
HXLINE( 555)											a116 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r114;
HXDLIN( 555)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 555)										if ((this198 == 0)) {
HXLINE( 555)											r114 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g114;
HXDLIN( 555)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 555)										if ((this199 == 0)) {
HXLINE( 555)											g114 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b117;
HXDLIN( 555)										int this200 = (this196 & 255);
HXDLIN( 555)										if ((this200 == 0)) {
HXLINE( 555)											b117 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a215;
HXDLIN( 555)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 555)										if ((this201 == 0)) {
HXLINE( 555)											a215 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r214;
HXDLIN( 555)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 555)										if ((this202 == 0)) {
HXLINE( 555)											r214 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g214;
HXDLIN( 555)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 555)										if ((this203 == 0)) {
HXLINE( 555)											g214 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b215;
HXDLIN( 555)										int this204 = (color15 & 255);
HXDLIN( 555)										if ((this204 == 0)) {
HXLINE( 555)											b215 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 555)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 555)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 555)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 555)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 555)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 555)										{
HXLINE( 555)											int here50;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here50 = blended14;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this205 = img1->image;
HXDLIN( 555)										int index33;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x26)) ));
            										}
HXDLIN( 555)										int here51;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here51 = c31;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x28 = ((x26 + 1) + this123->width);
HXDLIN( 555)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 555)								::Dynamic this206 = this123->image;
HXDLIN( 555)								int index34;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x26)) ));
            								}
HXDLIN( 555)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 555)								int color16;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color16 = c32;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c33 = color16;
HXDLIN( 555)									bool here52;
HXDLIN( 555)									if ((((c33 >> 24) & 255) < 254)) {
HXLINE( 555)										here52 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here52 = false;
            									}
HXDLIN( 555)									if (here52) {
HXLINE( 555)										int location15;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x28)) ));
            										}
HXDLIN( 555)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 555)										int this208;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this208 = this207;
            										}
HXDLIN( 555)										Float a117;
HXDLIN( 555)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 555)										if ((this209 == 0)) {
HXLINE( 555)											a117 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r115;
HXDLIN( 555)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 555)										if ((this210 == 0)) {
HXLINE( 555)											r115 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g115;
HXDLIN( 555)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 555)										if ((this211 == 0)) {
HXLINE( 555)											g115 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b118;
HXDLIN( 555)										int this212 = (this208 & 255);
HXDLIN( 555)										if ((this212 == 0)) {
HXLINE( 555)											b118 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a216;
HXDLIN( 555)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 555)										if ((this213 == 0)) {
HXLINE( 555)											a216 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r215;
HXDLIN( 555)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 555)										if ((this214 == 0)) {
HXLINE( 555)											r215 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g215;
HXDLIN( 555)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 555)										if ((this215 == 0)) {
HXLINE( 555)											g215 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b216;
HXDLIN( 555)										int this216 = (color16 & 255);
HXDLIN( 555)										if ((this216 == 0)) {
HXLINE( 555)											b216 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 555)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 555)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 555)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 555)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 555)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 555)										{
HXLINE( 555)											int here53;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here53 = blended15;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this217 = img1->image;
HXDLIN( 555)										int index35;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x28)) ));
            										}
HXDLIN( 555)										int here54;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here54 = c33;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int x29 = ((x26 + 1) + this123->width);
HXDLIN( 555)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 555)								::Dynamic this218 = this123->image;
HXDLIN( 555)								int index36;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x26)) ));
            								}
HXDLIN( 555)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 555)								int color17;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color17 = c34;
            								}
HXDLIN( 555)								int color18 = color17;
HXDLIN( 555)								{
HXLINE( 555)									int c35 = color18;
HXDLIN( 555)									bool here55;
HXDLIN( 555)									if ((((c35 >> 24) & 255) < 254)) {
HXLINE( 555)										here55 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here55 = false;
            									}
HXDLIN( 555)									if (here55) {
HXLINE( 555)										int location16;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x29) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x29)) ));
            										}
HXDLIN( 555)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 555)										int this220;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this220 = this219;
            										}
HXDLIN( 555)										Float a118;
HXDLIN( 555)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 555)										if ((this221 == 0)) {
HXLINE( 555)											a118 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r116;
HXDLIN( 555)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 555)										if ((this222 == 0)) {
HXLINE( 555)											r116 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g116;
HXDLIN( 555)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 555)										if ((this223 == 0)) {
HXLINE( 555)											g116 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b119;
HXDLIN( 555)										int this224 = (this220 & 255);
HXDLIN( 555)										if ((this224 == 0)) {
HXLINE( 555)											b119 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a217;
HXDLIN( 555)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 555)										if ((this225 == 0)) {
HXLINE( 555)											a217 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r216;
HXDLIN( 555)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 555)										if ((this226 == 0)) {
HXLINE( 555)											r216 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g216;
HXDLIN( 555)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 555)										if ((this227 == 0)) {
HXLINE( 555)											g216 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b217;
HXDLIN( 555)										int this228 = (color18 & 255);
HXDLIN( 555)										if ((this228 == 0)) {
HXLINE( 555)											b217 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 555)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 555)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 555)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 555)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 555)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 555)										{
HXLINE( 555)											int here56;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here56 = blended16;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this229 = img1->image;
HXDLIN( 555)										int index37;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x29) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x29)) ));
            										}
HXDLIN( 555)										int here57;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here57 = c35;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 555)							{
HXLINE( 555)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 555)								int x30 = (((this123->width - 1) - 1) + x26);
HXDLIN( 555)								::Dynamic this230 = this123->image;
HXDLIN( 555)								int index38;
HXDLIN( 555)								if (this123->useVirtualPos) {
HXLINE( 555)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x30) - this123->virtualX));
            								}
            								else {
HXLINE( 555)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x30)) ));
            								}
HXDLIN( 555)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 555)								int color19;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									color19 = c36;
            								}
HXDLIN( 555)								{
HXLINE( 555)									int c37 = color19;
HXDLIN( 555)									bool here58;
HXDLIN( 555)									if ((((c37 >> 24) & 255) < 254)) {
HXLINE( 555)										here58 = img1->transparent;
            									}
            									else {
HXLINE( 555)										here58 = false;
            									}
HXDLIN( 555)									if (here58) {
HXLINE( 555)										int location17;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x26)) ));
            										}
HXDLIN( 555)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 555)										int this232;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											this232 = this231;
            										}
HXDLIN( 555)										Float a119;
HXDLIN( 555)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 555)										if ((this233 == 0)) {
HXLINE( 555)											a119 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r117;
HXDLIN( 555)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 555)										if ((this234 == 0)) {
HXLINE( 555)											r117 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g117;
HXDLIN( 555)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 555)										if ((this235 == 0)) {
HXLINE( 555)											g117 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b120;
HXDLIN( 555)										int this236 = (this232 & 255);
HXDLIN( 555)										if ((this236 == 0)) {
HXLINE( 555)											b120 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a218;
HXDLIN( 555)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 555)										if ((this237 == 0)) {
HXLINE( 555)											a218 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float r217;
HXDLIN( 555)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 555)										if ((this238 == 0)) {
HXLINE( 555)											r217 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float g217;
HXDLIN( 555)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 555)										if ((this239 == 0)) {
HXLINE( 555)											g217 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float b218;
HXDLIN( 555)										int this240 = (color19 & 255);
HXDLIN( 555)										if ((this240 == 0)) {
HXLINE( 555)											b218 = ((Float)0.);
            										}
            										else {
HXLINE( 555)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 555)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 555)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 555)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 555)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 555)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 555)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 555)										{
HXLINE( 555)											int here59;
HXDLIN( 555)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXLINE( 555)												here59 = blended17;
            											}
HXDLIN( 555)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXLINE( 555)										::Dynamic this241 = img1->image;
HXDLIN( 555)										int index39;
HXDLIN( 555)										if (img1->useVirtualPos) {
HXLINE( 555)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 555)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x26)) ));
            										}
HXDLIN( 555)										int here60;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											here60 = c37;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 555)				here = img1;
            			}
            			break;
            		}
HXDLIN( 555)		{
HXLINE( 555)			int _g80 = 1;
HXDLIN( 555)			int _g81 = (this1->height - 2);
HXDLIN( 555)			while((_g80 < _g81)){
HXLINE( 555)				_g80 = (_g80 + 1);
HXDLIN( 555)				int y30 = (_g80 - 1);
HXDLIN( 555)				{
HXLINE( 555)					int _g82 = 1;
HXDLIN( 555)					int _g83 = (this1->width - 2);
HXDLIN( 555)					while((_g82 < _g83)){
HXLINE( 555)						_g82 = (_g82 + 1);
HXDLIN( 555)						int x31 = (_g82 - 1);
HXDLIN( 555)						if ((x31 == 1)) {
HXLINE( 555)							int x32 = (x31 - 1);
HXDLIN( 555)							int y31 = (y30 - 1);
HXDLIN( 555)							::Dynamic this242 = here->image;
HXDLIN( 555)							int index40;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x32)) ));
            							}
HXDLIN( 555)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								a0 = c38;
            							}
HXDLIN( 555)							int y32 = (y30 - 1);
HXDLIN( 555)							::Dynamic this243 = here->image;
HXDLIN( 555)							int index41;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x31)) ));
            							}
HXDLIN( 555)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								b0 = c39;
            							}
HXDLIN( 555)							int x33 = (x31 + 1);
HXDLIN( 555)							int y33 = (y30 - 1);
HXDLIN( 555)							::Dynamic this244 = here->image;
HXDLIN( 555)							int index42;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x33)) ));
            							}
HXDLIN( 555)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								c0 = c40;
            							}
HXDLIN( 555)							int x34 = (x31 - 1);
HXDLIN( 555)							::Dynamic this245 = here->image;
HXDLIN( 555)							int index43;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 555)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								d0 = c41;
            							}
HXDLIN( 555)							::Dynamic this246 = here->image;
HXDLIN( 555)							int index44;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x31)) ));
            							}
HXDLIN( 555)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 555)							int e01;
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 555)							int x35 = (x31 + 1);
HXDLIN( 555)							::Dynamic this247 = here->image;
HXDLIN( 555)							int index45;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x35)) ));
            							}
HXDLIN( 555)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								f0 = c43;
            							}
HXDLIN( 555)							int x36 = (x31 - 1);
HXDLIN( 555)							int y34 = (y30 + 1);
HXDLIN( 555)							::Dynamic this248 = here->image;
HXDLIN( 555)							int index46;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x36)) ));
            							}
HXDLIN( 555)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								g0 = c44;
            							}
HXDLIN( 555)							int y35 = (y30 + 1);
HXDLIN( 555)							::Dynamic this249 = here->image;
HXDLIN( 555)							int index47;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x31)) ));
            							}
HXDLIN( 555)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								h0 = c45;
            							}
HXDLIN( 555)							int x37 = (x31 + 1);
HXDLIN( 555)							int y36 = (y30 + 1);
HXDLIN( 555)							::Dynamic this250 = here->image;
HXDLIN( 555)							int index48;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x37)) ));
            							}
HXDLIN( 555)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 555)							int x38 = (x31 + 1);
HXDLIN( 555)							int y37 = (y30 - 1);
HXDLIN( 555)							::Dynamic this251 = here->image;
HXDLIN( 555)							int index49;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x38)) ));
            							}
HXDLIN( 555)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 555)							int x39 = (x31 + 1);
HXDLIN( 555)							::Dynamic this252 = here->image;
HXDLIN( 555)							int index50;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x39)) ));
            							}
HXDLIN( 555)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 555)							int x40 = (x31 + 1);
HXDLIN( 555)							int y38 = (y30 + 1);
HXDLIN( 555)							::Dynamic this253 = here->image;
HXDLIN( 555)							int index51;
HXDLIN( 555)							if (here->useVirtualPos) {
HXLINE( 555)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x40) - here->virtualX));
            							}
            							else {
HXLINE( 555)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x40)) ));
            							}
HXDLIN( 555)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 555)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXLINE( 555)								i0 = c49;
            							}
            						}
HXDLIN( 555)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 555)							bool _hx_tmp2;
HXDLIN( 555)							if ((m33_a != ((Float)0.))) {
HXLINE( 555)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp2 = false;
            							}
HXDLIN( 555)							if (_hx_tmp2) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 555)							bool _hx_tmp3;
HXDLIN( 555)							if ((m33_b != ((Float)0.))) {
HXLINE( 555)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp3 = false;
            							}
HXDLIN( 555)							if (_hx_tmp3) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 555)							bool _hx_tmp4;
HXDLIN( 555)							if ((m33_c != ((Float)0.))) {
HXLINE( 555)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp4 = false;
            							}
HXDLIN( 555)							if (_hx_tmp4) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 555)							bool _hx_tmp5;
HXDLIN( 555)							if ((m33_d != ((Float)0.))) {
HXLINE( 555)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp5 = false;
            							}
HXDLIN( 555)							if (_hx_tmp5) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 555)							bool _hx_tmp6;
HXDLIN( 555)							if ((m33_e != ((Float)0.))) {
HXLINE( 555)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp6 = false;
            							}
HXDLIN( 555)							if (_hx_tmp6) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 555)							bool _hx_tmp7;
HXDLIN( 555)							if ((m33_f != ((Float)0.))) {
HXLINE( 555)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp7 = false;
            							}
HXDLIN( 555)							if (_hx_tmp7) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 555)							bool _hx_tmp8;
HXDLIN( 555)							if ((m33_g != ((Float)0.))) {
HXLINE( 555)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp8 = false;
            							}
HXDLIN( 555)							if (_hx_tmp8) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 555)							bool _hx_tmp9;
HXDLIN( 555)							if ((m33_h != ((Float)0.))) {
HXLINE( 555)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp9 = false;
            							}
HXDLIN( 555)							if (_hx_tmp9) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 555)							bool _hx_tmp10;
HXDLIN( 555)							if ((m33_i != ((Float)0.))) {
HXLINE( 555)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp10 = false;
            							}
HXDLIN( 555)							if (_hx_tmp10) {
HXLINE( 555)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 555)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 555)							bool _hx_tmp11;
HXDLIN( 555)							if ((m33_a != ((Float)0.))) {
HXLINE( 555)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp11 = false;
            							}
HXDLIN( 555)							if (_hx_tmp11) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 555)							bool _hx_tmp12;
HXDLIN( 555)							if ((m33_b != ((Float)0.))) {
HXLINE( 555)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp12 = false;
            							}
HXDLIN( 555)							if (_hx_tmp12) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 555)							bool _hx_tmp13;
HXDLIN( 555)							if ((m33_c != ((Float)0.))) {
HXLINE( 555)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp13 = false;
            							}
HXDLIN( 555)							if (_hx_tmp13) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 555)							bool _hx_tmp14;
HXDLIN( 555)							if ((m33_d != ((Float)0.))) {
HXLINE( 555)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp14 = false;
            							}
HXDLIN( 555)							if (_hx_tmp14) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 555)							bool _hx_tmp15;
HXDLIN( 555)							if ((m33_e != ((Float)0.))) {
HXLINE( 555)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp15 = false;
            							}
HXDLIN( 555)							if (_hx_tmp15) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 555)							bool _hx_tmp16;
HXDLIN( 555)							if ((m33_f != ((Float)0.))) {
HXLINE( 555)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp16 = false;
            							}
HXDLIN( 555)							if (_hx_tmp16) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 555)							bool _hx_tmp17;
HXDLIN( 555)							if ((m33_g != ((Float)0.))) {
HXLINE( 555)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp17 = false;
            							}
HXDLIN( 555)							if (_hx_tmp17) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 555)							bool _hx_tmp18;
HXDLIN( 555)							if ((m33_h != ((Float)0.))) {
HXLINE( 555)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp18 = false;
            							}
HXDLIN( 555)							if (_hx_tmp18) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 555)							bool _hx_tmp19;
HXDLIN( 555)							if ((m33_i != ((Float)0.))) {
HXLINE( 555)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp19 = false;
            							}
HXDLIN( 555)							if (_hx_tmp19) {
HXLINE( 555)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 555)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 555)							bool _hx_tmp20;
HXDLIN( 555)							if ((m33_a != ((Float)0.))) {
HXLINE( 555)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp20 = false;
            							}
HXDLIN( 555)							if (_hx_tmp20) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 555)							bool _hx_tmp21;
HXDLIN( 555)							if ((m33_b != ((Float)0.))) {
HXLINE( 555)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp21 = false;
            							}
HXDLIN( 555)							if (_hx_tmp21) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 555)							bool _hx_tmp22;
HXDLIN( 555)							if ((m33_c != ((Float)0.))) {
HXLINE( 555)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp22 = false;
            							}
HXDLIN( 555)							if (_hx_tmp22) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 555)							bool _hx_tmp23;
HXDLIN( 555)							if ((m33_d != ((Float)0.))) {
HXLINE( 555)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp23 = false;
            							}
HXDLIN( 555)							if (_hx_tmp23) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 555)							bool _hx_tmp24;
HXDLIN( 555)							if ((m33_e != ((Float)0.))) {
HXLINE( 555)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp24 = false;
            							}
HXDLIN( 555)							if (_hx_tmp24) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 555)							bool _hx_tmp25;
HXDLIN( 555)							if ((m33_f != ((Float)0.))) {
HXLINE( 555)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp25 = false;
            							}
HXDLIN( 555)							if (_hx_tmp25) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 555)							bool _hx_tmp26;
HXDLIN( 555)							if ((m33_g != ((Float)0.))) {
HXLINE( 555)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp26 = false;
            							}
HXDLIN( 555)							if (_hx_tmp26) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 555)							bool _hx_tmp27;
HXDLIN( 555)							if ((m33_h != ((Float)0.))) {
HXLINE( 555)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp27 = false;
            							}
HXDLIN( 555)							if (_hx_tmp27) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 555)							bool _hx_tmp28;
HXDLIN( 555)							if ((m33_i != ((Float)0.))) {
HXLINE( 555)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp28 = false;
            							}
HXDLIN( 555)							if (_hx_tmp28) {
HXLINE( 555)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 555)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 555)							bool _hx_tmp29;
HXDLIN( 555)							if ((m33_a != ((Float)0.))) {
HXLINE( 555)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp29 = false;
            							}
HXDLIN( 555)							if (_hx_tmp29) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 555)							bool _hx_tmp30;
HXDLIN( 555)							if ((m33_b != ((Float)0.))) {
HXLINE( 555)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp30 = false;
            							}
HXDLIN( 555)							if (_hx_tmp30) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 555)							bool _hx_tmp31;
HXDLIN( 555)							if ((m33_c != ((Float)0.))) {
HXLINE( 555)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp31 = false;
            							}
HXDLIN( 555)							if (_hx_tmp31) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 555)							bool _hx_tmp32;
HXDLIN( 555)							if ((m33_d != ((Float)0.))) {
HXLINE( 555)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp32 = false;
            							}
HXDLIN( 555)							if (_hx_tmp32) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 555)							bool _hx_tmp33;
HXDLIN( 555)							if ((m33_e != ((Float)0.))) {
HXLINE( 555)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp33 = false;
            							}
HXDLIN( 555)							if (_hx_tmp33) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 555)							bool _hx_tmp34;
HXDLIN( 555)							if ((m33_f != ((Float)0.))) {
HXLINE( 555)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp34 = false;
            							}
HXDLIN( 555)							if (_hx_tmp34) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 555)							bool _hx_tmp35;
HXDLIN( 555)							if ((m33_g != ((Float)0.))) {
HXLINE( 555)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp35 = false;
            							}
HXDLIN( 555)							if (_hx_tmp35) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 555)							bool _hx_tmp36;
HXDLIN( 555)							if ((m33_h != ((Float)0.))) {
HXLINE( 555)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp36 = false;
            							}
HXDLIN( 555)							if (_hx_tmp36) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 555)							bool _hx_tmp37;
HXDLIN( 555)							if ((m33_i != ((Float)0.))) {
HXLINE( 555)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXLINE( 555)								_hx_tmp37 = false;
            							}
HXDLIN( 555)							if (_hx_tmp37) {
HXLINE( 555)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 555)						bool _hx_tmp38;
HXDLIN( 555)						if ((borderMode != 0)) {
HXLINE( 555)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXLINE( 555)							_hx_tmp38 = true;
            						}
HXDLIN( 555)						if (_hx_tmp38) {
HXLINE( 555)							int x41 = (x31 - 1);
HXDLIN( 555)							int y39 = (y30 - 1);
HXDLIN( 555)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 555)							{
HXLINE( 555)								int c50 = color20;
HXDLIN( 555)								bool _hx_tmp39;
HXDLIN( 555)								if ((((c50 >> 24) & 255) < 254)) {
HXLINE( 555)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXLINE( 555)									_hx_tmp39 = false;
            								}
HXDLIN( 555)								if (_hx_tmp39) {
HXLINE( 555)									int location18;
HXDLIN( 555)									if (out->useVirtualPos) {
HXLINE( 555)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            									}
            									else {
HXLINE( 555)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x41)) ));
            									}
HXDLIN( 555)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 555)									int this255;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										this255 = this254;
            									}
HXDLIN( 555)									Float a120;
HXDLIN( 555)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 555)									if ((this256 == 0)) {
HXLINE( 555)										a120 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r118;
HXDLIN( 555)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 555)									if ((this257 == 0)) {
HXLINE( 555)										r118 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g118;
HXDLIN( 555)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 555)									if ((this258 == 0)) {
HXLINE( 555)										g118 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b121;
HXDLIN( 555)									int this259 = (this255 & 255);
HXDLIN( 555)									if ((this259 == 0)) {
HXLINE( 555)										b121 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a219;
HXDLIN( 555)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 555)									if ((this260 == 0)) {
HXLINE( 555)										a219 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r218;
HXDLIN( 555)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 555)									if ((this261 == 0)) {
HXLINE( 555)										r218 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g218;
HXDLIN( 555)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 555)									if ((this262 == 0)) {
HXLINE( 555)										g218 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b219;
HXDLIN( 555)									int this263 = (color20 & 255);
HXDLIN( 555)									if ((this263 == 0)) {
HXLINE( 555)										b219 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 555)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 555)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 555)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 555)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 555)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 555)									{
HXLINE( 555)										int _hx_tmp40;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											_hx_tmp40 = blended18;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXLINE( 555)									::Dynamic this264 = out->image;
HXDLIN( 555)									int index52;
HXDLIN( 555)									if (out->useVirtualPos) {
HXLINE( 555)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            									}
            									else {
HXLINE( 555)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x41)) ));
            									}
HXDLIN( 555)									int _hx_tmp41;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp41 = c50;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXLINE( 555)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 555)							{
HXLINE( 555)								int c51 = color21;
HXDLIN( 555)								bool _hx_tmp42;
HXDLIN( 555)								if ((((c51 >> 24) & 255) < 254)) {
HXLINE( 555)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXLINE( 555)									_hx_tmp42 = false;
            								}
HXDLIN( 555)								if (_hx_tmp42) {
HXLINE( 555)									int location19;
HXDLIN( 555)									if (out->useVirtualPos) {
HXLINE( 555)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x31) - out->virtualX));
            									}
            									else {
HXLINE( 555)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x31)) ));
            									}
HXDLIN( 555)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 555)									int this266;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										this266 = this265;
            									}
HXDLIN( 555)									Float a121;
HXDLIN( 555)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 555)									if ((this267 == 0)) {
HXLINE( 555)										a121 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r119;
HXDLIN( 555)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 555)									if ((this268 == 0)) {
HXLINE( 555)										r119 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g119;
HXDLIN( 555)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 555)									if ((this269 == 0)) {
HXLINE( 555)										g119 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b122;
HXDLIN( 555)									int this270 = (this266 & 255);
HXDLIN( 555)									if ((this270 == 0)) {
HXLINE( 555)										b122 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a220;
HXDLIN( 555)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 555)									if ((this271 == 0)) {
HXLINE( 555)										a220 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float r219;
HXDLIN( 555)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 555)									if ((this272 == 0)) {
HXLINE( 555)										r219 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float g219;
HXDLIN( 555)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 555)									if ((this273 == 0)) {
HXLINE( 555)										g219 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float b220;
HXDLIN( 555)									int this274 = (color21 & 255);
HXDLIN( 555)									if ((this274 == 0)) {
HXLINE( 555)										b220 = ((Float)0.);
            									}
            									else {
HXLINE( 555)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 555)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 555)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 555)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 555)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 555)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 555)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 555)									{
HXLINE( 555)										int _hx_tmp43;
HXDLIN( 555)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXLINE( 555)											_hx_tmp43 = blended19;
            										}
HXDLIN( 555)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXLINE( 555)									::Dynamic this275 = out->image;
HXDLIN( 555)									int index53;
HXDLIN( 555)									if (out->useVirtualPos) {
HXLINE( 555)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x31) - out->virtualX));
            									}
            									else {
HXLINE( 555)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x31)) ));
            									}
HXDLIN( 555)									int _hx_tmp44;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp44 = c51;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 555)		if ((borderMode == 1)) {
HXLINE( 555)			{
HXLINE( 555)				int _g84 = 0;
HXDLIN( 555)				int _g85 = (this1->width - 1);
HXDLIN( 555)				while((_g84 < _g85)){
HXLINE( 555)					_g84 = (_g84 + 1);
HXDLIN( 555)					int x42 = (_g84 - 1);
HXDLIN( 555)					{
HXLINE( 555)						::Dynamic this276 = here->image;
HXDLIN( 555)						int index54;
HXDLIN( 555)						if (here->useVirtualPos) {
HXLINE( 555)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            						}
            						else {
HXLINE( 555)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x42)) ));
            						}
HXDLIN( 555)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 555)						int color22;
HXDLIN( 555)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXLINE( 555)							color22 = c52;
            						}
HXDLIN( 555)						int color23 = color22;
HXDLIN( 555)						{
HXLINE( 555)							int c53 = color23;
HXDLIN( 555)							bool _hx_tmp45;
HXDLIN( 555)							if ((((c53 >> 24) & 255) < 254)) {
HXLINE( 555)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXLINE( 555)								_hx_tmp45 = false;
            							}
HXDLIN( 555)							if (_hx_tmp45) {
HXLINE( 555)								int location20;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 555)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x42)) ));
            								}
HXDLIN( 555)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 555)								int this278;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									this278 = this277;
            								}
HXDLIN( 555)								Float a122;
HXDLIN( 555)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 555)								if ((this279 == 0)) {
HXLINE( 555)									a122 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r120;
HXDLIN( 555)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 555)								if ((this280 == 0)) {
HXLINE( 555)									r120 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g120;
HXDLIN( 555)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 555)								if ((this281 == 0)) {
HXLINE( 555)									g120 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b123;
HXDLIN( 555)								int this282 = (this278 & 255);
HXDLIN( 555)								if ((this282 == 0)) {
HXLINE( 555)									b123 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a221;
HXDLIN( 555)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 555)								if ((this283 == 0)) {
HXLINE( 555)									a221 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r220;
HXDLIN( 555)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 555)								if ((this284 == 0)) {
HXLINE( 555)									r220 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g220;
HXDLIN( 555)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 555)								if ((this285 == 0)) {
HXLINE( 555)									g220 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b221;
HXDLIN( 555)								int this286 = (color23 & 255);
HXDLIN( 555)								if ((this286 == 0)) {
HXLINE( 555)									b221 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 555)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 555)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 555)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 555)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 555)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 555)								{
HXLINE( 555)									int _hx_tmp46;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp46 = blended20;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXLINE( 555)								::Dynamic this287 = out->image;
HXDLIN( 555)								int index55;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 555)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x42)) ));
            								}
HXDLIN( 555)								int _hx_tmp47;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									_hx_tmp47 = c53;
            								}
HXDLIN( 555)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 555)					{
HXLINE( 555)						int y40 = (this1->height - 1);
HXDLIN( 555)						int y41 = (this1->height - 1);
HXDLIN( 555)						::Dynamic this288 = here->image;
HXDLIN( 555)						int index56;
HXDLIN( 555)						if (here->useVirtualPos) {
HXLINE( 555)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            						}
            						else {
HXLINE( 555)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x42)) ));
            						}
HXDLIN( 555)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 555)						int color24;
HXDLIN( 555)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXLINE( 555)							color24 = c54;
            						}
HXDLIN( 555)						{
HXLINE( 555)							int c55 = color24;
HXDLIN( 555)							bool _hx_tmp48;
HXDLIN( 555)							if ((((c55 >> 24) & 255) < 254)) {
HXLINE( 555)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXLINE( 555)								_hx_tmp48 = false;
            							}
HXDLIN( 555)							if (_hx_tmp48) {
HXLINE( 555)								int location21;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 555)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x42)) ));
            								}
HXDLIN( 555)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 555)								int this290;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									this290 = this289;
            								}
HXDLIN( 555)								Float a123;
HXDLIN( 555)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 555)								if ((this291 == 0)) {
HXLINE( 555)									a123 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r121;
HXDLIN( 555)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 555)								if ((this292 == 0)) {
HXLINE( 555)									r121 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g121;
HXDLIN( 555)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 555)								if ((this293 == 0)) {
HXLINE( 555)									g121 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b124;
HXDLIN( 555)								int this294 = (this290 & 255);
HXDLIN( 555)								if ((this294 == 0)) {
HXLINE( 555)									b124 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a222;
HXDLIN( 555)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 555)								if ((this295 == 0)) {
HXLINE( 555)									a222 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r221;
HXDLIN( 555)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 555)								if ((this296 == 0)) {
HXLINE( 555)									r221 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g221;
HXDLIN( 555)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 555)								if ((this297 == 0)) {
HXLINE( 555)									g221 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b222;
HXDLIN( 555)								int this298 = (color24 & 255);
HXDLIN( 555)								if ((this298 == 0)) {
HXLINE( 555)									b222 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 555)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 555)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 555)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 555)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 555)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 555)								{
HXLINE( 555)									int _hx_tmp49;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp49 = blended21;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXLINE( 555)								::Dynamic this299 = out->image;
HXDLIN( 555)								int index57;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 555)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x42)) ));
            								}
HXDLIN( 555)								int _hx_tmp50;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									_hx_tmp50 = c55;
            								}
HXDLIN( 555)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 555)			{
HXLINE( 555)				int _g86 = 1;
HXDLIN( 555)				int _g87 = (this1->height - 2);
HXDLIN( 555)				while((_g86 < _g87)){
HXLINE( 555)					_g86 = (_g86 + 1);
HXDLIN( 555)					int y42 = (_g86 - 1);
HXDLIN( 555)					{
HXLINE( 555)						::Dynamic this300 = here->image;
HXDLIN( 555)						int index58;
HXDLIN( 555)						if (here->useVirtualPos) {
HXLINE( 555)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXLINE( 555)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 555)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 555)						int color25;
HXDLIN( 555)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXLINE( 555)							color25 = c56;
            						}
HXDLIN( 555)						int color26 = color25;
HXDLIN( 555)						{
HXLINE( 555)							int c57 = color26;
HXDLIN( 555)							bool _hx_tmp51;
HXDLIN( 555)							if ((((c57 >> 24) & 255) < 254)) {
HXLINE( 555)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXLINE( 555)								_hx_tmp51 = false;
            							}
HXDLIN( 555)							if (_hx_tmp51) {
HXLINE( 555)								int location22;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 555)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 555)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 555)								int this302;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									this302 = this301;
            								}
HXDLIN( 555)								Float a124;
HXDLIN( 555)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 555)								if ((this303 == 0)) {
HXLINE( 555)									a124 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r122;
HXDLIN( 555)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 555)								if ((this304 == 0)) {
HXLINE( 555)									r122 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g122;
HXDLIN( 555)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 555)								if ((this305 == 0)) {
HXLINE( 555)									g122 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b125;
HXDLIN( 555)								int this306 = (this302 & 255);
HXDLIN( 555)								if ((this306 == 0)) {
HXLINE( 555)									b125 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a223;
HXDLIN( 555)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 555)								if ((this307 == 0)) {
HXLINE( 555)									a223 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r222;
HXDLIN( 555)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 555)								if ((this308 == 0)) {
HXLINE( 555)									r222 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g222;
HXDLIN( 555)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 555)								if ((this309 == 0)) {
HXLINE( 555)									g222 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b223;
HXDLIN( 555)								int this310 = (color26 & 255);
HXDLIN( 555)								if ((this310 == 0)) {
HXLINE( 555)									b223 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 555)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 555)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 555)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 555)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 555)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 555)								{
HXLINE( 555)									int _hx_tmp52;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp52 = blended22;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXLINE( 555)								::Dynamic this311 = out->image;
HXDLIN( 555)								int index59;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 555)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 555)								int _hx_tmp53;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									_hx_tmp53 = c57;
            								}
HXDLIN( 555)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 555)					{
HXLINE( 555)						int x43 = (this1->width - 1);
HXDLIN( 555)						int x44 = (this1->width - 1);
HXDLIN( 555)						::Dynamic this312 = here->image;
HXDLIN( 555)						int index60;
HXDLIN( 555)						if (here->useVirtualPos) {
HXLINE( 555)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x44) - here->virtualX));
            						}
            						else {
HXLINE( 555)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x44)) ));
            						}
HXDLIN( 555)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 555)						int color27;
HXDLIN( 555)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXLINE( 555)							color27 = c58;
            						}
HXDLIN( 555)						{
HXLINE( 555)							int c59 = color27;
HXDLIN( 555)							bool _hx_tmp54;
HXDLIN( 555)							if ((((c59 >> 24) & 255) < 254)) {
HXLINE( 555)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXLINE( 555)								_hx_tmp54 = false;
            							}
HXDLIN( 555)							if (_hx_tmp54) {
HXLINE( 555)								int location23;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x43) - out->virtualX));
            								}
            								else {
HXLINE( 555)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x43)) ));
            								}
HXDLIN( 555)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 555)								int this314;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									this314 = this313;
            								}
HXDLIN( 555)								Float a125;
HXDLIN( 555)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 555)								if ((this315 == 0)) {
HXLINE( 555)									a125 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r123;
HXDLIN( 555)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 555)								if ((this316 == 0)) {
HXLINE( 555)									r123 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g123;
HXDLIN( 555)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 555)								if ((this317 == 0)) {
HXLINE( 555)									g123 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b126;
HXDLIN( 555)								int this318 = (this314 & 255);
HXDLIN( 555)								if ((this318 == 0)) {
HXLINE( 555)									b126 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a224;
HXDLIN( 555)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 555)								if ((this319 == 0)) {
HXLINE( 555)									a224 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float r223;
HXDLIN( 555)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 555)								if ((this320 == 0)) {
HXLINE( 555)									r223 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float g223;
HXDLIN( 555)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 555)								if ((this321 == 0)) {
HXLINE( 555)									g223 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float b224;
HXDLIN( 555)								int this322 = (color27 & 255);
HXDLIN( 555)								if ((this322 == 0)) {
HXLINE( 555)									b224 = ((Float)0.);
            								}
            								else {
HXLINE( 555)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 555)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 555)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 555)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 555)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 555)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 555)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 555)								{
HXLINE( 555)									int _hx_tmp55;
HXDLIN( 555)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXLINE( 555)										_hx_tmp55 = blended23;
            									}
HXDLIN( 555)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXLINE( 555)								::Dynamic this323 = out->image;
HXDLIN( 555)								int index61;
HXDLIN( 555)								if (out->useVirtualPos) {
HXLINE( 555)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x43) - out->virtualX));
            								}
            								else {
HXLINE( 555)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x43)) ));
            								}
HXDLIN( 555)								int _hx_tmp56;
HXDLIN( 555)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 555)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXLINE( 555)									_hx_tmp56 = c59;
            								}
HXDLIN( 555)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 555)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Convolution_Impl__obj,sharpen0_3x3,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::boxBlur0_3x3( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_563_boxBlur0_3x3)
HXDLIN( 563)		Float m33_a = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_b = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_c = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_d = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_e = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_f = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_g = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_h = ((Float)0.111111111111111105);
HXDLIN( 563)		Float m33_i = ((Float)0.111111111111111105);
HXDLIN( 563)		bool adjustRed = true;
HXDLIN( 563)		bool adjustGreen = true;
HXDLIN( 563)		bool adjustBlue = true;
HXDLIN( 563)		int a0 = 0;
HXDLIN( 563)		int b0 = 0;
HXDLIN( 563)		int c0 = 0;
HXDLIN( 563)		int d0 = 0;
HXDLIN( 563)		int e0 = 0;
HXDLIN( 563)		int f0 = 0;
HXDLIN( 563)		int g0 = 0;
HXDLIN( 563)		int h0 = 0;
HXDLIN( 563)		int i0 = 0;
HXDLIN( 563)		Float r_ = ((Float)0.);
HXDLIN( 563)		Float g_ = ((Float)0.);
HXDLIN( 563)		Float b_ = ((Float)0.);
HXDLIN( 563)		Float a_ = ((Float)0.);
HXDLIN( 563)		int width = this1->width;
HXDLIN( 563)		int height = this1->height;
HXDLIN( 563)		 ::Dynamic imageType = null();
HXDLIN( 563)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 563)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 563)		::Dynamic _hx_tmp;
HXDLIN( 563)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 563)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 563)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 563)				{
HXDLIN( 563)					b->width = width;
HXDLIN( 563)					b->height = height;
HXDLIN( 563)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 563)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 563)					{
HXDLIN( 563)						int len = b->length;
HXDLIN( 563)						int w = 0;
HXDLIN( 563)						{
HXDLIN( 563)							int _g = 0;
HXDLIN( 563)							int _g1 = b->height;
HXDLIN( 563)							while((_g < _g1)){
HXDLIN( 563)								_g = (_g + 1);
HXDLIN( 563)								int y = (_g - 1);
HXDLIN( 563)								{
HXDLIN( 563)									int _g2 = 0;
HXDLIN( 563)									int _g3 = b->width;
HXDLIN( 563)									while((_g2 < _g3)){
HXDLIN( 563)										_g2 = (_g2 + 1);
HXDLIN( 563)										int x = (_g2 - 1);
HXDLIN( 563)										{
HXDLIN( 563)											w = (w + 1);
HXDLIN( 563)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 563)										{
HXDLIN( 563)											w = (w + 1);
HXDLIN( 563)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 563)										{
HXDLIN( 563)											w = (w + 1);
HXDLIN( 563)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 563)										{
HXDLIN( 563)											w = (w + 1);
HXDLIN( 563)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 563)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 563)				{
HXDLIN( 563)					a->width = width;
HXDLIN( 563)					a->height = height;
HXDLIN( 563)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 563)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 563)					{
HXDLIN( 563)						int _g4 = 0;
HXDLIN( 563)						int _g5 = a->length;
HXDLIN( 563)						while((_g4 < _g5)){
HXDLIN( 563)							_g4 = (_g4 + 1);
HXDLIN( 563)							int i = (_g4 - 1);
HXDLIN( 563)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 563)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 563)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 563)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 563)				{
HXDLIN( 563)					b1->width = width;
HXDLIN( 563)					b1->height = height;
HXDLIN( 563)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 563)					int size = (b1->length * 4);
HXDLIN( 563)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 563)					{
HXDLIN( 563)						int _g6 = 0;
HXDLIN( 563)						int _g7 = b1->length;
HXDLIN( 563)						while((_g6 < _g7)){
HXDLIN( 563)							_g6 = (_g6 + 1);
HXDLIN( 563)							int i1 = (_g6 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 563)								bool _hx_tmp1;
HXDLIN( 563)								if ((i1 >= 0)) {
HXDLIN( 563)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 563)									_hx_tmp1 = false;
            								}
HXDLIN( 563)								if (_hx_tmp1) {
HXDLIN( 563)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 563)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 563)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 563)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 563)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 563)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 563)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 563)				{
HXDLIN( 563)					v->width = width;
HXDLIN( 563)					v->height = height;
HXDLIN( 563)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 563)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 563)					{
HXDLIN( 563)						int _g8 = 0;
HXDLIN( 563)						int _g9 = v->length;
HXDLIN( 563)						while((_g8 < _g9)){
HXDLIN( 563)							_g8 = (_g8 + 1);
HXDLIN( 563)							int i2 = (_g8 - 1);
HXDLIN( 563)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 563)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 563)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 563)				{
HXDLIN( 563)					b2->width = width;
HXDLIN( 563)					b2->height = height;
HXDLIN( 563)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 563)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 563)					{
HXDLIN( 563)						int len1 = b2->length;
HXDLIN( 563)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 563)						if (::hx::IsNull( d->head )) {
HXDLIN( 563)							int _g10 = 0;
HXDLIN( 563)							int _g11 = len1;
HXDLIN( 563)							while((_g10 < _g11)){
HXDLIN( 563)								_g10 = (_g10 + 1);
HXDLIN( 563)								int i3 = (_g10 - 1);
HXDLIN( 563)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 563)							int _g12 = 0;
HXDLIN( 563)							int _g13 = len1;
HXDLIN( 563)							while((_g12 < _g13)){
HXDLIN( 563)								_g12 = (_g12 + 1);
HXDLIN( 563)								int i4 = (_g12 - 1);
HXDLIN( 563)								{
HXDLIN( 563)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 563)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 563)									{
HXDLIN( 563)										int _g14 = 0;
HXDLIN( 563)										int _g15 = i4;
HXDLIN( 563)										while((_g14 < _g15)){
HXDLIN( 563)											_g14 = (_g14 + 1);
HXDLIN( 563)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 563)									if (::hx::IsNull( prev )) {
HXDLIN( 563)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 563)										l = null();
            									}
            									else {
HXDLIN( 563)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 563)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 563)		this2->image = _hx_tmp;
HXDLIN( 563)		this2->width = width;
HXDLIN( 563)		this2->height = height;
HXDLIN( 563)		this2->imageType = ( (int)(imageType) );
HXDLIN( 563)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 563)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 563)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 563)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 563)				int width1 = (this4->width + 2);
HXDLIN( 563)				int height1 = (this4->height + 2);
HXDLIN( 563)				 ::Dynamic imageType1 = null();
HXDLIN( 563)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 563)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 563)				::Dynamic here1;
HXDLIN( 563)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 563)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 563)						{
HXDLIN( 563)							b3->width = width1;
HXDLIN( 563)							b3->height = height1;
HXDLIN( 563)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 563)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 563)							{
HXDLIN( 563)								int len2 = b3->length;
HXDLIN( 563)								int w1 = 0;
HXDLIN( 563)								{
HXDLIN( 563)									int _g16 = 0;
HXDLIN( 563)									int _g17 = b3->height;
HXDLIN( 563)									while((_g16 < _g17)){
HXDLIN( 563)										_g16 = (_g16 + 1);
HXDLIN( 563)										int y1 = (_g16 - 1);
HXDLIN( 563)										{
HXDLIN( 563)											int _g18 = 0;
HXDLIN( 563)											int _g19 = b3->width;
HXDLIN( 563)											while((_g18 < _g19)){
HXDLIN( 563)												_g18 = (_g18 + 1);
HXDLIN( 563)												int x1 = (_g18 - 1);
HXDLIN( 563)												{
HXDLIN( 563)													w1 = (w1 + 1);
HXDLIN( 563)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w1 = (w1 + 1);
HXDLIN( 563)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w1 = (w1 + 1);
HXDLIN( 563)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w1 = (w1 + 1);
HXDLIN( 563)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 563)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 563)						{
HXDLIN( 563)							a1->width = width1;
HXDLIN( 563)							a1->height = height1;
HXDLIN( 563)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 563)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 563)							{
HXDLIN( 563)								int _g20 = 0;
HXDLIN( 563)								int _g21 = a1->length;
HXDLIN( 563)								while((_g20 < _g21)){
HXDLIN( 563)									_g20 = (_g20 + 1);
HXDLIN( 563)									int i6 = (_g20 - 1);
HXDLIN( 563)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 563)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 563)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 563)						{
HXDLIN( 563)							b4->width = width1;
HXDLIN( 563)							b4->height = height1;
HXDLIN( 563)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 563)							int size1 = (b4->length * 4);
HXDLIN( 563)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 563)							{
HXDLIN( 563)								int _g22 = 0;
HXDLIN( 563)								int _g23 = b4->length;
HXDLIN( 563)								while((_g22 < _g23)){
HXDLIN( 563)									_g22 = (_g22 + 1);
HXDLIN( 563)									int i7 = (_g22 - 1);
HXDLIN( 563)									{
HXDLIN( 563)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 563)										bool here2;
HXDLIN( 563)										if ((i7 >= 0)) {
HXDLIN( 563)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 563)											here2 = false;
            										}
HXDLIN( 563)										if (here2) {
HXDLIN( 563)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 563)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 563)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 563)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 563)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 563)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 563)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 563)						{
HXDLIN( 563)							v1->width = width1;
HXDLIN( 563)							v1->height = height1;
HXDLIN( 563)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 563)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 563)							{
HXDLIN( 563)								int _g24 = 0;
HXDLIN( 563)								int _g25 = v1->length;
HXDLIN( 563)								while((_g24 < _g25)){
HXDLIN( 563)									_g24 = (_g24 + 1);
HXDLIN( 563)									int i8 = (_g24 - 1);
HXDLIN( 563)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 563)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 563)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 563)						{
HXDLIN( 563)							b5->width = width1;
HXDLIN( 563)							b5->height = height1;
HXDLIN( 563)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 563)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 563)							{
HXDLIN( 563)								int len3 = b5->length;
HXDLIN( 563)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 563)								if (::hx::IsNull( d1->head )) {
HXDLIN( 563)									int _g26 = 0;
HXDLIN( 563)									int _g27 = len3;
HXDLIN( 563)									while((_g26 < _g27)){
HXDLIN( 563)										_g26 = (_g26 + 1);
HXDLIN( 563)										int i9 = (_g26 - 1);
HXDLIN( 563)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 563)									int _g28 = 0;
HXDLIN( 563)									int _g29 = len3;
HXDLIN( 563)									while((_g28 < _g29)){
HXDLIN( 563)										_g28 = (_g28 + 1);
HXDLIN( 563)										int i10 = (_g28 - 1);
HXDLIN( 563)										{
HXDLIN( 563)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 563)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 563)											{
HXDLIN( 563)												int _g30 = 0;
HXDLIN( 563)												int _g31 = i10;
HXDLIN( 563)												while((_g30 < _g31)){
HXDLIN( 563)													_g30 = (_g30 + 1);
HXDLIN( 563)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 563)											if (::hx::IsNull( prev1 )) {
HXDLIN( 563)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 563)												l1 = null();
            											}
            											else {
HXDLIN( 563)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 563)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 563)				this5->image = here1;
HXDLIN( 563)				this5->width = width1;
HXDLIN( 563)				this5->height = height1;
HXDLIN( 563)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 563)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 563)				bool forceClear = false;
HXDLIN( 563)				int _g32 = 0;
HXDLIN( 563)				int _g33 = this4->height;
HXDLIN( 563)				while((_g32 < _g33)){
HXDLIN( 563)					_g32 = (_g32 + 1);
HXDLIN( 563)					int dy = (_g32 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g34 = 0;
HXDLIN( 563)						int _g35 = this4->width;
HXDLIN( 563)						while((_g34 < _g35)){
HXDLIN( 563)							_g34 = (_g34 + 1);
HXDLIN( 563)							int dx = (_g34 - 1);
HXDLIN( 563)							::Dynamic this7 = this4->image;
HXDLIN( 563)							int index;
HXDLIN( 563)							if (this4->useVirtualPos) {
HXDLIN( 563)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 563)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 563)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 563)							int col;
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								col = c;
            							}
HXDLIN( 563)							bool here3;
HXDLIN( 563)							if (this4->useMask) {
HXDLIN( 563)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 563)								here3 = false;
            							}
HXDLIN( 563)							if (here3) {
HXDLIN( 563)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 563)								::Dynamic this9 = this8->image;
HXDLIN( 563)								int index1;
HXDLIN( 563)								if (this8->useVirtualPos) {
HXDLIN( 563)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 563)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 563)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 563)								int v2;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									v2 = c1;
            								}
HXDLIN( 563)								int maskPixel = v2;
HXDLIN( 563)								int this10 = col;
HXDLIN( 563)								if ((maskPixel == 0)) {
HXDLIN( 563)									col = this10;
            								}
            								else {
HXDLIN( 563)									Float m0;
HXDLIN( 563)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 563)									if ((this11 == 0)) {
HXDLIN( 563)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m1;
HXDLIN( 563)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 563)									if ((this12 == 0)) {
HXDLIN( 563)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m2;
HXDLIN( 563)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 563)									if ((this13 == 0)) {
HXDLIN( 563)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m3;
HXDLIN( 563)									int this14 = (maskPixel & 255);
HXDLIN( 563)									if ((this14 == 0)) {
HXDLIN( 563)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 563)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 563)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 563)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 563)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 563)							if ((col != 0)) {
HXDLIN( 563)								int x2 = (1 + dx);
HXDLIN( 563)								int y2 = (1 + dy);
HXDLIN( 563)								int c2 = col;
HXDLIN( 563)								bool here4;
HXDLIN( 563)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 563)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 563)									here4 = false;
            								}
HXDLIN( 563)								if (here4) {
HXDLIN( 563)									int location;
HXDLIN( 563)									if (img->useVirtualPos) {
HXDLIN( 563)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 563)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 563)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 563)									int this16;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										this16 = this15;
            									}
HXDLIN( 563)									Float a11;
HXDLIN( 563)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 563)									if ((this17 == 0)) {
HXDLIN( 563)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r1;
HXDLIN( 563)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 563)									if ((this18 == 0)) {
HXDLIN( 563)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g1;
HXDLIN( 563)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 563)									if ((this19 == 0)) {
HXDLIN( 563)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b11;
HXDLIN( 563)									int this20 = (this16 & 255);
HXDLIN( 563)									if ((this20 == 0)) {
HXDLIN( 563)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a2;
HXDLIN( 563)									int this21 = ((col >> 24) & 255);
HXDLIN( 563)									if ((this21 == 0)) {
HXDLIN( 563)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r2;
HXDLIN( 563)									int this22 = ((col >> 16) & 255);
HXDLIN( 563)									if ((this22 == 0)) {
HXDLIN( 563)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g2;
HXDLIN( 563)									int this23 = ((col >> 8) & 255);
HXDLIN( 563)									if ((this23 == 0)) {
HXDLIN( 563)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b21;
HXDLIN( 563)									int this24 = (col & 255);
HXDLIN( 563)									if ((this24 == 0)) {
HXDLIN( 563)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 563)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 563)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 563)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 563)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 563)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 563)									{
HXDLIN( 563)										int here5;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here5 = blended;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 563)									::Dynamic this25 = img->image;
HXDLIN( 563)									int index2;
HXDLIN( 563)									if (img->useVirtualPos) {
HXDLIN( 563)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 563)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 563)									int here6;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										here6 = c2;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 563)								if (forceClear) {
HXDLIN( 563)									::Dynamic this26 = img->image;
HXDLIN( 563)									int x3 = (1 + dx);
HXDLIN( 563)									int y3 = (1 + dy);
HXDLIN( 563)									int index3;
HXDLIN( 563)									if (img->useVirtualPos) {
HXDLIN( 563)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 563)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g36 = 0;
HXDLIN( 563)				int _g37 = this4->width;
HXDLIN( 563)				while((_g36 < _g37)){
HXDLIN( 563)					_g36 = (_g36 + 1);
HXDLIN( 563)					int x4 = (_g36 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g38 = 0;
HXDLIN( 563)						int _g39 = 1;
HXDLIN( 563)						while((_g38 < _g39)){
HXDLIN( 563)							_g38 = (_g38 + 1);
HXDLIN( 563)							int y4 = (_g38 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								int x5 = (x4 + 1);
HXDLIN( 563)								::Dynamic this27 = this4->image;
HXDLIN( 563)								int index4;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 563)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 563)								int color;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color = c3;
            								}
HXDLIN( 563)								int color1 = color;
HXDLIN( 563)								{
HXDLIN( 563)									int c4 = color1;
HXDLIN( 563)									bool here7;
HXDLIN( 563)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 563)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here7 = false;
            									}
HXDLIN( 563)									if (here7) {
HXDLIN( 563)										int location1;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 563)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 563)										int this29;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this29 = this28;
            										}
HXDLIN( 563)										Float a12;
HXDLIN( 563)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 563)										if ((this30 == 0)) {
HXDLIN( 563)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r11;
HXDLIN( 563)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 563)										if ((this31 == 0)) {
HXDLIN( 563)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g11;
HXDLIN( 563)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 563)										if ((this32 == 0)) {
HXDLIN( 563)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b12;
HXDLIN( 563)										int this33 = (this29 & 255);
HXDLIN( 563)										if ((this33 == 0)) {
HXDLIN( 563)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a21;
HXDLIN( 563)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 563)										if ((this34 == 0)) {
HXDLIN( 563)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r21;
HXDLIN( 563)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 563)										if ((this35 == 0)) {
HXDLIN( 563)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g21;
HXDLIN( 563)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 563)										if ((this36 == 0)) {
HXDLIN( 563)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b22;
HXDLIN( 563)										int this37 = (color1 & 255);
HXDLIN( 563)										if ((this37 == 0)) {
HXDLIN( 563)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 563)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 563)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 563)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 563)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 563)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 563)										{
HXDLIN( 563)											int here8;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here8 = blended1;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this38 = img->image;
HXDLIN( 563)										int index5;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 563)										int here9;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here9 = c4;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x6 = (x4 + 1);
HXDLIN( 563)								int y5 = ((img->height - y4) - 1);
HXDLIN( 563)								int y6 = (this4->height - 1);
HXDLIN( 563)								::Dynamic this39 = this4->image;
HXDLIN( 563)								int index6;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 563)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 563)								int color2;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color2 = c5;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c6 = color2;
HXDLIN( 563)									bool here10;
HXDLIN( 563)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 563)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here10 = false;
            									}
HXDLIN( 563)									if (here10) {
HXDLIN( 563)										int location2;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 563)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 563)										int this41;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this41 = this40;
            										}
HXDLIN( 563)										Float a13;
HXDLIN( 563)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 563)										if ((this42 == 0)) {
HXDLIN( 563)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r12;
HXDLIN( 563)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 563)										if ((this43 == 0)) {
HXDLIN( 563)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g12;
HXDLIN( 563)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 563)										if ((this44 == 0)) {
HXDLIN( 563)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b13;
HXDLIN( 563)										int this45 = (this41 & 255);
HXDLIN( 563)										if ((this45 == 0)) {
HXDLIN( 563)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a22;
HXDLIN( 563)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 563)										if ((this46 == 0)) {
HXDLIN( 563)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r22;
HXDLIN( 563)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 563)										if ((this47 == 0)) {
HXDLIN( 563)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g22;
HXDLIN( 563)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 563)										if ((this48 == 0)) {
HXDLIN( 563)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b23;
HXDLIN( 563)										int this49 = (color2 & 255);
HXDLIN( 563)										if ((this49 == 0)) {
HXDLIN( 563)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 563)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 563)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 563)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 563)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 563)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 563)										{
HXDLIN( 563)											int here11;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here11 = blended2;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this50 = img->image;
HXDLIN( 563)										int index7;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 563)										int here12;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here12 = c6;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g40 = 0;
HXDLIN( 563)				int _g41 = this4->height;
HXDLIN( 563)				while((_g40 < _g41)){
HXDLIN( 563)					_g40 = (_g40 + 1);
HXDLIN( 563)					int y7 = (_g40 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g42 = 0;
HXDLIN( 563)						int _g43 = 1;
HXDLIN( 563)						while((_g42 < _g43)){
HXDLIN( 563)							_g42 = (_g42 + 1);
HXDLIN( 563)							int x7 = (_g42 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								int y8 = (y7 + 1);
HXDLIN( 563)								::Dynamic this51 = this4->image;
HXDLIN( 563)								int index8;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 563)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 563)								int color3;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color3 = c7;
            								}
HXDLIN( 563)								int color4 = color3;
HXDLIN( 563)								{
HXDLIN( 563)									int c8 = color4;
HXDLIN( 563)									bool here13;
HXDLIN( 563)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 563)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here13 = false;
            									}
HXDLIN( 563)									if (here13) {
HXDLIN( 563)										int location3;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 563)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 563)										int this53;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this53 = this52;
            										}
HXDLIN( 563)										Float a14;
HXDLIN( 563)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 563)										if ((this54 == 0)) {
HXDLIN( 563)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r13;
HXDLIN( 563)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 563)										if ((this55 == 0)) {
HXDLIN( 563)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g13;
HXDLIN( 563)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 563)										if ((this56 == 0)) {
HXDLIN( 563)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b14;
HXDLIN( 563)										int this57 = (this53 & 255);
HXDLIN( 563)										if ((this57 == 0)) {
HXDLIN( 563)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a23;
HXDLIN( 563)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 563)										if ((this58 == 0)) {
HXDLIN( 563)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r23;
HXDLIN( 563)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 563)										if ((this59 == 0)) {
HXDLIN( 563)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g23;
HXDLIN( 563)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 563)										if ((this60 == 0)) {
HXDLIN( 563)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b24;
HXDLIN( 563)										int this61 = (color4 & 255);
HXDLIN( 563)										if ((this61 == 0)) {
HXDLIN( 563)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 563)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 563)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 563)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 563)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 563)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 563)										{
HXDLIN( 563)											int here14;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here14 = blended3;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this62 = img->image;
HXDLIN( 563)										int index9;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 563)										int here15;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here15 = c8;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x8 = ((img->width - x7) - 1);
HXDLIN( 563)								int y9 = (y7 + 1);
HXDLIN( 563)								int x9 = (this4->width - 1);
HXDLIN( 563)								::Dynamic this63 = this4->image;
HXDLIN( 563)								int index10;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 563)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 563)								int color5;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color5 = c9;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c10 = color5;
HXDLIN( 563)									bool here16;
HXDLIN( 563)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 563)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here16 = false;
            									}
HXDLIN( 563)									if (here16) {
HXDLIN( 563)										int location4;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 563)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 563)										int this65;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this65 = this64;
            										}
HXDLIN( 563)										Float a15;
HXDLIN( 563)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 563)										if ((this66 == 0)) {
HXDLIN( 563)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r14;
HXDLIN( 563)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 563)										if ((this67 == 0)) {
HXDLIN( 563)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g14;
HXDLIN( 563)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 563)										if ((this68 == 0)) {
HXDLIN( 563)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b15;
HXDLIN( 563)										int this69 = (this65 & 255);
HXDLIN( 563)										if ((this69 == 0)) {
HXDLIN( 563)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a24;
HXDLIN( 563)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 563)										if ((this70 == 0)) {
HXDLIN( 563)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r24;
HXDLIN( 563)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 563)										if ((this71 == 0)) {
HXDLIN( 563)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g24;
HXDLIN( 563)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 563)										if ((this72 == 0)) {
HXDLIN( 563)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b25;
HXDLIN( 563)										int this73 = (color5 & 255);
HXDLIN( 563)										if ((this73 == 0)) {
HXDLIN( 563)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 563)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 563)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 563)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 563)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 563)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 563)										{
HXDLIN( 563)											int here17;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here17 = blended4;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this74 = img->image;
HXDLIN( 563)										int index11;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 563)										int here18;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here18 = c10;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g44 = 0;
HXDLIN( 563)				int _g45 = 1;
HXDLIN( 563)				while((_g44 < _g45)){
HXDLIN( 563)					_g44 = (_g44 + 1);
HXDLIN( 563)					int x10 = (_g44 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g46 = 0;
HXDLIN( 563)						int _g47 = 1;
HXDLIN( 563)						while((_g46 < _g47)){
HXDLIN( 563)							_g46 = (_g46 + 1);
HXDLIN( 563)							int y10 = (_g46 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								::Dynamic this75 = this4->image;
HXDLIN( 563)								int index12;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 563)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 563)								int color6;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color6 = c11;
            								}
HXDLIN( 563)								int color7 = color6;
HXDLIN( 563)								{
HXDLIN( 563)									int c12 = color7;
HXDLIN( 563)									bool here19;
HXDLIN( 563)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 563)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here19 = false;
            									}
HXDLIN( 563)									if (here19) {
HXDLIN( 563)										int location5;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 563)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 563)										int this77;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this77 = this76;
            										}
HXDLIN( 563)										Float a16;
HXDLIN( 563)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 563)										if ((this78 == 0)) {
HXDLIN( 563)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r15;
HXDLIN( 563)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 563)										if ((this79 == 0)) {
HXDLIN( 563)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g15;
HXDLIN( 563)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 563)										if ((this80 == 0)) {
HXDLIN( 563)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b16;
HXDLIN( 563)										int this81 = (this77 & 255);
HXDLIN( 563)										if ((this81 == 0)) {
HXDLIN( 563)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a25;
HXDLIN( 563)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 563)										if ((this82 == 0)) {
HXDLIN( 563)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r25;
HXDLIN( 563)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 563)										if ((this83 == 0)) {
HXDLIN( 563)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g25;
HXDLIN( 563)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 563)										if ((this84 == 0)) {
HXDLIN( 563)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b26;
HXDLIN( 563)										int this85 = (color7 & 255);
HXDLIN( 563)										if ((this85 == 0)) {
HXDLIN( 563)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 563)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 563)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 563)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 563)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 563)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 563)										{
HXDLIN( 563)											int here20;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here20 = blended5;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this86 = img->image;
HXDLIN( 563)										int index13;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 563)										int here21;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here21 = c12;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x11 = ((x10 + 1) + this4->width);
HXDLIN( 563)								int x12 = (this4->width - 1);
HXDLIN( 563)								::Dynamic this87 = this4->image;
HXDLIN( 563)								int index14;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 563)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 563)								int color8;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color8 = c13;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c14 = color8;
HXDLIN( 563)									bool here22;
HXDLIN( 563)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 563)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here22 = false;
            									}
HXDLIN( 563)									if (here22) {
HXDLIN( 563)										int location6;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 563)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 563)										int this89;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this89 = this88;
            										}
HXDLIN( 563)										Float a17;
HXDLIN( 563)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 563)										if ((this90 == 0)) {
HXDLIN( 563)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r16;
HXDLIN( 563)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 563)										if ((this91 == 0)) {
HXDLIN( 563)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g16;
HXDLIN( 563)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 563)										if ((this92 == 0)) {
HXDLIN( 563)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b18;
HXDLIN( 563)										int this93 = (this89 & 255);
HXDLIN( 563)										if ((this93 == 0)) {
HXDLIN( 563)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a26;
HXDLIN( 563)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 563)										if ((this94 == 0)) {
HXDLIN( 563)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r26;
HXDLIN( 563)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 563)										if ((this95 == 0)) {
HXDLIN( 563)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g26;
HXDLIN( 563)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 563)										if ((this96 == 0)) {
HXDLIN( 563)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b27;
HXDLIN( 563)										int this97 = (color8 & 255);
HXDLIN( 563)										if ((this97 == 0)) {
HXDLIN( 563)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 563)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 563)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 563)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 563)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 563)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 563)										{
HXDLIN( 563)											int here23;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here23 = blended6;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this98 = img->image;
HXDLIN( 563)										int index15;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 563)										int here24;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here24 = c14;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x13 = ((x10 + 1) + this4->width);
HXDLIN( 563)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 563)								int x14 = (this4->width - 1);
HXDLIN( 563)								int y12 = (this4->height - 1);
HXDLIN( 563)								::Dynamic this99 = this4->image;
HXDLIN( 563)								int index16;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 563)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 563)								int color9;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color9 = c15;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c16 = color9;
HXDLIN( 563)									bool here25;
HXDLIN( 563)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 563)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here25 = false;
            									}
HXDLIN( 563)									if (here25) {
HXDLIN( 563)										int location7;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 563)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 563)										int this101;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this101 = this100;
            										}
HXDLIN( 563)										Float a18;
HXDLIN( 563)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 563)										if ((this102 == 0)) {
HXDLIN( 563)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r17;
HXDLIN( 563)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 563)										if ((this103 == 0)) {
HXDLIN( 563)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g17;
HXDLIN( 563)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 563)										if ((this104 == 0)) {
HXDLIN( 563)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b110;
HXDLIN( 563)										int this105 = (this101 & 255);
HXDLIN( 563)										if ((this105 == 0)) {
HXDLIN( 563)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a27;
HXDLIN( 563)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 563)										if ((this106 == 0)) {
HXDLIN( 563)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r27;
HXDLIN( 563)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 563)										if ((this107 == 0)) {
HXDLIN( 563)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g27;
HXDLIN( 563)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 563)										if ((this108 == 0)) {
HXDLIN( 563)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b28;
HXDLIN( 563)										int this109 = (color9 & 255);
HXDLIN( 563)										if ((this109 == 0)) {
HXDLIN( 563)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 563)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 563)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 563)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 563)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 563)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 563)										{
HXDLIN( 563)											int here26;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here26 = blended7;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this110 = img->image;
HXDLIN( 563)										int index17;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 563)										int here27;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here27 = c16;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 563)								int y14 = (this4->height - 1);
HXDLIN( 563)								::Dynamic this111 = this4->image;
HXDLIN( 563)								int index18;
HXDLIN( 563)								if (this4->useVirtualPos) {
HXDLIN( 563)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 563)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 563)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 563)								int color10;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color10 = c17;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c18 = color10;
HXDLIN( 563)									bool here28;
HXDLIN( 563)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 563)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 563)										here28 = false;
            									}
HXDLIN( 563)									if (here28) {
HXDLIN( 563)										int location8;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 563)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 563)										int this113;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this113 = this112;
            										}
HXDLIN( 563)										Float a110;
HXDLIN( 563)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 563)										if ((this114 == 0)) {
HXDLIN( 563)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r18;
HXDLIN( 563)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 563)										if ((this115 == 0)) {
HXDLIN( 563)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g18;
HXDLIN( 563)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 563)										if ((this116 == 0)) {
HXDLIN( 563)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b111;
HXDLIN( 563)										int this117 = (this113 & 255);
HXDLIN( 563)										if ((this117 == 0)) {
HXDLIN( 563)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a28;
HXDLIN( 563)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 563)										if ((this118 == 0)) {
HXDLIN( 563)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r28;
HXDLIN( 563)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 563)										if ((this119 == 0)) {
HXDLIN( 563)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g28;
HXDLIN( 563)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 563)										if ((this120 == 0)) {
HXDLIN( 563)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b29;
HXDLIN( 563)										int this121 = (color10 & 255);
HXDLIN( 563)										if ((this121 == 0)) {
HXDLIN( 563)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 563)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 563)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 563)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 563)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 563)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 563)										{
HXDLIN( 563)											int here29;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here29 = blended8;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this122 = img->image;
HXDLIN( 563)										int index19;
HXDLIN( 563)										if (img->useVirtualPos) {
HXDLIN( 563)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 563)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 563)										int here30;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here30 = c18;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 563)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 563)				int width2 = (this123->width + 2);
HXDLIN( 563)				int height2 = (this123->height + 2);
HXDLIN( 563)				 ::Dynamic imageType2 = null();
HXDLIN( 563)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 563)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 563)				::Dynamic here31;
HXDLIN( 563)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 563)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 563)						{
HXDLIN( 563)							b31->width = width2;
HXDLIN( 563)							b31->height = height2;
HXDLIN( 563)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 563)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 563)							{
HXDLIN( 563)								int len4 = b31->length;
HXDLIN( 563)								int w2 = 0;
HXDLIN( 563)								{
HXDLIN( 563)									int _g48 = 0;
HXDLIN( 563)									int _g49 = b31->height;
HXDLIN( 563)									while((_g48 < _g49)){
HXDLIN( 563)										_g48 = (_g48 + 1);
HXDLIN( 563)										int y15 = (_g48 - 1);
HXDLIN( 563)										{
HXDLIN( 563)											int _g50 = 0;
HXDLIN( 563)											int _g51 = b31->width;
HXDLIN( 563)											while((_g50 < _g51)){
HXDLIN( 563)												_g50 = (_g50 + 1);
HXDLIN( 563)												int x15 = (_g50 - 1);
HXDLIN( 563)												{
HXDLIN( 563)													w2 = (w2 + 1);
HXDLIN( 563)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w2 = (w2 + 1);
HXDLIN( 563)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w2 = (w2 + 1);
HXDLIN( 563)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 563)												{
HXDLIN( 563)													w2 = (w2 + 1);
HXDLIN( 563)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 563)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 563)						{
HXDLIN( 563)							a29->width = width2;
HXDLIN( 563)							a29->height = height2;
HXDLIN( 563)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 563)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 563)							{
HXDLIN( 563)								int _g52 = 0;
HXDLIN( 563)								int _g53 = a29->length;
HXDLIN( 563)								while((_g52 < _g53)){
HXDLIN( 563)									_g52 = (_g52 + 1);
HXDLIN( 563)									int i12 = (_g52 - 1);
HXDLIN( 563)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 563)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 563)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 563)						{
HXDLIN( 563)							b32->width = width2;
HXDLIN( 563)							b32->height = height2;
HXDLIN( 563)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 563)							int size2 = (b32->length * 4);
HXDLIN( 563)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 563)							{
HXDLIN( 563)								int _g54 = 0;
HXDLIN( 563)								int _g55 = b32->length;
HXDLIN( 563)								while((_g54 < _g55)){
HXDLIN( 563)									_g54 = (_g54 + 1);
HXDLIN( 563)									int i13 = (_g54 - 1);
HXDLIN( 563)									{
HXDLIN( 563)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 563)										bool here32;
HXDLIN( 563)										if ((i13 >= 0)) {
HXDLIN( 563)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 563)											here32 = false;
            										}
HXDLIN( 563)										if (here32) {
HXDLIN( 563)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 563)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 563)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 563)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 563)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 563)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 563)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 563)						{
HXDLIN( 563)							v3->width = width2;
HXDLIN( 563)							v3->height = height2;
HXDLIN( 563)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 563)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 563)							{
HXDLIN( 563)								int _g56 = 0;
HXDLIN( 563)								int _g57 = v3->length;
HXDLIN( 563)								while((_g56 < _g57)){
HXDLIN( 563)									_g56 = (_g56 + 1);
HXDLIN( 563)									int i14 = (_g56 - 1);
HXDLIN( 563)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 563)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 563)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 563)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 563)						{
HXDLIN( 563)							b33->width = width2;
HXDLIN( 563)							b33->height = height2;
HXDLIN( 563)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 563)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 563)							{
HXDLIN( 563)								int len5 = b33->length;
HXDLIN( 563)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 563)								if (::hx::IsNull( d2->head )) {
HXDLIN( 563)									int _g58 = 0;
HXDLIN( 563)									int _g59 = len5;
HXDLIN( 563)									while((_g58 < _g59)){
HXDLIN( 563)										_g58 = (_g58 + 1);
HXDLIN( 563)										int i15 = (_g58 - 1);
HXDLIN( 563)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 563)									int _g60 = 0;
HXDLIN( 563)									int _g61 = len5;
HXDLIN( 563)									while((_g60 < _g61)){
HXDLIN( 563)										_g60 = (_g60 + 1);
HXDLIN( 563)										int i16 = (_g60 - 1);
HXDLIN( 563)										{
HXDLIN( 563)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 563)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 563)											{
HXDLIN( 563)												int _g62 = 0;
HXDLIN( 563)												int _g63 = i16;
HXDLIN( 563)												while((_g62 < _g63)){
HXDLIN( 563)													_g62 = (_g62 + 1);
HXDLIN( 563)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 563)											if (::hx::IsNull( prev2 )) {
HXDLIN( 563)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 563)												l2 = null();
            											}
            											else {
HXDLIN( 563)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 563)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 563)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 563)				this124->image = here31;
HXDLIN( 563)				this124->width = width2;
HXDLIN( 563)				this124->height = height2;
HXDLIN( 563)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 563)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 563)				bool forceClear1 = false;
HXDLIN( 563)				int _g64 = 0;
HXDLIN( 563)				int _g65 = this123->height;
HXDLIN( 563)				while((_g64 < _g65)){
HXDLIN( 563)					_g64 = (_g64 + 1);
HXDLIN( 563)					int dy1 = (_g64 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g66 = 0;
HXDLIN( 563)						int _g67 = this123->width;
HXDLIN( 563)						while((_g66 < _g67)){
HXDLIN( 563)							_g66 = (_g66 + 1);
HXDLIN( 563)							int dx1 = (_g66 - 1);
HXDLIN( 563)							::Dynamic this126 = this123->image;
HXDLIN( 563)							int index20;
HXDLIN( 563)							if (this123->useVirtualPos) {
HXDLIN( 563)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 563)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 563)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 563)							int col1;
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								col1 = c19;
            							}
HXDLIN( 563)							bool here33;
HXDLIN( 563)							if (this123->useMask) {
HXDLIN( 563)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 563)								here33 = false;
            							}
HXDLIN( 563)							if (here33) {
HXDLIN( 563)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 563)								::Dynamic this128 = this127->image;
HXDLIN( 563)								int index21;
HXDLIN( 563)								if (this127->useVirtualPos) {
HXDLIN( 563)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 563)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 563)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 563)								int v4;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									v4 = c20;
            								}
HXDLIN( 563)								int maskPixel1 = v4;
HXDLIN( 563)								int this129 = col1;
HXDLIN( 563)								if ((maskPixel1 == 0)) {
HXDLIN( 563)									col1 = this129;
            								}
            								else {
HXDLIN( 563)									Float m01;
HXDLIN( 563)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 563)									if ((this130 == 0)) {
HXDLIN( 563)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m11;
HXDLIN( 563)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 563)									if ((this131 == 0)) {
HXDLIN( 563)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m21;
HXDLIN( 563)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 563)									if ((this132 == 0)) {
HXDLIN( 563)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float m31;
HXDLIN( 563)									int this133 = (maskPixel1 & 255);
HXDLIN( 563)									if ((this133 == 0)) {
HXDLIN( 563)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 563)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 563)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 563)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 563)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 563)							if ((col1 != 0)) {
HXDLIN( 563)								int x16 = (1 + dx1);
HXDLIN( 563)								int y16 = (1 + dy1);
HXDLIN( 563)								int c21 = col1;
HXDLIN( 563)								bool here34;
HXDLIN( 563)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 563)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 563)									here34 = false;
            								}
HXDLIN( 563)								if (here34) {
HXDLIN( 563)									int location9;
HXDLIN( 563)									if (img1->useVirtualPos) {
HXDLIN( 563)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 563)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 563)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 563)									int this135;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										this135 = this134;
            									}
HXDLIN( 563)									Float a111;
HXDLIN( 563)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 563)									if ((this136 == 0)) {
HXDLIN( 563)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r19;
HXDLIN( 563)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 563)									if ((this137 == 0)) {
HXDLIN( 563)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g19;
HXDLIN( 563)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 563)									if ((this138 == 0)) {
HXDLIN( 563)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b112;
HXDLIN( 563)									int this139 = (this135 & 255);
HXDLIN( 563)									if ((this139 == 0)) {
HXDLIN( 563)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a210;
HXDLIN( 563)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 563)									if ((this140 == 0)) {
HXDLIN( 563)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r29;
HXDLIN( 563)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 563)									if ((this141 == 0)) {
HXDLIN( 563)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g29;
HXDLIN( 563)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 563)									if ((this142 == 0)) {
HXDLIN( 563)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b210;
HXDLIN( 563)									int this143 = (col1 & 255);
HXDLIN( 563)									if ((this143 == 0)) {
HXDLIN( 563)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 563)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 563)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 563)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 563)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 563)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 563)									{
HXDLIN( 563)										int here35;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here35 = blended9;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 563)									::Dynamic this144 = img1->image;
HXDLIN( 563)									int index22;
HXDLIN( 563)									if (img1->useVirtualPos) {
HXDLIN( 563)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 563)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 563)									int here36;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										here36 = c21;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 563)								if (forceClear1) {
HXDLIN( 563)									::Dynamic this145 = img1->image;
HXDLIN( 563)									int x17 = (1 + dx1);
HXDLIN( 563)									int y17 = (1 + dy1);
HXDLIN( 563)									int index23;
HXDLIN( 563)									if (img1->useVirtualPos) {
HXDLIN( 563)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 563)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g68 = 0;
HXDLIN( 563)				int _g69 = this123->width;
HXDLIN( 563)				while((_g68 < _g69)){
HXDLIN( 563)					_g68 = (_g68 + 1);
HXDLIN( 563)					int x18 = (_g68 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g70 = 0;
HXDLIN( 563)						int _g71 = 1;
HXDLIN( 563)						while((_g70 < _g71)){
HXDLIN( 563)							_g70 = (_g70 + 1);
HXDLIN( 563)							int y18 = (_g70 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								int x19 = (x18 + 1);
HXDLIN( 563)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 563)								::Dynamic this146 = this123->image;
HXDLIN( 563)								int index24;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 563)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 563)								int color11;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color11 = c22;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c23 = color11;
HXDLIN( 563)									bool here37;
HXDLIN( 563)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 563)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here37 = false;
            									}
HXDLIN( 563)									if (here37) {
HXDLIN( 563)										int location10;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 563)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 563)										int this148;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this148 = this147;
            										}
HXDLIN( 563)										Float a112;
HXDLIN( 563)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 563)										if ((this149 == 0)) {
HXDLIN( 563)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r110;
HXDLIN( 563)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 563)										if ((this150 == 0)) {
HXDLIN( 563)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g110;
HXDLIN( 563)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 563)										if ((this151 == 0)) {
HXDLIN( 563)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b113;
HXDLIN( 563)										int this152 = (this148 & 255);
HXDLIN( 563)										if ((this152 == 0)) {
HXDLIN( 563)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a211;
HXDLIN( 563)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 563)										if ((this153 == 0)) {
HXDLIN( 563)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r210;
HXDLIN( 563)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 563)										if ((this154 == 0)) {
HXDLIN( 563)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g210;
HXDLIN( 563)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 563)										if ((this155 == 0)) {
HXDLIN( 563)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b211;
HXDLIN( 563)										int this156 = (color11 & 255);
HXDLIN( 563)										if ((this156 == 0)) {
HXDLIN( 563)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 563)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 563)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 563)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 563)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 563)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 563)										{
HXDLIN( 563)											int here38;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here38 = blended10;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this157 = img1->image;
HXDLIN( 563)										int index25;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 563)										int here39;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here39 = c23;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x20 = (x18 + 1);
HXDLIN( 563)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 563)								int y21 = (1 - y18);
HXDLIN( 563)								::Dynamic this158 = this123->image;
HXDLIN( 563)								int index26;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 563)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 563)								int color12;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color12 = c24;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c25 = color12;
HXDLIN( 563)									bool here40;
HXDLIN( 563)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 563)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here40 = false;
            									}
HXDLIN( 563)									if (here40) {
HXDLIN( 563)										int location11;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 563)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 563)										int this160;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this160 = this159;
            										}
HXDLIN( 563)										Float a113;
HXDLIN( 563)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 563)										if ((this161 == 0)) {
HXDLIN( 563)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r111;
HXDLIN( 563)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 563)										if ((this162 == 0)) {
HXDLIN( 563)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g111;
HXDLIN( 563)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 563)										if ((this163 == 0)) {
HXDLIN( 563)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b114;
HXDLIN( 563)										int this164 = (this160 & 255);
HXDLIN( 563)										if ((this164 == 0)) {
HXDLIN( 563)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a212;
HXDLIN( 563)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 563)										if ((this165 == 0)) {
HXDLIN( 563)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r211;
HXDLIN( 563)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 563)										if ((this166 == 0)) {
HXDLIN( 563)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g211;
HXDLIN( 563)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 563)										if ((this167 == 0)) {
HXDLIN( 563)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b212;
HXDLIN( 563)										int this168 = (color12 & 255);
HXDLIN( 563)										if ((this168 == 0)) {
HXDLIN( 563)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 563)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 563)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 563)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 563)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 563)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 563)										{
HXDLIN( 563)											int here41;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here41 = blended11;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this169 = img1->image;
HXDLIN( 563)										int index27;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 563)										int here42;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here42 = c25;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g72 = 0;
HXDLIN( 563)				int _g73 = this123->height;
HXDLIN( 563)				while((_g72 < _g73)){
HXDLIN( 563)					_g72 = (_g72 + 1);
HXDLIN( 563)					int y22 = (_g72 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g74 = 0;
HXDLIN( 563)						int _g75 = 1;
HXDLIN( 563)						while((_g74 < _g75)){
HXDLIN( 563)							_g74 = (_g74 + 1);
HXDLIN( 563)							int x21 = (_g74 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								int y23 = (y22 + 1);
HXDLIN( 563)								int x22 = (((this123->width - 1) - 1) + x21);
HXDLIN( 563)								::Dynamic this170 = this123->image;
HXDLIN( 563)								int index28;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 563)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 563)								int color13;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color13 = c26;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c27 = color13;
HXDLIN( 563)									bool here43;
HXDLIN( 563)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 563)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here43 = false;
            									}
HXDLIN( 563)									if (here43) {
HXDLIN( 563)										int location12;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 563)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 563)										int this172;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this172 = this171;
            										}
HXDLIN( 563)										Float a114;
HXDLIN( 563)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 563)										if ((this173 == 0)) {
HXDLIN( 563)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r112;
HXDLIN( 563)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 563)										if ((this174 == 0)) {
HXDLIN( 563)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g112;
HXDLIN( 563)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 563)										if ((this175 == 0)) {
HXDLIN( 563)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b115;
HXDLIN( 563)										int this176 = (this172 & 255);
HXDLIN( 563)										if ((this176 == 0)) {
HXDLIN( 563)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a213;
HXDLIN( 563)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 563)										if ((this177 == 0)) {
HXDLIN( 563)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r212;
HXDLIN( 563)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 563)										if ((this178 == 0)) {
HXDLIN( 563)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g212;
HXDLIN( 563)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 563)										if ((this179 == 0)) {
HXDLIN( 563)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b213;
HXDLIN( 563)										int this180 = (color13 & 255);
HXDLIN( 563)										if ((this180 == 0)) {
HXDLIN( 563)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 563)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 563)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 563)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 563)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 563)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 563)										{
HXDLIN( 563)											int here44;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here44 = blended12;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this181 = img1->image;
HXDLIN( 563)										int index29;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 563)										int here45;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here45 = c27;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 563)								int y24 = (y22 + 1);
HXDLIN( 563)								int x24 = (1 - x21);
HXDLIN( 563)								::Dynamic this182 = this123->image;
HXDLIN( 563)								int index30;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 563)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 563)								int color14;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color14 = c28;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c29 = color14;
HXDLIN( 563)									bool here46;
HXDLIN( 563)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 563)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here46 = false;
            									}
HXDLIN( 563)									if (here46) {
HXDLIN( 563)										int location13;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 563)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 563)										int this184;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this184 = this183;
            										}
HXDLIN( 563)										Float a115;
HXDLIN( 563)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 563)										if ((this185 == 0)) {
HXDLIN( 563)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r113;
HXDLIN( 563)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 563)										if ((this186 == 0)) {
HXDLIN( 563)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g113;
HXDLIN( 563)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 563)										if ((this187 == 0)) {
HXDLIN( 563)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b116;
HXDLIN( 563)										int this188 = (this184 & 255);
HXDLIN( 563)										if ((this188 == 0)) {
HXDLIN( 563)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a214;
HXDLIN( 563)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 563)										if ((this189 == 0)) {
HXDLIN( 563)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r213;
HXDLIN( 563)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 563)										if ((this190 == 0)) {
HXDLIN( 563)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g213;
HXDLIN( 563)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 563)										if ((this191 == 0)) {
HXDLIN( 563)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b214;
HXDLIN( 563)										int this192 = (color14 & 255);
HXDLIN( 563)										if ((this192 == 0)) {
HXDLIN( 563)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 563)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 563)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 563)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 563)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 563)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 563)										{
HXDLIN( 563)											int here47;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here47 = blended13;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this193 = img1->image;
HXDLIN( 563)										int index31;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 563)										int here48;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here48 = c29;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				int _g76 = 0;
HXDLIN( 563)				int _g77 = 1;
HXDLIN( 563)				while((_g76 < _g77)){
HXDLIN( 563)					_g76 = (_g76 + 1);
HXDLIN( 563)					int x25 = (_g76 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						int _g78 = 0;
HXDLIN( 563)						int _g79 = 1;
HXDLIN( 563)						while((_g78 < _g79)){
HXDLIN( 563)							_g78 = (_g78 + 1);
HXDLIN( 563)							int y25 = (_g78 - 1);
HXDLIN( 563)							{
HXDLIN( 563)								int x26 = (((this123->width - 1) - 1) + x25);
HXDLIN( 563)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 563)								::Dynamic this194 = this123->image;
HXDLIN( 563)								int index32;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 563)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 563)								int color15;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color15 = c30;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c31 = color15;
HXDLIN( 563)									bool here49;
HXDLIN( 563)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 563)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here49 = false;
            									}
HXDLIN( 563)									if (here49) {
HXDLIN( 563)										int location14;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 563)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 563)										int this196;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this196 = this195;
            										}
HXDLIN( 563)										Float a116;
HXDLIN( 563)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 563)										if ((this197 == 0)) {
HXDLIN( 563)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r114;
HXDLIN( 563)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 563)										if ((this198 == 0)) {
HXDLIN( 563)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g114;
HXDLIN( 563)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 563)										if ((this199 == 0)) {
HXDLIN( 563)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b117;
HXDLIN( 563)										int this200 = (this196 & 255);
HXDLIN( 563)										if ((this200 == 0)) {
HXDLIN( 563)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a215;
HXDLIN( 563)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 563)										if ((this201 == 0)) {
HXDLIN( 563)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r214;
HXDLIN( 563)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 563)										if ((this202 == 0)) {
HXDLIN( 563)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g214;
HXDLIN( 563)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 563)										if ((this203 == 0)) {
HXDLIN( 563)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b215;
HXDLIN( 563)										int this204 = (color15 & 255);
HXDLIN( 563)										if ((this204 == 0)) {
HXDLIN( 563)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 563)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 563)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 563)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 563)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 563)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 563)										{
HXDLIN( 563)											int here50;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here50 = blended14;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this205 = img1->image;
HXDLIN( 563)										int index33;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 563)										int here51;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here51 = c31;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x27 = ((x25 + 1) + this123->width);
HXDLIN( 563)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 563)								::Dynamic this206 = this123->image;
HXDLIN( 563)								int index34;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 563)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 563)								int color16;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color16 = c32;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c33 = color16;
HXDLIN( 563)									bool here52;
HXDLIN( 563)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 563)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here52 = false;
            									}
HXDLIN( 563)									if (here52) {
HXDLIN( 563)										int location15;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 563)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 563)										int this208;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this208 = this207;
            										}
HXDLIN( 563)										Float a117;
HXDLIN( 563)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 563)										if ((this209 == 0)) {
HXDLIN( 563)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r115;
HXDLIN( 563)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 563)										if ((this210 == 0)) {
HXDLIN( 563)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g115;
HXDLIN( 563)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 563)										if ((this211 == 0)) {
HXDLIN( 563)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b118;
HXDLIN( 563)										int this212 = (this208 & 255);
HXDLIN( 563)										if ((this212 == 0)) {
HXDLIN( 563)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a216;
HXDLIN( 563)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 563)										if ((this213 == 0)) {
HXDLIN( 563)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r215;
HXDLIN( 563)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 563)										if ((this214 == 0)) {
HXDLIN( 563)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g215;
HXDLIN( 563)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 563)										if ((this215 == 0)) {
HXDLIN( 563)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b216;
HXDLIN( 563)										int this216 = (color16 & 255);
HXDLIN( 563)										if ((this216 == 0)) {
HXDLIN( 563)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 563)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 563)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 563)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 563)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 563)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 563)										{
HXDLIN( 563)											int here53;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here53 = blended15;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this217 = img1->image;
HXDLIN( 563)										int index35;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 563)										int here54;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here54 = c33;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int x28 = ((x25 + 1) + this123->width);
HXDLIN( 563)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 563)								::Dynamic this218 = this123->image;
HXDLIN( 563)								int index36;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 563)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 563)								int color17;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color17 = c34;
            								}
HXDLIN( 563)								int color18 = color17;
HXDLIN( 563)								{
HXDLIN( 563)									int c35 = color18;
HXDLIN( 563)									bool here55;
HXDLIN( 563)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 563)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here55 = false;
            									}
HXDLIN( 563)									if (here55) {
HXDLIN( 563)										int location16;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 563)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 563)										int this220;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this220 = this219;
            										}
HXDLIN( 563)										Float a118;
HXDLIN( 563)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 563)										if ((this221 == 0)) {
HXDLIN( 563)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r116;
HXDLIN( 563)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 563)										if ((this222 == 0)) {
HXDLIN( 563)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g116;
HXDLIN( 563)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 563)										if ((this223 == 0)) {
HXDLIN( 563)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b119;
HXDLIN( 563)										int this224 = (this220 & 255);
HXDLIN( 563)										if ((this224 == 0)) {
HXDLIN( 563)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a217;
HXDLIN( 563)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 563)										if ((this225 == 0)) {
HXDLIN( 563)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r216;
HXDLIN( 563)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 563)										if ((this226 == 0)) {
HXDLIN( 563)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g216;
HXDLIN( 563)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 563)										if ((this227 == 0)) {
HXDLIN( 563)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b217;
HXDLIN( 563)										int this228 = (color18 & 255);
HXDLIN( 563)										if ((this228 == 0)) {
HXDLIN( 563)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 563)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 563)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 563)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 563)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 563)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 563)										{
HXDLIN( 563)											int here56;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here56 = blended16;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this229 = img1->image;
HXDLIN( 563)										int index37;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 563)										int here57;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here57 = c35;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 563)							{
HXDLIN( 563)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 563)								int x29 = (((this123->width - 1) - 1) + x25);
HXDLIN( 563)								::Dynamic this230 = this123->image;
HXDLIN( 563)								int index38;
HXDLIN( 563)								if (this123->useVirtualPos) {
HXDLIN( 563)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 563)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 563)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 563)								int color19;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									color19 = c36;
            								}
HXDLIN( 563)								{
HXDLIN( 563)									int c37 = color19;
HXDLIN( 563)									bool here58;
HXDLIN( 563)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 563)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 563)										here58 = false;
            									}
HXDLIN( 563)									if (here58) {
HXDLIN( 563)										int location17;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 563)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 563)										int this232;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											this232 = this231;
            										}
HXDLIN( 563)										Float a119;
HXDLIN( 563)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 563)										if ((this233 == 0)) {
HXDLIN( 563)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r117;
HXDLIN( 563)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 563)										if ((this234 == 0)) {
HXDLIN( 563)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g117;
HXDLIN( 563)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 563)										if ((this235 == 0)) {
HXDLIN( 563)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b120;
HXDLIN( 563)										int this236 = (this232 & 255);
HXDLIN( 563)										if ((this236 == 0)) {
HXDLIN( 563)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a218;
HXDLIN( 563)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 563)										if ((this237 == 0)) {
HXDLIN( 563)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float r217;
HXDLIN( 563)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 563)										if ((this238 == 0)) {
HXDLIN( 563)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float g217;
HXDLIN( 563)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 563)										if ((this239 == 0)) {
HXDLIN( 563)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float b218;
HXDLIN( 563)										int this240 = (color19 & 255);
HXDLIN( 563)										if ((this240 == 0)) {
HXDLIN( 563)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 563)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 563)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 563)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 563)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 563)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 563)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 563)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 563)										{
HXDLIN( 563)											int here59;
HXDLIN( 563)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 563)												here59 = blended17;
            											}
HXDLIN( 563)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 563)										::Dynamic this241 = img1->image;
HXDLIN( 563)										int index39;
HXDLIN( 563)										if (img1->useVirtualPos) {
HXDLIN( 563)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 563)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 563)										int here60;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											here60 = c37;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 563)				here = img1;
            			}
            			break;
            		}
HXDLIN( 563)		{
HXDLIN( 563)			int _g80 = 1;
HXDLIN( 563)			int _g81 = (this1->height - 2);
HXDLIN( 563)			while((_g80 < _g81)){
HXDLIN( 563)				_g80 = (_g80 + 1);
HXDLIN( 563)				int y30 = (_g80 - 1);
HXDLIN( 563)				{
HXDLIN( 563)					int _g82 = 1;
HXDLIN( 563)					int _g83 = (this1->width - 2);
HXDLIN( 563)					while((_g82 < _g83)){
HXDLIN( 563)						_g82 = (_g82 + 1);
HXDLIN( 563)						int x30 = (_g82 - 1);
HXDLIN( 563)						if ((x30 == 1)) {
HXDLIN( 563)							int x31 = (x30 - 1);
HXDLIN( 563)							int y31 = (y30 - 1);
HXDLIN( 563)							::Dynamic this242 = here->image;
HXDLIN( 563)							int index40;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 563)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								a0 = c38;
            							}
HXDLIN( 563)							int y32 = (y30 - 1);
HXDLIN( 563)							::Dynamic this243 = here->image;
HXDLIN( 563)							int index41;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x30)) ));
            							}
HXDLIN( 563)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								b0 = c39;
            							}
HXDLIN( 563)							int x32 = (x30 + 1);
HXDLIN( 563)							int y33 = (y30 - 1);
HXDLIN( 563)							::Dynamic this244 = here->image;
HXDLIN( 563)							int index42;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x32)) ));
            							}
HXDLIN( 563)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								c0 = c40;
            							}
HXDLIN( 563)							int x33 = (x30 - 1);
HXDLIN( 563)							::Dynamic this245 = here->image;
HXDLIN( 563)							int index43;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x33)) ));
            							}
HXDLIN( 563)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								d0 = c41;
            							}
HXDLIN( 563)							::Dynamic this246 = here->image;
HXDLIN( 563)							int index44;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 563)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 563)							int e01;
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 563)							int x34 = (x30 + 1);
HXDLIN( 563)							::Dynamic this247 = here->image;
HXDLIN( 563)							int index45;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 563)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								f0 = c43;
            							}
HXDLIN( 563)							int x35 = (x30 - 1);
HXDLIN( 563)							int y34 = (y30 + 1);
HXDLIN( 563)							::Dynamic this248 = here->image;
HXDLIN( 563)							int index46;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x35)) ));
            							}
HXDLIN( 563)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								g0 = c44;
            							}
HXDLIN( 563)							int y35 = (y30 + 1);
HXDLIN( 563)							::Dynamic this249 = here->image;
HXDLIN( 563)							int index47;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x30)) ));
            							}
HXDLIN( 563)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								h0 = c45;
            							}
HXDLIN( 563)							int x36 = (x30 + 1);
HXDLIN( 563)							int y36 = (y30 + 1);
HXDLIN( 563)							::Dynamic this250 = here->image;
HXDLIN( 563)							int index48;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x36)) ));
            							}
HXDLIN( 563)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 563)							int x37 = (x30 + 1);
HXDLIN( 563)							int y37 = (y30 - 1);
HXDLIN( 563)							::Dynamic this251 = here->image;
HXDLIN( 563)							int index49;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x37)) ));
            							}
HXDLIN( 563)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 563)							int x38 = (x30 + 1);
HXDLIN( 563)							::Dynamic this252 = here->image;
HXDLIN( 563)							int index50;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x38)) ));
            							}
HXDLIN( 563)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 563)							int x39 = (x30 + 1);
HXDLIN( 563)							int y38 = (y30 + 1);
HXDLIN( 563)							::Dynamic this253 = here->image;
HXDLIN( 563)							int index51;
HXDLIN( 563)							if (here->useVirtualPos) {
HXDLIN( 563)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 563)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x39)) ));
            							}
HXDLIN( 563)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 563)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 563)								i0 = c49;
            							}
            						}
HXDLIN( 563)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 563)							bool _hx_tmp2;
HXDLIN( 563)							if ((m33_a != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp2 = false;
            							}
HXDLIN( 563)							if (_hx_tmp2) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 563)							bool _hx_tmp3;
HXDLIN( 563)							if ((m33_b != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp3 = false;
            							}
HXDLIN( 563)							if (_hx_tmp3) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 563)							bool _hx_tmp4;
HXDLIN( 563)							if ((m33_c != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp4 = false;
            							}
HXDLIN( 563)							if (_hx_tmp4) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 563)							bool _hx_tmp5;
HXDLIN( 563)							if ((m33_d != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp5 = false;
            							}
HXDLIN( 563)							if (_hx_tmp5) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 563)							bool _hx_tmp6;
HXDLIN( 563)							if ((m33_e != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp6 = false;
            							}
HXDLIN( 563)							if (_hx_tmp6) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 563)							bool _hx_tmp7;
HXDLIN( 563)							if ((m33_f != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp7 = false;
            							}
HXDLIN( 563)							if (_hx_tmp7) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 563)							bool _hx_tmp8;
HXDLIN( 563)							if ((m33_g != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp8 = false;
            							}
HXDLIN( 563)							if (_hx_tmp8) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 563)							bool _hx_tmp9;
HXDLIN( 563)							if ((m33_h != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp9 = false;
            							}
HXDLIN( 563)							if (_hx_tmp9) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 563)							bool _hx_tmp10;
HXDLIN( 563)							if ((m33_i != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp10 = false;
            							}
HXDLIN( 563)							if (_hx_tmp10) {
HXDLIN( 563)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 563)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 563)							bool _hx_tmp11;
HXDLIN( 563)							if ((m33_a != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp11 = false;
            							}
HXDLIN( 563)							if (_hx_tmp11) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 563)							bool _hx_tmp12;
HXDLIN( 563)							if ((m33_b != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp12 = false;
            							}
HXDLIN( 563)							if (_hx_tmp12) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 563)							bool _hx_tmp13;
HXDLIN( 563)							if ((m33_c != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp13 = false;
            							}
HXDLIN( 563)							if (_hx_tmp13) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 563)							bool _hx_tmp14;
HXDLIN( 563)							if ((m33_d != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp14 = false;
            							}
HXDLIN( 563)							if (_hx_tmp14) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 563)							bool _hx_tmp15;
HXDLIN( 563)							if ((m33_e != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp15 = false;
            							}
HXDLIN( 563)							if (_hx_tmp15) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 563)							bool _hx_tmp16;
HXDLIN( 563)							if ((m33_f != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp16 = false;
            							}
HXDLIN( 563)							if (_hx_tmp16) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 563)							bool _hx_tmp17;
HXDLIN( 563)							if ((m33_g != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp17 = false;
            							}
HXDLIN( 563)							if (_hx_tmp17) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 563)							bool _hx_tmp18;
HXDLIN( 563)							if ((m33_h != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp18 = false;
            							}
HXDLIN( 563)							if (_hx_tmp18) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 563)							bool _hx_tmp19;
HXDLIN( 563)							if ((m33_i != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp19 = false;
            							}
HXDLIN( 563)							if (_hx_tmp19) {
HXDLIN( 563)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 563)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 563)							bool _hx_tmp20;
HXDLIN( 563)							if ((m33_a != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp20 = false;
            							}
HXDLIN( 563)							if (_hx_tmp20) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 563)							bool _hx_tmp21;
HXDLIN( 563)							if ((m33_b != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp21 = false;
            							}
HXDLIN( 563)							if (_hx_tmp21) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 563)							bool _hx_tmp22;
HXDLIN( 563)							if ((m33_c != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp22 = false;
            							}
HXDLIN( 563)							if (_hx_tmp22) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 563)							bool _hx_tmp23;
HXDLIN( 563)							if ((m33_d != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp23 = false;
            							}
HXDLIN( 563)							if (_hx_tmp23) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 563)							bool _hx_tmp24;
HXDLIN( 563)							if ((m33_e != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp24 = false;
            							}
HXDLIN( 563)							if (_hx_tmp24) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 563)							bool _hx_tmp25;
HXDLIN( 563)							if ((m33_f != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp25 = false;
            							}
HXDLIN( 563)							if (_hx_tmp25) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 563)							bool _hx_tmp26;
HXDLIN( 563)							if ((m33_g != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp26 = false;
            							}
HXDLIN( 563)							if (_hx_tmp26) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 563)							bool _hx_tmp27;
HXDLIN( 563)							if ((m33_h != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp27 = false;
            							}
HXDLIN( 563)							if (_hx_tmp27) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 563)							bool _hx_tmp28;
HXDLIN( 563)							if ((m33_i != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp28 = false;
            							}
HXDLIN( 563)							if (_hx_tmp28) {
HXDLIN( 563)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 563)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 563)							bool _hx_tmp29;
HXDLIN( 563)							if ((m33_a != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp29 = false;
            							}
HXDLIN( 563)							if (_hx_tmp29) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 563)							bool _hx_tmp30;
HXDLIN( 563)							if ((m33_b != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp30 = false;
            							}
HXDLIN( 563)							if (_hx_tmp30) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 563)							bool _hx_tmp31;
HXDLIN( 563)							if ((m33_c != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp31 = false;
            							}
HXDLIN( 563)							if (_hx_tmp31) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 563)							bool _hx_tmp32;
HXDLIN( 563)							if ((m33_d != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp32 = false;
            							}
HXDLIN( 563)							if (_hx_tmp32) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 563)							bool _hx_tmp33;
HXDLIN( 563)							if ((m33_e != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp33 = false;
            							}
HXDLIN( 563)							if (_hx_tmp33) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 563)							bool _hx_tmp34;
HXDLIN( 563)							if ((m33_f != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp34 = false;
            							}
HXDLIN( 563)							if (_hx_tmp34) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 563)							bool _hx_tmp35;
HXDLIN( 563)							if ((m33_g != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp35 = false;
            							}
HXDLIN( 563)							if (_hx_tmp35) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 563)							bool _hx_tmp36;
HXDLIN( 563)							if ((m33_h != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp36 = false;
            							}
HXDLIN( 563)							if (_hx_tmp36) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 563)							bool _hx_tmp37;
HXDLIN( 563)							if ((m33_i != ((Float)0.))) {
HXDLIN( 563)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXDLIN( 563)								_hx_tmp37 = false;
            							}
HXDLIN( 563)							if (_hx_tmp37) {
HXDLIN( 563)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 563)						bool _hx_tmp38;
HXDLIN( 563)						if ((borderMode != 0)) {
HXDLIN( 563)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXDLIN( 563)							_hx_tmp38 = true;
            						}
HXDLIN( 563)						if (_hx_tmp38) {
HXDLIN( 563)							int x40 = (x30 - 1);
HXDLIN( 563)							int y39 = (y30 - 1);
HXDLIN( 563)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 563)							{
HXDLIN( 563)								int c50 = color20;
HXDLIN( 563)								bool _hx_tmp39;
HXDLIN( 563)								if ((((c50 >> 24) & 255) < 254)) {
HXDLIN( 563)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXDLIN( 563)									_hx_tmp39 = false;
            								}
HXDLIN( 563)								if (_hx_tmp39) {
HXDLIN( 563)									int location18;
HXDLIN( 563)									if (out->useVirtualPos) {
HXDLIN( 563)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 563)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 563)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 563)									int this255;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										this255 = this254;
            									}
HXDLIN( 563)									Float a120;
HXDLIN( 563)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 563)									if ((this256 == 0)) {
HXDLIN( 563)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r118;
HXDLIN( 563)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 563)									if ((this257 == 0)) {
HXDLIN( 563)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g118;
HXDLIN( 563)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 563)									if ((this258 == 0)) {
HXDLIN( 563)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b121;
HXDLIN( 563)									int this259 = (this255 & 255);
HXDLIN( 563)									if ((this259 == 0)) {
HXDLIN( 563)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a219;
HXDLIN( 563)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 563)									if ((this260 == 0)) {
HXDLIN( 563)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r218;
HXDLIN( 563)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 563)									if ((this261 == 0)) {
HXDLIN( 563)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g218;
HXDLIN( 563)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 563)									if ((this262 == 0)) {
HXDLIN( 563)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b219;
HXDLIN( 563)									int this263 = (color20 & 255);
HXDLIN( 563)									if ((this263 == 0)) {
HXDLIN( 563)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 563)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 563)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 563)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 563)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 563)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 563)									{
HXDLIN( 563)										int _hx_tmp40;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											_hx_tmp40 = blended18;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXDLIN( 563)									::Dynamic this264 = out->image;
HXDLIN( 563)									int index52;
HXDLIN( 563)									if (out->useVirtualPos) {
HXDLIN( 563)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 563)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 563)									int _hx_tmp41;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp41 = c50;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXDLIN( 563)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 563)							{
HXDLIN( 563)								int c51 = color21;
HXDLIN( 563)								bool _hx_tmp42;
HXDLIN( 563)								if ((((c51 >> 24) & 255) < 254)) {
HXDLIN( 563)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXDLIN( 563)									_hx_tmp42 = false;
            								}
HXDLIN( 563)								if (_hx_tmp42) {
HXDLIN( 563)									int location19;
HXDLIN( 563)									if (out->useVirtualPos) {
HXDLIN( 563)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 563)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 563)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 563)									int this266;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										this266 = this265;
            									}
HXDLIN( 563)									Float a121;
HXDLIN( 563)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 563)									if ((this267 == 0)) {
HXDLIN( 563)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r119;
HXDLIN( 563)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 563)									if ((this268 == 0)) {
HXDLIN( 563)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g119;
HXDLIN( 563)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 563)									if ((this269 == 0)) {
HXDLIN( 563)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b122;
HXDLIN( 563)									int this270 = (this266 & 255);
HXDLIN( 563)									if ((this270 == 0)) {
HXDLIN( 563)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a220;
HXDLIN( 563)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 563)									if ((this271 == 0)) {
HXDLIN( 563)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float r219;
HXDLIN( 563)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 563)									if ((this272 == 0)) {
HXDLIN( 563)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float g219;
HXDLIN( 563)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 563)									if ((this273 == 0)) {
HXDLIN( 563)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float b220;
HXDLIN( 563)									int this274 = (color21 & 255);
HXDLIN( 563)									if ((this274 == 0)) {
HXDLIN( 563)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 563)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 563)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 563)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 563)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 563)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 563)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 563)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 563)									{
HXDLIN( 563)										int _hx_tmp43;
HXDLIN( 563)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 563)											_hx_tmp43 = blended19;
            										}
HXDLIN( 563)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXDLIN( 563)									::Dynamic this275 = out->image;
HXDLIN( 563)									int index53;
HXDLIN( 563)									if (out->useVirtualPos) {
HXDLIN( 563)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 563)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 563)									int _hx_tmp44;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp44 = c51;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 563)		if ((borderMode == 1)) {
HXDLIN( 563)			{
HXDLIN( 563)				int _g84 = 0;
HXDLIN( 563)				int _g85 = (this1->width - 1);
HXDLIN( 563)				while((_g84 < _g85)){
HXDLIN( 563)					_g84 = (_g84 + 1);
HXDLIN( 563)					int x41 = (_g84 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						::Dynamic this276 = here->image;
HXDLIN( 563)						int index54;
HXDLIN( 563)						if (here->useVirtualPos) {
HXDLIN( 563)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 563)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x41)) ));
            						}
HXDLIN( 563)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 563)						int color22;
HXDLIN( 563)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXDLIN( 563)							color22 = c52;
            						}
HXDLIN( 563)						int color23 = color22;
HXDLIN( 563)						{
HXDLIN( 563)							int c53 = color23;
HXDLIN( 563)							bool _hx_tmp45;
HXDLIN( 563)							if ((((c53 >> 24) & 255) < 254)) {
HXDLIN( 563)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXDLIN( 563)								_hx_tmp45 = false;
            							}
HXDLIN( 563)							if (_hx_tmp45) {
HXDLIN( 563)								int location20;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 563)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 563)								int this278;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									this278 = this277;
            								}
HXDLIN( 563)								Float a122;
HXDLIN( 563)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 563)								if ((this279 == 0)) {
HXDLIN( 563)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r120;
HXDLIN( 563)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 563)								if ((this280 == 0)) {
HXDLIN( 563)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g120;
HXDLIN( 563)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 563)								if ((this281 == 0)) {
HXDLIN( 563)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b123;
HXDLIN( 563)								int this282 = (this278 & 255);
HXDLIN( 563)								if ((this282 == 0)) {
HXDLIN( 563)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a221;
HXDLIN( 563)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 563)								if ((this283 == 0)) {
HXDLIN( 563)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r220;
HXDLIN( 563)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 563)								if ((this284 == 0)) {
HXDLIN( 563)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g220;
HXDLIN( 563)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 563)								if ((this285 == 0)) {
HXDLIN( 563)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b221;
HXDLIN( 563)								int this286 = (color23 & 255);
HXDLIN( 563)								if ((this286 == 0)) {
HXDLIN( 563)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 563)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 563)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 563)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 563)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 563)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 563)								{
HXDLIN( 563)									int _hx_tmp46;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp46 = blended20;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXDLIN( 563)								::Dynamic this287 = out->image;
HXDLIN( 563)								int index55;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 563)								int _hx_tmp47;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									_hx_tmp47 = c53;
            								}
HXDLIN( 563)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 563)					{
HXDLIN( 563)						int y40 = (this1->height - 1);
HXDLIN( 563)						int y41 = (this1->height - 1);
HXDLIN( 563)						::Dynamic this288 = here->image;
HXDLIN( 563)						int index56;
HXDLIN( 563)						if (here->useVirtualPos) {
HXDLIN( 563)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 563)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x41)) ));
            						}
HXDLIN( 563)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 563)						int color24;
HXDLIN( 563)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXDLIN( 563)							color24 = c54;
            						}
HXDLIN( 563)						{
HXDLIN( 563)							int c55 = color24;
HXDLIN( 563)							bool _hx_tmp48;
HXDLIN( 563)							if ((((c55 >> 24) & 255) < 254)) {
HXDLIN( 563)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXDLIN( 563)								_hx_tmp48 = false;
            							}
HXDLIN( 563)							if (_hx_tmp48) {
HXDLIN( 563)								int location21;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 563)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 563)								int this290;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									this290 = this289;
            								}
HXDLIN( 563)								Float a123;
HXDLIN( 563)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 563)								if ((this291 == 0)) {
HXDLIN( 563)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r121;
HXDLIN( 563)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 563)								if ((this292 == 0)) {
HXDLIN( 563)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g121;
HXDLIN( 563)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 563)								if ((this293 == 0)) {
HXDLIN( 563)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b124;
HXDLIN( 563)								int this294 = (this290 & 255);
HXDLIN( 563)								if ((this294 == 0)) {
HXDLIN( 563)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a222;
HXDLIN( 563)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 563)								if ((this295 == 0)) {
HXDLIN( 563)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r221;
HXDLIN( 563)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 563)								if ((this296 == 0)) {
HXDLIN( 563)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g221;
HXDLIN( 563)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 563)								if ((this297 == 0)) {
HXDLIN( 563)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b222;
HXDLIN( 563)								int this298 = (color24 & 255);
HXDLIN( 563)								if ((this298 == 0)) {
HXDLIN( 563)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 563)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 563)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 563)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 563)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 563)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 563)								{
HXDLIN( 563)									int _hx_tmp49;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp49 = blended21;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXDLIN( 563)								::Dynamic this299 = out->image;
HXDLIN( 563)								int index57;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 563)								int _hx_tmp50;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									_hx_tmp50 = c55;
            								}
HXDLIN( 563)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 563)			{
HXDLIN( 563)				int _g86 = 1;
HXDLIN( 563)				int _g87 = (this1->height - 2);
HXDLIN( 563)				while((_g86 < _g87)){
HXDLIN( 563)					_g86 = (_g86 + 1);
HXDLIN( 563)					int y42 = (_g86 - 1);
HXDLIN( 563)					{
HXDLIN( 563)						::Dynamic this300 = here->image;
HXDLIN( 563)						int index58;
HXDLIN( 563)						if (here->useVirtualPos) {
HXDLIN( 563)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 563)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 563)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 563)						int color25;
HXDLIN( 563)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXDLIN( 563)							color25 = c56;
            						}
HXDLIN( 563)						int color26 = color25;
HXDLIN( 563)						{
HXDLIN( 563)							int c57 = color26;
HXDLIN( 563)							bool _hx_tmp51;
HXDLIN( 563)							if ((((c57 >> 24) & 255) < 254)) {
HXDLIN( 563)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXDLIN( 563)								_hx_tmp51 = false;
            							}
HXDLIN( 563)							if (_hx_tmp51) {
HXDLIN( 563)								int location22;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 563)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 563)								int this302;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									this302 = this301;
            								}
HXDLIN( 563)								Float a124;
HXDLIN( 563)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 563)								if ((this303 == 0)) {
HXDLIN( 563)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r122;
HXDLIN( 563)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 563)								if ((this304 == 0)) {
HXDLIN( 563)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g122;
HXDLIN( 563)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 563)								if ((this305 == 0)) {
HXDLIN( 563)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b125;
HXDLIN( 563)								int this306 = (this302 & 255);
HXDLIN( 563)								if ((this306 == 0)) {
HXDLIN( 563)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a223;
HXDLIN( 563)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 563)								if ((this307 == 0)) {
HXDLIN( 563)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r222;
HXDLIN( 563)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 563)								if ((this308 == 0)) {
HXDLIN( 563)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g222;
HXDLIN( 563)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 563)								if ((this309 == 0)) {
HXDLIN( 563)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b223;
HXDLIN( 563)								int this310 = (color26 & 255);
HXDLIN( 563)								if ((this310 == 0)) {
HXDLIN( 563)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 563)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 563)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 563)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 563)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 563)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 563)								{
HXDLIN( 563)									int _hx_tmp52;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp52 = blended22;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXDLIN( 563)								::Dynamic this311 = out->image;
HXDLIN( 563)								int index59;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 563)								int _hx_tmp53;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									_hx_tmp53 = c57;
            								}
HXDLIN( 563)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 563)					{
HXDLIN( 563)						int x42 = (this1->width - 1);
HXDLIN( 563)						int x43 = (this1->width - 1);
HXDLIN( 563)						::Dynamic this312 = here->image;
HXDLIN( 563)						int index60;
HXDLIN( 563)						if (here->useVirtualPos) {
HXDLIN( 563)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            						}
            						else {
HXDLIN( 563)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x43)) ));
            						}
HXDLIN( 563)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 563)						int color27;
HXDLIN( 563)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXDLIN( 563)							color27 = c58;
            						}
HXDLIN( 563)						{
HXDLIN( 563)							int c59 = color27;
HXDLIN( 563)							bool _hx_tmp54;
HXDLIN( 563)							if ((((c59 >> 24) & 255) < 254)) {
HXDLIN( 563)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXDLIN( 563)								_hx_tmp54 = false;
            							}
HXDLIN( 563)							if (_hx_tmp54) {
HXDLIN( 563)								int location23;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 563)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 563)								int this314;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									this314 = this313;
            								}
HXDLIN( 563)								Float a125;
HXDLIN( 563)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 563)								if ((this315 == 0)) {
HXDLIN( 563)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r123;
HXDLIN( 563)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 563)								if ((this316 == 0)) {
HXDLIN( 563)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g123;
HXDLIN( 563)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 563)								if ((this317 == 0)) {
HXDLIN( 563)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b126;
HXDLIN( 563)								int this318 = (this314 & 255);
HXDLIN( 563)								if ((this318 == 0)) {
HXDLIN( 563)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a224;
HXDLIN( 563)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 563)								if ((this319 == 0)) {
HXDLIN( 563)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float r223;
HXDLIN( 563)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 563)								if ((this320 == 0)) {
HXDLIN( 563)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float g223;
HXDLIN( 563)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 563)								if ((this321 == 0)) {
HXDLIN( 563)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float b224;
HXDLIN( 563)								int this322 = (color27 & 255);
HXDLIN( 563)								if ((this322 == 0)) {
HXDLIN( 563)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 563)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 563)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 563)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 563)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 563)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 563)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 563)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 563)								{
HXDLIN( 563)									int _hx_tmp55;
HXDLIN( 563)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 563)										_hx_tmp55 = blended23;
            									}
HXDLIN( 563)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXDLIN( 563)								::Dynamic this323 = out->image;
HXDLIN( 563)								int index61;
HXDLIN( 563)								if (out->useVirtualPos) {
HXDLIN( 563)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 563)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 563)								int _hx_tmp56;
HXDLIN( 563)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 563)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXDLIN( 563)									_hx_tmp56 = c59;
            								}
HXDLIN( 563)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 563)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,boxBlur0_3x3,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::gussianBlur_3x3( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_571_gussianBlur_3x3)
HXDLIN( 571)		Float m33_a = ((Float)0.0625);
HXDLIN( 571)		Float m33_b = ((Float)0.125);
HXDLIN( 571)		Float m33_c = ((Float)0.0625);
HXDLIN( 571)		Float m33_d = ((Float)0.125);
HXDLIN( 571)		Float m33_e = ((Float)0.25);
HXDLIN( 571)		Float m33_f = ((Float)0.125);
HXDLIN( 571)		Float m33_g = ((Float)0.0625);
HXDLIN( 571)		Float m33_h = ((Float)0.125);
HXDLIN( 571)		Float m33_i = ((Float)0.0625);
HXDLIN( 571)		bool adjustRed = true;
HXDLIN( 571)		bool adjustGreen = true;
HXDLIN( 571)		bool adjustBlue = true;
HXDLIN( 571)		int a0 = 0;
HXDLIN( 571)		int b0 = 0;
HXDLIN( 571)		int c0 = 0;
HXDLIN( 571)		int d0 = 0;
HXDLIN( 571)		int e0 = 0;
HXDLIN( 571)		int f0 = 0;
HXDLIN( 571)		int g0 = 0;
HXDLIN( 571)		int h0 = 0;
HXDLIN( 571)		int i0 = 0;
HXDLIN( 571)		Float r_ = ((Float)0.);
HXDLIN( 571)		Float g_ = ((Float)0.);
HXDLIN( 571)		Float b_ = ((Float)0.);
HXDLIN( 571)		Float a_ = ((Float)0.);
HXDLIN( 571)		int width = this1->width;
HXDLIN( 571)		int height = this1->height;
HXDLIN( 571)		 ::Dynamic imageType = null();
HXDLIN( 571)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 571)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 571)		::Dynamic _hx_tmp;
HXDLIN( 571)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 571)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 571)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 571)				{
HXDLIN( 571)					b->width = width;
HXDLIN( 571)					b->height = height;
HXDLIN( 571)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 571)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 571)					{
HXDLIN( 571)						int len = b->length;
HXDLIN( 571)						int w = 0;
HXDLIN( 571)						{
HXDLIN( 571)							int _g = 0;
HXDLIN( 571)							int _g1 = b->height;
HXDLIN( 571)							while((_g < _g1)){
HXDLIN( 571)								_g = (_g + 1);
HXDLIN( 571)								int y = (_g - 1);
HXDLIN( 571)								{
HXDLIN( 571)									int _g2 = 0;
HXDLIN( 571)									int _g3 = b->width;
HXDLIN( 571)									while((_g2 < _g3)){
HXDLIN( 571)										_g2 = (_g2 + 1);
HXDLIN( 571)										int x = (_g2 - 1);
HXDLIN( 571)										{
HXDLIN( 571)											w = (w + 1);
HXDLIN( 571)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 571)										{
HXDLIN( 571)											w = (w + 1);
HXDLIN( 571)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 571)										{
HXDLIN( 571)											w = (w + 1);
HXDLIN( 571)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 571)										{
HXDLIN( 571)											w = (w + 1);
HXDLIN( 571)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 571)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 571)				{
HXDLIN( 571)					a->width = width;
HXDLIN( 571)					a->height = height;
HXDLIN( 571)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 571)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 571)					{
HXDLIN( 571)						int _g4 = 0;
HXDLIN( 571)						int _g5 = a->length;
HXDLIN( 571)						while((_g4 < _g5)){
HXDLIN( 571)							_g4 = (_g4 + 1);
HXDLIN( 571)							int i = (_g4 - 1);
HXDLIN( 571)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 571)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 571)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 571)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 571)				{
HXDLIN( 571)					b1->width = width;
HXDLIN( 571)					b1->height = height;
HXDLIN( 571)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 571)					int size = (b1->length * 4);
HXDLIN( 571)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 571)					{
HXDLIN( 571)						int _g6 = 0;
HXDLIN( 571)						int _g7 = b1->length;
HXDLIN( 571)						while((_g6 < _g7)){
HXDLIN( 571)							_g6 = (_g6 + 1);
HXDLIN( 571)							int i1 = (_g6 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 571)								bool _hx_tmp1;
HXDLIN( 571)								if ((i1 >= 0)) {
HXDLIN( 571)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 571)									_hx_tmp1 = false;
            								}
HXDLIN( 571)								if (_hx_tmp1) {
HXDLIN( 571)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 571)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 571)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 571)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 571)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 571)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 571)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 571)				{
HXDLIN( 571)					v->width = width;
HXDLIN( 571)					v->height = height;
HXDLIN( 571)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 571)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 571)					{
HXDLIN( 571)						int _g8 = 0;
HXDLIN( 571)						int _g9 = v->length;
HXDLIN( 571)						while((_g8 < _g9)){
HXDLIN( 571)							_g8 = (_g8 + 1);
HXDLIN( 571)							int i2 = (_g8 - 1);
HXDLIN( 571)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 571)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 571)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 571)				{
HXDLIN( 571)					b2->width = width;
HXDLIN( 571)					b2->height = height;
HXDLIN( 571)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 571)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 571)					{
HXDLIN( 571)						int len1 = b2->length;
HXDLIN( 571)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 571)						if (::hx::IsNull( d->head )) {
HXDLIN( 571)							int _g10 = 0;
HXDLIN( 571)							int _g11 = len1;
HXDLIN( 571)							while((_g10 < _g11)){
HXDLIN( 571)								_g10 = (_g10 + 1);
HXDLIN( 571)								int i3 = (_g10 - 1);
HXDLIN( 571)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 571)							int _g12 = 0;
HXDLIN( 571)							int _g13 = len1;
HXDLIN( 571)							while((_g12 < _g13)){
HXDLIN( 571)								_g12 = (_g12 + 1);
HXDLIN( 571)								int i4 = (_g12 - 1);
HXDLIN( 571)								{
HXDLIN( 571)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 571)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 571)									{
HXDLIN( 571)										int _g14 = 0;
HXDLIN( 571)										int _g15 = i4;
HXDLIN( 571)										while((_g14 < _g15)){
HXDLIN( 571)											_g14 = (_g14 + 1);
HXDLIN( 571)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 571)									if (::hx::IsNull( prev )) {
HXDLIN( 571)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 571)										l = null();
            									}
            									else {
HXDLIN( 571)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 571)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 571)		this2->image = _hx_tmp;
HXDLIN( 571)		this2->width = width;
HXDLIN( 571)		this2->height = height;
HXDLIN( 571)		this2->imageType = ( (int)(imageType) );
HXDLIN( 571)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 571)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 571)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 571)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 571)				int width1 = (this4->width + 2);
HXDLIN( 571)				int height1 = (this4->height + 2);
HXDLIN( 571)				 ::Dynamic imageType1 = null();
HXDLIN( 571)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 571)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 571)				::Dynamic here1;
HXDLIN( 571)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 571)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 571)						{
HXDLIN( 571)							b3->width = width1;
HXDLIN( 571)							b3->height = height1;
HXDLIN( 571)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 571)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 571)							{
HXDLIN( 571)								int len2 = b3->length;
HXDLIN( 571)								int w1 = 0;
HXDLIN( 571)								{
HXDLIN( 571)									int _g16 = 0;
HXDLIN( 571)									int _g17 = b3->height;
HXDLIN( 571)									while((_g16 < _g17)){
HXDLIN( 571)										_g16 = (_g16 + 1);
HXDLIN( 571)										int y1 = (_g16 - 1);
HXDLIN( 571)										{
HXDLIN( 571)											int _g18 = 0;
HXDLIN( 571)											int _g19 = b3->width;
HXDLIN( 571)											while((_g18 < _g19)){
HXDLIN( 571)												_g18 = (_g18 + 1);
HXDLIN( 571)												int x1 = (_g18 - 1);
HXDLIN( 571)												{
HXDLIN( 571)													w1 = (w1 + 1);
HXDLIN( 571)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w1 = (w1 + 1);
HXDLIN( 571)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w1 = (w1 + 1);
HXDLIN( 571)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w1 = (w1 + 1);
HXDLIN( 571)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 571)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 571)						{
HXDLIN( 571)							a1->width = width1;
HXDLIN( 571)							a1->height = height1;
HXDLIN( 571)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 571)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 571)							{
HXDLIN( 571)								int _g20 = 0;
HXDLIN( 571)								int _g21 = a1->length;
HXDLIN( 571)								while((_g20 < _g21)){
HXDLIN( 571)									_g20 = (_g20 + 1);
HXDLIN( 571)									int i6 = (_g20 - 1);
HXDLIN( 571)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 571)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 571)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 571)						{
HXDLIN( 571)							b4->width = width1;
HXDLIN( 571)							b4->height = height1;
HXDLIN( 571)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 571)							int size1 = (b4->length * 4);
HXDLIN( 571)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 571)							{
HXDLIN( 571)								int _g22 = 0;
HXDLIN( 571)								int _g23 = b4->length;
HXDLIN( 571)								while((_g22 < _g23)){
HXDLIN( 571)									_g22 = (_g22 + 1);
HXDLIN( 571)									int i7 = (_g22 - 1);
HXDLIN( 571)									{
HXDLIN( 571)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 571)										bool here2;
HXDLIN( 571)										if ((i7 >= 0)) {
HXDLIN( 571)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 571)											here2 = false;
            										}
HXDLIN( 571)										if (here2) {
HXDLIN( 571)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 571)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 571)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 571)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 571)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 571)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 571)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 571)						{
HXDLIN( 571)							v1->width = width1;
HXDLIN( 571)							v1->height = height1;
HXDLIN( 571)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 571)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 571)							{
HXDLIN( 571)								int _g24 = 0;
HXDLIN( 571)								int _g25 = v1->length;
HXDLIN( 571)								while((_g24 < _g25)){
HXDLIN( 571)									_g24 = (_g24 + 1);
HXDLIN( 571)									int i8 = (_g24 - 1);
HXDLIN( 571)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 571)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 571)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 571)						{
HXDLIN( 571)							b5->width = width1;
HXDLIN( 571)							b5->height = height1;
HXDLIN( 571)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 571)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 571)							{
HXDLIN( 571)								int len3 = b5->length;
HXDLIN( 571)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 571)								if (::hx::IsNull( d1->head )) {
HXDLIN( 571)									int _g26 = 0;
HXDLIN( 571)									int _g27 = len3;
HXDLIN( 571)									while((_g26 < _g27)){
HXDLIN( 571)										_g26 = (_g26 + 1);
HXDLIN( 571)										int i9 = (_g26 - 1);
HXDLIN( 571)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 571)									int _g28 = 0;
HXDLIN( 571)									int _g29 = len3;
HXDLIN( 571)									while((_g28 < _g29)){
HXDLIN( 571)										_g28 = (_g28 + 1);
HXDLIN( 571)										int i10 = (_g28 - 1);
HXDLIN( 571)										{
HXDLIN( 571)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 571)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 571)											{
HXDLIN( 571)												int _g30 = 0;
HXDLIN( 571)												int _g31 = i10;
HXDLIN( 571)												while((_g30 < _g31)){
HXDLIN( 571)													_g30 = (_g30 + 1);
HXDLIN( 571)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 571)											if (::hx::IsNull( prev1 )) {
HXDLIN( 571)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 571)												l1 = null();
            											}
            											else {
HXDLIN( 571)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 571)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 571)				this5->image = here1;
HXDLIN( 571)				this5->width = width1;
HXDLIN( 571)				this5->height = height1;
HXDLIN( 571)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 571)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 571)				bool forceClear = false;
HXDLIN( 571)				int _g32 = 0;
HXDLIN( 571)				int _g33 = this4->height;
HXDLIN( 571)				while((_g32 < _g33)){
HXDLIN( 571)					_g32 = (_g32 + 1);
HXDLIN( 571)					int dy = (_g32 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g34 = 0;
HXDLIN( 571)						int _g35 = this4->width;
HXDLIN( 571)						while((_g34 < _g35)){
HXDLIN( 571)							_g34 = (_g34 + 1);
HXDLIN( 571)							int dx = (_g34 - 1);
HXDLIN( 571)							::Dynamic this7 = this4->image;
HXDLIN( 571)							int index;
HXDLIN( 571)							if (this4->useVirtualPos) {
HXDLIN( 571)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 571)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 571)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 571)							int col;
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								col = c;
            							}
HXDLIN( 571)							bool here3;
HXDLIN( 571)							if (this4->useMask) {
HXDLIN( 571)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 571)								here3 = false;
            							}
HXDLIN( 571)							if (here3) {
HXDLIN( 571)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 571)								::Dynamic this9 = this8->image;
HXDLIN( 571)								int index1;
HXDLIN( 571)								if (this8->useVirtualPos) {
HXDLIN( 571)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 571)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 571)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 571)								int v2;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									v2 = c1;
            								}
HXDLIN( 571)								int maskPixel = v2;
HXDLIN( 571)								int this10 = col;
HXDLIN( 571)								if ((maskPixel == 0)) {
HXDLIN( 571)									col = this10;
            								}
            								else {
HXDLIN( 571)									Float m0;
HXDLIN( 571)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 571)									if ((this11 == 0)) {
HXDLIN( 571)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m1;
HXDLIN( 571)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 571)									if ((this12 == 0)) {
HXDLIN( 571)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m2;
HXDLIN( 571)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 571)									if ((this13 == 0)) {
HXDLIN( 571)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m3;
HXDLIN( 571)									int this14 = (maskPixel & 255);
HXDLIN( 571)									if ((this14 == 0)) {
HXDLIN( 571)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 571)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 571)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 571)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 571)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 571)							if ((col != 0)) {
HXDLIN( 571)								int x2 = (1 + dx);
HXDLIN( 571)								int y2 = (1 + dy);
HXDLIN( 571)								int c2 = col;
HXDLIN( 571)								bool here4;
HXDLIN( 571)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 571)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 571)									here4 = false;
            								}
HXDLIN( 571)								if (here4) {
HXDLIN( 571)									int location;
HXDLIN( 571)									if (img->useVirtualPos) {
HXDLIN( 571)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 571)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 571)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 571)									int this16;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										this16 = this15;
            									}
HXDLIN( 571)									Float a11;
HXDLIN( 571)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 571)									if ((this17 == 0)) {
HXDLIN( 571)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r1;
HXDLIN( 571)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 571)									if ((this18 == 0)) {
HXDLIN( 571)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g1;
HXDLIN( 571)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 571)									if ((this19 == 0)) {
HXDLIN( 571)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b11;
HXDLIN( 571)									int this20 = (this16 & 255);
HXDLIN( 571)									if ((this20 == 0)) {
HXDLIN( 571)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a2;
HXDLIN( 571)									int this21 = ((col >> 24) & 255);
HXDLIN( 571)									if ((this21 == 0)) {
HXDLIN( 571)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r2;
HXDLIN( 571)									int this22 = ((col >> 16) & 255);
HXDLIN( 571)									if ((this22 == 0)) {
HXDLIN( 571)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g2;
HXDLIN( 571)									int this23 = ((col >> 8) & 255);
HXDLIN( 571)									if ((this23 == 0)) {
HXDLIN( 571)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b21;
HXDLIN( 571)									int this24 = (col & 255);
HXDLIN( 571)									if ((this24 == 0)) {
HXDLIN( 571)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 571)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 571)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 571)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 571)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 571)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 571)									{
HXDLIN( 571)										int here5;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here5 = blended;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 571)									::Dynamic this25 = img->image;
HXDLIN( 571)									int index2;
HXDLIN( 571)									if (img->useVirtualPos) {
HXDLIN( 571)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 571)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 571)									int here6;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										here6 = c2;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 571)								if (forceClear) {
HXDLIN( 571)									::Dynamic this26 = img->image;
HXDLIN( 571)									int x3 = (1 + dx);
HXDLIN( 571)									int y3 = (1 + dy);
HXDLIN( 571)									int index3;
HXDLIN( 571)									if (img->useVirtualPos) {
HXDLIN( 571)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 571)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g36 = 0;
HXDLIN( 571)				int _g37 = this4->width;
HXDLIN( 571)				while((_g36 < _g37)){
HXDLIN( 571)					_g36 = (_g36 + 1);
HXDLIN( 571)					int x4 = (_g36 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g38 = 0;
HXDLIN( 571)						int _g39 = 1;
HXDLIN( 571)						while((_g38 < _g39)){
HXDLIN( 571)							_g38 = (_g38 + 1);
HXDLIN( 571)							int y4 = (_g38 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								int x5 = (x4 + 1);
HXDLIN( 571)								::Dynamic this27 = this4->image;
HXDLIN( 571)								int index4;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 571)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 571)								int color;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color = c3;
            								}
HXDLIN( 571)								int color1 = color;
HXDLIN( 571)								{
HXDLIN( 571)									int c4 = color1;
HXDLIN( 571)									bool here7;
HXDLIN( 571)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 571)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here7 = false;
            									}
HXDLIN( 571)									if (here7) {
HXDLIN( 571)										int location1;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 571)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 571)										int this29;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this29 = this28;
            										}
HXDLIN( 571)										Float a12;
HXDLIN( 571)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 571)										if ((this30 == 0)) {
HXDLIN( 571)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r11;
HXDLIN( 571)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 571)										if ((this31 == 0)) {
HXDLIN( 571)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g11;
HXDLIN( 571)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 571)										if ((this32 == 0)) {
HXDLIN( 571)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b12;
HXDLIN( 571)										int this33 = (this29 & 255);
HXDLIN( 571)										if ((this33 == 0)) {
HXDLIN( 571)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a21;
HXDLIN( 571)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 571)										if ((this34 == 0)) {
HXDLIN( 571)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r21;
HXDLIN( 571)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 571)										if ((this35 == 0)) {
HXDLIN( 571)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g21;
HXDLIN( 571)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 571)										if ((this36 == 0)) {
HXDLIN( 571)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b22;
HXDLIN( 571)										int this37 = (color1 & 255);
HXDLIN( 571)										if ((this37 == 0)) {
HXDLIN( 571)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 571)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 571)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 571)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 571)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 571)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 571)										{
HXDLIN( 571)											int here8;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here8 = blended1;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this38 = img->image;
HXDLIN( 571)										int index5;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 571)										int here9;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here9 = c4;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x6 = (x4 + 1);
HXDLIN( 571)								int y5 = ((img->height - y4) - 1);
HXDLIN( 571)								int y6 = (this4->height - 1);
HXDLIN( 571)								::Dynamic this39 = this4->image;
HXDLIN( 571)								int index6;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 571)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 571)								int color2;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color2 = c5;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c6 = color2;
HXDLIN( 571)									bool here10;
HXDLIN( 571)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 571)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here10 = false;
            									}
HXDLIN( 571)									if (here10) {
HXDLIN( 571)										int location2;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 571)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 571)										int this41;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this41 = this40;
            										}
HXDLIN( 571)										Float a13;
HXDLIN( 571)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 571)										if ((this42 == 0)) {
HXDLIN( 571)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r12;
HXDLIN( 571)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 571)										if ((this43 == 0)) {
HXDLIN( 571)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g12;
HXDLIN( 571)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 571)										if ((this44 == 0)) {
HXDLIN( 571)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b13;
HXDLIN( 571)										int this45 = (this41 & 255);
HXDLIN( 571)										if ((this45 == 0)) {
HXDLIN( 571)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a22;
HXDLIN( 571)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 571)										if ((this46 == 0)) {
HXDLIN( 571)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r22;
HXDLIN( 571)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 571)										if ((this47 == 0)) {
HXDLIN( 571)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g22;
HXDLIN( 571)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 571)										if ((this48 == 0)) {
HXDLIN( 571)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b23;
HXDLIN( 571)										int this49 = (color2 & 255);
HXDLIN( 571)										if ((this49 == 0)) {
HXDLIN( 571)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 571)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 571)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 571)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 571)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 571)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 571)										{
HXDLIN( 571)											int here11;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here11 = blended2;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this50 = img->image;
HXDLIN( 571)										int index7;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 571)										int here12;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here12 = c6;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g40 = 0;
HXDLIN( 571)				int _g41 = this4->height;
HXDLIN( 571)				while((_g40 < _g41)){
HXDLIN( 571)					_g40 = (_g40 + 1);
HXDLIN( 571)					int y7 = (_g40 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g42 = 0;
HXDLIN( 571)						int _g43 = 1;
HXDLIN( 571)						while((_g42 < _g43)){
HXDLIN( 571)							_g42 = (_g42 + 1);
HXDLIN( 571)							int x7 = (_g42 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								int y8 = (y7 + 1);
HXDLIN( 571)								::Dynamic this51 = this4->image;
HXDLIN( 571)								int index8;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 571)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 571)								int color3;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color3 = c7;
            								}
HXDLIN( 571)								int color4 = color3;
HXDLIN( 571)								{
HXDLIN( 571)									int c8 = color4;
HXDLIN( 571)									bool here13;
HXDLIN( 571)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 571)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here13 = false;
            									}
HXDLIN( 571)									if (here13) {
HXDLIN( 571)										int location3;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 571)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 571)										int this53;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this53 = this52;
            										}
HXDLIN( 571)										Float a14;
HXDLIN( 571)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 571)										if ((this54 == 0)) {
HXDLIN( 571)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r13;
HXDLIN( 571)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 571)										if ((this55 == 0)) {
HXDLIN( 571)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g13;
HXDLIN( 571)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 571)										if ((this56 == 0)) {
HXDLIN( 571)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b14;
HXDLIN( 571)										int this57 = (this53 & 255);
HXDLIN( 571)										if ((this57 == 0)) {
HXDLIN( 571)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a23;
HXDLIN( 571)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 571)										if ((this58 == 0)) {
HXDLIN( 571)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r23;
HXDLIN( 571)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 571)										if ((this59 == 0)) {
HXDLIN( 571)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g23;
HXDLIN( 571)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 571)										if ((this60 == 0)) {
HXDLIN( 571)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b24;
HXDLIN( 571)										int this61 = (color4 & 255);
HXDLIN( 571)										if ((this61 == 0)) {
HXDLIN( 571)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 571)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 571)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 571)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 571)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 571)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 571)										{
HXDLIN( 571)											int here14;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here14 = blended3;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this62 = img->image;
HXDLIN( 571)										int index9;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 571)										int here15;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here15 = c8;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x8 = ((img->width - x7) - 1);
HXDLIN( 571)								int y9 = (y7 + 1);
HXDLIN( 571)								int x9 = (this4->width - 1);
HXDLIN( 571)								::Dynamic this63 = this4->image;
HXDLIN( 571)								int index10;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 571)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 571)								int color5;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color5 = c9;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c10 = color5;
HXDLIN( 571)									bool here16;
HXDLIN( 571)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 571)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here16 = false;
            									}
HXDLIN( 571)									if (here16) {
HXDLIN( 571)										int location4;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 571)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 571)										int this65;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this65 = this64;
            										}
HXDLIN( 571)										Float a15;
HXDLIN( 571)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 571)										if ((this66 == 0)) {
HXDLIN( 571)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r14;
HXDLIN( 571)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 571)										if ((this67 == 0)) {
HXDLIN( 571)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g14;
HXDLIN( 571)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 571)										if ((this68 == 0)) {
HXDLIN( 571)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b15;
HXDLIN( 571)										int this69 = (this65 & 255);
HXDLIN( 571)										if ((this69 == 0)) {
HXDLIN( 571)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a24;
HXDLIN( 571)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 571)										if ((this70 == 0)) {
HXDLIN( 571)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r24;
HXDLIN( 571)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 571)										if ((this71 == 0)) {
HXDLIN( 571)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g24;
HXDLIN( 571)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 571)										if ((this72 == 0)) {
HXDLIN( 571)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b25;
HXDLIN( 571)										int this73 = (color5 & 255);
HXDLIN( 571)										if ((this73 == 0)) {
HXDLIN( 571)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 571)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 571)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 571)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 571)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 571)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 571)										{
HXDLIN( 571)											int here17;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here17 = blended4;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this74 = img->image;
HXDLIN( 571)										int index11;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 571)										int here18;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here18 = c10;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g44 = 0;
HXDLIN( 571)				int _g45 = 1;
HXDLIN( 571)				while((_g44 < _g45)){
HXDLIN( 571)					_g44 = (_g44 + 1);
HXDLIN( 571)					int x10 = (_g44 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g46 = 0;
HXDLIN( 571)						int _g47 = 1;
HXDLIN( 571)						while((_g46 < _g47)){
HXDLIN( 571)							_g46 = (_g46 + 1);
HXDLIN( 571)							int y10 = (_g46 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								::Dynamic this75 = this4->image;
HXDLIN( 571)								int index12;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 571)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 571)								int color6;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color6 = c11;
            								}
HXDLIN( 571)								int color7 = color6;
HXDLIN( 571)								{
HXDLIN( 571)									int c12 = color7;
HXDLIN( 571)									bool here19;
HXDLIN( 571)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 571)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here19 = false;
            									}
HXDLIN( 571)									if (here19) {
HXDLIN( 571)										int location5;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 571)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 571)										int this77;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this77 = this76;
            										}
HXDLIN( 571)										Float a16;
HXDLIN( 571)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 571)										if ((this78 == 0)) {
HXDLIN( 571)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r15;
HXDLIN( 571)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 571)										if ((this79 == 0)) {
HXDLIN( 571)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g15;
HXDLIN( 571)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 571)										if ((this80 == 0)) {
HXDLIN( 571)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b16;
HXDLIN( 571)										int this81 = (this77 & 255);
HXDLIN( 571)										if ((this81 == 0)) {
HXDLIN( 571)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a25;
HXDLIN( 571)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 571)										if ((this82 == 0)) {
HXDLIN( 571)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r25;
HXDLIN( 571)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 571)										if ((this83 == 0)) {
HXDLIN( 571)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g25;
HXDLIN( 571)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 571)										if ((this84 == 0)) {
HXDLIN( 571)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b26;
HXDLIN( 571)										int this85 = (color7 & 255);
HXDLIN( 571)										if ((this85 == 0)) {
HXDLIN( 571)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 571)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 571)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 571)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 571)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 571)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 571)										{
HXDLIN( 571)											int here20;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here20 = blended5;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this86 = img->image;
HXDLIN( 571)										int index13;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 571)										int here21;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here21 = c12;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x11 = ((x10 + 1) + this4->width);
HXDLIN( 571)								int x12 = (this4->width - 1);
HXDLIN( 571)								::Dynamic this87 = this4->image;
HXDLIN( 571)								int index14;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 571)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 571)								int color8;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color8 = c13;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c14 = color8;
HXDLIN( 571)									bool here22;
HXDLIN( 571)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 571)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here22 = false;
            									}
HXDLIN( 571)									if (here22) {
HXDLIN( 571)										int location6;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 571)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 571)										int this89;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this89 = this88;
            										}
HXDLIN( 571)										Float a17;
HXDLIN( 571)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 571)										if ((this90 == 0)) {
HXDLIN( 571)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r16;
HXDLIN( 571)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 571)										if ((this91 == 0)) {
HXDLIN( 571)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g16;
HXDLIN( 571)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 571)										if ((this92 == 0)) {
HXDLIN( 571)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b18;
HXDLIN( 571)										int this93 = (this89 & 255);
HXDLIN( 571)										if ((this93 == 0)) {
HXDLIN( 571)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a26;
HXDLIN( 571)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 571)										if ((this94 == 0)) {
HXDLIN( 571)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r26;
HXDLIN( 571)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 571)										if ((this95 == 0)) {
HXDLIN( 571)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g26;
HXDLIN( 571)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 571)										if ((this96 == 0)) {
HXDLIN( 571)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b27;
HXDLIN( 571)										int this97 = (color8 & 255);
HXDLIN( 571)										if ((this97 == 0)) {
HXDLIN( 571)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 571)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 571)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 571)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 571)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 571)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 571)										{
HXDLIN( 571)											int here23;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here23 = blended6;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this98 = img->image;
HXDLIN( 571)										int index15;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 571)										int here24;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here24 = c14;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x13 = ((x10 + 1) + this4->width);
HXDLIN( 571)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 571)								int x14 = (this4->width - 1);
HXDLIN( 571)								int y12 = (this4->height - 1);
HXDLIN( 571)								::Dynamic this99 = this4->image;
HXDLIN( 571)								int index16;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 571)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 571)								int color9;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color9 = c15;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c16 = color9;
HXDLIN( 571)									bool here25;
HXDLIN( 571)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 571)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here25 = false;
            									}
HXDLIN( 571)									if (here25) {
HXDLIN( 571)										int location7;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 571)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 571)										int this101;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this101 = this100;
            										}
HXDLIN( 571)										Float a18;
HXDLIN( 571)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 571)										if ((this102 == 0)) {
HXDLIN( 571)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r17;
HXDLIN( 571)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 571)										if ((this103 == 0)) {
HXDLIN( 571)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g17;
HXDLIN( 571)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 571)										if ((this104 == 0)) {
HXDLIN( 571)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b110;
HXDLIN( 571)										int this105 = (this101 & 255);
HXDLIN( 571)										if ((this105 == 0)) {
HXDLIN( 571)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a27;
HXDLIN( 571)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 571)										if ((this106 == 0)) {
HXDLIN( 571)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r27;
HXDLIN( 571)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 571)										if ((this107 == 0)) {
HXDLIN( 571)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g27;
HXDLIN( 571)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 571)										if ((this108 == 0)) {
HXDLIN( 571)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b28;
HXDLIN( 571)										int this109 = (color9 & 255);
HXDLIN( 571)										if ((this109 == 0)) {
HXDLIN( 571)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 571)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 571)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 571)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 571)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 571)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 571)										{
HXDLIN( 571)											int here26;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here26 = blended7;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this110 = img->image;
HXDLIN( 571)										int index17;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 571)										int here27;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here27 = c16;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 571)								int y14 = (this4->height - 1);
HXDLIN( 571)								::Dynamic this111 = this4->image;
HXDLIN( 571)								int index18;
HXDLIN( 571)								if (this4->useVirtualPos) {
HXDLIN( 571)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 571)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 571)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 571)								int color10;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color10 = c17;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c18 = color10;
HXDLIN( 571)									bool here28;
HXDLIN( 571)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 571)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 571)										here28 = false;
            									}
HXDLIN( 571)									if (here28) {
HXDLIN( 571)										int location8;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 571)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 571)										int this113;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this113 = this112;
            										}
HXDLIN( 571)										Float a110;
HXDLIN( 571)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 571)										if ((this114 == 0)) {
HXDLIN( 571)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r18;
HXDLIN( 571)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 571)										if ((this115 == 0)) {
HXDLIN( 571)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g18;
HXDLIN( 571)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 571)										if ((this116 == 0)) {
HXDLIN( 571)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b111;
HXDLIN( 571)										int this117 = (this113 & 255);
HXDLIN( 571)										if ((this117 == 0)) {
HXDLIN( 571)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a28;
HXDLIN( 571)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 571)										if ((this118 == 0)) {
HXDLIN( 571)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r28;
HXDLIN( 571)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 571)										if ((this119 == 0)) {
HXDLIN( 571)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g28;
HXDLIN( 571)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 571)										if ((this120 == 0)) {
HXDLIN( 571)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b29;
HXDLIN( 571)										int this121 = (color10 & 255);
HXDLIN( 571)										if ((this121 == 0)) {
HXDLIN( 571)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 571)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 571)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 571)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 571)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 571)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 571)										{
HXDLIN( 571)											int here29;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here29 = blended8;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this122 = img->image;
HXDLIN( 571)										int index19;
HXDLIN( 571)										if (img->useVirtualPos) {
HXDLIN( 571)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 571)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 571)										int here30;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here30 = c18;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 571)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 571)				int width2 = (this123->width + 2);
HXDLIN( 571)				int height2 = (this123->height + 2);
HXDLIN( 571)				 ::Dynamic imageType2 = null();
HXDLIN( 571)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 571)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 571)				::Dynamic here31;
HXDLIN( 571)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 571)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 571)						{
HXDLIN( 571)							b31->width = width2;
HXDLIN( 571)							b31->height = height2;
HXDLIN( 571)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 571)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 571)							{
HXDLIN( 571)								int len4 = b31->length;
HXDLIN( 571)								int w2 = 0;
HXDLIN( 571)								{
HXDLIN( 571)									int _g48 = 0;
HXDLIN( 571)									int _g49 = b31->height;
HXDLIN( 571)									while((_g48 < _g49)){
HXDLIN( 571)										_g48 = (_g48 + 1);
HXDLIN( 571)										int y15 = (_g48 - 1);
HXDLIN( 571)										{
HXDLIN( 571)											int _g50 = 0;
HXDLIN( 571)											int _g51 = b31->width;
HXDLIN( 571)											while((_g50 < _g51)){
HXDLIN( 571)												_g50 = (_g50 + 1);
HXDLIN( 571)												int x15 = (_g50 - 1);
HXDLIN( 571)												{
HXDLIN( 571)													w2 = (w2 + 1);
HXDLIN( 571)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w2 = (w2 + 1);
HXDLIN( 571)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w2 = (w2 + 1);
HXDLIN( 571)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 571)												{
HXDLIN( 571)													w2 = (w2 + 1);
HXDLIN( 571)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 571)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 571)						{
HXDLIN( 571)							a29->width = width2;
HXDLIN( 571)							a29->height = height2;
HXDLIN( 571)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 571)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 571)							{
HXDLIN( 571)								int _g52 = 0;
HXDLIN( 571)								int _g53 = a29->length;
HXDLIN( 571)								while((_g52 < _g53)){
HXDLIN( 571)									_g52 = (_g52 + 1);
HXDLIN( 571)									int i12 = (_g52 - 1);
HXDLIN( 571)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 571)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 571)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 571)						{
HXDLIN( 571)							b32->width = width2;
HXDLIN( 571)							b32->height = height2;
HXDLIN( 571)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 571)							int size2 = (b32->length * 4);
HXDLIN( 571)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 571)							{
HXDLIN( 571)								int _g54 = 0;
HXDLIN( 571)								int _g55 = b32->length;
HXDLIN( 571)								while((_g54 < _g55)){
HXDLIN( 571)									_g54 = (_g54 + 1);
HXDLIN( 571)									int i13 = (_g54 - 1);
HXDLIN( 571)									{
HXDLIN( 571)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 571)										bool here32;
HXDLIN( 571)										if ((i13 >= 0)) {
HXDLIN( 571)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 571)											here32 = false;
            										}
HXDLIN( 571)										if (here32) {
HXDLIN( 571)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 571)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 571)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 571)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 571)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 571)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 571)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 571)						{
HXDLIN( 571)							v3->width = width2;
HXDLIN( 571)							v3->height = height2;
HXDLIN( 571)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 571)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 571)							{
HXDLIN( 571)								int _g56 = 0;
HXDLIN( 571)								int _g57 = v3->length;
HXDLIN( 571)								while((_g56 < _g57)){
HXDLIN( 571)									_g56 = (_g56 + 1);
HXDLIN( 571)									int i14 = (_g56 - 1);
HXDLIN( 571)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 571)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 571)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 571)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 571)						{
HXDLIN( 571)							b33->width = width2;
HXDLIN( 571)							b33->height = height2;
HXDLIN( 571)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 571)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 571)							{
HXDLIN( 571)								int len5 = b33->length;
HXDLIN( 571)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 571)								if (::hx::IsNull( d2->head )) {
HXDLIN( 571)									int _g58 = 0;
HXDLIN( 571)									int _g59 = len5;
HXDLIN( 571)									while((_g58 < _g59)){
HXDLIN( 571)										_g58 = (_g58 + 1);
HXDLIN( 571)										int i15 = (_g58 - 1);
HXDLIN( 571)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 571)									int _g60 = 0;
HXDLIN( 571)									int _g61 = len5;
HXDLIN( 571)									while((_g60 < _g61)){
HXDLIN( 571)										_g60 = (_g60 + 1);
HXDLIN( 571)										int i16 = (_g60 - 1);
HXDLIN( 571)										{
HXDLIN( 571)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 571)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 571)											{
HXDLIN( 571)												int _g62 = 0;
HXDLIN( 571)												int _g63 = i16;
HXDLIN( 571)												while((_g62 < _g63)){
HXDLIN( 571)													_g62 = (_g62 + 1);
HXDLIN( 571)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 571)											if (::hx::IsNull( prev2 )) {
HXDLIN( 571)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 571)												l2 = null();
            											}
            											else {
HXDLIN( 571)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 571)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 571)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 571)				this124->image = here31;
HXDLIN( 571)				this124->width = width2;
HXDLIN( 571)				this124->height = height2;
HXDLIN( 571)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 571)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 571)				bool forceClear1 = false;
HXDLIN( 571)				int _g64 = 0;
HXDLIN( 571)				int _g65 = this123->height;
HXDLIN( 571)				while((_g64 < _g65)){
HXDLIN( 571)					_g64 = (_g64 + 1);
HXDLIN( 571)					int dy1 = (_g64 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g66 = 0;
HXDLIN( 571)						int _g67 = this123->width;
HXDLIN( 571)						while((_g66 < _g67)){
HXDLIN( 571)							_g66 = (_g66 + 1);
HXDLIN( 571)							int dx1 = (_g66 - 1);
HXDLIN( 571)							::Dynamic this126 = this123->image;
HXDLIN( 571)							int index20;
HXDLIN( 571)							if (this123->useVirtualPos) {
HXDLIN( 571)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 571)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 571)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 571)							int col1;
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								col1 = c19;
            							}
HXDLIN( 571)							bool here33;
HXDLIN( 571)							if (this123->useMask) {
HXDLIN( 571)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 571)								here33 = false;
            							}
HXDLIN( 571)							if (here33) {
HXDLIN( 571)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 571)								::Dynamic this128 = this127->image;
HXDLIN( 571)								int index21;
HXDLIN( 571)								if (this127->useVirtualPos) {
HXDLIN( 571)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 571)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 571)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 571)								int v4;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									v4 = c20;
            								}
HXDLIN( 571)								int maskPixel1 = v4;
HXDLIN( 571)								int this129 = col1;
HXDLIN( 571)								if ((maskPixel1 == 0)) {
HXDLIN( 571)									col1 = this129;
            								}
            								else {
HXDLIN( 571)									Float m01;
HXDLIN( 571)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 571)									if ((this130 == 0)) {
HXDLIN( 571)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m11;
HXDLIN( 571)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 571)									if ((this131 == 0)) {
HXDLIN( 571)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m21;
HXDLIN( 571)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 571)									if ((this132 == 0)) {
HXDLIN( 571)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float m31;
HXDLIN( 571)									int this133 = (maskPixel1 & 255);
HXDLIN( 571)									if ((this133 == 0)) {
HXDLIN( 571)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 571)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 571)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 571)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 571)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 571)							if ((col1 != 0)) {
HXDLIN( 571)								int x16 = (1 + dx1);
HXDLIN( 571)								int y16 = (1 + dy1);
HXDLIN( 571)								int c21 = col1;
HXDLIN( 571)								bool here34;
HXDLIN( 571)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 571)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 571)									here34 = false;
            								}
HXDLIN( 571)								if (here34) {
HXDLIN( 571)									int location9;
HXDLIN( 571)									if (img1->useVirtualPos) {
HXDLIN( 571)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 571)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 571)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 571)									int this135;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										this135 = this134;
            									}
HXDLIN( 571)									Float a111;
HXDLIN( 571)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 571)									if ((this136 == 0)) {
HXDLIN( 571)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r19;
HXDLIN( 571)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 571)									if ((this137 == 0)) {
HXDLIN( 571)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g19;
HXDLIN( 571)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 571)									if ((this138 == 0)) {
HXDLIN( 571)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b112;
HXDLIN( 571)									int this139 = (this135 & 255);
HXDLIN( 571)									if ((this139 == 0)) {
HXDLIN( 571)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a210;
HXDLIN( 571)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 571)									if ((this140 == 0)) {
HXDLIN( 571)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r29;
HXDLIN( 571)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 571)									if ((this141 == 0)) {
HXDLIN( 571)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g29;
HXDLIN( 571)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 571)									if ((this142 == 0)) {
HXDLIN( 571)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b210;
HXDLIN( 571)									int this143 = (col1 & 255);
HXDLIN( 571)									if ((this143 == 0)) {
HXDLIN( 571)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 571)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 571)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 571)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 571)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 571)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 571)									{
HXDLIN( 571)										int here35;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here35 = blended9;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 571)									::Dynamic this144 = img1->image;
HXDLIN( 571)									int index22;
HXDLIN( 571)									if (img1->useVirtualPos) {
HXDLIN( 571)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 571)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 571)									int here36;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										here36 = c21;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 571)								if (forceClear1) {
HXDLIN( 571)									::Dynamic this145 = img1->image;
HXDLIN( 571)									int x17 = (1 + dx1);
HXDLIN( 571)									int y17 = (1 + dy1);
HXDLIN( 571)									int index23;
HXDLIN( 571)									if (img1->useVirtualPos) {
HXDLIN( 571)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 571)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g68 = 0;
HXDLIN( 571)				int _g69 = this123->width;
HXDLIN( 571)				while((_g68 < _g69)){
HXDLIN( 571)					_g68 = (_g68 + 1);
HXDLIN( 571)					int x18 = (_g68 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g70 = 0;
HXDLIN( 571)						int _g71 = 1;
HXDLIN( 571)						while((_g70 < _g71)){
HXDLIN( 571)							_g70 = (_g70 + 1);
HXDLIN( 571)							int y18 = (_g70 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								int x19 = (x18 + 1);
HXDLIN( 571)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 571)								::Dynamic this146 = this123->image;
HXDLIN( 571)								int index24;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 571)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 571)								int color11;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color11 = c22;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c23 = color11;
HXDLIN( 571)									bool here37;
HXDLIN( 571)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 571)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here37 = false;
            									}
HXDLIN( 571)									if (here37) {
HXDLIN( 571)										int location10;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 571)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 571)										int this148;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this148 = this147;
            										}
HXDLIN( 571)										Float a112;
HXDLIN( 571)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 571)										if ((this149 == 0)) {
HXDLIN( 571)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r110;
HXDLIN( 571)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 571)										if ((this150 == 0)) {
HXDLIN( 571)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g110;
HXDLIN( 571)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 571)										if ((this151 == 0)) {
HXDLIN( 571)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b113;
HXDLIN( 571)										int this152 = (this148 & 255);
HXDLIN( 571)										if ((this152 == 0)) {
HXDLIN( 571)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a211;
HXDLIN( 571)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 571)										if ((this153 == 0)) {
HXDLIN( 571)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r210;
HXDLIN( 571)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 571)										if ((this154 == 0)) {
HXDLIN( 571)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g210;
HXDLIN( 571)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 571)										if ((this155 == 0)) {
HXDLIN( 571)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b211;
HXDLIN( 571)										int this156 = (color11 & 255);
HXDLIN( 571)										if ((this156 == 0)) {
HXDLIN( 571)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 571)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 571)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 571)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 571)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 571)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 571)										{
HXDLIN( 571)											int here38;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here38 = blended10;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this157 = img1->image;
HXDLIN( 571)										int index25;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 571)										int here39;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here39 = c23;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x20 = (x18 + 1);
HXDLIN( 571)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 571)								int y21 = (1 - y18);
HXDLIN( 571)								::Dynamic this158 = this123->image;
HXDLIN( 571)								int index26;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 571)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 571)								int color12;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color12 = c24;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c25 = color12;
HXDLIN( 571)									bool here40;
HXDLIN( 571)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 571)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here40 = false;
            									}
HXDLIN( 571)									if (here40) {
HXDLIN( 571)										int location11;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 571)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 571)										int this160;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this160 = this159;
            										}
HXDLIN( 571)										Float a113;
HXDLIN( 571)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 571)										if ((this161 == 0)) {
HXDLIN( 571)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r111;
HXDLIN( 571)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 571)										if ((this162 == 0)) {
HXDLIN( 571)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g111;
HXDLIN( 571)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 571)										if ((this163 == 0)) {
HXDLIN( 571)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b114;
HXDLIN( 571)										int this164 = (this160 & 255);
HXDLIN( 571)										if ((this164 == 0)) {
HXDLIN( 571)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a212;
HXDLIN( 571)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 571)										if ((this165 == 0)) {
HXDLIN( 571)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r211;
HXDLIN( 571)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 571)										if ((this166 == 0)) {
HXDLIN( 571)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g211;
HXDLIN( 571)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 571)										if ((this167 == 0)) {
HXDLIN( 571)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b212;
HXDLIN( 571)										int this168 = (color12 & 255);
HXDLIN( 571)										if ((this168 == 0)) {
HXDLIN( 571)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 571)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 571)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 571)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 571)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 571)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 571)										{
HXDLIN( 571)											int here41;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here41 = blended11;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this169 = img1->image;
HXDLIN( 571)										int index27;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 571)										int here42;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here42 = c25;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g72 = 0;
HXDLIN( 571)				int _g73 = this123->height;
HXDLIN( 571)				while((_g72 < _g73)){
HXDLIN( 571)					_g72 = (_g72 + 1);
HXDLIN( 571)					int y22 = (_g72 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g74 = 0;
HXDLIN( 571)						int _g75 = 1;
HXDLIN( 571)						while((_g74 < _g75)){
HXDLIN( 571)							_g74 = (_g74 + 1);
HXDLIN( 571)							int x21 = (_g74 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								int y23 = (y22 + 1);
HXDLIN( 571)								int x22 = (((this123->width - 1) - 1) + x21);
HXDLIN( 571)								::Dynamic this170 = this123->image;
HXDLIN( 571)								int index28;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 571)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 571)								int color13;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color13 = c26;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c27 = color13;
HXDLIN( 571)									bool here43;
HXDLIN( 571)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 571)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here43 = false;
            									}
HXDLIN( 571)									if (here43) {
HXDLIN( 571)										int location12;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 571)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 571)										int this172;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this172 = this171;
            										}
HXDLIN( 571)										Float a114;
HXDLIN( 571)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 571)										if ((this173 == 0)) {
HXDLIN( 571)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r112;
HXDLIN( 571)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 571)										if ((this174 == 0)) {
HXDLIN( 571)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g112;
HXDLIN( 571)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 571)										if ((this175 == 0)) {
HXDLIN( 571)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b115;
HXDLIN( 571)										int this176 = (this172 & 255);
HXDLIN( 571)										if ((this176 == 0)) {
HXDLIN( 571)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a213;
HXDLIN( 571)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 571)										if ((this177 == 0)) {
HXDLIN( 571)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r212;
HXDLIN( 571)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 571)										if ((this178 == 0)) {
HXDLIN( 571)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g212;
HXDLIN( 571)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 571)										if ((this179 == 0)) {
HXDLIN( 571)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b213;
HXDLIN( 571)										int this180 = (color13 & 255);
HXDLIN( 571)										if ((this180 == 0)) {
HXDLIN( 571)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 571)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 571)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 571)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 571)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 571)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 571)										{
HXDLIN( 571)											int here44;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here44 = blended12;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this181 = img1->image;
HXDLIN( 571)										int index29;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 571)										int here45;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here45 = c27;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 571)								int y24 = (y22 + 1);
HXDLIN( 571)								int x24 = (1 - x21);
HXDLIN( 571)								::Dynamic this182 = this123->image;
HXDLIN( 571)								int index30;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 571)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 571)								int color14;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color14 = c28;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c29 = color14;
HXDLIN( 571)									bool here46;
HXDLIN( 571)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 571)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here46 = false;
            									}
HXDLIN( 571)									if (here46) {
HXDLIN( 571)										int location13;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 571)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 571)										int this184;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this184 = this183;
            										}
HXDLIN( 571)										Float a115;
HXDLIN( 571)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 571)										if ((this185 == 0)) {
HXDLIN( 571)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r113;
HXDLIN( 571)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 571)										if ((this186 == 0)) {
HXDLIN( 571)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g113;
HXDLIN( 571)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 571)										if ((this187 == 0)) {
HXDLIN( 571)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b116;
HXDLIN( 571)										int this188 = (this184 & 255);
HXDLIN( 571)										if ((this188 == 0)) {
HXDLIN( 571)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a214;
HXDLIN( 571)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 571)										if ((this189 == 0)) {
HXDLIN( 571)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r213;
HXDLIN( 571)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 571)										if ((this190 == 0)) {
HXDLIN( 571)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g213;
HXDLIN( 571)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 571)										if ((this191 == 0)) {
HXDLIN( 571)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b214;
HXDLIN( 571)										int this192 = (color14 & 255);
HXDLIN( 571)										if ((this192 == 0)) {
HXDLIN( 571)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 571)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 571)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 571)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 571)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 571)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 571)										{
HXDLIN( 571)											int here47;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here47 = blended13;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this193 = img1->image;
HXDLIN( 571)										int index31;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 571)										int here48;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here48 = c29;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				int _g76 = 0;
HXDLIN( 571)				int _g77 = 1;
HXDLIN( 571)				while((_g76 < _g77)){
HXDLIN( 571)					_g76 = (_g76 + 1);
HXDLIN( 571)					int x25 = (_g76 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						int _g78 = 0;
HXDLIN( 571)						int _g79 = 1;
HXDLIN( 571)						while((_g78 < _g79)){
HXDLIN( 571)							_g78 = (_g78 + 1);
HXDLIN( 571)							int y25 = (_g78 - 1);
HXDLIN( 571)							{
HXDLIN( 571)								int x26 = (((this123->width - 1) - 1) + x25);
HXDLIN( 571)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 571)								::Dynamic this194 = this123->image;
HXDLIN( 571)								int index32;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 571)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 571)								int color15;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color15 = c30;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c31 = color15;
HXDLIN( 571)									bool here49;
HXDLIN( 571)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 571)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here49 = false;
            									}
HXDLIN( 571)									if (here49) {
HXDLIN( 571)										int location14;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 571)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 571)										int this196;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this196 = this195;
            										}
HXDLIN( 571)										Float a116;
HXDLIN( 571)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 571)										if ((this197 == 0)) {
HXDLIN( 571)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r114;
HXDLIN( 571)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 571)										if ((this198 == 0)) {
HXDLIN( 571)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g114;
HXDLIN( 571)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 571)										if ((this199 == 0)) {
HXDLIN( 571)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b117;
HXDLIN( 571)										int this200 = (this196 & 255);
HXDLIN( 571)										if ((this200 == 0)) {
HXDLIN( 571)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a215;
HXDLIN( 571)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 571)										if ((this201 == 0)) {
HXDLIN( 571)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r214;
HXDLIN( 571)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 571)										if ((this202 == 0)) {
HXDLIN( 571)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g214;
HXDLIN( 571)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 571)										if ((this203 == 0)) {
HXDLIN( 571)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b215;
HXDLIN( 571)										int this204 = (color15 & 255);
HXDLIN( 571)										if ((this204 == 0)) {
HXDLIN( 571)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 571)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 571)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 571)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 571)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 571)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 571)										{
HXDLIN( 571)											int here50;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here50 = blended14;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this205 = img1->image;
HXDLIN( 571)										int index33;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 571)										int here51;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here51 = c31;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x27 = ((x25 + 1) + this123->width);
HXDLIN( 571)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 571)								::Dynamic this206 = this123->image;
HXDLIN( 571)								int index34;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 571)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 571)								int color16;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color16 = c32;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c33 = color16;
HXDLIN( 571)									bool here52;
HXDLIN( 571)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 571)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here52 = false;
            									}
HXDLIN( 571)									if (here52) {
HXDLIN( 571)										int location15;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 571)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 571)										int this208;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this208 = this207;
            										}
HXDLIN( 571)										Float a117;
HXDLIN( 571)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 571)										if ((this209 == 0)) {
HXDLIN( 571)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r115;
HXDLIN( 571)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 571)										if ((this210 == 0)) {
HXDLIN( 571)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g115;
HXDLIN( 571)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 571)										if ((this211 == 0)) {
HXDLIN( 571)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b118;
HXDLIN( 571)										int this212 = (this208 & 255);
HXDLIN( 571)										if ((this212 == 0)) {
HXDLIN( 571)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a216;
HXDLIN( 571)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 571)										if ((this213 == 0)) {
HXDLIN( 571)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r215;
HXDLIN( 571)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 571)										if ((this214 == 0)) {
HXDLIN( 571)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g215;
HXDLIN( 571)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 571)										if ((this215 == 0)) {
HXDLIN( 571)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b216;
HXDLIN( 571)										int this216 = (color16 & 255);
HXDLIN( 571)										if ((this216 == 0)) {
HXDLIN( 571)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 571)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 571)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 571)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 571)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 571)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 571)										{
HXDLIN( 571)											int here53;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here53 = blended15;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this217 = img1->image;
HXDLIN( 571)										int index35;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 571)										int here54;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here54 = c33;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int x28 = ((x25 + 1) + this123->width);
HXDLIN( 571)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 571)								::Dynamic this218 = this123->image;
HXDLIN( 571)								int index36;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 571)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 571)								int color17;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color17 = c34;
            								}
HXDLIN( 571)								int color18 = color17;
HXDLIN( 571)								{
HXDLIN( 571)									int c35 = color18;
HXDLIN( 571)									bool here55;
HXDLIN( 571)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 571)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here55 = false;
            									}
HXDLIN( 571)									if (here55) {
HXDLIN( 571)										int location16;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 571)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 571)										int this220;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this220 = this219;
            										}
HXDLIN( 571)										Float a118;
HXDLIN( 571)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 571)										if ((this221 == 0)) {
HXDLIN( 571)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r116;
HXDLIN( 571)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 571)										if ((this222 == 0)) {
HXDLIN( 571)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g116;
HXDLIN( 571)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 571)										if ((this223 == 0)) {
HXDLIN( 571)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b119;
HXDLIN( 571)										int this224 = (this220 & 255);
HXDLIN( 571)										if ((this224 == 0)) {
HXDLIN( 571)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a217;
HXDLIN( 571)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 571)										if ((this225 == 0)) {
HXDLIN( 571)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r216;
HXDLIN( 571)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 571)										if ((this226 == 0)) {
HXDLIN( 571)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g216;
HXDLIN( 571)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 571)										if ((this227 == 0)) {
HXDLIN( 571)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b217;
HXDLIN( 571)										int this228 = (color18 & 255);
HXDLIN( 571)										if ((this228 == 0)) {
HXDLIN( 571)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 571)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 571)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 571)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 571)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 571)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 571)										{
HXDLIN( 571)											int here56;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here56 = blended16;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this229 = img1->image;
HXDLIN( 571)										int index37;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 571)										int here57;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here57 = c35;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 571)							{
HXDLIN( 571)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 571)								int x29 = (((this123->width - 1) - 1) + x25);
HXDLIN( 571)								::Dynamic this230 = this123->image;
HXDLIN( 571)								int index38;
HXDLIN( 571)								if (this123->useVirtualPos) {
HXDLIN( 571)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 571)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 571)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 571)								int color19;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									color19 = c36;
            								}
HXDLIN( 571)								{
HXDLIN( 571)									int c37 = color19;
HXDLIN( 571)									bool here58;
HXDLIN( 571)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 571)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 571)										here58 = false;
            									}
HXDLIN( 571)									if (here58) {
HXDLIN( 571)										int location17;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 571)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 571)										int this232;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											this232 = this231;
            										}
HXDLIN( 571)										Float a119;
HXDLIN( 571)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 571)										if ((this233 == 0)) {
HXDLIN( 571)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r117;
HXDLIN( 571)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 571)										if ((this234 == 0)) {
HXDLIN( 571)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g117;
HXDLIN( 571)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 571)										if ((this235 == 0)) {
HXDLIN( 571)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b120;
HXDLIN( 571)										int this236 = (this232 & 255);
HXDLIN( 571)										if ((this236 == 0)) {
HXDLIN( 571)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a218;
HXDLIN( 571)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 571)										if ((this237 == 0)) {
HXDLIN( 571)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float r217;
HXDLIN( 571)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 571)										if ((this238 == 0)) {
HXDLIN( 571)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float g217;
HXDLIN( 571)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 571)										if ((this239 == 0)) {
HXDLIN( 571)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float b218;
HXDLIN( 571)										int this240 = (color19 & 255);
HXDLIN( 571)										if ((this240 == 0)) {
HXDLIN( 571)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 571)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 571)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 571)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 571)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 571)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 571)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 571)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 571)										{
HXDLIN( 571)											int here59;
HXDLIN( 571)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 571)												here59 = blended17;
            											}
HXDLIN( 571)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 571)										::Dynamic this241 = img1->image;
HXDLIN( 571)										int index39;
HXDLIN( 571)										if (img1->useVirtualPos) {
HXDLIN( 571)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 571)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 571)										int here60;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											here60 = c37;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 571)				here = img1;
            			}
            			break;
            		}
HXDLIN( 571)		{
HXDLIN( 571)			int _g80 = 1;
HXDLIN( 571)			int _g81 = (this1->height - 2);
HXDLIN( 571)			while((_g80 < _g81)){
HXDLIN( 571)				_g80 = (_g80 + 1);
HXDLIN( 571)				int y30 = (_g80 - 1);
HXDLIN( 571)				{
HXDLIN( 571)					int _g82 = 1;
HXDLIN( 571)					int _g83 = (this1->width - 2);
HXDLIN( 571)					while((_g82 < _g83)){
HXDLIN( 571)						_g82 = (_g82 + 1);
HXDLIN( 571)						int x30 = (_g82 - 1);
HXDLIN( 571)						if ((x30 == 1)) {
HXDLIN( 571)							int x31 = (x30 - 1);
HXDLIN( 571)							int y31 = (y30 - 1);
HXDLIN( 571)							::Dynamic this242 = here->image;
HXDLIN( 571)							int index40;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 571)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								a0 = c38;
            							}
HXDLIN( 571)							int y32 = (y30 - 1);
HXDLIN( 571)							::Dynamic this243 = here->image;
HXDLIN( 571)							int index41;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x30)) ));
            							}
HXDLIN( 571)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								b0 = c39;
            							}
HXDLIN( 571)							int x32 = (x30 + 1);
HXDLIN( 571)							int y33 = (y30 - 1);
HXDLIN( 571)							::Dynamic this244 = here->image;
HXDLIN( 571)							int index42;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x32)) ));
            							}
HXDLIN( 571)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								c0 = c40;
            							}
HXDLIN( 571)							int x33 = (x30 - 1);
HXDLIN( 571)							::Dynamic this245 = here->image;
HXDLIN( 571)							int index43;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x33)) ));
            							}
HXDLIN( 571)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								d0 = c41;
            							}
HXDLIN( 571)							::Dynamic this246 = here->image;
HXDLIN( 571)							int index44;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 571)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 571)							int e01;
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 571)							int x34 = (x30 + 1);
HXDLIN( 571)							::Dynamic this247 = here->image;
HXDLIN( 571)							int index45;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 571)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								f0 = c43;
            							}
HXDLIN( 571)							int x35 = (x30 - 1);
HXDLIN( 571)							int y34 = (y30 + 1);
HXDLIN( 571)							::Dynamic this248 = here->image;
HXDLIN( 571)							int index46;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x35)) ));
            							}
HXDLIN( 571)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								g0 = c44;
            							}
HXDLIN( 571)							int y35 = (y30 + 1);
HXDLIN( 571)							::Dynamic this249 = here->image;
HXDLIN( 571)							int index47;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x30)) ));
            							}
HXDLIN( 571)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								h0 = c45;
            							}
HXDLIN( 571)							int x36 = (x30 + 1);
HXDLIN( 571)							int y36 = (y30 + 1);
HXDLIN( 571)							::Dynamic this250 = here->image;
HXDLIN( 571)							int index48;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x36)) ));
            							}
HXDLIN( 571)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 571)							int x37 = (x30 + 1);
HXDLIN( 571)							int y37 = (y30 - 1);
HXDLIN( 571)							::Dynamic this251 = here->image;
HXDLIN( 571)							int index49;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x37)) ));
            							}
HXDLIN( 571)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 571)							int x38 = (x30 + 1);
HXDLIN( 571)							::Dynamic this252 = here->image;
HXDLIN( 571)							int index50;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x38)) ));
            							}
HXDLIN( 571)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 571)							int x39 = (x30 + 1);
HXDLIN( 571)							int y38 = (y30 + 1);
HXDLIN( 571)							::Dynamic this253 = here->image;
HXDLIN( 571)							int index51;
HXDLIN( 571)							if (here->useVirtualPos) {
HXDLIN( 571)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 571)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x39)) ));
            							}
HXDLIN( 571)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 571)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 571)								i0 = c49;
            							}
            						}
HXDLIN( 571)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 571)							bool _hx_tmp2;
HXDLIN( 571)							if ((m33_a != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp2 = false;
            							}
HXDLIN( 571)							if (_hx_tmp2) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 571)							bool _hx_tmp3;
HXDLIN( 571)							if ((m33_b != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp3 = false;
            							}
HXDLIN( 571)							if (_hx_tmp3) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 571)							bool _hx_tmp4;
HXDLIN( 571)							if ((m33_c != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp4 = false;
            							}
HXDLIN( 571)							if (_hx_tmp4) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 571)							bool _hx_tmp5;
HXDLIN( 571)							if ((m33_d != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp5 = false;
            							}
HXDLIN( 571)							if (_hx_tmp5) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 571)							bool _hx_tmp6;
HXDLIN( 571)							if ((m33_e != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp6 = false;
            							}
HXDLIN( 571)							if (_hx_tmp6) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 571)							bool _hx_tmp7;
HXDLIN( 571)							if ((m33_f != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp7 = false;
            							}
HXDLIN( 571)							if (_hx_tmp7) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 571)							bool _hx_tmp8;
HXDLIN( 571)							if ((m33_g != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp8 = false;
            							}
HXDLIN( 571)							if (_hx_tmp8) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 571)							bool _hx_tmp9;
HXDLIN( 571)							if ((m33_h != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp9 = false;
            							}
HXDLIN( 571)							if (_hx_tmp9) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 571)							bool _hx_tmp10;
HXDLIN( 571)							if ((m33_i != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp10 = false;
            							}
HXDLIN( 571)							if (_hx_tmp10) {
HXDLIN( 571)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 571)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 571)							bool _hx_tmp11;
HXDLIN( 571)							if ((m33_a != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp11 = false;
            							}
HXDLIN( 571)							if (_hx_tmp11) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 571)							bool _hx_tmp12;
HXDLIN( 571)							if ((m33_b != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp12 = false;
            							}
HXDLIN( 571)							if (_hx_tmp12) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 571)							bool _hx_tmp13;
HXDLIN( 571)							if ((m33_c != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp13 = false;
            							}
HXDLIN( 571)							if (_hx_tmp13) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 571)							bool _hx_tmp14;
HXDLIN( 571)							if ((m33_d != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp14 = false;
            							}
HXDLIN( 571)							if (_hx_tmp14) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 571)							bool _hx_tmp15;
HXDLIN( 571)							if ((m33_e != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp15 = false;
            							}
HXDLIN( 571)							if (_hx_tmp15) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 571)							bool _hx_tmp16;
HXDLIN( 571)							if ((m33_f != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp16 = false;
            							}
HXDLIN( 571)							if (_hx_tmp16) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 571)							bool _hx_tmp17;
HXDLIN( 571)							if ((m33_g != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp17 = false;
            							}
HXDLIN( 571)							if (_hx_tmp17) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 571)							bool _hx_tmp18;
HXDLIN( 571)							if ((m33_h != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp18 = false;
            							}
HXDLIN( 571)							if (_hx_tmp18) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 571)							bool _hx_tmp19;
HXDLIN( 571)							if ((m33_i != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp19 = false;
            							}
HXDLIN( 571)							if (_hx_tmp19) {
HXDLIN( 571)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 571)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 571)							bool _hx_tmp20;
HXDLIN( 571)							if ((m33_a != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp20 = false;
            							}
HXDLIN( 571)							if (_hx_tmp20) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 571)							bool _hx_tmp21;
HXDLIN( 571)							if ((m33_b != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp21 = false;
            							}
HXDLIN( 571)							if (_hx_tmp21) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 571)							bool _hx_tmp22;
HXDLIN( 571)							if ((m33_c != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp22 = false;
            							}
HXDLIN( 571)							if (_hx_tmp22) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 571)							bool _hx_tmp23;
HXDLIN( 571)							if ((m33_d != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp23 = false;
            							}
HXDLIN( 571)							if (_hx_tmp23) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 571)							bool _hx_tmp24;
HXDLIN( 571)							if ((m33_e != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp24 = false;
            							}
HXDLIN( 571)							if (_hx_tmp24) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 571)							bool _hx_tmp25;
HXDLIN( 571)							if ((m33_f != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp25 = false;
            							}
HXDLIN( 571)							if (_hx_tmp25) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 571)							bool _hx_tmp26;
HXDLIN( 571)							if ((m33_g != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp26 = false;
            							}
HXDLIN( 571)							if (_hx_tmp26) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 571)							bool _hx_tmp27;
HXDLIN( 571)							if ((m33_h != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp27 = false;
            							}
HXDLIN( 571)							if (_hx_tmp27) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 571)							bool _hx_tmp28;
HXDLIN( 571)							if ((m33_i != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp28 = false;
            							}
HXDLIN( 571)							if (_hx_tmp28) {
HXDLIN( 571)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 571)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 571)							bool _hx_tmp29;
HXDLIN( 571)							if ((m33_a != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp29 = false;
            							}
HXDLIN( 571)							if (_hx_tmp29) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 571)							bool _hx_tmp30;
HXDLIN( 571)							if ((m33_b != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp30 = false;
            							}
HXDLIN( 571)							if (_hx_tmp30) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 571)							bool _hx_tmp31;
HXDLIN( 571)							if ((m33_c != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp31 = false;
            							}
HXDLIN( 571)							if (_hx_tmp31) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 571)							bool _hx_tmp32;
HXDLIN( 571)							if ((m33_d != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp32 = false;
            							}
HXDLIN( 571)							if (_hx_tmp32) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 571)							bool _hx_tmp33;
HXDLIN( 571)							if ((m33_e != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp33 = false;
            							}
HXDLIN( 571)							if (_hx_tmp33) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 571)							bool _hx_tmp34;
HXDLIN( 571)							if ((m33_f != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp34 = false;
            							}
HXDLIN( 571)							if (_hx_tmp34) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 571)							bool _hx_tmp35;
HXDLIN( 571)							if ((m33_g != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp35 = false;
            							}
HXDLIN( 571)							if (_hx_tmp35) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 571)							bool _hx_tmp36;
HXDLIN( 571)							if ((m33_h != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp36 = false;
            							}
HXDLIN( 571)							if (_hx_tmp36) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 571)							bool _hx_tmp37;
HXDLIN( 571)							if ((m33_i != ((Float)0.))) {
HXDLIN( 571)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXDLIN( 571)								_hx_tmp37 = false;
            							}
HXDLIN( 571)							if (_hx_tmp37) {
HXDLIN( 571)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 571)						bool _hx_tmp38;
HXDLIN( 571)						if ((borderMode != 0)) {
HXDLIN( 571)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXDLIN( 571)							_hx_tmp38 = true;
            						}
HXDLIN( 571)						if (_hx_tmp38) {
HXDLIN( 571)							int x40 = (x30 - 1);
HXDLIN( 571)							int y39 = (y30 - 1);
HXDLIN( 571)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 571)							{
HXDLIN( 571)								int c50 = color20;
HXDLIN( 571)								bool _hx_tmp39;
HXDLIN( 571)								if ((((c50 >> 24) & 255) < 254)) {
HXDLIN( 571)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXDLIN( 571)									_hx_tmp39 = false;
            								}
HXDLIN( 571)								if (_hx_tmp39) {
HXDLIN( 571)									int location18;
HXDLIN( 571)									if (out->useVirtualPos) {
HXDLIN( 571)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 571)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 571)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 571)									int this255;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										this255 = this254;
            									}
HXDLIN( 571)									Float a120;
HXDLIN( 571)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 571)									if ((this256 == 0)) {
HXDLIN( 571)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r118;
HXDLIN( 571)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 571)									if ((this257 == 0)) {
HXDLIN( 571)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g118;
HXDLIN( 571)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 571)									if ((this258 == 0)) {
HXDLIN( 571)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b121;
HXDLIN( 571)									int this259 = (this255 & 255);
HXDLIN( 571)									if ((this259 == 0)) {
HXDLIN( 571)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a219;
HXDLIN( 571)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 571)									if ((this260 == 0)) {
HXDLIN( 571)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r218;
HXDLIN( 571)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 571)									if ((this261 == 0)) {
HXDLIN( 571)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g218;
HXDLIN( 571)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 571)									if ((this262 == 0)) {
HXDLIN( 571)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b219;
HXDLIN( 571)									int this263 = (color20 & 255);
HXDLIN( 571)									if ((this263 == 0)) {
HXDLIN( 571)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 571)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 571)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 571)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 571)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 571)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 571)									{
HXDLIN( 571)										int _hx_tmp40;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											_hx_tmp40 = blended18;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXDLIN( 571)									::Dynamic this264 = out->image;
HXDLIN( 571)									int index52;
HXDLIN( 571)									if (out->useVirtualPos) {
HXDLIN( 571)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 571)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 571)									int _hx_tmp41;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp41 = c50;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXDLIN( 571)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 571)							{
HXDLIN( 571)								int c51 = color21;
HXDLIN( 571)								bool _hx_tmp42;
HXDLIN( 571)								if ((((c51 >> 24) & 255) < 254)) {
HXDLIN( 571)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXDLIN( 571)									_hx_tmp42 = false;
            								}
HXDLIN( 571)								if (_hx_tmp42) {
HXDLIN( 571)									int location19;
HXDLIN( 571)									if (out->useVirtualPos) {
HXDLIN( 571)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 571)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 571)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 571)									int this266;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										this266 = this265;
            									}
HXDLIN( 571)									Float a121;
HXDLIN( 571)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 571)									if ((this267 == 0)) {
HXDLIN( 571)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r119;
HXDLIN( 571)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 571)									if ((this268 == 0)) {
HXDLIN( 571)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g119;
HXDLIN( 571)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 571)									if ((this269 == 0)) {
HXDLIN( 571)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b122;
HXDLIN( 571)									int this270 = (this266 & 255);
HXDLIN( 571)									if ((this270 == 0)) {
HXDLIN( 571)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a220;
HXDLIN( 571)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 571)									if ((this271 == 0)) {
HXDLIN( 571)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float r219;
HXDLIN( 571)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 571)									if ((this272 == 0)) {
HXDLIN( 571)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float g219;
HXDLIN( 571)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 571)									if ((this273 == 0)) {
HXDLIN( 571)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float b220;
HXDLIN( 571)									int this274 = (color21 & 255);
HXDLIN( 571)									if ((this274 == 0)) {
HXDLIN( 571)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 571)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 571)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 571)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 571)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 571)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 571)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 571)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 571)									{
HXDLIN( 571)										int _hx_tmp43;
HXDLIN( 571)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 571)											_hx_tmp43 = blended19;
            										}
HXDLIN( 571)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXDLIN( 571)									::Dynamic this275 = out->image;
HXDLIN( 571)									int index53;
HXDLIN( 571)									if (out->useVirtualPos) {
HXDLIN( 571)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 571)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 571)									int _hx_tmp44;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp44 = c51;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 571)		if ((borderMode == 1)) {
HXDLIN( 571)			{
HXDLIN( 571)				int _g84 = 0;
HXDLIN( 571)				int _g85 = (this1->width - 1);
HXDLIN( 571)				while((_g84 < _g85)){
HXDLIN( 571)					_g84 = (_g84 + 1);
HXDLIN( 571)					int x41 = (_g84 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						::Dynamic this276 = here->image;
HXDLIN( 571)						int index54;
HXDLIN( 571)						if (here->useVirtualPos) {
HXDLIN( 571)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 571)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x41)) ));
            						}
HXDLIN( 571)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 571)						int color22;
HXDLIN( 571)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXDLIN( 571)							color22 = c52;
            						}
HXDLIN( 571)						int color23 = color22;
HXDLIN( 571)						{
HXDLIN( 571)							int c53 = color23;
HXDLIN( 571)							bool _hx_tmp45;
HXDLIN( 571)							if ((((c53 >> 24) & 255) < 254)) {
HXDLIN( 571)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXDLIN( 571)								_hx_tmp45 = false;
            							}
HXDLIN( 571)							if (_hx_tmp45) {
HXDLIN( 571)								int location20;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 571)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 571)								int this278;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									this278 = this277;
            								}
HXDLIN( 571)								Float a122;
HXDLIN( 571)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 571)								if ((this279 == 0)) {
HXDLIN( 571)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r120;
HXDLIN( 571)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 571)								if ((this280 == 0)) {
HXDLIN( 571)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g120;
HXDLIN( 571)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 571)								if ((this281 == 0)) {
HXDLIN( 571)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b123;
HXDLIN( 571)								int this282 = (this278 & 255);
HXDLIN( 571)								if ((this282 == 0)) {
HXDLIN( 571)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a221;
HXDLIN( 571)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 571)								if ((this283 == 0)) {
HXDLIN( 571)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r220;
HXDLIN( 571)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 571)								if ((this284 == 0)) {
HXDLIN( 571)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g220;
HXDLIN( 571)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 571)								if ((this285 == 0)) {
HXDLIN( 571)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b221;
HXDLIN( 571)								int this286 = (color23 & 255);
HXDLIN( 571)								if ((this286 == 0)) {
HXDLIN( 571)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 571)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 571)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 571)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 571)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 571)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 571)								{
HXDLIN( 571)									int _hx_tmp46;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp46 = blended20;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXDLIN( 571)								::Dynamic this287 = out->image;
HXDLIN( 571)								int index55;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 571)								int _hx_tmp47;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									_hx_tmp47 = c53;
            								}
HXDLIN( 571)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 571)					{
HXDLIN( 571)						int y40 = (this1->height - 1);
HXDLIN( 571)						int y41 = (this1->height - 1);
HXDLIN( 571)						::Dynamic this288 = here->image;
HXDLIN( 571)						int index56;
HXDLIN( 571)						if (here->useVirtualPos) {
HXDLIN( 571)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 571)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x41)) ));
            						}
HXDLIN( 571)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 571)						int color24;
HXDLIN( 571)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXDLIN( 571)							color24 = c54;
            						}
HXDLIN( 571)						{
HXDLIN( 571)							int c55 = color24;
HXDLIN( 571)							bool _hx_tmp48;
HXDLIN( 571)							if ((((c55 >> 24) & 255) < 254)) {
HXDLIN( 571)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXDLIN( 571)								_hx_tmp48 = false;
            							}
HXDLIN( 571)							if (_hx_tmp48) {
HXDLIN( 571)								int location21;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 571)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 571)								int this290;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									this290 = this289;
            								}
HXDLIN( 571)								Float a123;
HXDLIN( 571)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 571)								if ((this291 == 0)) {
HXDLIN( 571)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r121;
HXDLIN( 571)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 571)								if ((this292 == 0)) {
HXDLIN( 571)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g121;
HXDLIN( 571)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 571)								if ((this293 == 0)) {
HXDLIN( 571)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b124;
HXDLIN( 571)								int this294 = (this290 & 255);
HXDLIN( 571)								if ((this294 == 0)) {
HXDLIN( 571)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a222;
HXDLIN( 571)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 571)								if ((this295 == 0)) {
HXDLIN( 571)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r221;
HXDLIN( 571)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 571)								if ((this296 == 0)) {
HXDLIN( 571)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g221;
HXDLIN( 571)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 571)								if ((this297 == 0)) {
HXDLIN( 571)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b222;
HXDLIN( 571)								int this298 = (color24 & 255);
HXDLIN( 571)								if ((this298 == 0)) {
HXDLIN( 571)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 571)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 571)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 571)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 571)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 571)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 571)								{
HXDLIN( 571)									int _hx_tmp49;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp49 = blended21;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXDLIN( 571)								::Dynamic this299 = out->image;
HXDLIN( 571)								int index57;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 571)								int _hx_tmp50;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									_hx_tmp50 = c55;
            								}
HXDLIN( 571)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 571)			{
HXDLIN( 571)				int _g86 = 1;
HXDLIN( 571)				int _g87 = (this1->height - 2);
HXDLIN( 571)				while((_g86 < _g87)){
HXDLIN( 571)					_g86 = (_g86 + 1);
HXDLIN( 571)					int y42 = (_g86 - 1);
HXDLIN( 571)					{
HXDLIN( 571)						::Dynamic this300 = here->image;
HXDLIN( 571)						int index58;
HXDLIN( 571)						if (here->useVirtualPos) {
HXDLIN( 571)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 571)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 571)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 571)						int color25;
HXDLIN( 571)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXDLIN( 571)							color25 = c56;
            						}
HXDLIN( 571)						int color26 = color25;
HXDLIN( 571)						{
HXDLIN( 571)							int c57 = color26;
HXDLIN( 571)							bool _hx_tmp51;
HXDLIN( 571)							if ((((c57 >> 24) & 255) < 254)) {
HXDLIN( 571)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXDLIN( 571)								_hx_tmp51 = false;
            							}
HXDLIN( 571)							if (_hx_tmp51) {
HXDLIN( 571)								int location22;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 571)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 571)								int this302;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									this302 = this301;
            								}
HXDLIN( 571)								Float a124;
HXDLIN( 571)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 571)								if ((this303 == 0)) {
HXDLIN( 571)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r122;
HXDLIN( 571)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 571)								if ((this304 == 0)) {
HXDLIN( 571)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g122;
HXDLIN( 571)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 571)								if ((this305 == 0)) {
HXDLIN( 571)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b125;
HXDLIN( 571)								int this306 = (this302 & 255);
HXDLIN( 571)								if ((this306 == 0)) {
HXDLIN( 571)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a223;
HXDLIN( 571)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 571)								if ((this307 == 0)) {
HXDLIN( 571)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r222;
HXDLIN( 571)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 571)								if ((this308 == 0)) {
HXDLIN( 571)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g222;
HXDLIN( 571)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 571)								if ((this309 == 0)) {
HXDLIN( 571)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b223;
HXDLIN( 571)								int this310 = (color26 & 255);
HXDLIN( 571)								if ((this310 == 0)) {
HXDLIN( 571)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 571)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 571)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 571)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 571)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 571)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 571)								{
HXDLIN( 571)									int _hx_tmp52;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp52 = blended22;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXDLIN( 571)								::Dynamic this311 = out->image;
HXDLIN( 571)								int index59;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 571)								int _hx_tmp53;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									_hx_tmp53 = c57;
            								}
HXDLIN( 571)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 571)					{
HXDLIN( 571)						int x42 = (this1->width - 1);
HXDLIN( 571)						int x43 = (this1->width - 1);
HXDLIN( 571)						::Dynamic this312 = here->image;
HXDLIN( 571)						int index60;
HXDLIN( 571)						if (here->useVirtualPos) {
HXDLIN( 571)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            						}
            						else {
HXDLIN( 571)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x43)) ));
            						}
HXDLIN( 571)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 571)						int color27;
HXDLIN( 571)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXDLIN( 571)							color27 = c58;
            						}
HXDLIN( 571)						{
HXDLIN( 571)							int c59 = color27;
HXDLIN( 571)							bool _hx_tmp54;
HXDLIN( 571)							if ((((c59 >> 24) & 255) < 254)) {
HXDLIN( 571)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXDLIN( 571)								_hx_tmp54 = false;
            							}
HXDLIN( 571)							if (_hx_tmp54) {
HXDLIN( 571)								int location23;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 571)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 571)								int this314;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									this314 = this313;
            								}
HXDLIN( 571)								Float a125;
HXDLIN( 571)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 571)								if ((this315 == 0)) {
HXDLIN( 571)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r123;
HXDLIN( 571)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 571)								if ((this316 == 0)) {
HXDLIN( 571)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g123;
HXDLIN( 571)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 571)								if ((this317 == 0)) {
HXDLIN( 571)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b126;
HXDLIN( 571)								int this318 = (this314 & 255);
HXDLIN( 571)								if ((this318 == 0)) {
HXDLIN( 571)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a224;
HXDLIN( 571)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 571)								if ((this319 == 0)) {
HXDLIN( 571)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float r223;
HXDLIN( 571)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 571)								if ((this320 == 0)) {
HXDLIN( 571)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float g223;
HXDLIN( 571)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 571)								if ((this321 == 0)) {
HXDLIN( 571)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float b224;
HXDLIN( 571)								int this322 = (color27 & 255);
HXDLIN( 571)								if ((this322 == 0)) {
HXDLIN( 571)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 571)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 571)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 571)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 571)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 571)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 571)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 571)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 571)								{
HXDLIN( 571)									int _hx_tmp55;
HXDLIN( 571)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 571)										_hx_tmp55 = blended23;
            									}
HXDLIN( 571)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXDLIN( 571)								::Dynamic this323 = out->image;
HXDLIN( 571)								int index61;
HXDLIN( 571)								if (out->useVirtualPos) {
HXDLIN( 571)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 571)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 571)								int _hx_tmp56;
HXDLIN( 571)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 571)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXDLIN( 571)									_hx_tmp56 = c59;
            								}
HXDLIN( 571)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 571)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,gussianBlur_3x3,return )

 ::pi_xy::imageAbstracts::Mat5x5data Convolution_Impl__obj::gussianBlur55data( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_579_gussianBlur55data)
HXDLIN( 579)		return  ::pi_xy::imageAbstracts::Mat5x5data_obj::__alloc( HX_CTX ,((Float)0.00390625),((Float)0.015625),((Float)0.0234375),((Float)0.015625),((Float)0.00390625),((Float)0.015625),((Float)0.0625),((Float)0.09375),((Float)0.0625),((Float)0.015625),((Float)0.0234375),((Float)0.09375),((Float)0.140625),((Float)0.09375),((Float)0.0234375),((Float)0.015625),((Float)0.0625),((Float)0.09375),((Float)0.0625),((Float)0.015625),((Float)0.00390625),((Float)0.015625),((Float)0.0234375),((Float)0.015625),((Float)0.00390625));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Convolution_Impl__obj,gussianBlur55data,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::gussianBlur_5x5( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_588_gussianBlur_5x5)
HXDLIN( 588)		Float m55_a = ((Float)0.00390625);
HXDLIN( 588)		Float m55_b = ((Float)0.015625);
HXDLIN( 588)		Float m55_c = ((Float)0.0234375);
HXDLIN( 588)		Float m55_d = ((Float)0.015625);
HXDLIN( 588)		Float m55_e = ((Float)0.00390625);
HXDLIN( 588)		Float m55_f = ((Float)0.015625);
HXDLIN( 588)		Float m55_g = ((Float)0.0625);
HXDLIN( 588)		Float m55_h = ((Float)0.09375);
HXDLIN( 588)		Float m55_i = ((Float)0.0625);
HXDLIN( 588)		Float m55_j = ((Float)0.015625);
HXDLIN( 588)		Float m55_k = ((Float)0.0234375);
HXDLIN( 588)		Float m55_l = ((Float)0.09375);
HXDLIN( 588)		Float m55_m = ((Float)0.140625);
HXDLIN( 588)		Float m55_n = ((Float)0.09375);
HXDLIN( 588)		Float m55_o = ((Float)0.0234375);
HXDLIN( 588)		Float m55_p = ((Float)0.015625);
HXDLIN( 588)		Float m55_q = ((Float)0.0625);
HXDLIN( 588)		Float m55_r = ((Float)0.09375);
HXDLIN( 588)		Float m55_s = ((Float)0.0625);
HXDLIN( 588)		Float m55_t = ((Float)0.015625);
HXDLIN( 588)		Float m55_u = ((Float)0.00390625);
HXDLIN( 588)		Float m55_v = ((Float)0.015625);
HXDLIN( 588)		Float m55_w = ((Float)0.0234375);
HXDLIN( 588)		Float m55_x = ((Float)0.015625);
HXDLIN( 588)		Float m55_y = ((Float)0.00390625);
HXDLIN( 588)		bool adjustRed = true;
HXDLIN( 588)		bool adjustGreen = true;
HXDLIN( 588)		bool adjustBlue = true;
HXDLIN( 588)		int a0 = 0;
HXDLIN( 588)		int b0 = 0;
HXDLIN( 588)		int c0 = 0;
HXDLIN( 588)		int d0 = 0;
HXDLIN( 588)		int e0 = 0;
HXDLIN( 588)		int f0 = 0;
HXDLIN( 588)		int g0 = 0;
HXDLIN( 588)		int h0 = 0;
HXDLIN( 588)		int i0 = 0;
HXDLIN( 588)		int j0 = 0;
HXDLIN( 588)		int k0 = 0;
HXDLIN( 588)		int l0 = 0;
HXDLIN( 588)		int m0 = 0;
HXDLIN( 588)		int n0 = 0;
HXDLIN( 588)		int o0 = 0;
HXDLIN( 588)		int p0 = 0;
HXDLIN( 588)		int q0 = 0;
HXDLIN( 588)		int r0 = 0;
HXDLIN( 588)		int s0 = 0;
HXDLIN( 588)		int t0 = 0;
HXDLIN( 588)		int u0 = 0;
HXDLIN( 588)		int v0 = 0;
HXDLIN( 588)		int w0 = 0;
HXDLIN( 588)		int x0 = 0;
HXDLIN( 588)		int y0 = 0;
HXDLIN( 588)		Float r_ = ((Float)0.);
HXDLIN( 588)		Float g_ = ((Float)0.);
HXDLIN( 588)		Float b_ = ((Float)0.);
HXDLIN( 588)		Float a_ = ((Float)0.);
HXDLIN( 588)		int width = this1->width;
HXDLIN( 588)		int height = this1->height;
HXDLIN( 588)		 ::Dynamic imageType = null();
HXDLIN( 588)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 588)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 588)		::Dynamic _hx_tmp;
HXDLIN( 588)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 588)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 588)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 588)				{
HXDLIN( 588)					b->width = width;
HXDLIN( 588)					b->height = height;
HXDLIN( 588)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 588)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 588)					{
HXDLIN( 588)						int len = b->length;
HXDLIN( 588)						int w = 0;
HXDLIN( 588)						{
HXDLIN( 588)							int _g = 0;
HXDLIN( 588)							int _g1 = b->height;
HXDLIN( 588)							while((_g < _g1)){
HXDLIN( 588)								_g = (_g + 1);
HXDLIN( 588)								int y = (_g - 1);
HXDLIN( 588)								{
HXDLIN( 588)									int _g2 = 0;
HXDLIN( 588)									int _g3 = b->width;
HXDLIN( 588)									while((_g2 < _g3)){
HXDLIN( 588)										_g2 = (_g2 + 1);
HXDLIN( 588)										int x = (_g2 - 1);
HXDLIN( 588)										{
HXDLIN( 588)											w = (w + 1);
HXDLIN( 588)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 588)										{
HXDLIN( 588)											w = (w + 1);
HXDLIN( 588)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 588)										{
HXDLIN( 588)											w = (w + 1);
HXDLIN( 588)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 588)										{
HXDLIN( 588)											w = (w + 1);
HXDLIN( 588)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 588)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 588)				{
HXDLIN( 588)					a->width = width;
HXDLIN( 588)					a->height = height;
HXDLIN( 588)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 588)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 588)					{
HXDLIN( 588)						int _g4 = 0;
HXDLIN( 588)						int _g5 = a->length;
HXDLIN( 588)						while((_g4 < _g5)){
HXDLIN( 588)							_g4 = (_g4 + 1);
HXDLIN( 588)							int i = (_g4 - 1);
HXDLIN( 588)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 588)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 588)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 588)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 588)				{
HXDLIN( 588)					b1->width = width;
HXDLIN( 588)					b1->height = height;
HXDLIN( 588)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 588)					int size = (b1->length * 4);
HXDLIN( 588)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 588)					{
HXDLIN( 588)						int _g6 = 0;
HXDLIN( 588)						int _g7 = b1->length;
HXDLIN( 588)						while((_g6 < _g7)){
HXDLIN( 588)							_g6 = (_g6 + 1);
HXDLIN( 588)							int i1 = (_g6 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 588)								bool _hx_tmp1;
HXDLIN( 588)								if ((i1 >= 0)) {
HXDLIN( 588)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 588)									_hx_tmp1 = false;
            								}
HXDLIN( 588)								if (_hx_tmp1) {
HXDLIN( 588)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 588)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 588)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 588)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 588)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 588)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 588)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 588)				{
HXDLIN( 588)					v->width = width;
HXDLIN( 588)					v->height = height;
HXDLIN( 588)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 588)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 588)					{
HXDLIN( 588)						int _g8 = 0;
HXDLIN( 588)						int _g9 = v->length;
HXDLIN( 588)						while((_g8 < _g9)){
HXDLIN( 588)							_g8 = (_g8 + 1);
HXDLIN( 588)							int i2 = (_g8 - 1);
HXDLIN( 588)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 588)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 588)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 588)				{
HXDLIN( 588)					b2->width = width;
HXDLIN( 588)					b2->height = height;
HXDLIN( 588)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 588)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 588)					{
HXDLIN( 588)						int len1 = b2->length;
HXDLIN( 588)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 588)						if (::hx::IsNull( d->head )) {
HXDLIN( 588)							int _g10 = 0;
HXDLIN( 588)							int _g11 = len1;
HXDLIN( 588)							while((_g10 < _g11)){
HXDLIN( 588)								_g10 = (_g10 + 1);
HXDLIN( 588)								int i3 = (_g10 - 1);
HXDLIN( 588)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 588)							int _g12 = 0;
HXDLIN( 588)							int _g13 = len1;
HXDLIN( 588)							while((_g12 < _g13)){
HXDLIN( 588)								_g12 = (_g12 + 1);
HXDLIN( 588)								int i4 = (_g12 - 1);
HXDLIN( 588)								{
HXDLIN( 588)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 588)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 588)									{
HXDLIN( 588)										int _g14 = 0;
HXDLIN( 588)										int _g15 = i4;
HXDLIN( 588)										while((_g14 < _g15)){
HXDLIN( 588)											_g14 = (_g14 + 1);
HXDLIN( 588)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 588)									if (::hx::IsNull( prev )) {
HXDLIN( 588)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 588)										l = null();
            									}
            									else {
HXDLIN( 588)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 588)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 588)		this2->image = _hx_tmp;
HXDLIN( 588)		this2->width = width;
HXDLIN( 588)		this2->height = height;
HXDLIN( 588)		this2->imageType = ( (int)(imageType) );
HXDLIN( 588)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 588)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 588)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 588)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 588)				int width1 = (this4->width + 4);
HXDLIN( 588)				int height1 = (this4->height + 4);
HXDLIN( 588)				 ::Dynamic imageType1 = null();
HXDLIN( 588)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 588)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 588)				::Dynamic here1;
HXDLIN( 588)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 588)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 588)						{
HXDLIN( 588)							b3->width = width1;
HXDLIN( 588)							b3->height = height1;
HXDLIN( 588)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 588)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 588)							{
HXDLIN( 588)								int len2 = b3->length;
HXDLIN( 588)								int w1 = 0;
HXDLIN( 588)								{
HXDLIN( 588)									int _g16 = 0;
HXDLIN( 588)									int _g17 = b3->height;
HXDLIN( 588)									while((_g16 < _g17)){
HXDLIN( 588)										_g16 = (_g16 + 1);
HXDLIN( 588)										int y1 = (_g16 - 1);
HXDLIN( 588)										{
HXDLIN( 588)											int _g18 = 0;
HXDLIN( 588)											int _g19 = b3->width;
HXDLIN( 588)											while((_g18 < _g19)){
HXDLIN( 588)												_g18 = (_g18 + 1);
HXDLIN( 588)												int x1 = (_g18 - 1);
HXDLIN( 588)												{
HXDLIN( 588)													w1 = (w1 + 1);
HXDLIN( 588)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w1 = (w1 + 1);
HXDLIN( 588)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w1 = (w1 + 1);
HXDLIN( 588)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w1 = (w1 + 1);
HXDLIN( 588)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 588)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 588)						{
HXDLIN( 588)							a1->width = width1;
HXDLIN( 588)							a1->height = height1;
HXDLIN( 588)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 588)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 588)							{
HXDLIN( 588)								int _g20 = 0;
HXDLIN( 588)								int _g21 = a1->length;
HXDLIN( 588)								while((_g20 < _g21)){
HXDLIN( 588)									_g20 = (_g20 + 1);
HXDLIN( 588)									int i6 = (_g20 - 1);
HXDLIN( 588)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 588)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 588)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 588)						{
HXDLIN( 588)							b4->width = width1;
HXDLIN( 588)							b4->height = height1;
HXDLIN( 588)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 588)							int size1 = (b4->length * 4);
HXDLIN( 588)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 588)							{
HXDLIN( 588)								int _g22 = 0;
HXDLIN( 588)								int _g23 = b4->length;
HXDLIN( 588)								while((_g22 < _g23)){
HXDLIN( 588)									_g22 = (_g22 + 1);
HXDLIN( 588)									int i7 = (_g22 - 1);
HXDLIN( 588)									{
HXDLIN( 588)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 588)										bool here2;
HXDLIN( 588)										if ((i7 >= 0)) {
HXDLIN( 588)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 588)											here2 = false;
            										}
HXDLIN( 588)										if (here2) {
HXDLIN( 588)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 588)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 588)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 588)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 588)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 588)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 588)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 588)						{
HXDLIN( 588)							v1->width = width1;
HXDLIN( 588)							v1->height = height1;
HXDLIN( 588)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 588)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 588)							{
HXDLIN( 588)								int _g24 = 0;
HXDLIN( 588)								int _g25 = v1->length;
HXDLIN( 588)								while((_g24 < _g25)){
HXDLIN( 588)									_g24 = (_g24 + 1);
HXDLIN( 588)									int i8 = (_g24 - 1);
HXDLIN( 588)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 588)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 588)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 588)						{
HXDLIN( 588)							b5->width = width1;
HXDLIN( 588)							b5->height = height1;
HXDLIN( 588)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 588)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 588)							{
HXDLIN( 588)								int len3 = b5->length;
HXDLIN( 588)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 588)								if (::hx::IsNull( d1->head )) {
HXDLIN( 588)									int _g26 = 0;
HXDLIN( 588)									int _g27 = len3;
HXDLIN( 588)									while((_g26 < _g27)){
HXDLIN( 588)										_g26 = (_g26 + 1);
HXDLIN( 588)										int i9 = (_g26 - 1);
HXDLIN( 588)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 588)									int _g28 = 0;
HXDLIN( 588)									int _g29 = len3;
HXDLIN( 588)									while((_g28 < _g29)){
HXDLIN( 588)										_g28 = (_g28 + 1);
HXDLIN( 588)										int i10 = (_g28 - 1);
HXDLIN( 588)										{
HXDLIN( 588)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 588)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 588)											{
HXDLIN( 588)												int _g30 = 0;
HXDLIN( 588)												int _g31 = i10;
HXDLIN( 588)												while((_g30 < _g31)){
HXDLIN( 588)													_g30 = (_g30 + 1);
HXDLIN( 588)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 588)											if (::hx::IsNull( prev1 )) {
HXDLIN( 588)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 588)												l1 = null();
            											}
            											else {
HXDLIN( 588)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 588)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 588)				this5->image = here1;
HXDLIN( 588)				this5->width = width1;
HXDLIN( 588)				this5->height = height1;
HXDLIN( 588)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 588)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 588)				bool forceClear = false;
HXDLIN( 588)				int _g32 = 0;
HXDLIN( 588)				int _g33 = this4->height;
HXDLIN( 588)				while((_g32 < _g33)){
HXDLIN( 588)					_g32 = (_g32 + 1);
HXDLIN( 588)					int dy = (_g32 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g34 = 0;
HXDLIN( 588)						int _g35 = this4->width;
HXDLIN( 588)						while((_g34 < _g35)){
HXDLIN( 588)							_g34 = (_g34 + 1);
HXDLIN( 588)							int dx = (_g34 - 1);
HXDLIN( 588)							::Dynamic this7 = this4->image;
HXDLIN( 588)							int index;
HXDLIN( 588)							if (this4->useVirtualPos) {
HXDLIN( 588)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 588)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 588)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 588)							int col;
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								col = c;
            							}
HXDLIN( 588)							bool here3;
HXDLIN( 588)							if (this4->useMask) {
HXDLIN( 588)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 588)								here3 = false;
            							}
HXDLIN( 588)							if (here3) {
HXDLIN( 588)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 588)								::Dynamic this9 = this8->image;
HXDLIN( 588)								int index1;
HXDLIN( 588)								if (this8->useVirtualPos) {
HXDLIN( 588)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 588)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 588)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 588)								int v2;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									v2 = c1;
            								}
HXDLIN( 588)								int maskPixel = v2;
HXDLIN( 588)								int this10 = col;
HXDLIN( 588)								if ((maskPixel == 0)) {
HXDLIN( 588)									col = this10;
            								}
            								else {
HXDLIN( 588)									Float m01;
HXDLIN( 588)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 588)									if ((this11 == 0)) {
HXDLIN( 588)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m01 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m1;
HXDLIN( 588)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 588)									if ((this12 == 0)) {
HXDLIN( 588)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m2;
HXDLIN( 588)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 588)									if ((this13 == 0)) {
HXDLIN( 588)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m3;
HXDLIN( 588)									int this14 = (maskPixel & 255);
HXDLIN( 588)									if ((this14 == 0)) {
HXDLIN( 588)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 588)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 588)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 588)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 588)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 588)							if ((col != 0)) {
HXDLIN( 588)								int x2 = (2 + dx);
HXDLIN( 588)								int y2 = (2 + dy);
HXDLIN( 588)								int c2 = col;
HXDLIN( 588)								bool here4;
HXDLIN( 588)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 588)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 588)									here4 = false;
            								}
HXDLIN( 588)								if (here4) {
HXDLIN( 588)									int location;
HXDLIN( 588)									if (img->useVirtualPos) {
HXDLIN( 588)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 588)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 588)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 588)									int this16;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										this16 = this15;
            									}
HXDLIN( 588)									Float a11;
HXDLIN( 588)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 588)									if ((this17 == 0)) {
HXDLIN( 588)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r1;
HXDLIN( 588)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 588)									if ((this18 == 0)) {
HXDLIN( 588)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g1;
HXDLIN( 588)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 588)									if ((this19 == 0)) {
HXDLIN( 588)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b11;
HXDLIN( 588)									int this20 = (this16 & 255);
HXDLIN( 588)									if ((this20 == 0)) {
HXDLIN( 588)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a2;
HXDLIN( 588)									int this21 = ((col >> 24) & 255);
HXDLIN( 588)									if ((this21 == 0)) {
HXDLIN( 588)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r2;
HXDLIN( 588)									int this22 = ((col >> 16) & 255);
HXDLIN( 588)									if ((this22 == 0)) {
HXDLIN( 588)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g2;
HXDLIN( 588)									int this23 = ((col >> 8) & 255);
HXDLIN( 588)									if ((this23 == 0)) {
HXDLIN( 588)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b21;
HXDLIN( 588)									int this24 = (col & 255);
HXDLIN( 588)									if ((this24 == 0)) {
HXDLIN( 588)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 588)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 588)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 588)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 588)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 588)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 588)									{
HXDLIN( 588)										int here5;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here5 = blended;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 588)									::Dynamic this25 = img->image;
HXDLIN( 588)									int index2;
HXDLIN( 588)									if (img->useVirtualPos) {
HXDLIN( 588)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 588)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 588)									int here6;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										here6 = c2;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 588)								if (forceClear) {
HXDLIN( 588)									::Dynamic this26 = img->image;
HXDLIN( 588)									int x3 = (2 + dx);
HXDLIN( 588)									int y3 = (2 + dy);
HXDLIN( 588)									int index3;
HXDLIN( 588)									if (img->useVirtualPos) {
HXDLIN( 588)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 588)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g36 = 0;
HXDLIN( 588)				int _g37 = this4->width;
HXDLIN( 588)				while((_g36 < _g37)){
HXDLIN( 588)					_g36 = (_g36 + 1);
HXDLIN( 588)					int x4 = (_g36 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g38 = 0;
HXDLIN( 588)						int _g39 = 2;
HXDLIN( 588)						while((_g38 < _g39)){
HXDLIN( 588)							_g38 = (_g38 + 1);
HXDLIN( 588)							int y4 = (_g38 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								int x5 = (x4 + 2);
HXDLIN( 588)								::Dynamic this27 = this4->image;
HXDLIN( 588)								int index4;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 588)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 588)								int color;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color = c3;
            								}
HXDLIN( 588)								int color1 = color;
HXDLIN( 588)								{
HXDLIN( 588)									int c4 = color1;
HXDLIN( 588)									bool here7;
HXDLIN( 588)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 588)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here7 = false;
            									}
HXDLIN( 588)									if (here7) {
HXDLIN( 588)										int location1;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 588)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 588)										int this29;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this29 = this28;
            										}
HXDLIN( 588)										Float a12;
HXDLIN( 588)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 588)										if ((this30 == 0)) {
HXDLIN( 588)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r11;
HXDLIN( 588)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 588)										if ((this31 == 0)) {
HXDLIN( 588)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g11;
HXDLIN( 588)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 588)										if ((this32 == 0)) {
HXDLIN( 588)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b12;
HXDLIN( 588)										int this33 = (this29 & 255);
HXDLIN( 588)										if ((this33 == 0)) {
HXDLIN( 588)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a21;
HXDLIN( 588)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 588)										if ((this34 == 0)) {
HXDLIN( 588)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r21;
HXDLIN( 588)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 588)										if ((this35 == 0)) {
HXDLIN( 588)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g21;
HXDLIN( 588)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 588)										if ((this36 == 0)) {
HXDLIN( 588)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b22;
HXDLIN( 588)										int this37 = (color1 & 255);
HXDLIN( 588)										if ((this37 == 0)) {
HXDLIN( 588)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 588)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 588)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 588)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 588)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 588)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 588)										{
HXDLIN( 588)											int here8;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here8 = blended1;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this38 = img->image;
HXDLIN( 588)										int index5;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 588)										int here9;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here9 = c4;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x6 = (x4 + 2);
HXDLIN( 588)								int y5 = ((img->height - y4) - 1);
HXDLIN( 588)								int y6 = (this4->height - 1);
HXDLIN( 588)								::Dynamic this39 = this4->image;
HXDLIN( 588)								int index6;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 588)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 588)								int color2;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color2 = c5;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c6 = color2;
HXDLIN( 588)									bool here10;
HXDLIN( 588)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 588)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here10 = false;
            									}
HXDLIN( 588)									if (here10) {
HXDLIN( 588)										int location2;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 588)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 588)										int this41;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this41 = this40;
            										}
HXDLIN( 588)										Float a13;
HXDLIN( 588)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 588)										if ((this42 == 0)) {
HXDLIN( 588)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r12;
HXDLIN( 588)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 588)										if ((this43 == 0)) {
HXDLIN( 588)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g12;
HXDLIN( 588)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 588)										if ((this44 == 0)) {
HXDLIN( 588)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b13;
HXDLIN( 588)										int this45 = (this41 & 255);
HXDLIN( 588)										if ((this45 == 0)) {
HXDLIN( 588)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a22;
HXDLIN( 588)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 588)										if ((this46 == 0)) {
HXDLIN( 588)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r22;
HXDLIN( 588)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 588)										if ((this47 == 0)) {
HXDLIN( 588)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g22;
HXDLIN( 588)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 588)										if ((this48 == 0)) {
HXDLIN( 588)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b23;
HXDLIN( 588)										int this49 = (color2 & 255);
HXDLIN( 588)										if ((this49 == 0)) {
HXDLIN( 588)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 588)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 588)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 588)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 588)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 588)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 588)										{
HXDLIN( 588)											int here11;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here11 = blended2;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this50 = img->image;
HXDLIN( 588)										int index7;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 588)										int here12;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here12 = c6;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g40 = 0;
HXDLIN( 588)				int _g41 = this4->height;
HXDLIN( 588)				while((_g40 < _g41)){
HXDLIN( 588)					_g40 = (_g40 + 1);
HXDLIN( 588)					int y7 = (_g40 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g42 = 0;
HXDLIN( 588)						int _g43 = 2;
HXDLIN( 588)						while((_g42 < _g43)){
HXDLIN( 588)							_g42 = (_g42 + 1);
HXDLIN( 588)							int x7 = (_g42 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								int y8 = (y7 + 2);
HXDLIN( 588)								::Dynamic this51 = this4->image;
HXDLIN( 588)								int index8;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 588)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 588)								int color3;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color3 = c7;
            								}
HXDLIN( 588)								int color4 = color3;
HXDLIN( 588)								{
HXDLIN( 588)									int c8 = color4;
HXDLIN( 588)									bool here13;
HXDLIN( 588)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 588)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here13 = false;
            									}
HXDLIN( 588)									if (here13) {
HXDLIN( 588)										int location3;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 588)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 588)										int this53;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this53 = this52;
            										}
HXDLIN( 588)										Float a14;
HXDLIN( 588)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 588)										if ((this54 == 0)) {
HXDLIN( 588)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r13;
HXDLIN( 588)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 588)										if ((this55 == 0)) {
HXDLIN( 588)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g13;
HXDLIN( 588)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 588)										if ((this56 == 0)) {
HXDLIN( 588)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b14;
HXDLIN( 588)										int this57 = (this53 & 255);
HXDLIN( 588)										if ((this57 == 0)) {
HXDLIN( 588)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a23;
HXDLIN( 588)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 588)										if ((this58 == 0)) {
HXDLIN( 588)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r23;
HXDLIN( 588)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 588)										if ((this59 == 0)) {
HXDLIN( 588)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g23;
HXDLIN( 588)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 588)										if ((this60 == 0)) {
HXDLIN( 588)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b24;
HXDLIN( 588)										int this61 = (color4 & 255);
HXDLIN( 588)										if ((this61 == 0)) {
HXDLIN( 588)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 588)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 588)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 588)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 588)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 588)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 588)										{
HXDLIN( 588)											int here14;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here14 = blended3;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this62 = img->image;
HXDLIN( 588)										int index9;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 588)										int here15;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here15 = c8;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x8 = ((img->width - x7) - 1);
HXDLIN( 588)								int y9 = (y7 + 2);
HXDLIN( 588)								int x9 = (this4->width - 1);
HXDLIN( 588)								::Dynamic this63 = this4->image;
HXDLIN( 588)								int index10;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 588)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 588)								int color5;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color5 = c9;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c10 = color5;
HXDLIN( 588)									bool here16;
HXDLIN( 588)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 588)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here16 = false;
            									}
HXDLIN( 588)									if (here16) {
HXDLIN( 588)										int location4;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 588)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 588)										int this65;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this65 = this64;
            										}
HXDLIN( 588)										Float a15;
HXDLIN( 588)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 588)										if ((this66 == 0)) {
HXDLIN( 588)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r14;
HXDLIN( 588)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 588)										if ((this67 == 0)) {
HXDLIN( 588)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g14;
HXDLIN( 588)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 588)										if ((this68 == 0)) {
HXDLIN( 588)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b15;
HXDLIN( 588)										int this69 = (this65 & 255);
HXDLIN( 588)										if ((this69 == 0)) {
HXDLIN( 588)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a24;
HXDLIN( 588)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 588)										if ((this70 == 0)) {
HXDLIN( 588)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r24;
HXDLIN( 588)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 588)										if ((this71 == 0)) {
HXDLIN( 588)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g24;
HXDLIN( 588)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 588)										if ((this72 == 0)) {
HXDLIN( 588)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b25;
HXDLIN( 588)										int this73 = (color5 & 255);
HXDLIN( 588)										if ((this73 == 0)) {
HXDLIN( 588)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 588)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 588)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 588)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 588)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 588)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 588)										{
HXDLIN( 588)											int here17;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here17 = blended4;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this74 = img->image;
HXDLIN( 588)										int index11;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 588)										int here18;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here18 = c10;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g44 = 0;
HXDLIN( 588)				int _g45 = 2;
HXDLIN( 588)				while((_g44 < _g45)){
HXDLIN( 588)					_g44 = (_g44 + 1);
HXDLIN( 588)					int x10 = (_g44 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g46 = 0;
HXDLIN( 588)						int _g47 = 2;
HXDLIN( 588)						while((_g46 < _g47)){
HXDLIN( 588)							_g46 = (_g46 + 1);
HXDLIN( 588)							int y10 = (_g46 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								::Dynamic this75 = this4->image;
HXDLIN( 588)								int index12;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 588)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 588)								int color6;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color6 = c11;
            								}
HXDLIN( 588)								int color7 = color6;
HXDLIN( 588)								{
HXDLIN( 588)									int c12 = color7;
HXDLIN( 588)									bool here19;
HXDLIN( 588)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 588)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here19 = false;
            									}
HXDLIN( 588)									if (here19) {
HXDLIN( 588)										int location5;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 588)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 588)										int this77;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this77 = this76;
            										}
HXDLIN( 588)										Float a16;
HXDLIN( 588)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 588)										if ((this78 == 0)) {
HXDLIN( 588)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r15;
HXDLIN( 588)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 588)										if ((this79 == 0)) {
HXDLIN( 588)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g15;
HXDLIN( 588)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 588)										if ((this80 == 0)) {
HXDLIN( 588)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b16;
HXDLIN( 588)										int this81 = (this77 & 255);
HXDLIN( 588)										if ((this81 == 0)) {
HXDLIN( 588)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a25;
HXDLIN( 588)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 588)										if ((this82 == 0)) {
HXDLIN( 588)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r25;
HXDLIN( 588)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 588)										if ((this83 == 0)) {
HXDLIN( 588)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g25;
HXDLIN( 588)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 588)										if ((this84 == 0)) {
HXDLIN( 588)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b26;
HXDLIN( 588)										int this85 = (color7 & 255);
HXDLIN( 588)										if ((this85 == 0)) {
HXDLIN( 588)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 588)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 588)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 588)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 588)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 588)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 588)										{
HXDLIN( 588)											int here20;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here20 = blended5;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this86 = img->image;
HXDLIN( 588)										int index13;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 588)										int here21;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here21 = c12;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x11 = ((x10 + 2) + this4->width);
HXDLIN( 588)								int x12 = (this4->width - 1);
HXDLIN( 588)								::Dynamic this87 = this4->image;
HXDLIN( 588)								int index14;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 588)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 588)								int color8;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color8 = c13;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c14 = color8;
HXDLIN( 588)									bool here22;
HXDLIN( 588)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 588)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here22 = false;
            									}
HXDLIN( 588)									if (here22) {
HXDLIN( 588)										int location6;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 588)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 588)										int this89;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this89 = this88;
            										}
HXDLIN( 588)										Float a17;
HXDLIN( 588)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 588)										if ((this90 == 0)) {
HXDLIN( 588)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r16;
HXDLIN( 588)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 588)										if ((this91 == 0)) {
HXDLIN( 588)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g16;
HXDLIN( 588)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 588)										if ((this92 == 0)) {
HXDLIN( 588)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b18;
HXDLIN( 588)										int this93 = (this89 & 255);
HXDLIN( 588)										if ((this93 == 0)) {
HXDLIN( 588)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a26;
HXDLIN( 588)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 588)										if ((this94 == 0)) {
HXDLIN( 588)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r26;
HXDLIN( 588)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 588)										if ((this95 == 0)) {
HXDLIN( 588)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g26;
HXDLIN( 588)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 588)										if ((this96 == 0)) {
HXDLIN( 588)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b27;
HXDLIN( 588)										int this97 = (color8 & 255);
HXDLIN( 588)										if ((this97 == 0)) {
HXDLIN( 588)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 588)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 588)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 588)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 588)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 588)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 588)										{
HXDLIN( 588)											int here23;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here23 = blended6;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this98 = img->image;
HXDLIN( 588)										int index15;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 588)										int here24;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here24 = c14;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x13 = ((x10 + 2) + this4->width);
HXDLIN( 588)								int y11 = ((y10 + 2) + this4->height);
HXDLIN( 588)								int x14 = (this4->width - 1);
HXDLIN( 588)								int y12 = (this4->height - 1);
HXDLIN( 588)								::Dynamic this99 = this4->image;
HXDLIN( 588)								int index16;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 588)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 588)								int color9;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color9 = c15;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c16 = color9;
HXDLIN( 588)									bool here25;
HXDLIN( 588)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 588)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here25 = false;
            									}
HXDLIN( 588)									if (here25) {
HXDLIN( 588)										int location7;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 588)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 588)										int this101;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this101 = this100;
            										}
HXDLIN( 588)										Float a18;
HXDLIN( 588)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 588)										if ((this102 == 0)) {
HXDLIN( 588)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r17;
HXDLIN( 588)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 588)										if ((this103 == 0)) {
HXDLIN( 588)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g17;
HXDLIN( 588)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 588)										if ((this104 == 0)) {
HXDLIN( 588)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b110;
HXDLIN( 588)										int this105 = (this101 & 255);
HXDLIN( 588)										if ((this105 == 0)) {
HXDLIN( 588)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a27;
HXDLIN( 588)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 588)										if ((this106 == 0)) {
HXDLIN( 588)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r27;
HXDLIN( 588)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 588)										if ((this107 == 0)) {
HXDLIN( 588)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g27;
HXDLIN( 588)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 588)										if ((this108 == 0)) {
HXDLIN( 588)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b28;
HXDLIN( 588)										int this109 = (color9 & 255);
HXDLIN( 588)										if ((this109 == 0)) {
HXDLIN( 588)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 588)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 588)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 588)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 588)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 588)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 588)										{
HXDLIN( 588)											int here26;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here26 = blended7;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this110 = img->image;
HXDLIN( 588)										int index17;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 588)										int here27;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here27 = c16;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int y13 = ((y10 + 2) + this4->width);
HXDLIN( 588)								int y14 = (this4->height - 1);
HXDLIN( 588)								::Dynamic this111 = this4->image;
HXDLIN( 588)								int index18;
HXDLIN( 588)								if (this4->useVirtualPos) {
HXDLIN( 588)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 588)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 588)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 588)								int color10;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color10 = c17;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c18 = color10;
HXDLIN( 588)									bool here28;
HXDLIN( 588)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 588)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 588)										here28 = false;
            									}
HXDLIN( 588)									if (here28) {
HXDLIN( 588)										int location8;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 588)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 588)										int this113;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this113 = this112;
            										}
HXDLIN( 588)										Float a110;
HXDLIN( 588)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 588)										if ((this114 == 0)) {
HXDLIN( 588)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r18;
HXDLIN( 588)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 588)										if ((this115 == 0)) {
HXDLIN( 588)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g18;
HXDLIN( 588)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 588)										if ((this116 == 0)) {
HXDLIN( 588)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b111;
HXDLIN( 588)										int this117 = (this113 & 255);
HXDLIN( 588)										if ((this117 == 0)) {
HXDLIN( 588)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a28;
HXDLIN( 588)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 588)										if ((this118 == 0)) {
HXDLIN( 588)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r28;
HXDLIN( 588)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 588)										if ((this119 == 0)) {
HXDLIN( 588)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g28;
HXDLIN( 588)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 588)										if ((this120 == 0)) {
HXDLIN( 588)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b29;
HXDLIN( 588)										int this121 = (color10 & 255);
HXDLIN( 588)										if ((this121 == 0)) {
HXDLIN( 588)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 588)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 588)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 588)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 588)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 588)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 588)										{
HXDLIN( 588)											int here29;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here29 = blended8;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this122 = img->image;
HXDLIN( 588)										int index19;
HXDLIN( 588)										if (img->useVirtualPos) {
HXDLIN( 588)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 588)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 588)										int here30;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here30 = c18;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 588)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 588)				int width2 = (this123->width + 4);
HXDLIN( 588)				int height2 = (this123->height + 4);
HXDLIN( 588)				 ::Dynamic imageType2 = null();
HXDLIN( 588)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 588)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 588)				::Dynamic here31;
HXDLIN( 588)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 588)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 588)						{
HXDLIN( 588)							b31->width = width2;
HXDLIN( 588)							b31->height = height2;
HXDLIN( 588)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 588)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 588)							{
HXDLIN( 588)								int len4 = b31->length;
HXDLIN( 588)								int w2 = 0;
HXDLIN( 588)								{
HXDLIN( 588)									int _g48 = 0;
HXDLIN( 588)									int _g49 = b31->height;
HXDLIN( 588)									while((_g48 < _g49)){
HXDLIN( 588)										_g48 = (_g48 + 1);
HXDLIN( 588)										int y15 = (_g48 - 1);
HXDLIN( 588)										{
HXDLIN( 588)											int _g50 = 0;
HXDLIN( 588)											int _g51 = b31->width;
HXDLIN( 588)											while((_g50 < _g51)){
HXDLIN( 588)												_g50 = (_g50 + 1);
HXDLIN( 588)												int x15 = (_g50 - 1);
HXDLIN( 588)												{
HXDLIN( 588)													w2 = (w2 + 1);
HXDLIN( 588)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w2 = (w2 + 1);
HXDLIN( 588)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w2 = (w2 + 1);
HXDLIN( 588)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 588)												{
HXDLIN( 588)													w2 = (w2 + 1);
HXDLIN( 588)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 588)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 588)						{
HXDLIN( 588)							a29->width = width2;
HXDLIN( 588)							a29->height = height2;
HXDLIN( 588)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 588)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 588)							{
HXDLIN( 588)								int _g52 = 0;
HXDLIN( 588)								int _g53 = a29->length;
HXDLIN( 588)								while((_g52 < _g53)){
HXDLIN( 588)									_g52 = (_g52 + 1);
HXDLIN( 588)									int i12 = (_g52 - 1);
HXDLIN( 588)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 588)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 588)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 588)						{
HXDLIN( 588)							b32->width = width2;
HXDLIN( 588)							b32->height = height2;
HXDLIN( 588)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 588)							int size2 = (b32->length * 4);
HXDLIN( 588)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 588)							{
HXDLIN( 588)								int _g54 = 0;
HXDLIN( 588)								int _g55 = b32->length;
HXDLIN( 588)								while((_g54 < _g55)){
HXDLIN( 588)									_g54 = (_g54 + 1);
HXDLIN( 588)									int i13 = (_g54 - 1);
HXDLIN( 588)									{
HXDLIN( 588)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 588)										bool here32;
HXDLIN( 588)										if ((i13 >= 0)) {
HXDLIN( 588)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 588)											here32 = false;
            										}
HXDLIN( 588)										if (here32) {
HXDLIN( 588)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 588)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 588)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 588)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 588)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 588)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 588)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 588)						{
HXDLIN( 588)							v3->width = width2;
HXDLIN( 588)							v3->height = height2;
HXDLIN( 588)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 588)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 588)							{
HXDLIN( 588)								int _g56 = 0;
HXDLIN( 588)								int _g57 = v3->length;
HXDLIN( 588)								while((_g56 < _g57)){
HXDLIN( 588)									_g56 = (_g56 + 1);
HXDLIN( 588)									int i14 = (_g56 - 1);
HXDLIN( 588)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 588)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 588)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 588)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 588)						{
HXDLIN( 588)							b33->width = width2;
HXDLIN( 588)							b33->height = height2;
HXDLIN( 588)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 588)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 588)							{
HXDLIN( 588)								int len5 = b33->length;
HXDLIN( 588)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 588)								if (::hx::IsNull( d2->head )) {
HXDLIN( 588)									int _g58 = 0;
HXDLIN( 588)									int _g59 = len5;
HXDLIN( 588)									while((_g58 < _g59)){
HXDLIN( 588)										_g58 = (_g58 + 1);
HXDLIN( 588)										int i15 = (_g58 - 1);
HXDLIN( 588)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 588)									int _g60 = 0;
HXDLIN( 588)									int _g61 = len5;
HXDLIN( 588)									while((_g60 < _g61)){
HXDLIN( 588)										_g60 = (_g60 + 1);
HXDLIN( 588)										int i16 = (_g60 - 1);
HXDLIN( 588)										{
HXDLIN( 588)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 588)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 588)											{
HXDLIN( 588)												int _g62 = 0;
HXDLIN( 588)												int _g63 = i16;
HXDLIN( 588)												while((_g62 < _g63)){
HXDLIN( 588)													_g62 = (_g62 + 1);
HXDLIN( 588)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 588)											if (::hx::IsNull( prev2 )) {
HXDLIN( 588)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 588)												l2 = null();
            											}
            											else {
HXDLIN( 588)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 588)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 588)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 588)				this124->image = here31;
HXDLIN( 588)				this124->width = width2;
HXDLIN( 588)				this124->height = height2;
HXDLIN( 588)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 588)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 588)				bool forceClear1 = false;
HXDLIN( 588)				int _g64 = 0;
HXDLIN( 588)				int _g65 = this123->height;
HXDLIN( 588)				while((_g64 < _g65)){
HXDLIN( 588)					_g64 = (_g64 + 1);
HXDLIN( 588)					int dy1 = (_g64 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g66 = 0;
HXDLIN( 588)						int _g67 = this123->width;
HXDLIN( 588)						while((_g66 < _g67)){
HXDLIN( 588)							_g66 = (_g66 + 1);
HXDLIN( 588)							int dx1 = (_g66 - 1);
HXDLIN( 588)							::Dynamic this126 = this123->image;
HXDLIN( 588)							int index20;
HXDLIN( 588)							if (this123->useVirtualPos) {
HXDLIN( 588)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 588)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 588)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 588)							int col1;
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								col1 = c19;
            							}
HXDLIN( 588)							bool here33;
HXDLIN( 588)							if (this123->useMask) {
HXDLIN( 588)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 588)								here33 = false;
            							}
HXDLIN( 588)							if (here33) {
HXDLIN( 588)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 588)								::Dynamic this128 = this127->image;
HXDLIN( 588)								int index21;
HXDLIN( 588)								if (this127->useVirtualPos) {
HXDLIN( 588)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 588)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 588)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 588)								int v4;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									v4 = c20;
            								}
HXDLIN( 588)								int maskPixel1 = v4;
HXDLIN( 588)								int this129 = col1;
HXDLIN( 588)								if ((maskPixel1 == 0)) {
HXDLIN( 588)									col1 = this129;
            								}
            								else {
HXDLIN( 588)									Float m02;
HXDLIN( 588)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 588)									if ((this130 == 0)) {
HXDLIN( 588)										m02 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m02 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m11;
HXDLIN( 588)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 588)									if ((this131 == 0)) {
HXDLIN( 588)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m21;
HXDLIN( 588)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 588)									if ((this132 == 0)) {
HXDLIN( 588)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float m31;
HXDLIN( 588)									int this133 = (maskPixel1 & 255);
HXDLIN( 588)									if ((this133 == 0)) {
HXDLIN( 588)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 588)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 588)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 588)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 588)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 588)							if ((col1 != 0)) {
HXDLIN( 588)								int x16 = (2 + dx1);
HXDLIN( 588)								int y16 = (2 + dy1);
HXDLIN( 588)								int c21 = col1;
HXDLIN( 588)								bool here34;
HXDLIN( 588)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 588)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 588)									here34 = false;
            								}
HXDLIN( 588)								if (here34) {
HXDLIN( 588)									int location9;
HXDLIN( 588)									if (img1->useVirtualPos) {
HXDLIN( 588)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 588)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 588)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 588)									int this135;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										this135 = this134;
            									}
HXDLIN( 588)									Float a111;
HXDLIN( 588)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 588)									if ((this136 == 0)) {
HXDLIN( 588)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r19;
HXDLIN( 588)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 588)									if ((this137 == 0)) {
HXDLIN( 588)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g19;
HXDLIN( 588)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 588)									if ((this138 == 0)) {
HXDLIN( 588)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b112;
HXDLIN( 588)									int this139 = (this135 & 255);
HXDLIN( 588)									if ((this139 == 0)) {
HXDLIN( 588)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a210;
HXDLIN( 588)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 588)									if ((this140 == 0)) {
HXDLIN( 588)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r29;
HXDLIN( 588)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 588)									if ((this141 == 0)) {
HXDLIN( 588)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g29;
HXDLIN( 588)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 588)									if ((this142 == 0)) {
HXDLIN( 588)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b210;
HXDLIN( 588)									int this143 = (col1 & 255);
HXDLIN( 588)									if ((this143 == 0)) {
HXDLIN( 588)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 588)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 588)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 588)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 588)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 588)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 588)									{
HXDLIN( 588)										int here35;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here35 = blended9;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 588)									::Dynamic this144 = img1->image;
HXDLIN( 588)									int index22;
HXDLIN( 588)									if (img1->useVirtualPos) {
HXDLIN( 588)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 588)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 588)									int here36;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										here36 = c21;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 588)								if (forceClear1) {
HXDLIN( 588)									::Dynamic this145 = img1->image;
HXDLIN( 588)									int x17 = (2 + dx1);
HXDLIN( 588)									int y17 = (2 + dy1);
HXDLIN( 588)									int index23;
HXDLIN( 588)									if (img1->useVirtualPos) {
HXDLIN( 588)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 588)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g68 = 0;
HXDLIN( 588)				int _g69 = this123->width;
HXDLIN( 588)				while((_g68 < _g69)){
HXDLIN( 588)					_g68 = (_g68 + 1);
HXDLIN( 588)					int x18 = (_g68 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g70 = 0;
HXDLIN( 588)						int _g71 = 2;
HXDLIN( 588)						while((_g70 < _g71)){
HXDLIN( 588)							_g70 = (_g70 + 1);
HXDLIN( 588)							int y18 = (_g70 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								int x19 = (x18 + 2);
HXDLIN( 588)								int y19 = (((this123->height - 1) - 2) + y18);
HXDLIN( 588)								::Dynamic this146 = this123->image;
HXDLIN( 588)								int index24;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 588)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 588)								int color11;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color11 = c22;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c23 = color11;
HXDLIN( 588)									bool here37;
HXDLIN( 588)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 588)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here37 = false;
            									}
HXDLIN( 588)									if (here37) {
HXDLIN( 588)										int location10;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 588)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 588)										int this148;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this148 = this147;
            										}
HXDLIN( 588)										Float a112;
HXDLIN( 588)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 588)										if ((this149 == 0)) {
HXDLIN( 588)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r110;
HXDLIN( 588)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 588)										if ((this150 == 0)) {
HXDLIN( 588)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g110;
HXDLIN( 588)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 588)										if ((this151 == 0)) {
HXDLIN( 588)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b113;
HXDLIN( 588)										int this152 = (this148 & 255);
HXDLIN( 588)										if ((this152 == 0)) {
HXDLIN( 588)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a211;
HXDLIN( 588)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 588)										if ((this153 == 0)) {
HXDLIN( 588)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r210;
HXDLIN( 588)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 588)										if ((this154 == 0)) {
HXDLIN( 588)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g210;
HXDLIN( 588)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 588)										if ((this155 == 0)) {
HXDLIN( 588)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b211;
HXDLIN( 588)										int this156 = (color11 & 255);
HXDLIN( 588)										if ((this156 == 0)) {
HXDLIN( 588)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 588)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 588)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 588)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 588)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 588)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 588)										{
HXDLIN( 588)											int here38;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here38 = blended10;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this157 = img1->image;
HXDLIN( 588)										int index25;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 588)										int here39;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here39 = c23;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x20 = (x18 + 2);
HXDLIN( 588)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 588)								int y21 = (2 - y18);
HXDLIN( 588)								::Dynamic this158 = this123->image;
HXDLIN( 588)								int index26;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 588)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 588)								int color12;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color12 = c24;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c25 = color12;
HXDLIN( 588)									bool here40;
HXDLIN( 588)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 588)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here40 = false;
            									}
HXDLIN( 588)									if (here40) {
HXDLIN( 588)										int location11;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 588)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 588)										int this160;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this160 = this159;
            										}
HXDLIN( 588)										Float a113;
HXDLIN( 588)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 588)										if ((this161 == 0)) {
HXDLIN( 588)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r111;
HXDLIN( 588)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 588)										if ((this162 == 0)) {
HXDLIN( 588)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g111;
HXDLIN( 588)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 588)										if ((this163 == 0)) {
HXDLIN( 588)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b114;
HXDLIN( 588)										int this164 = (this160 & 255);
HXDLIN( 588)										if ((this164 == 0)) {
HXDLIN( 588)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a212;
HXDLIN( 588)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 588)										if ((this165 == 0)) {
HXDLIN( 588)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r211;
HXDLIN( 588)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 588)										if ((this166 == 0)) {
HXDLIN( 588)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g211;
HXDLIN( 588)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 588)										if ((this167 == 0)) {
HXDLIN( 588)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b212;
HXDLIN( 588)										int this168 = (color12 & 255);
HXDLIN( 588)										if ((this168 == 0)) {
HXDLIN( 588)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 588)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 588)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 588)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 588)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 588)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 588)										{
HXDLIN( 588)											int here41;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here41 = blended11;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this169 = img1->image;
HXDLIN( 588)										int index27;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 588)										int here42;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here42 = c25;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g72 = 0;
HXDLIN( 588)				int _g73 = this123->height;
HXDLIN( 588)				while((_g72 < _g73)){
HXDLIN( 588)					_g72 = (_g72 + 1);
HXDLIN( 588)					int y22 = (_g72 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g74 = 0;
HXDLIN( 588)						int _g75 = 2;
HXDLIN( 588)						while((_g74 < _g75)){
HXDLIN( 588)							_g74 = (_g74 + 1);
HXDLIN( 588)							int x21 = (_g74 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								int y23 = (y22 + 2);
HXDLIN( 588)								int x22 = (((this123->width - 1) - 2) + x21);
HXDLIN( 588)								::Dynamic this170 = this123->image;
HXDLIN( 588)								int index28;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 588)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 588)								int color13;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color13 = c26;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c27 = color13;
HXDLIN( 588)									bool here43;
HXDLIN( 588)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 588)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here43 = false;
            									}
HXDLIN( 588)									if (here43) {
HXDLIN( 588)										int location12;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 588)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 588)										int this172;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this172 = this171;
            										}
HXDLIN( 588)										Float a114;
HXDLIN( 588)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 588)										if ((this173 == 0)) {
HXDLIN( 588)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r112;
HXDLIN( 588)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 588)										if ((this174 == 0)) {
HXDLIN( 588)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g112;
HXDLIN( 588)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 588)										if ((this175 == 0)) {
HXDLIN( 588)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b115;
HXDLIN( 588)										int this176 = (this172 & 255);
HXDLIN( 588)										if ((this176 == 0)) {
HXDLIN( 588)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a213;
HXDLIN( 588)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 588)										if ((this177 == 0)) {
HXDLIN( 588)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r212;
HXDLIN( 588)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 588)										if ((this178 == 0)) {
HXDLIN( 588)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g212;
HXDLIN( 588)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 588)										if ((this179 == 0)) {
HXDLIN( 588)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b213;
HXDLIN( 588)										int this180 = (color13 & 255);
HXDLIN( 588)										if ((this180 == 0)) {
HXDLIN( 588)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 588)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 588)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 588)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 588)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 588)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 588)										{
HXDLIN( 588)											int here44;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here44 = blended12;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this181 = img1->image;
HXDLIN( 588)										int index29;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 588)										int here45;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here45 = c27;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 588)								int y24 = (y22 + 2);
HXDLIN( 588)								int x24 = (2 - x21);
HXDLIN( 588)								::Dynamic this182 = this123->image;
HXDLIN( 588)								int index30;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 588)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 588)								int color14;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color14 = c28;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c29 = color14;
HXDLIN( 588)									bool here46;
HXDLIN( 588)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 588)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here46 = false;
            									}
HXDLIN( 588)									if (here46) {
HXDLIN( 588)										int location13;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 588)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 588)										int this184;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this184 = this183;
            										}
HXDLIN( 588)										Float a115;
HXDLIN( 588)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 588)										if ((this185 == 0)) {
HXDLIN( 588)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r113;
HXDLIN( 588)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 588)										if ((this186 == 0)) {
HXDLIN( 588)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g113;
HXDLIN( 588)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 588)										if ((this187 == 0)) {
HXDLIN( 588)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b116;
HXDLIN( 588)										int this188 = (this184 & 255);
HXDLIN( 588)										if ((this188 == 0)) {
HXDLIN( 588)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a214;
HXDLIN( 588)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 588)										if ((this189 == 0)) {
HXDLIN( 588)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r213;
HXDLIN( 588)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 588)										if ((this190 == 0)) {
HXDLIN( 588)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g213;
HXDLIN( 588)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 588)										if ((this191 == 0)) {
HXDLIN( 588)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b214;
HXDLIN( 588)										int this192 = (color14 & 255);
HXDLIN( 588)										if ((this192 == 0)) {
HXDLIN( 588)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 588)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 588)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 588)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 588)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 588)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 588)										{
HXDLIN( 588)											int here47;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here47 = blended13;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this193 = img1->image;
HXDLIN( 588)										int index31;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 588)										int here48;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here48 = c29;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				int _g76 = 0;
HXDLIN( 588)				int _g77 = 2;
HXDLIN( 588)				while((_g76 < _g77)){
HXDLIN( 588)					_g76 = (_g76 + 1);
HXDLIN( 588)					int x25 = (_g76 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						int _g78 = 0;
HXDLIN( 588)						int _g79 = 2;
HXDLIN( 588)						while((_g78 < _g79)){
HXDLIN( 588)							_g78 = (_g78 + 1);
HXDLIN( 588)							int y25 = (_g78 - 1);
HXDLIN( 588)							{
HXDLIN( 588)								int x26 = (((this123->width - 1) - 2) + x25);
HXDLIN( 588)								int y26 = (((this123->height - 1) - 2) + y25);
HXDLIN( 588)								::Dynamic this194 = this123->image;
HXDLIN( 588)								int index32;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 588)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 588)								int color15;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color15 = c30;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c31 = color15;
HXDLIN( 588)									bool here49;
HXDLIN( 588)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 588)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here49 = false;
            									}
HXDLIN( 588)									if (here49) {
HXDLIN( 588)										int location14;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 588)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 588)										int this196;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this196 = this195;
            										}
HXDLIN( 588)										Float a116;
HXDLIN( 588)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 588)										if ((this197 == 0)) {
HXDLIN( 588)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r114;
HXDLIN( 588)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 588)										if ((this198 == 0)) {
HXDLIN( 588)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g114;
HXDLIN( 588)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 588)										if ((this199 == 0)) {
HXDLIN( 588)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b117;
HXDLIN( 588)										int this200 = (this196 & 255);
HXDLIN( 588)										if ((this200 == 0)) {
HXDLIN( 588)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a215;
HXDLIN( 588)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 588)										if ((this201 == 0)) {
HXDLIN( 588)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r214;
HXDLIN( 588)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 588)										if ((this202 == 0)) {
HXDLIN( 588)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g214;
HXDLIN( 588)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 588)										if ((this203 == 0)) {
HXDLIN( 588)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b215;
HXDLIN( 588)										int this204 = (color15 & 255);
HXDLIN( 588)										if ((this204 == 0)) {
HXDLIN( 588)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 588)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 588)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 588)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 588)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 588)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 588)										{
HXDLIN( 588)											int here50;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here50 = blended14;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this205 = img1->image;
HXDLIN( 588)										int index33;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 588)										int here51;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here51 = c31;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x27 = ((x25 + 2) + this123->width);
HXDLIN( 588)								int y27 = (((this123->height - 1) - 2) + y25);
HXDLIN( 588)								::Dynamic this206 = this123->image;
HXDLIN( 588)								int index34;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 588)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 588)								int color16;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color16 = c32;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c33 = color16;
HXDLIN( 588)									bool here52;
HXDLIN( 588)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 588)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here52 = false;
            									}
HXDLIN( 588)									if (here52) {
HXDLIN( 588)										int location15;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 588)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 588)										int this208;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this208 = this207;
            										}
HXDLIN( 588)										Float a117;
HXDLIN( 588)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 588)										if ((this209 == 0)) {
HXDLIN( 588)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r115;
HXDLIN( 588)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 588)										if ((this210 == 0)) {
HXDLIN( 588)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g115;
HXDLIN( 588)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 588)										if ((this211 == 0)) {
HXDLIN( 588)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b118;
HXDLIN( 588)										int this212 = (this208 & 255);
HXDLIN( 588)										if ((this212 == 0)) {
HXDLIN( 588)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a216;
HXDLIN( 588)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 588)										if ((this213 == 0)) {
HXDLIN( 588)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r215;
HXDLIN( 588)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 588)										if ((this214 == 0)) {
HXDLIN( 588)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g215;
HXDLIN( 588)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 588)										if ((this215 == 0)) {
HXDLIN( 588)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b216;
HXDLIN( 588)										int this216 = (color16 & 255);
HXDLIN( 588)										if ((this216 == 0)) {
HXDLIN( 588)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 588)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 588)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 588)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 588)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 588)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 588)										{
HXDLIN( 588)											int here53;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here53 = blended15;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this217 = img1->image;
HXDLIN( 588)										int index35;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 588)										int here54;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here54 = c33;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int x28 = ((x25 + 2) + this123->width);
HXDLIN( 588)								int y28 = ((y25 + 2) + this123->height);
HXDLIN( 588)								::Dynamic this218 = this123->image;
HXDLIN( 588)								int index36;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 588)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 588)								int color17;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color17 = c34;
            								}
HXDLIN( 588)								int color18 = color17;
HXDLIN( 588)								{
HXDLIN( 588)									int c35 = color18;
HXDLIN( 588)									bool here55;
HXDLIN( 588)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 588)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here55 = false;
            									}
HXDLIN( 588)									if (here55) {
HXDLIN( 588)										int location16;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 588)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 588)										int this220;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this220 = this219;
            										}
HXDLIN( 588)										Float a118;
HXDLIN( 588)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 588)										if ((this221 == 0)) {
HXDLIN( 588)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r116;
HXDLIN( 588)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 588)										if ((this222 == 0)) {
HXDLIN( 588)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g116;
HXDLIN( 588)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 588)										if ((this223 == 0)) {
HXDLIN( 588)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b119;
HXDLIN( 588)										int this224 = (this220 & 255);
HXDLIN( 588)										if ((this224 == 0)) {
HXDLIN( 588)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a217;
HXDLIN( 588)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 588)										if ((this225 == 0)) {
HXDLIN( 588)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r216;
HXDLIN( 588)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 588)										if ((this226 == 0)) {
HXDLIN( 588)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g216;
HXDLIN( 588)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 588)										if ((this227 == 0)) {
HXDLIN( 588)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b217;
HXDLIN( 588)										int this228 = (color18 & 255);
HXDLIN( 588)										if ((this228 == 0)) {
HXDLIN( 588)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 588)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 588)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 588)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 588)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 588)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 588)										{
HXDLIN( 588)											int here56;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here56 = blended16;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this229 = img1->image;
HXDLIN( 588)										int index37;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 588)										int here57;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here57 = c35;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 588)							{
HXDLIN( 588)								int y29 = ((y25 + 2) + this123->width);
HXDLIN( 588)								int x29 = (((this123->width - 1) - 2) + x25);
HXDLIN( 588)								::Dynamic this230 = this123->image;
HXDLIN( 588)								int index38;
HXDLIN( 588)								if (this123->useVirtualPos) {
HXDLIN( 588)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 588)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 588)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 588)								int color19;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									color19 = c36;
            								}
HXDLIN( 588)								{
HXDLIN( 588)									int c37 = color19;
HXDLIN( 588)									bool here58;
HXDLIN( 588)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 588)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 588)										here58 = false;
            									}
HXDLIN( 588)									if (here58) {
HXDLIN( 588)										int location17;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 588)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 588)										int this232;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											this232 = this231;
            										}
HXDLIN( 588)										Float a119;
HXDLIN( 588)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 588)										if ((this233 == 0)) {
HXDLIN( 588)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r117;
HXDLIN( 588)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 588)										if ((this234 == 0)) {
HXDLIN( 588)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g117;
HXDLIN( 588)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 588)										if ((this235 == 0)) {
HXDLIN( 588)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b120;
HXDLIN( 588)										int this236 = (this232 & 255);
HXDLIN( 588)										if ((this236 == 0)) {
HXDLIN( 588)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a218;
HXDLIN( 588)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 588)										if ((this237 == 0)) {
HXDLIN( 588)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float r217;
HXDLIN( 588)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 588)										if ((this238 == 0)) {
HXDLIN( 588)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float g217;
HXDLIN( 588)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 588)										if ((this239 == 0)) {
HXDLIN( 588)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float b218;
HXDLIN( 588)										int this240 = (color19 & 255);
HXDLIN( 588)										if ((this240 == 0)) {
HXDLIN( 588)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 588)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 588)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 588)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 588)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 588)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 588)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 588)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 588)										{
HXDLIN( 588)											int here59;
HXDLIN( 588)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 588)												here59 = blended17;
            											}
HXDLIN( 588)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 588)										::Dynamic this241 = img1->image;
HXDLIN( 588)										int index39;
HXDLIN( 588)										if (img1->useVirtualPos) {
HXDLIN( 588)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 588)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 588)										int here60;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											here60 = c37;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 588)				here = img1;
            			}
            			break;
            		}
HXDLIN( 588)		{
HXDLIN( 588)			int _g80 = 2;
HXDLIN( 588)			int _g81 = (this1->height - 3);
HXDLIN( 588)			while((_g80 < _g81)){
HXDLIN( 588)				_g80 = (_g80 + 1);
HXDLIN( 588)				int y30 = (_g80 - 1);
HXDLIN( 588)				{
HXDLIN( 588)					int _g82 = 2;
HXDLIN( 588)					int _g83 = (this1->width - 3);
HXDLIN( 588)					while((_g82 < _g83)){
HXDLIN( 588)						_g82 = (_g82 + 1);
HXDLIN( 588)						int x30 = (_g82 - 1);
HXDLIN( 588)						if ((x30 == 2)) {
HXDLIN( 588)							int x31 = (x30 - 2);
HXDLIN( 588)							int y31 = (y30 - 2);
HXDLIN( 588)							::Dynamic this242 = here->image;
HXDLIN( 588)							int index40;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 588)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								a0 = c38;
            							}
HXDLIN( 588)							int x32 = (x30 - 1);
HXDLIN( 588)							int y32 = (y30 - 2);
HXDLIN( 588)							::Dynamic this243 = here->image;
HXDLIN( 588)							int index41;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x32)) ));
            							}
HXDLIN( 588)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								b0 = c39;
            							}
HXDLIN( 588)							int y33 = (y30 - 2);
HXDLIN( 588)							::Dynamic this244 = here->image;
HXDLIN( 588)							int index42;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x30)) ));
            							}
HXDLIN( 588)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								c0 = c40;
            							}
HXDLIN( 588)							int x33 = (x30 + 1);
HXDLIN( 588)							int y34 = (y30 - 2);
HXDLIN( 588)							::Dynamic this245 = here->image;
HXDLIN( 588)							int index43;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index43 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index43 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x33)) ));
            							}
HXDLIN( 588)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								d0 = c41;
            							}
HXDLIN( 588)							int x34 = (x30 + 2);
HXDLIN( 588)							int y35 = (y30 - 2);
HXDLIN( 588)							::Dynamic this246 = here->image;
HXDLIN( 588)							int index44;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index44 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index44 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x34)) ));
            							}
HXDLIN( 588)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								e0 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								e0 = c42;
            							}
HXDLIN( 588)							int x35 = (x30 - 2);
HXDLIN( 588)							int y36 = (y30 - 1);
HXDLIN( 588)							::Dynamic this247 = here->image;
HXDLIN( 588)							int index45;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index45 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index45 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x35)) ));
            							}
HXDLIN( 588)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								f0 = c43;
            							}
HXDLIN( 588)							int x36 = (x30 - 1);
HXDLIN( 588)							int y37 = (y30 - 1);
HXDLIN( 588)							::Dynamic this248 = here->image;
HXDLIN( 588)							int index46;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index46 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index46 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x36)) ));
            							}
HXDLIN( 588)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								g0 = c44;
            							}
HXDLIN( 588)							int y38 = (y30 - 1);
HXDLIN( 588)							::Dynamic this249 = here->image;
HXDLIN( 588)							int index47;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index47 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index47 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x30)) ));
            							}
HXDLIN( 588)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								h0 = c45;
            							}
HXDLIN( 588)							int x37 = (x30 + 1);
HXDLIN( 588)							int y39 = (y30 - 1);
HXDLIN( 588)							::Dynamic this250 = here->image;
HXDLIN( 588)							int index48;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index48 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index48 = ::Std_obj::_hx_int(( (Float)(((y39 * here->width) + x37)) ));
            							}
HXDLIN( 588)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								i0 = c46;
            							}
HXDLIN( 588)							int x38 = (x30 + 2);
HXDLIN( 588)							int y40 = (y30 - 1);
HXDLIN( 588)							::Dynamic this251 = here->image;
HXDLIN( 588)							int index49;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index49 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index49 = ::Std_obj::_hx_int(( (Float)(((y40 * here->width) + x38)) ));
            							}
HXDLIN( 588)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								j0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								j0 = c47;
            							}
HXDLIN( 588)							int x39 = (x30 - 2);
HXDLIN( 588)							::Dynamic this252 = here->image;
HXDLIN( 588)							int index50;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x39)) ));
            							}
HXDLIN( 588)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								k0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								k0 = c48;
            							}
HXDLIN( 588)							int x40 = (x30 - 1);
HXDLIN( 588)							::Dynamic this253 = here->image;
HXDLIN( 588)							int index51;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index51 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x40) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index51 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x40)) ));
            							}
HXDLIN( 588)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								l0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								l0 = c49;
            							}
HXDLIN( 588)							::Dynamic this254 = here->image;
HXDLIN( 588)							int index52;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index52 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index52 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 588)							int c50 = ::iterMagic::Iimg_obj::get(this254,index52);
HXDLIN( 588)							int m03;
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								m03 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								m03 = c50;
            							}
HXLINE( 336)							m0 = m03;
HXLINE( 588)							int x41 = (x30 + 1);
HXDLIN( 588)							::Dynamic this255 = here->image;
HXDLIN( 588)							int index53;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index53 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x41)) ));
            							}
HXDLIN( 588)							int c51 = ::iterMagic::Iimg_obj::get(this255,index53);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								n0 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								n0 = c51;
            							}
HXDLIN( 588)							int x42 = (x30 + 2);
HXDLIN( 588)							::Dynamic this256 = here->image;
HXDLIN( 588)							int index54;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index54 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index54 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x42)) ));
            							}
HXDLIN( 588)							int c52 = ::iterMagic::Iimg_obj::get(this256,index54);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								o0 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								o0 = c52;
            							}
HXDLIN( 588)							int x43 = (x30 - 2);
HXDLIN( 588)							int y41 = (y30 + 1);
HXDLIN( 588)							::Dynamic this257 = here->image;
HXDLIN( 588)							int index55;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index55 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index55 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x43)) ));
            							}
HXDLIN( 588)							int c53 = ::iterMagic::Iimg_obj::get(this257,index55);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								p0 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								p0 = c53;
            							}
HXDLIN( 588)							int x44 = (x30 - 1);
HXDLIN( 588)							int y42 = (y30 + 1);
HXDLIN( 588)							::Dynamic this258 = here->image;
HXDLIN( 588)							int index56;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index56 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x44) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index56 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x44)) ));
            							}
HXDLIN( 588)							int c54 = ::iterMagic::Iimg_obj::get(this258,index56);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								q0 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								q0 = c54;
            							}
HXDLIN( 588)							int y43 = (y30 + 1);
HXDLIN( 588)							::Dynamic this259 = here->image;
HXDLIN( 588)							int index57;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index57 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index57 = ::Std_obj::_hx_int(( (Float)(((y43 * here->width) + x30)) ));
            							}
HXDLIN( 588)							int c55 = ::iterMagic::Iimg_obj::get(this259,index57);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								r0 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								r0 = c55;
            							}
HXDLIN( 588)							int x45 = (x30 + 1);
HXDLIN( 588)							int y44 = (y30 + 1);
HXDLIN( 588)							::Dynamic this260 = here->image;
HXDLIN( 588)							int index58;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index58 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - here->virtualY) * ( (Float)(here->width) )) + x45) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index58 = ::Std_obj::_hx_int(( (Float)(((y44 * here->width) + x45)) ));
            							}
HXDLIN( 588)							int c56 = ::iterMagic::Iimg_obj::get(this260,index58);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								s0 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								s0 = c56;
            							}
HXDLIN( 588)							int x46 = (x30 + 2);
HXDLIN( 588)							int y45 = (y30 + 1);
HXDLIN( 588)							::Dynamic this261 = here->image;
HXDLIN( 588)							int index59;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index59 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - here->virtualY) * ( (Float)(here->width) )) + x46) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index59 = ::Std_obj::_hx_int(( (Float)(((y45 * here->width) + x46)) ));
            							}
HXDLIN( 588)							int c57 = ::iterMagic::Iimg_obj::get(this261,index59);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								t0 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								t0 = c57;
            							}
HXDLIN( 588)							int x47 = (x30 - 2);
HXDLIN( 588)							int y46 = (y30 + 2);
HXDLIN( 588)							::Dynamic this262 = here->image;
HXDLIN( 588)							int index60;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index60 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - here->virtualY) * ( (Float)(here->width) )) + x47) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index60 = ::Std_obj::_hx_int(( (Float)(((y46 * here->width) + x47)) ));
            							}
HXDLIN( 588)							int c58 = ::iterMagic::Iimg_obj::get(this262,index60);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								u0 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								u0 = c58;
            							}
HXDLIN( 588)							int x48 = (x30 - 1);
HXDLIN( 588)							int y47 = (y30 + 2);
HXDLIN( 588)							::Dynamic this263 = here->image;
HXDLIN( 588)							int index61;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index61 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - here->virtualY) * ( (Float)(here->width) )) + x48) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index61 = ::Std_obj::_hx_int(( (Float)(((y47 * here->width) + x48)) ));
            							}
HXDLIN( 588)							int c59 = ::iterMagic::Iimg_obj::get(this263,index61);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								v0 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								v0 = c59;
            							}
HXDLIN( 588)							int y48 = (y30 + 2);
HXDLIN( 588)							::Dynamic this264 = here->image;
HXDLIN( 588)							int index62;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index62 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index62 = ::Std_obj::_hx_int(( (Float)(((y48 * here->width) + x30)) ));
            							}
HXDLIN( 588)							int c60 = ::iterMagic::Iimg_obj::get(this264,index62);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								w0 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								w0 = c60;
            							}
HXDLIN( 588)							int x49 = (x30 + 1);
HXDLIN( 588)							int y49 = (y30 + 2);
HXDLIN( 588)							::Dynamic this265 = here->image;
HXDLIN( 588)							int index63;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index63 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - here->virtualY) * ( (Float)(here->width) )) + x49) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index63 = ::Std_obj::_hx_int(( (Float)(((y49 * here->width) + x49)) ));
            							}
HXDLIN( 588)							int c61 = ::iterMagic::Iimg_obj::get(this265,index63);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								x0 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								x0 = c61;
            							}
HXDLIN( 588)							int x50 = (x30 + 2);
HXDLIN( 588)							int y50 = (y30 + 2);
HXDLIN( 588)							::Dynamic this266 = here->image;
HXDLIN( 588)							int index64;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index64 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - here->virtualY) * ( (Float)(here->width) )) + x50) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index64 = ::Std_obj::_hx_int(( (Float)(((y50 * here->width) + x50)) ));
            							}
HXDLIN( 588)							int c62 = ::iterMagic::Iimg_obj::get(this266,index64);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								y0 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								y0 = c62;
            							}
            						}
            						else {
HXLINE( 353)							a0 = b0;
HXLINE( 354)							b0 = c0;
HXLINE( 355)							c0 = d0;
HXLINE( 356)							d0 = e0;
HXLINE( 588)							int x51 = (x30 + 1);
HXDLIN( 588)							int y51 = (y30 - 2);
HXDLIN( 588)							::Dynamic this267 = here->image;
HXDLIN( 588)							int index65;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index65 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - here->virtualY) * ( (Float)(here->width) )) + x51) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index65 = ::Std_obj::_hx_int(( (Float)(((y51 * here->width) + x51)) ));
            							}
HXDLIN( 588)							int c63 = ::iterMagic::Iimg_obj::get(this267,index65);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								e0 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								e0 = c63;
            							}
HXLINE( 359)							f0 = g0;
HXLINE( 360)							g0 = h0;
HXLINE( 361)							h0 = i0;
HXLINE( 362)							i0 = h0;
HXLINE( 588)							int x52 = (x30 + 1);
HXDLIN( 588)							int y52 = (y30 - 1);
HXDLIN( 588)							::Dynamic this268 = here->image;
HXDLIN( 588)							int index66;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index66 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - here->virtualY) * ( (Float)(here->width) )) + x52) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index66 = ::Std_obj::_hx_int(( (Float)(((y52 * here->width) + x52)) ));
            							}
HXDLIN( 588)							int c64 = ::iterMagic::Iimg_obj::get(this268,index66);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								j0 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								j0 = c64;
            							}
HXLINE( 365)							k0 = l0;
HXLINE( 366)							l0 = m0;
HXLINE( 367)							m0 = n0;
HXLINE( 368)							n0 = o0;
HXLINE( 588)							int x53 = (x30 + 1);
HXDLIN( 588)							::Dynamic this269 = here->image;
HXDLIN( 588)							int index67;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index67 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x53) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index67 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x53)) ));
            							}
HXDLIN( 588)							int c65 = ::iterMagic::Iimg_obj::get(this269,index67);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								o0 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								o0 = c65;
            							}
HXLINE( 371)							p0 = q0;
HXLINE( 372)							q0 = r0;
HXLINE( 373)							r0 = s0;
HXLINE( 374)							s0 = t0;
HXLINE( 588)							int x54 = (x30 + 1);
HXDLIN( 588)							int y53 = (y30 + 1);
HXDLIN( 588)							::Dynamic this270 = here->image;
HXDLIN( 588)							int index68;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index68 = ::Std_obj::_hx_int(((((( (Float)(y53) ) - here->virtualY) * ( (Float)(here->width) )) + x54) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index68 = ::Std_obj::_hx_int(( (Float)(((y53 * here->width) + x54)) ));
            							}
HXDLIN( 588)							int c66 = ::iterMagic::Iimg_obj::get(this270,index68);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								t0 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								t0 = c66;
            							}
HXLINE( 377)							u0 = v0;
HXLINE( 378)							v0 = w0;
HXLINE( 379)							w0 = x0;
HXLINE( 380)							x0 = v0;
HXLINE( 588)							int x55 = (x30 + 1);
HXDLIN( 588)							int y54 = (y30 + 2);
HXDLIN( 588)							::Dynamic this271 = here->image;
HXDLIN( 588)							int index69;
HXDLIN( 588)							if (here->useVirtualPos) {
HXDLIN( 588)								index69 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - here->virtualY) * ( (Float)(here->width) )) + x55) - here->virtualX));
            							}
            							else {
HXDLIN( 588)								index69 = ::Std_obj::_hx_int(( (Float)(((y54 * here->width) + x55)) ));
            							}
HXDLIN( 588)							int c67 = ::iterMagic::Iimg_obj::get(this271,index69);
HXDLIN( 588)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)								v0 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            							}
            							else {
HXDLIN( 588)								v0 = c67;
            							}
            						}
HXDLIN( 588)						if (adjustRed) {
HXLINE( 384)							r_ = ((Float)0.);
HXLINE( 588)							bool _hx_tmp2;
HXDLIN( 588)							if ((m55_a != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp2 = false;
            							}
HXDLIN( 588)							if (_hx_tmp2) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 588)							bool _hx_tmp3;
HXDLIN( 588)							if ((m55_b != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp3 = false;
            							}
HXDLIN( 588)							if (_hx_tmp3) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 588)							bool _hx_tmp4;
HXDLIN( 588)							if ((m55_c != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp4 = false;
            							}
HXDLIN( 588)							if (_hx_tmp4) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 588)							bool _hx_tmp5;
HXDLIN( 588)							if ((m55_d != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp5 = false;
            							}
HXDLIN( 588)							if (_hx_tmp5) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 588)							bool _hx_tmp6;
HXDLIN( 588)							if ((m55_e != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp6 = false;
            							}
HXDLIN( 588)							if (_hx_tmp6) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 588)							bool _hx_tmp7;
HXDLIN( 588)							if ((m55_f != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp7 = false;
            							}
HXDLIN( 588)							if (_hx_tmp7) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 588)							bool _hx_tmp8;
HXDLIN( 588)							if ((m55_g != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp8 = false;
            							}
HXDLIN( 588)							if (_hx_tmp8) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 588)							bool _hx_tmp9;
HXDLIN( 588)							if ((m55_h != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp9 = false;
            							}
HXDLIN( 588)							if (_hx_tmp9) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 588)							bool _hx_tmp10;
HXDLIN( 588)							if ((m55_i != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp10 = false;
            							}
HXDLIN( 588)							if (_hx_tmp10) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 588)							bool _hx_tmp11;
HXDLIN( 588)							if ((m55_j != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp11 = (j0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp11 = false;
            							}
HXDLIN( 588)							if (_hx_tmp11) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((j0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 588)							bool _hx_tmp12;
HXDLIN( 588)							if ((m55_k != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp12 = (k0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp12 = false;
            							}
HXDLIN( 588)							if (_hx_tmp12) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((k0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 588)							bool _hx_tmp13;
HXDLIN( 588)							if ((m55_l != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp13 = (l0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp13 = false;
            							}
HXDLIN( 588)							if (_hx_tmp13) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((l0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 588)							bool _hx_tmp14;
HXDLIN( 588)							if ((m55_m != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp14 = (m0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp14 = false;
            							}
HXDLIN( 588)							if (_hx_tmp14) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((m0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 588)							bool _hx_tmp15;
HXDLIN( 588)							if ((m55_n != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp15 = (n0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp15 = false;
            							}
HXDLIN( 588)							if (_hx_tmp15) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((n0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 588)							bool _hx_tmp16;
HXDLIN( 588)							if ((m55_o != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp16 = (o0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp16 = false;
            							}
HXDLIN( 588)							if (_hx_tmp16) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((o0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 588)							bool _hx_tmp17;
HXDLIN( 588)							if ((m55_p != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp17 = (p0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp17 = false;
            							}
HXDLIN( 588)							if (_hx_tmp17) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((p0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 588)							bool _hx_tmp18;
HXDLIN( 588)							if ((m55_q != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp18 = (q0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp18 = false;
            							}
HXDLIN( 588)							if (_hx_tmp18) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((q0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 588)							bool _hx_tmp19;
HXDLIN( 588)							if ((m55_r != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp19 = (r0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp19 = false;
            							}
HXDLIN( 588)							if (_hx_tmp19) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((r0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 588)							bool _hx_tmp20;
HXDLIN( 588)							if ((m55_s != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp20 = (s0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp20 = false;
            							}
HXDLIN( 588)							if (_hx_tmp20) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((s0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 588)							bool _hx_tmp21;
HXDLIN( 588)							if ((m55_t != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp21 = (t0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp21 = false;
            							}
HXDLIN( 588)							if (_hx_tmp21) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((t0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 588)							bool _hx_tmp22;
HXDLIN( 588)							if ((m55_u != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp22 = (u0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp22 = false;
            							}
HXDLIN( 588)							if (_hx_tmp22) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((u0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 588)							bool _hx_tmp23;
HXDLIN( 588)							if ((m55_v != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp23 = (v0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp23 = false;
            							}
HXDLIN( 588)							if (_hx_tmp23) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((v0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 588)							bool _hx_tmp24;
HXDLIN( 588)							if ((m55_w != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp24 = (w0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp24 = false;
            							}
HXDLIN( 588)							if (_hx_tmp24) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((w0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 588)							bool _hx_tmp25;
HXDLIN( 588)							if ((m55_x != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp25 = (x0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp25 = false;
            							}
HXDLIN( 588)							if (_hx_tmp25) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((x0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 588)							bool _hx_tmp26;
HXDLIN( 588)							if ((m55_y != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp26 = (y0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp26 = false;
            							}
HXDLIN( 588)							if (_hx_tmp26) {
HXDLIN( 588)								r_ = (r_ + ((( (Float)(((y0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 416)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 588)						if (adjustGreen) {
HXLINE( 419)							g_ = ((Float)0.);
HXLINE( 588)							bool _hx_tmp27;
HXDLIN( 588)							if ((m55_a != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp27 = (a0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp27 = false;
            							}
HXDLIN( 588)							if (_hx_tmp27) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 588)							bool _hx_tmp28;
HXDLIN( 588)							if ((m55_b != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp28 = (b0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp28 = false;
            							}
HXDLIN( 588)							if (_hx_tmp28) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 588)							bool _hx_tmp29;
HXDLIN( 588)							if ((m55_c != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp29 = (c0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp29 = false;
            							}
HXDLIN( 588)							if (_hx_tmp29) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 588)							bool _hx_tmp30;
HXDLIN( 588)							if ((m55_d != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp30 = (d0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp30 = false;
            							}
HXDLIN( 588)							if (_hx_tmp30) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 588)							bool _hx_tmp31;
HXDLIN( 588)							if ((m55_e != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp31 = (e0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp31 = false;
            							}
HXDLIN( 588)							if (_hx_tmp31) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 588)							bool _hx_tmp32;
HXDLIN( 588)							if ((m55_f != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp32 = (f0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp32 = false;
            							}
HXDLIN( 588)							if (_hx_tmp32) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 588)							bool _hx_tmp33;
HXDLIN( 588)							if ((m55_g != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp33 = (g0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp33 = false;
            							}
HXDLIN( 588)							if (_hx_tmp33) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 588)							bool _hx_tmp34;
HXDLIN( 588)							if ((m55_h != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp34 = (h0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp34 = false;
            							}
HXDLIN( 588)							if (_hx_tmp34) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 588)							bool _hx_tmp35;
HXDLIN( 588)							if ((m55_i != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp35 = (i0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp35 = false;
            							}
HXDLIN( 588)							if (_hx_tmp35) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 588)							bool _hx_tmp36;
HXDLIN( 588)							if ((m55_j != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp36 = (j0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp36 = false;
            							}
HXDLIN( 588)							if (_hx_tmp36) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((j0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 588)							bool _hx_tmp37;
HXDLIN( 588)							if ((m55_k != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp37 = (k0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp37 = false;
            							}
HXDLIN( 588)							if (_hx_tmp37) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((k0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 588)							bool _hx_tmp38;
HXDLIN( 588)							if ((m55_l != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp38 = (l0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp38 = false;
            							}
HXDLIN( 588)							if (_hx_tmp38) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((l0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 588)							bool _hx_tmp39;
HXDLIN( 588)							if ((m55_m != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp39 = (m0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp39 = false;
            							}
HXDLIN( 588)							if (_hx_tmp39) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((m0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 588)							bool _hx_tmp40;
HXDLIN( 588)							if ((m55_n != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp40 = (n0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp40 = false;
            							}
HXDLIN( 588)							if (_hx_tmp40) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((n0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 588)							bool _hx_tmp41;
HXDLIN( 588)							if ((m55_o != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp41 = (o0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp41 = false;
            							}
HXDLIN( 588)							if (_hx_tmp41) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((o0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 588)							bool _hx_tmp42;
HXDLIN( 588)							if ((m55_p != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp42 = (p0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp42 = false;
            							}
HXDLIN( 588)							if (_hx_tmp42) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((p0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 588)							bool _hx_tmp43;
HXDLIN( 588)							if ((m55_q != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp43 = (q0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp43 = false;
            							}
HXDLIN( 588)							if (_hx_tmp43) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((q0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 588)							bool _hx_tmp44;
HXDLIN( 588)							if ((m55_r != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp44 = (r0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp44 = false;
            							}
HXDLIN( 588)							if (_hx_tmp44) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((r0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 588)							bool _hx_tmp45;
HXDLIN( 588)							if ((m55_s != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp45 = (s0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp45 = false;
            							}
HXDLIN( 588)							if (_hx_tmp45) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((s0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 588)							bool _hx_tmp46;
HXDLIN( 588)							if ((m55_t != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp46 = (t0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp46 = false;
            							}
HXDLIN( 588)							if (_hx_tmp46) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((t0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 588)							bool _hx_tmp47;
HXDLIN( 588)							if ((m55_u != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp47 = (u0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp47 = false;
            							}
HXDLIN( 588)							if (_hx_tmp47) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((u0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 588)							bool _hx_tmp48;
HXDLIN( 588)							if ((m55_v != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp48 = (v0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp48 = false;
            							}
HXDLIN( 588)							if (_hx_tmp48) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((v0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 588)							bool _hx_tmp49;
HXDLIN( 588)							if ((m55_w != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp49 = (w0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp49 = false;
            							}
HXDLIN( 588)							if (_hx_tmp49) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((w0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 588)							bool _hx_tmp50;
HXDLIN( 588)							if ((m55_y != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp50 = (x0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp50 = false;
            							}
HXDLIN( 588)							if (_hx_tmp50) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((x0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 588)							bool _hx_tmp51;
HXDLIN( 588)							if ((m55_y != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp51 = (y0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp51 = false;
            							}
HXDLIN( 588)							if (_hx_tmp51) {
HXDLIN( 588)								g_ = (g_ + ((( (Float)(((y0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 450)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 588)						if (adjustBlue) {
HXLINE( 453)							b_ = ((Float)0.);
HXLINE( 588)							bool _hx_tmp52;
HXDLIN( 588)							if ((m55_a != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp52 = (a0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp52 = false;
            							}
HXDLIN( 588)							if (_hx_tmp52) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 588)							bool _hx_tmp53;
HXDLIN( 588)							if ((m55_b != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp53 = (b0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp53 = false;
            							}
HXDLIN( 588)							if (_hx_tmp53) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 588)							bool _hx_tmp54;
HXDLIN( 588)							if ((m55_c != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp54 = (c0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp54 = false;
            							}
HXDLIN( 588)							if (_hx_tmp54) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 588)							bool _hx_tmp55;
HXDLIN( 588)							if ((m55_d != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp55 = (d0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp55 = false;
            							}
HXDLIN( 588)							if (_hx_tmp55) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 588)							bool _hx_tmp56;
HXDLIN( 588)							if ((m55_e != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp56 = (e0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp56 = false;
            							}
HXDLIN( 588)							if (_hx_tmp56) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 588)							bool _hx_tmp57;
HXDLIN( 588)							if ((m55_f != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp57 = (f0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp57 = false;
            							}
HXDLIN( 588)							if (_hx_tmp57) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 588)							bool _hx_tmp58;
HXDLIN( 588)							if ((m55_g != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp58 = (g0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp58 = false;
            							}
HXDLIN( 588)							if (_hx_tmp58) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 588)							bool _hx_tmp59;
HXDLIN( 588)							if ((m55_h != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp59 = (h0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp59 = false;
            							}
HXDLIN( 588)							if (_hx_tmp59) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 588)							bool _hx_tmp60;
HXDLIN( 588)							if ((m55_i != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp60 = (i0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp60 = false;
            							}
HXDLIN( 588)							if (_hx_tmp60) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 588)							bool _hx_tmp61;
HXDLIN( 588)							if ((m55_j != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp61 = (j0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp61 = false;
            							}
HXDLIN( 588)							if (_hx_tmp61) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((j0 & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 588)							bool _hx_tmp62;
HXDLIN( 588)							if ((m55_k != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp62 = (k0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp62 = false;
            							}
HXDLIN( 588)							if (_hx_tmp62) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((k0 & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 588)							bool _hx_tmp63;
HXDLIN( 588)							if ((m55_l != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp63 = (l0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp63 = false;
            							}
HXDLIN( 588)							if (_hx_tmp63) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((l0 & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 588)							bool _hx_tmp64;
HXDLIN( 588)							if ((m55_m != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp64 = (m0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp64 = false;
            							}
HXDLIN( 588)							if (_hx_tmp64) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((m0 & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 588)							bool _hx_tmp65;
HXDLIN( 588)							if ((m55_n != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp65 = (n0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp65 = false;
            							}
HXDLIN( 588)							if (_hx_tmp65) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((n0 & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 588)							bool _hx_tmp66;
HXDLIN( 588)							if ((m55_o != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp66 = (o0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp66 = false;
            							}
HXDLIN( 588)							if (_hx_tmp66) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((o0 & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 588)							bool _hx_tmp67;
HXDLIN( 588)							if ((m55_p != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp67 = (p0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp67 = false;
            							}
HXDLIN( 588)							if (_hx_tmp67) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((p0 & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 588)							bool _hx_tmp68;
HXDLIN( 588)							if ((m55_q != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp68 = (q0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp68 = false;
            							}
HXDLIN( 588)							if (_hx_tmp68) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((q0 & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 588)							bool _hx_tmp69;
HXDLIN( 588)							if ((m55_r != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp69 = (r0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp69 = false;
            							}
HXDLIN( 588)							if (_hx_tmp69) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((r0 & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 588)							bool _hx_tmp70;
HXDLIN( 588)							if ((m55_s != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp70 = (s0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp70 = false;
            							}
HXDLIN( 588)							if (_hx_tmp70) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((s0 & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 588)							bool _hx_tmp71;
HXDLIN( 588)							if ((m55_t != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp71 = (t0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp71 = false;
            							}
HXDLIN( 588)							if (_hx_tmp71) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((t0 & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 588)							bool _hx_tmp72;
HXDLIN( 588)							if ((m55_u != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp72 = (u0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp72 = false;
            							}
HXDLIN( 588)							if (_hx_tmp72) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((u0 & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 588)							bool _hx_tmp73;
HXDLIN( 588)							if ((m55_v != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp73 = (v0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp73 = false;
            							}
HXDLIN( 588)							if (_hx_tmp73) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((v0 & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 588)							bool _hx_tmp74;
HXDLIN( 588)							if ((m55_w != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp74 = (w0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp74 = false;
            							}
HXDLIN( 588)							if (_hx_tmp74) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((w0 & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 588)							bool _hx_tmp75;
HXDLIN( 588)							if ((m55_x != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp75 = (x0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp75 = false;
            							}
HXDLIN( 588)							if (_hx_tmp75) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((x0 & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 588)							bool _hx_tmp76;
HXDLIN( 588)							if ((m55_y != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp76 = (y0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp76 = false;
            							}
HXDLIN( 588)							if (_hx_tmp76) {
HXDLIN( 588)								b_ = (b_ + ((( (Float)((y0 & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 484)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 588)						if (adjustAlpha) {
HXLINE( 487)							a_ = ((Float)0.);
HXLINE( 588)							bool _hx_tmp77;
HXDLIN( 588)							if ((m55_a != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp77 = (a0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp77 = false;
            							}
HXDLIN( 588)							if (_hx_tmp77) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 588)							bool _hx_tmp78;
HXDLIN( 588)							if ((m55_b != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp78 = (b0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp78 = false;
            							}
HXDLIN( 588)							if (_hx_tmp78) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 588)							bool _hx_tmp79;
HXDLIN( 588)							if ((m55_c != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp79 = (c0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp79 = false;
            							}
HXDLIN( 588)							if (_hx_tmp79) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 588)							bool _hx_tmp80;
HXDLIN( 588)							if ((m55_d != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp80 = (d0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp80 = false;
            							}
HXDLIN( 588)							if (_hx_tmp80) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 588)							bool _hx_tmp81;
HXDLIN( 588)							if ((m55_e != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp81 = (e0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp81 = false;
            							}
HXDLIN( 588)							if (_hx_tmp81) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 588)							bool _hx_tmp82;
HXDLIN( 588)							if ((m55_f != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp82 = (f0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp82 = false;
            							}
HXDLIN( 588)							if (_hx_tmp82) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 588)							bool _hx_tmp83;
HXDLIN( 588)							if ((m55_g != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp83 = (g0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp83 = false;
            							}
HXDLIN( 588)							if (_hx_tmp83) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 588)							bool _hx_tmp84;
HXDLIN( 588)							if ((m55_h != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp84 = (h0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp84 = false;
            							}
HXDLIN( 588)							if (_hx_tmp84) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 588)							bool _hx_tmp85;
HXDLIN( 588)							if ((m55_i != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp85 = (i0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp85 = false;
            							}
HXDLIN( 588)							if (_hx_tmp85) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 588)							bool _hx_tmp86;
HXDLIN( 588)							if ((m55_j != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp86 = (j0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp86 = false;
            							}
HXDLIN( 588)							if (_hx_tmp86) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((j0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 588)							bool _hx_tmp87;
HXDLIN( 588)							if ((m55_k != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp87 = (k0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp87 = false;
            							}
HXDLIN( 588)							if (_hx_tmp87) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((k0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 588)							bool _hx_tmp88;
HXDLIN( 588)							if ((m55_l != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp88 = (l0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp88 = false;
            							}
HXDLIN( 588)							if (_hx_tmp88) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((l0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 588)							bool _hx_tmp89;
HXDLIN( 588)							if ((m55_m != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp89 = (m0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp89 = false;
            							}
HXDLIN( 588)							if (_hx_tmp89) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((m0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 588)							bool _hx_tmp90;
HXDLIN( 588)							if ((m55_n != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp90 = (n0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp90 = false;
            							}
HXDLIN( 588)							if (_hx_tmp90) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((n0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 588)							bool _hx_tmp91;
HXDLIN( 588)							if ((m55_o != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp91 = (o0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp91 = false;
            							}
HXDLIN( 588)							if (_hx_tmp91) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((o0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 588)							bool _hx_tmp92;
HXDLIN( 588)							if ((m55_p != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp92 = (p0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp92 = false;
            							}
HXDLIN( 588)							if (_hx_tmp92) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((p0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 588)							bool _hx_tmp93;
HXDLIN( 588)							if ((m55_q != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp93 = (q0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp93 = false;
            							}
HXDLIN( 588)							if (_hx_tmp93) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((q0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 588)							bool _hx_tmp94;
HXDLIN( 588)							if ((m55_r != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp94 = (r0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp94 = false;
            							}
HXDLIN( 588)							if (_hx_tmp94) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((r0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 588)							bool _hx_tmp95;
HXDLIN( 588)							if ((m55_s != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp95 = (s0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp95 = false;
            							}
HXDLIN( 588)							if (_hx_tmp95) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((s0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 588)							bool _hx_tmp96;
HXDLIN( 588)							if ((m55_t != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp96 = (t0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp96 = false;
            							}
HXDLIN( 588)							if (_hx_tmp96) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((t0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 588)							bool _hx_tmp97;
HXDLIN( 588)							if ((m55_u != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp97 = (u0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp97 = false;
            							}
HXDLIN( 588)							if (_hx_tmp97) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((u0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 588)							bool _hx_tmp98;
HXDLIN( 588)							if ((m55_v != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp98 = (v0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp98 = false;
            							}
HXDLIN( 588)							if (_hx_tmp98) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((v0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 588)							bool _hx_tmp99;
HXDLIN( 588)							if ((m55_w != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp99 = (w0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp99 = false;
            							}
HXDLIN( 588)							if (_hx_tmp99) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((w0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 588)							bool _hx_tmp100;
HXDLIN( 588)							if ((m55_x != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp100 = (x0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp100 = false;
            							}
HXDLIN( 588)							if (_hx_tmp100) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((x0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 588)							bool _hx_tmp101;
HXDLIN( 588)							if ((m55_y != ((Float)0.))) {
HXDLIN( 588)								_hx_tmp101 = (y0 != 0);
            							}
            							else {
HXDLIN( 588)								_hx_tmp101 = false;
            							}
HXDLIN( 588)							if (_hx_tmp101) {
HXDLIN( 588)								a_ = (a_ + ((( (Float)(((y0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 518)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 588)						bool _hx_tmp102;
HXDLIN( 588)						if ((borderMode != 0)) {
HXDLIN( 588)							_hx_tmp102 = (borderMode == 2);
            						}
            						else {
HXDLIN( 588)							_hx_tmp102 = true;
            						}
HXDLIN( 588)						if (_hx_tmp102) {
HXDLIN( 588)							int x56 = (x30 - 2);
HXDLIN( 588)							int y55 = (y30 - 2);
HXDLIN( 588)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 588)							{
HXDLIN( 588)								int c68 = color20;
HXDLIN( 588)								bool _hx_tmp103;
HXDLIN( 588)								if ((((c68 >> 24) & 255) < 254)) {
HXDLIN( 588)									_hx_tmp103 = out->transparent;
            								}
            								else {
HXDLIN( 588)									_hx_tmp103 = false;
            								}
HXDLIN( 588)								if (_hx_tmp103) {
HXDLIN( 588)									int location18;
HXDLIN( 588)									if (out->useVirtualPos) {
HXDLIN( 588)										location18 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXDLIN( 588)										location18 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 588)									int this272 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 588)									int this273;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										this273 = ((((((this272 >> 24) & 255) << 24) | ((this272 & 255) << 16)) | (((this272 >> 8) & 255) << 8)) | ((this272 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										this273 = this272;
            									}
HXDLIN( 588)									Float a120;
HXDLIN( 588)									int this274 = ((this273 >> 24) & 255);
HXDLIN( 588)									if ((this274 == 0)) {
HXDLIN( 588)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a120 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r118;
HXDLIN( 588)									int this275 = ((this273 >> 16) & 255);
HXDLIN( 588)									if ((this275 == 0)) {
HXDLIN( 588)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r118 = (( (Float)(this275) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g118;
HXDLIN( 588)									int this276 = ((this273 >> 8) & 255);
HXDLIN( 588)									if ((this276 == 0)) {
HXDLIN( 588)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g118 = (( (Float)(this276) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b121;
HXDLIN( 588)									int this277 = (this273 & 255);
HXDLIN( 588)									if ((this277 == 0)) {
HXDLIN( 588)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b121 = (( (Float)(this277) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a219;
HXDLIN( 588)									int this278 = ((color20 >> 24) & 255);
HXDLIN( 588)									if ((this278 == 0)) {
HXDLIN( 588)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a219 = (( (Float)(this278) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r218;
HXDLIN( 588)									int this279 = ((color20 >> 16) & 255);
HXDLIN( 588)									if ((this279 == 0)) {
HXDLIN( 588)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r218 = (( (Float)(this279) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g218;
HXDLIN( 588)									int this280 = ((color20 >> 8) & 255);
HXDLIN( 588)									if ((this280 == 0)) {
HXDLIN( 588)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g218 = (( (Float)(this280) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b219;
HXDLIN( 588)									int this281 = (color20 & 255);
HXDLIN( 588)									if ((this281 == 0)) {
HXDLIN( 588)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b219 = (( (Float)(this281) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 588)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 588)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 588)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 588)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 588)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 588)									{
HXDLIN( 588)										int _hx_tmp104;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											_hx_tmp104 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											_hx_tmp104 = blended18;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp104);
            									}
            								}
            								else {
HXDLIN( 588)									::Dynamic this282 = out->image;
HXDLIN( 588)									int index70;
HXDLIN( 588)									if (out->useVirtualPos) {
HXDLIN( 588)										index70 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXDLIN( 588)										index70 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 588)									int _hx_tmp105;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp105 = ((((((c68 >> 24) & 255) << 24) | ((c68 & 255) << 16)) | (((c68 >> 8) & 255) << 8)) | ((c68 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp105 = c68;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this282,index70,_hx_tmp105);
            								}
            							}
            						}
            						else {
HXDLIN( 588)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 588)							{
HXDLIN( 588)								int c69 = color21;
HXDLIN( 588)								bool _hx_tmp106;
HXDLIN( 588)								if ((((c69 >> 24) & 255) < 254)) {
HXDLIN( 588)									_hx_tmp106 = out->transparent;
            								}
            								else {
HXDLIN( 588)									_hx_tmp106 = false;
            								}
HXDLIN( 588)								if (_hx_tmp106) {
HXDLIN( 588)									int location19;
HXDLIN( 588)									if (out->useVirtualPos) {
HXDLIN( 588)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 588)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 588)									int this283 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 588)									int this284;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										this284 = ((((((this283 >> 24) & 255) << 24) | ((this283 & 255) << 16)) | (((this283 >> 8) & 255) << 8)) | ((this283 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										this284 = this283;
            									}
HXDLIN( 588)									Float a121;
HXDLIN( 588)									int this285 = ((this284 >> 24) & 255);
HXDLIN( 588)									if ((this285 == 0)) {
HXDLIN( 588)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a121 = (( (Float)(this285) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r119;
HXDLIN( 588)									int this286 = ((this284 >> 16) & 255);
HXDLIN( 588)									if ((this286 == 0)) {
HXDLIN( 588)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r119 = (( (Float)(this286) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g119;
HXDLIN( 588)									int this287 = ((this284 >> 8) & 255);
HXDLIN( 588)									if ((this287 == 0)) {
HXDLIN( 588)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g119 = (( (Float)(this287) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b122;
HXDLIN( 588)									int this288 = (this284 & 255);
HXDLIN( 588)									if ((this288 == 0)) {
HXDLIN( 588)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b122 = (( (Float)(this288) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a220;
HXDLIN( 588)									int this289 = ((color21 >> 24) & 255);
HXDLIN( 588)									if ((this289 == 0)) {
HXDLIN( 588)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										a220 = (( (Float)(this289) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float r219;
HXDLIN( 588)									int this290 = ((color21 >> 16) & 255);
HXDLIN( 588)									if ((this290 == 0)) {
HXDLIN( 588)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										r219 = (( (Float)(this290) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float g219;
HXDLIN( 588)									int this291 = ((color21 >> 8) & 255);
HXDLIN( 588)									if ((this291 == 0)) {
HXDLIN( 588)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										g219 = (( (Float)(this291) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float b220;
HXDLIN( 588)									int this292 = (color21 & 255);
HXDLIN( 588)									if ((this292 == 0)) {
HXDLIN( 588)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 588)										b220 = (( (Float)(this292) ) / ( (Float)(255) ));
            									}
HXDLIN( 588)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 588)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 588)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 588)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 588)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 588)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 588)									{
HXDLIN( 588)										int _hx_tmp107;
HXDLIN( 588)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)											_hx_tmp107 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 588)											_hx_tmp107 = blended19;
            										}
HXDLIN( 588)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp107);
            									}
            								}
            								else {
HXDLIN( 588)									::Dynamic this293 = out->image;
HXDLIN( 588)									int index71;
HXDLIN( 588)									if (out->useVirtualPos) {
HXDLIN( 588)										index71 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 588)										index71 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 588)									int _hx_tmp108;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp108 = ((((((c69 >> 24) & 255) << 24) | ((c69 & 255) << 16)) | (((c69 >> 8) & 255) << 8)) | ((c69 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp108 = c69;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(this293,index71,_hx_tmp108);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 588)		if ((borderMode == 1)) {
HXDLIN( 588)			{
HXDLIN( 588)				int _g84 = 0;
HXDLIN( 588)				int _g85 = (this1->width - 1);
HXDLIN( 588)				while((_g84 < _g85)){
HXDLIN( 588)					_g84 = (_g84 + 1);
HXDLIN( 588)					int x57 = (_g84 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						::Dynamic this294 = here->image;
HXDLIN( 588)						int index72;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index72 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index72 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x57)) ));
            						}
HXDLIN( 588)						int c70 = ::iterMagic::Iimg_obj::get(this294,index72);
HXDLIN( 588)						int color22;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color22 = ((((((c70 >> 24) & 255) << 24) | ((c70 & 255) << 16)) | (((c70 >> 8) & 255) << 8)) | ((c70 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color22 = c70;
            						}
HXDLIN( 588)						int color23 = color22;
HXDLIN( 588)						{
HXDLIN( 588)							int c71 = color23;
HXDLIN( 588)							bool _hx_tmp109;
HXDLIN( 588)							if ((((c71 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp109 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp109 = false;
            							}
HXDLIN( 588)							if (_hx_tmp109) {
HXDLIN( 588)								int location20;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int this295 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 588)								int this296;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this296 = ((((((this295 >> 24) & 255) << 24) | ((this295 & 255) << 16)) | (((this295 >> 8) & 255) << 8)) | ((this295 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this296 = this295;
            								}
HXDLIN( 588)								Float a122;
HXDLIN( 588)								int this297 = ((this296 >> 24) & 255);
HXDLIN( 588)								if ((this297 == 0)) {
HXDLIN( 588)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a122 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r120;
HXDLIN( 588)								int this298 = ((this296 >> 16) & 255);
HXDLIN( 588)								if ((this298 == 0)) {
HXDLIN( 588)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r120 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g120;
HXDLIN( 588)								int this299 = ((this296 >> 8) & 255);
HXDLIN( 588)								if ((this299 == 0)) {
HXDLIN( 588)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g120 = (( (Float)(this299) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b123;
HXDLIN( 588)								int this300 = (this296 & 255);
HXDLIN( 588)								if ((this300 == 0)) {
HXDLIN( 588)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b123 = (( (Float)(this300) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a221;
HXDLIN( 588)								int this301 = ((color23 >> 24) & 255);
HXDLIN( 588)								if ((this301 == 0)) {
HXDLIN( 588)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a221 = (( (Float)(this301) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r220;
HXDLIN( 588)								int this302 = ((color23 >> 16) & 255);
HXDLIN( 588)								if ((this302 == 0)) {
HXDLIN( 588)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r220 = (( (Float)(this302) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g220;
HXDLIN( 588)								int this303 = ((color23 >> 8) & 255);
HXDLIN( 588)								if ((this303 == 0)) {
HXDLIN( 588)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g220 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b221;
HXDLIN( 588)								int this304 = (color23 & 255);
HXDLIN( 588)								if ((this304 == 0)) {
HXDLIN( 588)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b221 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 588)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 588)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 588)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 588)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 588)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp110;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp110 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp110 = blended20;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp110);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this305 = out->image;
HXDLIN( 588)								int index73;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index73 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index73 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int _hx_tmp111;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp111 = ((((((c71 >> 24) & 255) << 24) | ((c71 & 255) << 16)) | (((c71 >> 8) & 255) << 8)) | ((c71 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp111 = c71;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this305,index73,_hx_tmp111);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						int x58 = (x57 + 1);
HXDLIN( 588)						int x59 = (x57 + 1);
HXDLIN( 588)						::Dynamic this306 = here->image;
HXDLIN( 588)						int index74;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index74 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x59) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index74 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x59)) ));
            						}
HXDLIN( 588)						int c72 = ::iterMagic::Iimg_obj::get(this306,index74);
HXDLIN( 588)						int color24;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color24 = ((((((c72 >> 24) & 255) << 24) | ((c72 & 255) << 16)) | (((c72 >> 8) & 255) << 8)) | ((c72 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color24 = c72;
            						}
HXDLIN( 588)						{
HXDLIN( 588)							int c73 = color24;
HXDLIN( 588)							bool _hx_tmp112;
HXDLIN( 588)							if ((((c73 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp112 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp112 = false;
            							}
HXDLIN( 588)							if (_hx_tmp112) {
HXDLIN( 588)								int location21;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location21 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location21 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 588)								int this307 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 588)								int this308;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this308 = ((((((this307 >> 24) & 255) << 24) | ((this307 & 255) << 16)) | (((this307 >> 8) & 255) << 8)) | ((this307 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this308 = this307;
            								}
HXDLIN( 588)								Float a123;
HXDLIN( 588)								int this309 = ((this308 >> 24) & 255);
HXDLIN( 588)								if ((this309 == 0)) {
HXDLIN( 588)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a123 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r121;
HXDLIN( 588)								int this310 = ((this308 >> 16) & 255);
HXDLIN( 588)								if ((this310 == 0)) {
HXDLIN( 588)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r121 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g121;
HXDLIN( 588)								int this311 = ((this308 >> 8) & 255);
HXDLIN( 588)								if ((this311 == 0)) {
HXDLIN( 588)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g121 = (( (Float)(this311) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b124;
HXDLIN( 588)								int this312 = (this308 & 255);
HXDLIN( 588)								if ((this312 == 0)) {
HXDLIN( 588)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b124 = (( (Float)(this312) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a222;
HXDLIN( 588)								int this313 = ((color24 >> 24) & 255);
HXDLIN( 588)								if ((this313 == 0)) {
HXDLIN( 588)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a222 = (( (Float)(this313) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r221;
HXDLIN( 588)								int this314 = ((color24 >> 16) & 255);
HXDLIN( 588)								if ((this314 == 0)) {
HXDLIN( 588)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r221 = (( (Float)(this314) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g221;
HXDLIN( 588)								int this315 = ((color24 >> 8) & 255);
HXDLIN( 588)								if ((this315 == 0)) {
HXDLIN( 588)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g221 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b222;
HXDLIN( 588)								int this316 = (color24 & 255);
HXDLIN( 588)								if ((this316 == 0)) {
HXDLIN( 588)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b222 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 588)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 588)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 588)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 588)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 588)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp113;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp113 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp113 = blended21;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp113);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this317 = out->image;
HXDLIN( 588)								int index75;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index75 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index75 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 588)								int _hx_tmp114;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp114 = ((((((c73 >> 24) & 255) << 24) | ((c73 & 255) << 16)) | (((c73 >> 8) & 255) << 8)) | ((c73 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp114 = c73;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this317,index75,_hx_tmp114);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						int y56 = (this1->height - 1);
HXDLIN( 588)						int y57 = (this1->height - 1);
HXDLIN( 588)						::Dynamic this318 = here->image;
HXDLIN( 588)						int index76;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index76 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index76 = ::Std_obj::_hx_int(( (Float)(((y57 * here->width) + x57)) ));
            						}
HXDLIN( 588)						int c74 = ::iterMagic::Iimg_obj::get(this318,index76);
HXDLIN( 588)						int color25;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color25 = ((((((c74 >> 24) & 255) << 24) | ((c74 & 255) << 16)) | (((c74 >> 8) & 255) << 8)) | ((c74 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color25 = c74;
            						}
HXDLIN( 588)						{
HXDLIN( 588)							int c75 = color25;
HXDLIN( 588)							bool _hx_tmp115;
HXDLIN( 588)							if ((((c75 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp115 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp115 = false;
            							}
HXDLIN( 588)							if (_hx_tmp115) {
HXDLIN( 588)								int location22;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location22 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location22 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int this319 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 588)								int this320;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this320 = ((((((this319 >> 24) & 255) << 24) | ((this319 & 255) << 16)) | (((this319 >> 8) & 255) << 8)) | ((this319 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this320 = this319;
            								}
HXDLIN( 588)								Float a124;
HXDLIN( 588)								int this321 = ((this320 >> 24) & 255);
HXDLIN( 588)								if ((this321 == 0)) {
HXDLIN( 588)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a124 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r122;
HXDLIN( 588)								int this322 = ((this320 >> 16) & 255);
HXDLIN( 588)								if ((this322 == 0)) {
HXDLIN( 588)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r122 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g122;
HXDLIN( 588)								int this323 = ((this320 >> 8) & 255);
HXDLIN( 588)								if ((this323 == 0)) {
HXDLIN( 588)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g122 = (( (Float)(this323) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b125;
HXDLIN( 588)								int this324 = (this320 & 255);
HXDLIN( 588)								if ((this324 == 0)) {
HXDLIN( 588)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b125 = (( (Float)(this324) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a223;
HXDLIN( 588)								int this325 = ((color25 >> 24) & 255);
HXDLIN( 588)								if ((this325 == 0)) {
HXDLIN( 588)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a223 = (( (Float)(this325) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r222;
HXDLIN( 588)								int this326 = ((color25 >> 16) & 255);
HXDLIN( 588)								if ((this326 == 0)) {
HXDLIN( 588)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r222 = (( (Float)(this326) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g222;
HXDLIN( 588)								int this327 = ((color25 >> 8) & 255);
HXDLIN( 588)								if ((this327 == 0)) {
HXDLIN( 588)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g222 = (( (Float)(this327) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b223;
HXDLIN( 588)								int this328 = (color25 & 255);
HXDLIN( 588)								if ((this328 == 0)) {
HXDLIN( 588)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b223 = (( (Float)(this328) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 588)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 588)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 588)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 588)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 588)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp116;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp116 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp116 = blended22;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp116);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this329 = out->image;
HXDLIN( 588)								int index77;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index77 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index77 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int _hx_tmp117;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp117 = ((((((c75 >> 24) & 255) << 24) | ((c75 & 255) << 16)) | (((c75 >> 8) & 255) << 8)) | ((c75 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp117 = c75;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this329,index77,_hx_tmp117);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						int y58 = (this1->height - 2);
HXDLIN( 588)						int y59 = (this1->height - 2);
HXDLIN( 588)						::Dynamic this330 = here->image;
HXDLIN( 588)						int index78;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index78 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index78 = ::Std_obj::_hx_int(( (Float)(((y59 * here->width) + x57)) ));
            						}
HXDLIN( 588)						int c76 = ::iterMagic::Iimg_obj::get(this330,index78);
HXDLIN( 588)						int color26;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color26 = ((((((c76 >> 24) & 255) << 24) | ((c76 & 255) << 16)) | (((c76 >> 8) & 255) << 8)) | ((c76 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color26 = c76;
            						}
HXDLIN( 588)						{
HXDLIN( 588)							int c77 = color26;
HXDLIN( 588)							bool _hx_tmp118;
HXDLIN( 588)							if ((((c77 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp118 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp118 = false;
            							}
HXDLIN( 588)							if (_hx_tmp118) {
HXDLIN( 588)								int location23;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location23 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location23 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int this331 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 588)								int this332;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this332 = ((((((this331 >> 24) & 255) << 24) | ((this331 & 255) << 16)) | (((this331 >> 8) & 255) << 8)) | ((this331 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this332 = this331;
            								}
HXDLIN( 588)								Float a125;
HXDLIN( 588)								int this333 = ((this332 >> 24) & 255);
HXDLIN( 588)								if ((this333 == 0)) {
HXDLIN( 588)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a125 = (( (Float)(this333) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r123;
HXDLIN( 588)								int this334 = ((this332 >> 16) & 255);
HXDLIN( 588)								if ((this334 == 0)) {
HXDLIN( 588)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r123 = (( (Float)(this334) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g123;
HXDLIN( 588)								int this335 = ((this332 >> 8) & 255);
HXDLIN( 588)								if ((this335 == 0)) {
HXDLIN( 588)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g123 = (( (Float)(this335) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b126;
HXDLIN( 588)								int this336 = (this332 & 255);
HXDLIN( 588)								if ((this336 == 0)) {
HXDLIN( 588)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b126 = (( (Float)(this336) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a224;
HXDLIN( 588)								int this337 = ((color26 >> 24) & 255);
HXDLIN( 588)								if ((this337 == 0)) {
HXDLIN( 588)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a224 = (( (Float)(this337) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r223;
HXDLIN( 588)								int this338 = ((color26 >> 16) & 255);
HXDLIN( 588)								if ((this338 == 0)) {
HXDLIN( 588)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r223 = (( (Float)(this338) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g223;
HXDLIN( 588)								int this339 = ((color26 >> 8) & 255);
HXDLIN( 588)								if ((this339 == 0)) {
HXDLIN( 588)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g223 = (( (Float)(this339) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b224;
HXDLIN( 588)								int this340 = (color26 & 255);
HXDLIN( 588)								if ((this340 == 0)) {
HXDLIN( 588)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b224 = (( (Float)(this340) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 588)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 588)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 588)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 588)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 588)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp119;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp119 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp119 = blended23;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp119);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this341 = out->image;
HXDLIN( 588)								int index79;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index79 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index79 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 588)								int _hx_tmp120;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp120 = ((((((c77 >> 24) & 255) << 24) | ((c77 & 255) << 16)) | (((c77 >> 8) & 255) << 8)) | ((c77 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp120 = c77;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this341,index79,_hx_tmp120);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 588)			{
HXDLIN( 588)				int _g86 = 2;
HXDLIN( 588)				int _g87 = (this1->height - 3);
HXDLIN( 588)				while((_g86 < _g87)){
HXDLIN( 588)					_g86 = (_g86 + 1);
HXDLIN( 588)					int y60 = (_g86 - 1);
HXDLIN( 588)					{
HXDLIN( 588)						::Dynamic this342 = here->image;
HXDLIN( 588)						int index80;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index80 = ::Std_obj::_hx_int((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index80 = ::Std_obj::_hx_int(( (Float)((y60 * here->width)) ));
            						}
HXDLIN( 588)						int c78 = ::iterMagic::Iimg_obj::get(this342,index80);
HXDLIN( 588)						int color27;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color27 = ((((((c78 >> 24) & 255) << 24) | ((c78 & 255) << 16)) | (((c78 >> 8) & 255) << 8)) | ((c78 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color27 = c78;
            						}
HXDLIN( 588)						int color28 = color27;
HXDLIN( 588)						{
HXDLIN( 588)							int c79 = color28;
HXDLIN( 588)							bool _hx_tmp121;
HXDLIN( 588)							if ((((c79 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp121 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp121 = false;
            							}
HXDLIN( 588)							if (_hx_tmp121) {
HXDLIN( 588)								int location24;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location24 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location24 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 588)								int this343 = ::iterMagic::Iimg_obj::get(out->image,location24);
HXDLIN( 588)								int this344;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this344 = ((((((this343 >> 24) & 255) << 24) | ((this343 & 255) << 16)) | (((this343 >> 8) & 255) << 8)) | ((this343 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this344 = this343;
            								}
HXDLIN( 588)								Float a126;
HXDLIN( 588)								int this345 = ((this344 >> 24) & 255);
HXDLIN( 588)								if ((this345 == 0)) {
HXDLIN( 588)									a126 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a126 = (( (Float)(this345) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r124;
HXDLIN( 588)								int this346 = ((this344 >> 16) & 255);
HXDLIN( 588)								if ((this346 == 0)) {
HXDLIN( 588)									r124 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r124 = (( (Float)(this346) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g124;
HXDLIN( 588)								int this347 = ((this344 >> 8) & 255);
HXDLIN( 588)								if ((this347 == 0)) {
HXDLIN( 588)									g124 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g124 = (( (Float)(this347) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b127;
HXDLIN( 588)								int this348 = (this344 & 255);
HXDLIN( 588)								if ((this348 == 0)) {
HXDLIN( 588)									b127 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b127 = (( (Float)(this348) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a225;
HXDLIN( 588)								int this349 = ((color28 >> 24) & 255);
HXDLIN( 588)								if ((this349 == 0)) {
HXDLIN( 588)									a225 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a225 = (( (Float)(this349) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r224;
HXDLIN( 588)								int this350 = ((color28 >> 16) & 255);
HXDLIN( 588)								if ((this350 == 0)) {
HXDLIN( 588)									r224 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r224 = (( (Float)(this350) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g224;
HXDLIN( 588)								int this351 = ((color28 >> 8) & 255);
HXDLIN( 588)								if ((this351 == 0)) {
HXDLIN( 588)									g224 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g224 = (( (Float)(this351) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b225;
HXDLIN( 588)								int this352 = (color28 & 255);
HXDLIN( 588)								if ((this352 == 0)) {
HXDLIN( 588)									b225 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b225 = (( (Float)(this352) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a324 = (a126 * (( (Float)(1) ) - a225));
HXDLIN( 588)								int r44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 588)								int g44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 588)								int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a324) + (b225 * a225))));
HXDLIN( 588)								int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 588)								int blended24 = ((((a54 << 24) | (r44 << 16)) | (g44 << 8)) | b49);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp122;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp122 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp122 = blended24;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location24,_hx_tmp122);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this353 = out->image;
HXDLIN( 588)								int index81;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index81 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index81 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 588)								int _hx_tmp123;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp123 = ((((((c79 >> 24) & 255) << 24) | ((c79 & 255) << 16)) | (((c79 >> 8) & 255) << 8)) | ((c79 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp123 = c79;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this353,index81,_hx_tmp123);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						::Dynamic this354 = here->image;
HXDLIN( 588)						int index82;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index82 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + 1) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index82 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + 1)) ));
            						}
HXDLIN( 588)						int c80 = ::iterMagic::Iimg_obj::get(this354,index82);
HXDLIN( 588)						int color29;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color29 = ((((((c80 >> 24) & 255) << 24) | ((c80 & 255) << 16)) | (((c80 >> 8) & 255) << 8)) | ((c80 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color29 = c80;
            						}
HXDLIN( 588)						int color30 = color29;
HXDLIN( 588)						{
HXDLIN( 588)							int c81 = color30;
HXDLIN( 588)							bool _hx_tmp124;
HXDLIN( 588)							if ((((c81 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp124 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp124 = false;
            							}
HXDLIN( 588)							if (_hx_tmp124) {
HXDLIN( 588)								int location25;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location25 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location25 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 588)								int this355 = ::iterMagic::Iimg_obj::get(out->image,location25);
HXDLIN( 588)								int this356;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this356 = ((((((this355 >> 24) & 255) << 24) | ((this355 & 255) << 16)) | (((this355 >> 8) & 255) << 8)) | ((this355 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this356 = this355;
            								}
HXDLIN( 588)								Float a127;
HXDLIN( 588)								int this357 = ((this356 >> 24) & 255);
HXDLIN( 588)								if ((this357 == 0)) {
HXDLIN( 588)									a127 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a127 = (( (Float)(this357) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r125;
HXDLIN( 588)								int this358 = ((this356 >> 16) & 255);
HXDLIN( 588)								if ((this358 == 0)) {
HXDLIN( 588)									r125 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r125 = (( (Float)(this358) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g125;
HXDLIN( 588)								int this359 = ((this356 >> 8) & 255);
HXDLIN( 588)								if ((this359 == 0)) {
HXDLIN( 588)									g125 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g125 = (( (Float)(this359) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b128;
HXDLIN( 588)								int this360 = (this356 & 255);
HXDLIN( 588)								if ((this360 == 0)) {
HXDLIN( 588)									b128 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b128 = (( (Float)(this360) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a226;
HXDLIN( 588)								int this361 = ((color30 >> 24) & 255);
HXDLIN( 588)								if ((this361 == 0)) {
HXDLIN( 588)									a226 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a226 = (( (Float)(this361) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r225;
HXDLIN( 588)								int this362 = ((color30 >> 16) & 255);
HXDLIN( 588)								if ((this362 == 0)) {
HXDLIN( 588)									r225 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r225 = (( (Float)(this362) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g225;
HXDLIN( 588)								int this363 = ((color30 >> 8) & 255);
HXDLIN( 588)								if ((this363 == 0)) {
HXDLIN( 588)									g225 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g225 = (( (Float)(this363) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b226;
HXDLIN( 588)								int this364 = (color30 & 255);
HXDLIN( 588)								if ((this364 == 0)) {
HXDLIN( 588)									b226 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b226 = (( (Float)(this364) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a325 = (a127 * (( (Float)(1) ) - a226));
HXDLIN( 588)								int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 588)								int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 588)								int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a325) + (b226 * a226))));
HXDLIN( 588)								int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 588)								int blended25 = ((((a55 << 24) | (r45 << 16)) | (g45 << 8)) | b50);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp125;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp125 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp125 = blended25;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location25,_hx_tmp125);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this365 = out->image;
HXDLIN( 588)								int index83;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index83 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index83 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 588)								int _hx_tmp126;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp126 = ((((((c81 >> 24) & 255) << 24) | ((c81 & 255) << 16)) | (((c81 >> 8) & 255) << 8)) | ((c81 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp126 = c81;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this365,index83,_hx_tmp126);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						int x60 = (this1->width - 1);
HXDLIN( 588)						int x61 = (this1->width - 1);
HXDLIN( 588)						::Dynamic this366 = here->image;
HXDLIN( 588)						int index84;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index84 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x61) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index84 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x61)) ));
            						}
HXDLIN( 588)						int c82 = ::iterMagic::Iimg_obj::get(this366,index84);
HXDLIN( 588)						int color31;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color31 = ((((((c82 >> 24) & 255) << 24) | ((c82 & 255) << 16)) | (((c82 >> 8) & 255) << 8)) | ((c82 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color31 = c82;
            						}
HXDLIN( 588)						{
HXDLIN( 588)							int c83 = color31;
HXDLIN( 588)							bool _hx_tmp127;
HXDLIN( 588)							if ((((c83 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp127 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp127 = false;
            							}
HXDLIN( 588)							if (_hx_tmp127) {
HXDLIN( 588)								int location26;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location26 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location26 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 588)								int this367 = ::iterMagic::Iimg_obj::get(out->image,location26);
HXDLIN( 588)								int this368;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this368 = ((((((this367 >> 24) & 255) << 24) | ((this367 & 255) << 16)) | (((this367 >> 8) & 255) << 8)) | ((this367 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this368 = this367;
            								}
HXDLIN( 588)								Float a128;
HXDLIN( 588)								int this369 = ((this368 >> 24) & 255);
HXDLIN( 588)								if ((this369 == 0)) {
HXDLIN( 588)									a128 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a128 = (( (Float)(this369) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r126;
HXDLIN( 588)								int this370 = ((this368 >> 16) & 255);
HXDLIN( 588)								if ((this370 == 0)) {
HXDLIN( 588)									r126 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r126 = (( (Float)(this370) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g126;
HXDLIN( 588)								int this371 = ((this368 >> 8) & 255);
HXDLIN( 588)								if ((this371 == 0)) {
HXDLIN( 588)									g126 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g126 = (( (Float)(this371) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b129;
HXDLIN( 588)								int this372 = (this368 & 255);
HXDLIN( 588)								if ((this372 == 0)) {
HXDLIN( 588)									b129 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b129 = (( (Float)(this372) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a227;
HXDLIN( 588)								int this373 = ((color31 >> 24) & 255);
HXDLIN( 588)								if ((this373 == 0)) {
HXDLIN( 588)									a227 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a227 = (( (Float)(this373) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r226;
HXDLIN( 588)								int this374 = ((color31 >> 16) & 255);
HXDLIN( 588)								if ((this374 == 0)) {
HXDLIN( 588)									r226 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r226 = (( (Float)(this374) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g226;
HXDLIN( 588)								int this375 = ((color31 >> 8) & 255);
HXDLIN( 588)								if ((this375 == 0)) {
HXDLIN( 588)									g226 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g226 = (( (Float)(this375) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b227;
HXDLIN( 588)								int this376 = (color31 & 255);
HXDLIN( 588)								if ((this376 == 0)) {
HXDLIN( 588)									b227 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b227 = (( (Float)(this376) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a326 = (a128 * (( (Float)(1) ) - a227));
HXDLIN( 588)								int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 588)								int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 588)								int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a326) + (b227 * a227))));
HXDLIN( 588)								int a56 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 588)								int blended26 = ((((a56 << 24) | (r46 << 16)) | (g46 << 8)) | b51);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp128;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp128 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp128 = blended26;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location26,_hx_tmp128);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this377 = out->image;
HXDLIN( 588)								int index85;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index85 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index85 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 588)								int _hx_tmp129;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp129 = ((((((c83 >> 24) & 255) << 24) | ((c83 & 255) << 16)) | (((c83 >> 8) & 255) << 8)) | ((c83 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp129 = c83;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this377,index85,_hx_tmp129);
            							}
            						}
            					}
HXDLIN( 588)					{
HXDLIN( 588)						int x62 = (this1->width - 2);
HXDLIN( 588)						int x63 = (this1->width - 2);
HXDLIN( 588)						::Dynamic this378 = here->image;
HXDLIN( 588)						int index86;
HXDLIN( 588)						if (here->useVirtualPos) {
HXDLIN( 588)							index86 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x63) - here->virtualX));
            						}
            						else {
HXDLIN( 588)							index86 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x63)) ));
            						}
HXDLIN( 588)						int c84 = ::iterMagic::Iimg_obj::get(this378,index86);
HXDLIN( 588)						int color32;
HXDLIN( 588)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)							color32 = ((((((c84 >> 24) & 255) << 24) | ((c84 & 255) << 16)) | (((c84 >> 8) & 255) << 8)) | ((c84 >> 16) & 255));
            						}
            						else {
HXDLIN( 588)							color32 = c84;
            						}
HXDLIN( 588)						{
HXDLIN( 588)							int c85 = color32;
HXDLIN( 588)							bool _hx_tmp130;
HXDLIN( 588)							if ((((c85 >> 24) & 255) < 254)) {
HXDLIN( 588)								_hx_tmp130 = out->transparent;
            							}
            							else {
HXDLIN( 588)								_hx_tmp130 = false;
            							}
HXDLIN( 588)							if (_hx_tmp130) {
HXDLIN( 588)								int location27;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									location27 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									location27 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 588)								int this379 = ::iterMagic::Iimg_obj::get(out->image,location27);
HXDLIN( 588)								int this380;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									this380 = ((((((this379 >> 24) & 255) << 24) | ((this379 & 255) << 16)) | (((this379 >> 8) & 255) << 8)) | ((this379 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									this380 = this379;
            								}
HXDLIN( 588)								Float a129;
HXDLIN( 588)								int this381 = ((this380 >> 24) & 255);
HXDLIN( 588)								if ((this381 == 0)) {
HXDLIN( 588)									a129 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a129 = (( (Float)(this381) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r127;
HXDLIN( 588)								int this382 = ((this380 >> 16) & 255);
HXDLIN( 588)								if ((this382 == 0)) {
HXDLIN( 588)									r127 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r127 = (( (Float)(this382) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g127;
HXDLIN( 588)								int this383 = ((this380 >> 8) & 255);
HXDLIN( 588)								if ((this383 == 0)) {
HXDLIN( 588)									g127 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g127 = (( (Float)(this383) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b130;
HXDLIN( 588)								int this384 = (this380 & 255);
HXDLIN( 588)								if ((this384 == 0)) {
HXDLIN( 588)									b130 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b130 = (( (Float)(this384) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a228;
HXDLIN( 588)								int this385 = ((color32 >> 24) & 255);
HXDLIN( 588)								if ((this385 == 0)) {
HXDLIN( 588)									a228 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									a228 = (( (Float)(this385) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float r227;
HXDLIN( 588)								int this386 = ((color32 >> 16) & 255);
HXDLIN( 588)								if ((this386 == 0)) {
HXDLIN( 588)									r227 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									r227 = (( (Float)(this386) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float g227;
HXDLIN( 588)								int this387 = ((color32 >> 8) & 255);
HXDLIN( 588)								if ((this387 == 0)) {
HXDLIN( 588)									g227 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									g227 = (( (Float)(this387) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float b228;
HXDLIN( 588)								int this388 = (color32 & 255);
HXDLIN( 588)								if ((this388 == 0)) {
HXDLIN( 588)									b228 = ((Float)0.);
            								}
            								else {
HXDLIN( 588)									b228 = (( (Float)(this388) ) / ( (Float)(255) ));
            								}
HXDLIN( 588)								Float a327 = (a129 * (( (Float)(1) ) - a228));
HXDLIN( 588)								int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 588)								int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 588)								int b52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a327) + (b228 * a228))));
HXDLIN( 588)								int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 588)								int blended27 = ((((a57 << 24) | (r47 << 16)) | (g47 << 8)) | b52);
HXDLIN( 588)								{
HXDLIN( 588)									int _hx_tmp131;
HXDLIN( 588)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)										_hx_tmp131 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            									}
            									else {
HXDLIN( 588)										_hx_tmp131 = blended27;
            									}
HXDLIN( 588)									::iterMagic::Iimg_obj::set(out->image,location27,_hx_tmp131);
            								}
            							}
            							else {
HXDLIN( 588)								::Dynamic this389 = out->image;
HXDLIN( 588)								int index87;
HXDLIN( 588)								if (out->useVirtualPos) {
HXDLIN( 588)									index87 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXDLIN( 588)									index87 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 588)								int _hx_tmp132;
HXDLIN( 588)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 588)									_hx_tmp132 = ((((((c85 >> 24) & 255) << 24) | ((c85 & 255) << 16)) | (((c85 >> 8) & 255) << 8)) | ((c85 >> 16) & 255));
            								}
            								else {
HXDLIN( 588)									_hx_tmp132 = c85;
            								}
HXDLIN( 588)								::iterMagic::Iimg_obj::set(this389,index87,_hx_tmp132);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 588)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,gussianBlur_5x5,return )

 ::pi_xy::imageAbstracts::Mat5x5data Convolution_Impl__obj::unsharpenMask055data( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_593_unsharpenMask055data)
HXDLIN( 593)		return  ::pi_xy::imageAbstracts::Mat5x5data_obj::__alloc( HX_CTX ,((Float)-0.00390625),((Float)-0.015625),((Float)-0.0234375),((Float)-0.015625),((Float)-0.00390625),((Float)-0.015625),((Float)-0.0625),((Float)-0.09375),((Float)-0.0625),((Float)-0.015625),((Float)-0.0234375),((Float)-0.09375),((Float)-0.140625),((Float)-0.09375),((Float)-0.0234375),((Float)-0.015625),((Float)-0.0625),((Float)-0.09375),((Float)-0.0625),((Float)-0.015625),((Float)-0.00390625),((Float)-0.015625),((Float)-0.0234375),((Float)-0.015625),((Float)-0.00390625));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Convolution_Impl__obj,unsharpenMask055data,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::unsharpenMask0_5x5( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_602_unsharpenMask0_5x5)
HXDLIN( 602)		Float m55_a = ((Float)-0.00390625);
HXDLIN( 602)		Float m55_b = ((Float)-0.015625);
HXDLIN( 602)		Float m55_c = ((Float)-0.0234375);
HXDLIN( 602)		Float m55_d = ((Float)-0.015625);
HXDLIN( 602)		Float m55_e = ((Float)-0.00390625);
HXDLIN( 602)		Float m55_f = ((Float)-0.015625);
HXDLIN( 602)		Float m55_g = ((Float)-0.0625);
HXDLIN( 602)		Float m55_h = ((Float)-0.09375);
HXDLIN( 602)		Float m55_i = ((Float)-0.0625);
HXDLIN( 602)		Float m55_j = ((Float)-0.015625);
HXDLIN( 602)		Float m55_k = ((Float)-0.0234375);
HXDLIN( 602)		Float m55_l = ((Float)-0.09375);
HXDLIN( 602)		Float m55_m = ((Float)-0.140625);
HXDLIN( 602)		Float m55_n = ((Float)-0.09375);
HXDLIN( 602)		Float m55_o = ((Float)-0.0234375);
HXDLIN( 602)		Float m55_p = ((Float)-0.015625);
HXDLIN( 602)		Float m55_q = ((Float)-0.0625);
HXDLIN( 602)		Float m55_r = ((Float)-0.09375);
HXDLIN( 602)		Float m55_s = ((Float)-0.0625);
HXDLIN( 602)		Float m55_t = ((Float)-0.015625);
HXDLIN( 602)		Float m55_u = ((Float)-0.00390625);
HXDLIN( 602)		Float m55_v = ((Float)-0.015625);
HXDLIN( 602)		Float m55_w = ((Float)-0.0234375);
HXDLIN( 602)		Float m55_x = ((Float)-0.015625);
HXDLIN( 602)		Float m55_y = ((Float)-0.00390625);
HXDLIN( 602)		bool adjustRed = true;
HXDLIN( 602)		bool adjustGreen = true;
HXDLIN( 602)		bool adjustBlue = true;
HXDLIN( 602)		int a0 = 0;
HXDLIN( 602)		int b0 = 0;
HXDLIN( 602)		int c0 = 0;
HXDLIN( 602)		int d0 = 0;
HXDLIN( 602)		int e0 = 0;
HXDLIN( 602)		int f0 = 0;
HXDLIN( 602)		int g0 = 0;
HXDLIN( 602)		int h0 = 0;
HXDLIN( 602)		int i0 = 0;
HXDLIN( 602)		int j0 = 0;
HXDLIN( 602)		int k0 = 0;
HXDLIN( 602)		int l0 = 0;
HXDLIN( 602)		int m0 = 0;
HXDLIN( 602)		int n0 = 0;
HXDLIN( 602)		int o0 = 0;
HXDLIN( 602)		int p0 = 0;
HXDLIN( 602)		int q0 = 0;
HXDLIN( 602)		int r0 = 0;
HXDLIN( 602)		int s0 = 0;
HXDLIN( 602)		int t0 = 0;
HXDLIN( 602)		int u0 = 0;
HXDLIN( 602)		int v0 = 0;
HXDLIN( 602)		int w0 = 0;
HXDLIN( 602)		int x0 = 0;
HXDLIN( 602)		int y0 = 0;
HXDLIN( 602)		Float r_ = ((Float)0.);
HXDLIN( 602)		Float g_ = ((Float)0.);
HXDLIN( 602)		Float b_ = ((Float)0.);
HXDLIN( 602)		Float a_ = ((Float)0.);
HXDLIN( 602)		int width = this1->width;
HXDLIN( 602)		int height = this1->height;
HXDLIN( 602)		 ::Dynamic imageType = null();
HXDLIN( 602)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 602)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 602)		::Dynamic _hx_tmp;
HXDLIN( 602)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 602)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 602)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 602)				{
HXDLIN( 602)					b->width = width;
HXDLIN( 602)					b->height = height;
HXDLIN( 602)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 602)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 602)					{
HXDLIN( 602)						int len = b->length;
HXDLIN( 602)						int w = 0;
HXDLIN( 602)						{
HXDLIN( 602)							int _g = 0;
HXDLIN( 602)							int _g1 = b->height;
HXDLIN( 602)							while((_g < _g1)){
HXDLIN( 602)								_g = (_g + 1);
HXDLIN( 602)								int y = (_g - 1);
HXDLIN( 602)								{
HXDLIN( 602)									int _g2 = 0;
HXDLIN( 602)									int _g3 = b->width;
HXDLIN( 602)									while((_g2 < _g3)){
HXDLIN( 602)										_g2 = (_g2 + 1);
HXDLIN( 602)										int x = (_g2 - 1);
HXDLIN( 602)										{
HXDLIN( 602)											w = (w + 1);
HXDLIN( 602)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 602)										{
HXDLIN( 602)											w = (w + 1);
HXDLIN( 602)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 602)										{
HXDLIN( 602)											w = (w + 1);
HXDLIN( 602)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 602)										{
HXDLIN( 602)											w = (w + 1);
HXDLIN( 602)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 602)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 602)				{
HXDLIN( 602)					a->width = width;
HXDLIN( 602)					a->height = height;
HXDLIN( 602)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 602)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 602)					{
HXDLIN( 602)						int _g4 = 0;
HXDLIN( 602)						int _g5 = a->length;
HXDLIN( 602)						while((_g4 < _g5)){
HXDLIN( 602)							_g4 = (_g4 + 1);
HXDLIN( 602)							int i = (_g4 - 1);
HXDLIN( 602)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 602)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 602)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 602)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 602)				{
HXDLIN( 602)					b1->width = width;
HXDLIN( 602)					b1->height = height;
HXDLIN( 602)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 602)					int size = (b1->length * 4);
HXDLIN( 602)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 602)					{
HXDLIN( 602)						int _g6 = 0;
HXDLIN( 602)						int _g7 = b1->length;
HXDLIN( 602)						while((_g6 < _g7)){
HXDLIN( 602)							_g6 = (_g6 + 1);
HXDLIN( 602)							int i1 = (_g6 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 602)								bool _hx_tmp1;
HXDLIN( 602)								if ((i1 >= 0)) {
HXDLIN( 602)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 602)									_hx_tmp1 = false;
            								}
HXDLIN( 602)								if (_hx_tmp1) {
HXDLIN( 602)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 602)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 602)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 602)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 602)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 602)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 602)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 602)				{
HXDLIN( 602)					v->width = width;
HXDLIN( 602)					v->height = height;
HXDLIN( 602)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 602)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 602)					{
HXDLIN( 602)						int _g8 = 0;
HXDLIN( 602)						int _g9 = v->length;
HXDLIN( 602)						while((_g8 < _g9)){
HXDLIN( 602)							_g8 = (_g8 + 1);
HXDLIN( 602)							int i2 = (_g8 - 1);
HXDLIN( 602)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 602)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 602)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 602)				{
HXDLIN( 602)					b2->width = width;
HXDLIN( 602)					b2->height = height;
HXDLIN( 602)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 602)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 602)					{
HXDLIN( 602)						int len1 = b2->length;
HXDLIN( 602)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 602)						if (::hx::IsNull( d->head )) {
HXDLIN( 602)							int _g10 = 0;
HXDLIN( 602)							int _g11 = len1;
HXDLIN( 602)							while((_g10 < _g11)){
HXDLIN( 602)								_g10 = (_g10 + 1);
HXDLIN( 602)								int i3 = (_g10 - 1);
HXDLIN( 602)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 602)							int _g12 = 0;
HXDLIN( 602)							int _g13 = len1;
HXDLIN( 602)							while((_g12 < _g13)){
HXDLIN( 602)								_g12 = (_g12 + 1);
HXDLIN( 602)								int i4 = (_g12 - 1);
HXDLIN( 602)								{
HXDLIN( 602)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 602)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 602)									{
HXDLIN( 602)										int _g14 = 0;
HXDLIN( 602)										int _g15 = i4;
HXDLIN( 602)										while((_g14 < _g15)){
HXDLIN( 602)											_g14 = (_g14 + 1);
HXDLIN( 602)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 602)									if (::hx::IsNull( prev )) {
HXDLIN( 602)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 602)										l = null();
            									}
            									else {
HXDLIN( 602)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 602)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 602)		this2->image = _hx_tmp;
HXDLIN( 602)		this2->width = width;
HXDLIN( 602)		this2->height = height;
HXDLIN( 602)		this2->imageType = ( (int)(imageType) );
HXDLIN( 602)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 602)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 602)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 602)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 602)				int width1 = (this4->width + 4);
HXDLIN( 602)				int height1 = (this4->height + 4);
HXDLIN( 602)				 ::Dynamic imageType1 = null();
HXDLIN( 602)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 602)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 602)				::Dynamic here1;
HXDLIN( 602)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 602)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 602)						{
HXDLIN( 602)							b3->width = width1;
HXDLIN( 602)							b3->height = height1;
HXDLIN( 602)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 602)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 602)							{
HXDLIN( 602)								int len2 = b3->length;
HXDLIN( 602)								int w1 = 0;
HXDLIN( 602)								{
HXDLIN( 602)									int _g16 = 0;
HXDLIN( 602)									int _g17 = b3->height;
HXDLIN( 602)									while((_g16 < _g17)){
HXDLIN( 602)										_g16 = (_g16 + 1);
HXDLIN( 602)										int y1 = (_g16 - 1);
HXDLIN( 602)										{
HXDLIN( 602)											int _g18 = 0;
HXDLIN( 602)											int _g19 = b3->width;
HXDLIN( 602)											while((_g18 < _g19)){
HXDLIN( 602)												_g18 = (_g18 + 1);
HXDLIN( 602)												int x1 = (_g18 - 1);
HXDLIN( 602)												{
HXDLIN( 602)													w1 = (w1 + 1);
HXDLIN( 602)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w1 = (w1 + 1);
HXDLIN( 602)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w1 = (w1 + 1);
HXDLIN( 602)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w1 = (w1 + 1);
HXDLIN( 602)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 602)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 602)						{
HXDLIN( 602)							a1->width = width1;
HXDLIN( 602)							a1->height = height1;
HXDLIN( 602)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 602)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 602)							{
HXDLIN( 602)								int _g20 = 0;
HXDLIN( 602)								int _g21 = a1->length;
HXDLIN( 602)								while((_g20 < _g21)){
HXDLIN( 602)									_g20 = (_g20 + 1);
HXDLIN( 602)									int i6 = (_g20 - 1);
HXDLIN( 602)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 602)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 602)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 602)						{
HXDLIN( 602)							b4->width = width1;
HXDLIN( 602)							b4->height = height1;
HXDLIN( 602)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 602)							int size1 = (b4->length * 4);
HXDLIN( 602)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 602)							{
HXDLIN( 602)								int _g22 = 0;
HXDLIN( 602)								int _g23 = b4->length;
HXDLIN( 602)								while((_g22 < _g23)){
HXDLIN( 602)									_g22 = (_g22 + 1);
HXDLIN( 602)									int i7 = (_g22 - 1);
HXDLIN( 602)									{
HXDLIN( 602)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 602)										bool here2;
HXDLIN( 602)										if ((i7 >= 0)) {
HXDLIN( 602)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 602)											here2 = false;
            										}
HXDLIN( 602)										if (here2) {
HXDLIN( 602)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 602)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 602)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 602)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 602)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 602)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 602)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 602)						{
HXDLIN( 602)							v1->width = width1;
HXDLIN( 602)							v1->height = height1;
HXDLIN( 602)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 602)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 602)							{
HXDLIN( 602)								int _g24 = 0;
HXDLIN( 602)								int _g25 = v1->length;
HXDLIN( 602)								while((_g24 < _g25)){
HXDLIN( 602)									_g24 = (_g24 + 1);
HXDLIN( 602)									int i8 = (_g24 - 1);
HXDLIN( 602)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 602)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 602)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 602)						{
HXDLIN( 602)							b5->width = width1;
HXDLIN( 602)							b5->height = height1;
HXDLIN( 602)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 602)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 602)							{
HXDLIN( 602)								int len3 = b5->length;
HXDLIN( 602)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 602)								if (::hx::IsNull( d1->head )) {
HXDLIN( 602)									int _g26 = 0;
HXDLIN( 602)									int _g27 = len3;
HXDLIN( 602)									while((_g26 < _g27)){
HXDLIN( 602)										_g26 = (_g26 + 1);
HXDLIN( 602)										int i9 = (_g26 - 1);
HXDLIN( 602)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 602)									int _g28 = 0;
HXDLIN( 602)									int _g29 = len3;
HXDLIN( 602)									while((_g28 < _g29)){
HXDLIN( 602)										_g28 = (_g28 + 1);
HXDLIN( 602)										int i10 = (_g28 - 1);
HXDLIN( 602)										{
HXDLIN( 602)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 602)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 602)											{
HXDLIN( 602)												int _g30 = 0;
HXDLIN( 602)												int _g31 = i10;
HXDLIN( 602)												while((_g30 < _g31)){
HXDLIN( 602)													_g30 = (_g30 + 1);
HXDLIN( 602)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 602)											if (::hx::IsNull( prev1 )) {
HXDLIN( 602)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 602)												l1 = null();
            											}
            											else {
HXDLIN( 602)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 602)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 602)				this5->image = here1;
HXDLIN( 602)				this5->width = width1;
HXDLIN( 602)				this5->height = height1;
HXDLIN( 602)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 602)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 602)				bool forceClear = false;
HXDLIN( 602)				int _g32 = 0;
HXDLIN( 602)				int _g33 = this4->height;
HXDLIN( 602)				while((_g32 < _g33)){
HXDLIN( 602)					_g32 = (_g32 + 1);
HXDLIN( 602)					int dy = (_g32 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g34 = 0;
HXDLIN( 602)						int _g35 = this4->width;
HXDLIN( 602)						while((_g34 < _g35)){
HXDLIN( 602)							_g34 = (_g34 + 1);
HXDLIN( 602)							int dx = (_g34 - 1);
HXDLIN( 602)							::Dynamic this7 = this4->image;
HXDLIN( 602)							int index;
HXDLIN( 602)							if (this4->useVirtualPos) {
HXDLIN( 602)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 602)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 602)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 602)							int col;
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								col = c;
            							}
HXDLIN( 602)							bool here3;
HXDLIN( 602)							if (this4->useMask) {
HXDLIN( 602)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 602)								here3 = false;
            							}
HXDLIN( 602)							if (here3) {
HXDLIN( 602)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 602)								::Dynamic this9 = this8->image;
HXDLIN( 602)								int index1;
HXDLIN( 602)								if (this8->useVirtualPos) {
HXDLIN( 602)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 602)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 602)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 602)								int v2;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									v2 = c1;
            								}
HXDLIN( 602)								int maskPixel = v2;
HXDLIN( 602)								int this10 = col;
HXDLIN( 602)								if ((maskPixel == 0)) {
HXDLIN( 602)									col = this10;
            								}
            								else {
HXDLIN( 602)									Float m01;
HXDLIN( 602)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 602)									if ((this11 == 0)) {
HXDLIN( 602)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m01 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m1;
HXDLIN( 602)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 602)									if ((this12 == 0)) {
HXDLIN( 602)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m2;
HXDLIN( 602)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 602)									if ((this13 == 0)) {
HXDLIN( 602)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m3;
HXDLIN( 602)									int this14 = (maskPixel & 255);
HXDLIN( 602)									if ((this14 == 0)) {
HXDLIN( 602)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 602)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 602)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 602)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 602)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 602)							if ((col != 0)) {
HXDLIN( 602)								int x2 = (2 + dx);
HXDLIN( 602)								int y2 = (2 + dy);
HXDLIN( 602)								int c2 = col;
HXDLIN( 602)								bool here4;
HXDLIN( 602)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 602)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 602)									here4 = false;
            								}
HXDLIN( 602)								if (here4) {
HXDLIN( 602)									int location;
HXDLIN( 602)									if (img->useVirtualPos) {
HXDLIN( 602)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 602)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 602)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 602)									int this16;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										this16 = this15;
            									}
HXDLIN( 602)									Float a11;
HXDLIN( 602)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 602)									if ((this17 == 0)) {
HXDLIN( 602)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r1;
HXDLIN( 602)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 602)									if ((this18 == 0)) {
HXDLIN( 602)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g1;
HXDLIN( 602)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 602)									if ((this19 == 0)) {
HXDLIN( 602)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b11;
HXDLIN( 602)									int this20 = (this16 & 255);
HXDLIN( 602)									if ((this20 == 0)) {
HXDLIN( 602)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a2;
HXDLIN( 602)									int this21 = ((col >> 24) & 255);
HXDLIN( 602)									if ((this21 == 0)) {
HXDLIN( 602)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r2;
HXDLIN( 602)									int this22 = ((col >> 16) & 255);
HXDLIN( 602)									if ((this22 == 0)) {
HXDLIN( 602)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g2;
HXDLIN( 602)									int this23 = ((col >> 8) & 255);
HXDLIN( 602)									if ((this23 == 0)) {
HXDLIN( 602)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b21;
HXDLIN( 602)									int this24 = (col & 255);
HXDLIN( 602)									if ((this24 == 0)) {
HXDLIN( 602)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 602)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 602)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 602)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 602)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 602)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 602)									{
HXDLIN( 602)										int here5;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here5 = blended;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 602)									::Dynamic this25 = img->image;
HXDLIN( 602)									int index2;
HXDLIN( 602)									if (img->useVirtualPos) {
HXDLIN( 602)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 602)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 602)									int here6;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										here6 = c2;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 602)								if (forceClear) {
HXDLIN( 602)									::Dynamic this26 = img->image;
HXDLIN( 602)									int x3 = (2 + dx);
HXDLIN( 602)									int y3 = (2 + dy);
HXDLIN( 602)									int index3;
HXDLIN( 602)									if (img->useVirtualPos) {
HXDLIN( 602)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 602)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g36 = 0;
HXDLIN( 602)				int _g37 = this4->width;
HXDLIN( 602)				while((_g36 < _g37)){
HXDLIN( 602)					_g36 = (_g36 + 1);
HXDLIN( 602)					int x4 = (_g36 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g38 = 0;
HXDLIN( 602)						int _g39 = 2;
HXDLIN( 602)						while((_g38 < _g39)){
HXDLIN( 602)							_g38 = (_g38 + 1);
HXDLIN( 602)							int y4 = (_g38 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								int x5 = (x4 + 2);
HXDLIN( 602)								::Dynamic this27 = this4->image;
HXDLIN( 602)								int index4;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 602)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 602)								int color;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color = c3;
            								}
HXDLIN( 602)								int color1 = color;
HXDLIN( 602)								{
HXDLIN( 602)									int c4 = color1;
HXDLIN( 602)									bool here7;
HXDLIN( 602)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 602)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here7 = false;
            									}
HXDLIN( 602)									if (here7) {
HXDLIN( 602)										int location1;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 602)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 602)										int this29;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this29 = this28;
            										}
HXDLIN( 602)										Float a12;
HXDLIN( 602)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 602)										if ((this30 == 0)) {
HXDLIN( 602)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r11;
HXDLIN( 602)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 602)										if ((this31 == 0)) {
HXDLIN( 602)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g11;
HXDLIN( 602)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 602)										if ((this32 == 0)) {
HXDLIN( 602)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b12;
HXDLIN( 602)										int this33 = (this29 & 255);
HXDLIN( 602)										if ((this33 == 0)) {
HXDLIN( 602)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a21;
HXDLIN( 602)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 602)										if ((this34 == 0)) {
HXDLIN( 602)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r21;
HXDLIN( 602)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 602)										if ((this35 == 0)) {
HXDLIN( 602)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g21;
HXDLIN( 602)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 602)										if ((this36 == 0)) {
HXDLIN( 602)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b22;
HXDLIN( 602)										int this37 = (color1 & 255);
HXDLIN( 602)										if ((this37 == 0)) {
HXDLIN( 602)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 602)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 602)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 602)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 602)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 602)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 602)										{
HXDLIN( 602)											int here8;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here8 = blended1;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this38 = img->image;
HXDLIN( 602)										int index5;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 602)										int here9;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here9 = c4;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x6 = (x4 + 2);
HXDLIN( 602)								int y5 = ((img->height - y4) - 1);
HXDLIN( 602)								int y6 = (this4->height - 1);
HXDLIN( 602)								::Dynamic this39 = this4->image;
HXDLIN( 602)								int index6;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 602)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 602)								int color2;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color2 = c5;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c6 = color2;
HXDLIN( 602)									bool here10;
HXDLIN( 602)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 602)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here10 = false;
            									}
HXDLIN( 602)									if (here10) {
HXDLIN( 602)										int location2;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 602)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 602)										int this41;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this41 = this40;
            										}
HXDLIN( 602)										Float a13;
HXDLIN( 602)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 602)										if ((this42 == 0)) {
HXDLIN( 602)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r12;
HXDLIN( 602)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 602)										if ((this43 == 0)) {
HXDLIN( 602)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g12;
HXDLIN( 602)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 602)										if ((this44 == 0)) {
HXDLIN( 602)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b13;
HXDLIN( 602)										int this45 = (this41 & 255);
HXDLIN( 602)										if ((this45 == 0)) {
HXDLIN( 602)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a22;
HXDLIN( 602)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 602)										if ((this46 == 0)) {
HXDLIN( 602)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r22;
HXDLIN( 602)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 602)										if ((this47 == 0)) {
HXDLIN( 602)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g22;
HXDLIN( 602)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 602)										if ((this48 == 0)) {
HXDLIN( 602)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b23;
HXDLIN( 602)										int this49 = (color2 & 255);
HXDLIN( 602)										if ((this49 == 0)) {
HXDLIN( 602)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 602)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 602)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 602)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 602)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 602)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 602)										{
HXDLIN( 602)											int here11;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here11 = blended2;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this50 = img->image;
HXDLIN( 602)										int index7;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 602)										int here12;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here12 = c6;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g40 = 0;
HXDLIN( 602)				int _g41 = this4->height;
HXDLIN( 602)				while((_g40 < _g41)){
HXDLIN( 602)					_g40 = (_g40 + 1);
HXDLIN( 602)					int y7 = (_g40 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g42 = 0;
HXDLIN( 602)						int _g43 = 2;
HXDLIN( 602)						while((_g42 < _g43)){
HXDLIN( 602)							_g42 = (_g42 + 1);
HXDLIN( 602)							int x7 = (_g42 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								int y8 = (y7 + 2);
HXDLIN( 602)								::Dynamic this51 = this4->image;
HXDLIN( 602)								int index8;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 602)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 602)								int color3;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color3 = c7;
            								}
HXDLIN( 602)								int color4 = color3;
HXDLIN( 602)								{
HXDLIN( 602)									int c8 = color4;
HXDLIN( 602)									bool here13;
HXDLIN( 602)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 602)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here13 = false;
            									}
HXDLIN( 602)									if (here13) {
HXDLIN( 602)										int location3;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 602)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 602)										int this53;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this53 = this52;
            										}
HXDLIN( 602)										Float a14;
HXDLIN( 602)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 602)										if ((this54 == 0)) {
HXDLIN( 602)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r13;
HXDLIN( 602)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 602)										if ((this55 == 0)) {
HXDLIN( 602)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g13;
HXDLIN( 602)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 602)										if ((this56 == 0)) {
HXDLIN( 602)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b14;
HXDLIN( 602)										int this57 = (this53 & 255);
HXDLIN( 602)										if ((this57 == 0)) {
HXDLIN( 602)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a23;
HXDLIN( 602)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 602)										if ((this58 == 0)) {
HXDLIN( 602)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r23;
HXDLIN( 602)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 602)										if ((this59 == 0)) {
HXDLIN( 602)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g23;
HXDLIN( 602)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 602)										if ((this60 == 0)) {
HXDLIN( 602)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b24;
HXDLIN( 602)										int this61 = (color4 & 255);
HXDLIN( 602)										if ((this61 == 0)) {
HXDLIN( 602)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 602)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 602)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 602)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 602)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 602)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 602)										{
HXDLIN( 602)											int here14;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here14 = blended3;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this62 = img->image;
HXDLIN( 602)										int index9;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 602)										int here15;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here15 = c8;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x8 = ((img->width - x7) - 1);
HXDLIN( 602)								int y9 = (y7 + 2);
HXDLIN( 602)								int x9 = (this4->width - 1);
HXDLIN( 602)								::Dynamic this63 = this4->image;
HXDLIN( 602)								int index10;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 602)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 602)								int color5;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color5 = c9;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c10 = color5;
HXDLIN( 602)									bool here16;
HXDLIN( 602)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 602)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here16 = false;
            									}
HXDLIN( 602)									if (here16) {
HXDLIN( 602)										int location4;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 602)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 602)										int this65;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this65 = this64;
            										}
HXDLIN( 602)										Float a15;
HXDLIN( 602)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 602)										if ((this66 == 0)) {
HXDLIN( 602)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r14;
HXDLIN( 602)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 602)										if ((this67 == 0)) {
HXDLIN( 602)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g14;
HXDLIN( 602)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 602)										if ((this68 == 0)) {
HXDLIN( 602)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b15;
HXDLIN( 602)										int this69 = (this65 & 255);
HXDLIN( 602)										if ((this69 == 0)) {
HXDLIN( 602)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a24;
HXDLIN( 602)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 602)										if ((this70 == 0)) {
HXDLIN( 602)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r24;
HXDLIN( 602)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 602)										if ((this71 == 0)) {
HXDLIN( 602)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g24;
HXDLIN( 602)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 602)										if ((this72 == 0)) {
HXDLIN( 602)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b25;
HXDLIN( 602)										int this73 = (color5 & 255);
HXDLIN( 602)										if ((this73 == 0)) {
HXDLIN( 602)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 602)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 602)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 602)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 602)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 602)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 602)										{
HXDLIN( 602)											int here17;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here17 = blended4;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this74 = img->image;
HXDLIN( 602)										int index11;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 602)										int here18;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here18 = c10;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g44 = 0;
HXDLIN( 602)				int _g45 = 2;
HXDLIN( 602)				while((_g44 < _g45)){
HXDLIN( 602)					_g44 = (_g44 + 1);
HXDLIN( 602)					int x10 = (_g44 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g46 = 0;
HXDLIN( 602)						int _g47 = 2;
HXDLIN( 602)						while((_g46 < _g47)){
HXDLIN( 602)							_g46 = (_g46 + 1);
HXDLIN( 602)							int y10 = (_g46 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								::Dynamic this75 = this4->image;
HXDLIN( 602)								int index12;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 602)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 602)								int color6;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color6 = c11;
            								}
HXDLIN( 602)								int color7 = color6;
HXDLIN( 602)								{
HXDLIN( 602)									int c12 = color7;
HXDLIN( 602)									bool here19;
HXDLIN( 602)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 602)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here19 = false;
            									}
HXDLIN( 602)									if (here19) {
HXDLIN( 602)										int location5;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 602)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 602)										int this77;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this77 = this76;
            										}
HXDLIN( 602)										Float a16;
HXDLIN( 602)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 602)										if ((this78 == 0)) {
HXDLIN( 602)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r15;
HXDLIN( 602)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 602)										if ((this79 == 0)) {
HXDLIN( 602)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g15;
HXDLIN( 602)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 602)										if ((this80 == 0)) {
HXDLIN( 602)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b16;
HXDLIN( 602)										int this81 = (this77 & 255);
HXDLIN( 602)										if ((this81 == 0)) {
HXDLIN( 602)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a25;
HXDLIN( 602)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 602)										if ((this82 == 0)) {
HXDLIN( 602)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r25;
HXDLIN( 602)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 602)										if ((this83 == 0)) {
HXDLIN( 602)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g25;
HXDLIN( 602)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 602)										if ((this84 == 0)) {
HXDLIN( 602)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b26;
HXDLIN( 602)										int this85 = (color7 & 255);
HXDLIN( 602)										if ((this85 == 0)) {
HXDLIN( 602)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 602)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 602)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 602)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 602)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 602)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 602)										{
HXDLIN( 602)											int here20;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here20 = blended5;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this86 = img->image;
HXDLIN( 602)										int index13;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 602)										int here21;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here21 = c12;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x11 = ((x10 + 2) + this4->width);
HXDLIN( 602)								int x12 = (this4->width - 1);
HXDLIN( 602)								::Dynamic this87 = this4->image;
HXDLIN( 602)								int index14;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 602)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 602)								int color8;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color8 = c13;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c14 = color8;
HXDLIN( 602)									bool here22;
HXDLIN( 602)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 602)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here22 = false;
            									}
HXDLIN( 602)									if (here22) {
HXDLIN( 602)										int location6;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 602)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 602)										int this89;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this89 = this88;
            										}
HXDLIN( 602)										Float a17;
HXDLIN( 602)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 602)										if ((this90 == 0)) {
HXDLIN( 602)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r16;
HXDLIN( 602)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 602)										if ((this91 == 0)) {
HXDLIN( 602)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g16;
HXDLIN( 602)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 602)										if ((this92 == 0)) {
HXDLIN( 602)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b18;
HXDLIN( 602)										int this93 = (this89 & 255);
HXDLIN( 602)										if ((this93 == 0)) {
HXDLIN( 602)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a26;
HXDLIN( 602)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 602)										if ((this94 == 0)) {
HXDLIN( 602)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r26;
HXDLIN( 602)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 602)										if ((this95 == 0)) {
HXDLIN( 602)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g26;
HXDLIN( 602)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 602)										if ((this96 == 0)) {
HXDLIN( 602)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b27;
HXDLIN( 602)										int this97 = (color8 & 255);
HXDLIN( 602)										if ((this97 == 0)) {
HXDLIN( 602)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 602)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 602)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 602)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 602)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 602)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 602)										{
HXDLIN( 602)											int here23;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here23 = blended6;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this98 = img->image;
HXDLIN( 602)										int index15;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 602)										int here24;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here24 = c14;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x13 = ((x10 + 2) + this4->width);
HXDLIN( 602)								int y11 = ((y10 + 2) + this4->height);
HXDLIN( 602)								int x14 = (this4->width - 1);
HXDLIN( 602)								int y12 = (this4->height - 1);
HXDLIN( 602)								::Dynamic this99 = this4->image;
HXDLIN( 602)								int index16;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 602)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 602)								int color9;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color9 = c15;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c16 = color9;
HXDLIN( 602)									bool here25;
HXDLIN( 602)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 602)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here25 = false;
            									}
HXDLIN( 602)									if (here25) {
HXDLIN( 602)										int location7;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 602)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 602)										int this101;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this101 = this100;
            										}
HXDLIN( 602)										Float a18;
HXDLIN( 602)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 602)										if ((this102 == 0)) {
HXDLIN( 602)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r17;
HXDLIN( 602)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 602)										if ((this103 == 0)) {
HXDLIN( 602)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g17;
HXDLIN( 602)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 602)										if ((this104 == 0)) {
HXDLIN( 602)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b110;
HXDLIN( 602)										int this105 = (this101 & 255);
HXDLIN( 602)										if ((this105 == 0)) {
HXDLIN( 602)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a27;
HXDLIN( 602)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 602)										if ((this106 == 0)) {
HXDLIN( 602)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r27;
HXDLIN( 602)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 602)										if ((this107 == 0)) {
HXDLIN( 602)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g27;
HXDLIN( 602)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 602)										if ((this108 == 0)) {
HXDLIN( 602)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b28;
HXDLIN( 602)										int this109 = (color9 & 255);
HXDLIN( 602)										if ((this109 == 0)) {
HXDLIN( 602)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 602)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 602)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 602)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 602)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 602)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 602)										{
HXDLIN( 602)											int here26;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here26 = blended7;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this110 = img->image;
HXDLIN( 602)										int index17;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 602)										int here27;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here27 = c16;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int y13 = ((y10 + 2) + this4->width);
HXDLIN( 602)								int y14 = (this4->height - 1);
HXDLIN( 602)								::Dynamic this111 = this4->image;
HXDLIN( 602)								int index18;
HXDLIN( 602)								if (this4->useVirtualPos) {
HXDLIN( 602)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 602)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 602)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 602)								int color10;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color10 = c17;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c18 = color10;
HXDLIN( 602)									bool here28;
HXDLIN( 602)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 602)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 602)										here28 = false;
            									}
HXDLIN( 602)									if (here28) {
HXDLIN( 602)										int location8;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 602)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 602)										int this113;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this113 = this112;
            										}
HXDLIN( 602)										Float a110;
HXDLIN( 602)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 602)										if ((this114 == 0)) {
HXDLIN( 602)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r18;
HXDLIN( 602)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 602)										if ((this115 == 0)) {
HXDLIN( 602)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g18;
HXDLIN( 602)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 602)										if ((this116 == 0)) {
HXDLIN( 602)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b111;
HXDLIN( 602)										int this117 = (this113 & 255);
HXDLIN( 602)										if ((this117 == 0)) {
HXDLIN( 602)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a28;
HXDLIN( 602)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 602)										if ((this118 == 0)) {
HXDLIN( 602)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r28;
HXDLIN( 602)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 602)										if ((this119 == 0)) {
HXDLIN( 602)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g28;
HXDLIN( 602)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 602)										if ((this120 == 0)) {
HXDLIN( 602)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b29;
HXDLIN( 602)										int this121 = (color10 & 255);
HXDLIN( 602)										if ((this121 == 0)) {
HXDLIN( 602)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 602)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 602)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 602)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 602)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 602)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 602)										{
HXDLIN( 602)											int here29;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here29 = blended8;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this122 = img->image;
HXDLIN( 602)										int index19;
HXDLIN( 602)										if (img->useVirtualPos) {
HXDLIN( 602)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 602)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 602)										int here30;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here30 = c18;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 602)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 602)				int width2 = (this123->width + 4);
HXDLIN( 602)				int height2 = (this123->height + 4);
HXDLIN( 602)				 ::Dynamic imageType2 = null();
HXDLIN( 602)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 602)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 602)				::Dynamic here31;
HXDLIN( 602)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 602)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 602)						{
HXDLIN( 602)							b31->width = width2;
HXDLIN( 602)							b31->height = height2;
HXDLIN( 602)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 602)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 602)							{
HXDLIN( 602)								int len4 = b31->length;
HXDLIN( 602)								int w2 = 0;
HXDLIN( 602)								{
HXDLIN( 602)									int _g48 = 0;
HXDLIN( 602)									int _g49 = b31->height;
HXDLIN( 602)									while((_g48 < _g49)){
HXDLIN( 602)										_g48 = (_g48 + 1);
HXDLIN( 602)										int y15 = (_g48 - 1);
HXDLIN( 602)										{
HXDLIN( 602)											int _g50 = 0;
HXDLIN( 602)											int _g51 = b31->width;
HXDLIN( 602)											while((_g50 < _g51)){
HXDLIN( 602)												_g50 = (_g50 + 1);
HXDLIN( 602)												int x15 = (_g50 - 1);
HXDLIN( 602)												{
HXDLIN( 602)													w2 = (w2 + 1);
HXDLIN( 602)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w2 = (w2 + 1);
HXDLIN( 602)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w2 = (w2 + 1);
HXDLIN( 602)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 602)												{
HXDLIN( 602)													w2 = (w2 + 1);
HXDLIN( 602)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 602)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 602)						{
HXDLIN( 602)							a29->width = width2;
HXDLIN( 602)							a29->height = height2;
HXDLIN( 602)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 602)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 602)							{
HXDLIN( 602)								int _g52 = 0;
HXDLIN( 602)								int _g53 = a29->length;
HXDLIN( 602)								while((_g52 < _g53)){
HXDLIN( 602)									_g52 = (_g52 + 1);
HXDLIN( 602)									int i12 = (_g52 - 1);
HXDLIN( 602)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 602)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 602)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 602)						{
HXDLIN( 602)							b32->width = width2;
HXDLIN( 602)							b32->height = height2;
HXDLIN( 602)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 602)							int size2 = (b32->length * 4);
HXDLIN( 602)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 602)							{
HXDLIN( 602)								int _g54 = 0;
HXDLIN( 602)								int _g55 = b32->length;
HXDLIN( 602)								while((_g54 < _g55)){
HXDLIN( 602)									_g54 = (_g54 + 1);
HXDLIN( 602)									int i13 = (_g54 - 1);
HXDLIN( 602)									{
HXDLIN( 602)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 602)										bool here32;
HXDLIN( 602)										if ((i13 >= 0)) {
HXDLIN( 602)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 602)											here32 = false;
            										}
HXDLIN( 602)										if (here32) {
HXDLIN( 602)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 602)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 602)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 602)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 602)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 602)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 602)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 602)						{
HXDLIN( 602)							v3->width = width2;
HXDLIN( 602)							v3->height = height2;
HXDLIN( 602)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 602)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 602)							{
HXDLIN( 602)								int _g56 = 0;
HXDLIN( 602)								int _g57 = v3->length;
HXDLIN( 602)								while((_g56 < _g57)){
HXDLIN( 602)									_g56 = (_g56 + 1);
HXDLIN( 602)									int i14 = (_g56 - 1);
HXDLIN( 602)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 602)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 602)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 602)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 602)						{
HXDLIN( 602)							b33->width = width2;
HXDLIN( 602)							b33->height = height2;
HXDLIN( 602)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 602)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 602)							{
HXDLIN( 602)								int len5 = b33->length;
HXDLIN( 602)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 602)								if (::hx::IsNull( d2->head )) {
HXDLIN( 602)									int _g58 = 0;
HXDLIN( 602)									int _g59 = len5;
HXDLIN( 602)									while((_g58 < _g59)){
HXDLIN( 602)										_g58 = (_g58 + 1);
HXDLIN( 602)										int i15 = (_g58 - 1);
HXDLIN( 602)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 602)									int _g60 = 0;
HXDLIN( 602)									int _g61 = len5;
HXDLIN( 602)									while((_g60 < _g61)){
HXDLIN( 602)										_g60 = (_g60 + 1);
HXDLIN( 602)										int i16 = (_g60 - 1);
HXDLIN( 602)										{
HXDLIN( 602)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 602)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 602)											{
HXDLIN( 602)												int _g62 = 0;
HXDLIN( 602)												int _g63 = i16;
HXDLIN( 602)												while((_g62 < _g63)){
HXDLIN( 602)													_g62 = (_g62 + 1);
HXDLIN( 602)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 602)											if (::hx::IsNull( prev2 )) {
HXDLIN( 602)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 602)												l2 = null();
            											}
            											else {
HXDLIN( 602)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 602)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 602)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 602)				this124->image = here31;
HXDLIN( 602)				this124->width = width2;
HXDLIN( 602)				this124->height = height2;
HXDLIN( 602)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 602)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 602)				bool forceClear1 = false;
HXDLIN( 602)				int _g64 = 0;
HXDLIN( 602)				int _g65 = this123->height;
HXDLIN( 602)				while((_g64 < _g65)){
HXDLIN( 602)					_g64 = (_g64 + 1);
HXDLIN( 602)					int dy1 = (_g64 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g66 = 0;
HXDLIN( 602)						int _g67 = this123->width;
HXDLIN( 602)						while((_g66 < _g67)){
HXDLIN( 602)							_g66 = (_g66 + 1);
HXDLIN( 602)							int dx1 = (_g66 - 1);
HXDLIN( 602)							::Dynamic this126 = this123->image;
HXDLIN( 602)							int index20;
HXDLIN( 602)							if (this123->useVirtualPos) {
HXDLIN( 602)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 602)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 602)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 602)							int col1;
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								col1 = c19;
            							}
HXDLIN( 602)							bool here33;
HXDLIN( 602)							if (this123->useMask) {
HXDLIN( 602)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 602)								here33 = false;
            							}
HXDLIN( 602)							if (here33) {
HXDLIN( 602)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 602)								::Dynamic this128 = this127->image;
HXDLIN( 602)								int index21;
HXDLIN( 602)								if (this127->useVirtualPos) {
HXDLIN( 602)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 602)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 602)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 602)								int v4;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									v4 = c20;
            								}
HXDLIN( 602)								int maskPixel1 = v4;
HXDLIN( 602)								int this129 = col1;
HXDLIN( 602)								if ((maskPixel1 == 0)) {
HXDLIN( 602)									col1 = this129;
            								}
            								else {
HXDLIN( 602)									Float m02;
HXDLIN( 602)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 602)									if ((this130 == 0)) {
HXDLIN( 602)										m02 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m02 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m11;
HXDLIN( 602)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 602)									if ((this131 == 0)) {
HXDLIN( 602)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m21;
HXDLIN( 602)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 602)									if ((this132 == 0)) {
HXDLIN( 602)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float m31;
HXDLIN( 602)									int this133 = (maskPixel1 & 255);
HXDLIN( 602)									if ((this133 == 0)) {
HXDLIN( 602)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 602)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 602)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 602)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 602)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 602)							if ((col1 != 0)) {
HXDLIN( 602)								int x16 = (2 + dx1);
HXDLIN( 602)								int y16 = (2 + dy1);
HXDLIN( 602)								int c21 = col1;
HXDLIN( 602)								bool here34;
HXDLIN( 602)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 602)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 602)									here34 = false;
            								}
HXDLIN( 602)								if (here34) {
HXDLIN( 602)									int location9;
HXDLIN( 602)									if (img1->useVirtualPos) {
HXDLIN( 602)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 602)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 602)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 602)									int this135;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										this135 = this134;
            									}
HXDLIN( 602)									Float a111;
HXDLIN( 602)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 602)									if ((this136 == 0)) {
HXDLIN( 602)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r19;
HXDLIN( 602)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 602)									if ((this137 == 0)) {
HXDLIN( 602)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g19;
HXDLIN( 602)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 602)									if ((this138 == 0)) {
HXDLIN( 602)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b112;
HXDLIN( 602)									int this139 = (this135 & 255);
HXDLIN( 602)									if ((this139 == 0)) {
HXDLIN( 602)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a210;
HXDLIN( 602)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 602)									if ((this140 == 0)) {
HXDLIN( 602)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r29;
HXDLIN( 602)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 602)									if ((this141 == 0)) {
HXDLIN( 602)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g29;
HXDLIN( 602)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 602)									if ((this142 == 0)) {
HXDLIN( 602)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b210;
HXDLIN( 602)									int this143 = (col1 & 255);
HXDLIN( 602)									if ((this143 == 0)) {
HXDLIN( 602)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 602)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 602)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 602)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 602)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 602)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 602)									{
HXDLIN( 602)										int here35;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here35 = blended9;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 602)									::Dynamic this144 = img1->image;
HXDLIN( 602)									int index22;
HXDLIN( 602)									if (img1->useVirtualPos) {
HXDLIN( 602)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 602)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 602)									int here36;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										here36 = c21;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 602)								if (forceClear1) {
HXDLIN( 602)									::Dynamic this145 = img1->image;
HXDLIN( 602)									int x17 = (2 + dx1);
HXDLIN( 602)									int y17 = (2 + dy1);
HXDLIN( 602)									int index23;
HXDLIN( 602)									if (img1->useVirtualPos) {
HXDLIN( 602)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 602)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g68 = 0;
HXDLIN( 602)				int _g69 = this123->width;
HXDLIN( 602)				while((_g68 < _g69)){
HXDLIN( 602)					_g68 = (_g68 + 1);
HXDLIN( 602)					int x18 = (_g68 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g70 = 0;
HXDLIN( 602)						int _g71 = 2;
HXDLIN( 602)						while((_g70 < _g71)){
HXDLIN( 602)							_g70 = (_g70 + 1);
HXDLIN( 602)							int y18 = (_g70 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								int x19 = (x18 + 2);
HXDLIN( 602)								int y19 = (((this123->height - 1) - 2) + y18);
HXDLIN( 602)								::Dynamic this146 = this123->image;
HXDLIN( 602)								int index24;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 602)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 602)								int color11;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color11 = c22;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c23 = color11;
HXDLIN( 602)									bool here37;
HXDLIN( 602)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 602)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here37 = false;
            									}
HXDLIN( 602)									if (here37) {
HXDLIN( 602)										int location10;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 602)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 602)										int this148;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this148 = this147;
            										}
HXDLIN( 602)										Float a112;
HXDLIN( 602)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 602)										if ((this149 == 0)) {
HXDLIN( 602)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r110;
HXDLIN( 602)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 602)										if ((this150 == 0)) {
HXDLIN( 602)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g110;
HXDLIN( 602)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 602)										if ((this151 == 0)) {
HXDLIN( 602)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b113;
HXDLIN( 602)										int this152 = (this148 & 255);
HXDLIN( 602)										if ((this152 == 0)) {
HXDLIN( 602)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a211;
HXDLIN( 602)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 602)										if ((this153 == 0)) {
HXDLIN( 602)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r210;
HXDLIN( 602)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 602)										if ((this154 == 0)) {
HXDLIN( 602)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g210;
HXDLIN( 602)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 602)										if ((this155 == 0)) {
HXDLIN( 602)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b211;
HXDLIN( 602)										int this156 = (color11 & 255);
HXDLIN( 602)										if ((this156 == 0)) {
HXDLIN( 602)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 602)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 602)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 602)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 602)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 602)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 602)										{
HXDLIN( 602)											int here38;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here38 = blended10;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this157 = img1->image;
HXDLIN( 602)										int index25;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 602)										int here39;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here39 = c23;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x20 = (x18 + 2);
HXDLIN( 602)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 602)								int y21 = (2 - y18);
HXDLIN( 602)								::Dynamic this158 = this123->image;
HXDLIN( 602)								int index26;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 602)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 602)								int color12;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color12 = c24;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c25 = color12;
HXDLIN( 602)									bool here40;
HXDLIN( 602)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 602)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here40 = false;
            									}
HXDLIN( 602)									if (here40) {
HXDLIN( 602)										int location11;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 602)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 602)										int this160;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this160 = this159;
            										}
HXDLIN( 602)										Float a113;
HXDLIN( 602)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 602)										if ((this161 == 0)) {
HXDLIN( 602)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r111;
HXDLIN( 602)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 602)										if ((this162 == 0)) {
HXDLIN( 602)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g111;
HXDLIN( 602)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 602)										if ((this163 == 0)) {
HXDLIN( 602)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b114;
HXDLIN( 602)										int this164 = (this160 & 255);
HXDLIN( 602)										if ((this164 == 0)) {
HXDLIN( 602)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a212;
HXDLIN( 602)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 602)										if ((this165 == 0)) {
HXDLIN( 602)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r211;
HXDLIN( 602)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 602)										if ((this166 == 0)) {
HXDLIN( 602)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g211;
HXDLIN( 602)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 602)										if ((this167 == 0)) {
HXDLIN( 602)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b212;
HXDLIN( 602)										int this168 = (color12 & 255);
HXDLIN( 602)										if ((this168 == 0)) {
HXDLIN( 602)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 602)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 602)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 602)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 602)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 602)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 602)										{
HXDLIN( 602)											int here41;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here41 = blended11;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this169 = img1->image;
HXDLIN( 602)										int index27;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 602)										int here42;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here42 = c25;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g72 = 0;
HXDLIN( 602)				int _g73 = this123->height;
HXDLIN( 602)				while((_g72 < _g73)){
HXDLIN( 602)					_g72 = (_g72 + 1);
HXDLIN( 602)					int y22 = (_g72 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g74 = 0;
HXDLIN( 602)						int _g75 = 2;
HXDLIN( 602)						while((_g74 < _g75)){
HXDLIN( 602)							_g74 = (_g74 + 1);
HXDLIN( 602)							int x21 = (_g74 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								int y23 = (y22 + 2);
HXDLIN( 602)								int x22 = (((this123->width - 1) - 2) + x21);
HXDLIN( 602)								::Dynamic this170 = this123->image;
HXDLIN( 602)								int index28;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 602)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 602)								int color13;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color13 = c26;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c27 = color13;
HXDLIN( 602)									bool here43;
HXDLIN( 602)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 602)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here43 = false;
            									}
HXDLIN( 602)									if (here43) {
HXDLIN( 602)										int location12;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 602)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 602)										int this172;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this172 = this171;
            										}
HXDLIN( 602)										Float a114;
HXDLIN( 602)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 602)										if ((this173 == 0)) {
HXDLIN( 602)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r112;
HXDLIN( 602)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 602)										if ((this174 == 0)) {
HXDLIN( 602)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g112;
HXDLIN( 602)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 602)										if ((this175 == 0)) {
HXDLIN( 602)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b115;
HXDLIN( 602)										int this176 = (this172 & 255);
HXDLIN( 602)										if ((this176 == 0)) {
HXDLIN( 602)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a213;
HXDLIN( 602)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 602)										if ((this177 == 0)) {
HXDLIN( 602)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r212;
HXDLIN( 602)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 602)										if ((this178 == 0)) {
HXDLIN( 602)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g212;
HXDLIN( 602)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 602)										if ((this179 == 0)) {
HXDLIN( 602)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b213;
HXDLIN( 602)										int this180 = (color13 & 255);
HXDLIN( 602)										if ((this180 == 0)) {
HXDLIN( 602)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 602)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 602)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 602)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 602)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 602)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 602)										{
HXDLIN( 602)											int here44;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here44 = blended12;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this181 = img1->image;
HXDLIN( 602)										int index29;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 602)										int here45;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here45 = c27;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 602)								int y24 = (y22 + 2);
HXDLIN( 602)								int x24 = (2 - x21);
HXDLIN( 602)								::Dynamic this182 = this123->image;
HXDLIN( 602)								int index30;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 602)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 602)								int color14;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color14 = c28;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c29 = color14;
HXDLIN( 602)									bool here46;
HXDLIN( 602)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 602)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here46 = false;
            									}
HXDLIN( 602)									if (here46) {
HXDLIN( 602)										int location13;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 602)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 602)										int this184;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this184 = this183;
            										}
HXDLIN( 602)										Float a115;
HXDLIN( 602)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 602)										if ((this185 == 0)) {
HXDLIN( 602)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r113;
HXDLIN( 602)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 602)										if ((this186 == 0)) {
HXDLIN( 602)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g113;
HXDLIN( 602)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 602)										if ((this187 == 0)) {
HXDLIN( 602)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b116;
HXDLIN( 602)										int this188 = (this184 & 255);
HXDLIN( 602)										if ((this188 == 0)) {
HXDLIN( 602)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a214;
HXDLIN( 602)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 602)										if ((this189 == 0)) {
HXDLIN( 602)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r213;
HXDLIN( 602)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 602)										if ((this190 == 0)) {
HXDLIN( 602)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g213;
HXDLIN( 602)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 602)										if ((this191 == 0)) {
HXDLIN( 602)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b214;
HXDLIN( 602)										int this192 = (color14 & 255);
HXDLIN( 602)										if ((this192 == 0)) {
HXDLIN( 602)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 602)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 602)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 602)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 602)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 602)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 602)										{
HXDLIN( 602)											int here47;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here47 = blended13;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this193 = img1->image;
HXDLIN( 602)										int index31;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 602)										int here48;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here48 = c29;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				int _g76 = 0;
HXDLIN( 602)				int _g77 = 2;
HXDLIN( 602)				while((_g76 < _g77)){
HXDLIN( 602)					_g76 = (_g76 + 1);
HXDLIN( 602)					int x25 = (_g76 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						int _g78 = 0;
HXDLIN( 602)						int _g79 = 2;
HXDLIN( 602)						while((_g78 < _g79)){
HXDLIN( 602)							_g78 = (_g78 + 1);
HXDLIN( 602)							int y25 = (_g78 - 1);
HXDLIN( 602)							{
HXDLIN( 602)								int x26 = (((this123->width - 1) - 2) + x25);
HXDLIN( 602)								int y26 = (((this123->height - 1) - 2) + y25);
HXDLIN( 602)								::Dynamic this194 = this123->image;
HXDLIN( 602)								int index32;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 602)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 602)								int color15;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color15 = c30;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c31 = color15;
HXDLIN( 602)									bool here49;
HXDLIN( 602)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 602)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here49 = false;
            									}
HXDLIN( 602)									if (here49) {
HXDLIN( 602)										int location14;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 602)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 602)										int this196;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this196 = this195;
            										}
HXDLIN( 602)										Float a116;
HXDLIN( 602)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 602)										if ((this197 == 0)) {
HXDLIN( 602)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r114;
HXDLIN( 602)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 602)										if ((this198 == 0)) {
HXDLIN( 602)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g114;
HXDLIN( 602)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 602)										if ((this199 == 0)) {
HXDLIN( 602)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b117;
HXDLIN( 602)										int this200 = (this196 & 255);
HXDLIN( 602)										if ((this200 == 0)) {
HXDLIN( 602)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a215;
HXDLIN( 602)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 602)										if ((this201 == 0)) {
HXDLIN( 602)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r214;
HXDLIN( 602)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 602)										if ((this202 == 0)) {
HXDLIN( 602)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g214;
HXDLIN( 602)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 602)										if ((this203 == 0)) {
HXDLIN( 602)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b215;
HXDLIN( 602)										int this204 = (color15 & 255);
HXDLIN( 602)										if ((this204 == 0)) {
HXDLIN( 602)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 602)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 602)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 602)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 602)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 602)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 602)										{
HXDLIN( 602)											int here50;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here50 = blended14;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this205 = img1->image;
HXDLIN( 602)										int index33;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 602)										int here51;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here51 = c31;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x27 = ((x25 + 2) + this123->width);
HXDLIN( 602)								int y27 = (((this123->height - 1) - 2) + y25);
HXDLIN( 602)								::Dynamic this206 = this123->image;
HXDLIN( 602)								int index34;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 602)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 602)								int color16;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color16 = c32;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c33 = color16;
HXDLIN( 602)									bool here52;
HXDLIN( 602)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 602)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here52 = false;
            									}
HXDLIN( 602)									if (here52) {
HXDLIN( 602)										int location15;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 602)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 602)										int this208;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this208 = this207;
            										}
HXDLIN( 602)										Float a117;
HXDLIN( 602)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 602)										if ((this209 == 0)) {
HXDLIN( 602)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r115;
HXDLIN( 602)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 602)										if ((this210 == 0)) {
HXDLIN( 602)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g115;
HXDLIN( 602)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 602)										if ((this211 == 0)) {
HXDLIN( 602)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b118;
HXDLIN( 602)										int this212 = (this208 & 255);
HXDLIN( 602)										if ((this212 == 0)) {
HXDLIN( 602)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a216;
HXDLIN( 602)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 602)										if ((this213 == 0)) {
HXDLIN( 602)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r215;
HXDLIN( 602)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 602)										if ((this214 == 0)) {
HXDLIN( 602)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g215;
HXDLIN( 602)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 602)										if ((this215 == 0)) {
HXDLIN( 602)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b216;
HXDLIN( 602)										int this216 = (color16 & 255);
HXDLIN( 602)										if ((this216 == 0)) {
HXDLIN( 602)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 602)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 602)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 602)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 602)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 602)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 602)										{
HXDLIN( 602)											int here53;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here53 = blended15;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this217 = img1->image;
HXDLIN( 602)										int index35;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 602)										int here54;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here54 = c33;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int x28 = ((x25 + 2) + this123->width);
HXDLIN( 602)								int y28 = ((y25 + 2) + this123->height);
HXDLIN( 602)								::Dynamic this218 = this123->image;
HXDLIN( 602)								int index36;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 602)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 602)								int color17;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color17 = c34;
            								}
HXDLIN( 602)								int color18 = color17;
HXDLIN( 602)								{
HXDLIN( 602)									int c35 = color18;
HXDLIN( 602)									bool here55;
HXDLIN( 602)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 602)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here55 = false;
            									}
HXDLIN( 602)									if (here55) {
HXDLIN( 602)										int location16;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 602)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 602)										int this220;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this220 = this219;
            										}
HXDLIN( 602)										Float a118;
HXDLIN( 602)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 602)										if ((this221 == 0)) {
HXDLIN( 602)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r116;
HXDLIN( 602)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 602)										if ((this222 == 0)) {
HXDLIN( 602)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g116;
HXDLIN( 602)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 602)										if ((this223 == 0)) {
HXDLIN( 602)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b119;
HXDLIN( 602)										int this224 = (this220 & 255);
HXDLIN( 602)										if ((this224 == 0)) {
HXDLIN( 602)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a217;
HXDLIN( 602)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 602)										if ((this225 == 0)) {
HXDLIN( 602)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r216;
HXDLIN( 602)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 602)										if ((this226 == 0)) {
HXDLIN( 602)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g216;
HXDLIN( 602)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 602)										if ((this227 == 0)) {
HXDLIN( 602)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b217;
HXDLIN( 602)										int this228 = (color18 & 255);
HXDLIN( 602)										if ((this228 == 0)) {
HXDLIN( 602)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 602)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 602)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 602)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 602)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 602)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 602)										{
HXDLIN( 602)											int here56;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here56 = blended16;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this229 = img1->image;
HXDLIN( 602)										int index37;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 602)										int here57;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here57 = c35;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 602)							{
HXDLIN( 602)								int y29 = ((y25 + 2) + this123->width);
HXDLIN( 602)								int x29 = (((this123->width - 1) - 2) + x25);
HXDLIN( 602)								::Dynamic this230 = this123->image;
HXDLIN( 602)								int index38;
HXDLIN( 602)								if (this123->useVirtualPos) {
HXDLIN( 602)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 602)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 602)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 602)								int color19;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									color19 = c36;
            								}
HXDLIN( 602)								{
HXDLIN( 602)									int c37 = color19;
HXDLIN( 602)									bool here58;
HXDLIN( 602)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 602)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 602)										here58 = false;
            									}
HXDLIN( 602)									if (here58) {
HXDLIN( 602)										int location17;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 602)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 602)										int this232;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											this232 = this231;
            										}
HXDLIN( 602)										Float a119;
HXDLIN( 602)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 602)										if ((this233 == 0)) {
HXDLIN( 602)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r117;
HXDLIN( 602)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 602)										if ((this234 == 0)) {
HXDLIN( 602)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g117;
HXDLIN( 602)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 602)										if ((this235 == 0)) {
HXDLIN( 602)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b120;
HXDLIN( 602)										int this236 = (this232 & 255);
HXDLIN( 602)										if ((this236 == 0)) {
HXDLIN( 602)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a218;
HXDLIN( 602)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 602)										if ((this237 == 0)) {
HXDLIN( 602)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float r217;
HXDLIN( 602)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 602)										if ((this238 == 0)) {
HXDLIN( 602)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float g217;
HXDLIN( 602)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 602)										if ((this239 == 0)) {
HXDLIN( 602)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float b218;
HXDLIN( 602)										int this240 = (color19 & 255);
HXDLIN( 602)										if ((this240 == 0)) {
HXDLIN( 602)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 602)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 602)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 602)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 602)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 602)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 602)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 602)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 602)										{
HXDLIN( 602)											int here59;
HXDLIN( 602)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 602)												here59 = blended17;
            											}
HXDLIN( 602)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 602)										::Dynamic this241 = img1->image;
HXDLIN( 602)										int index39;
HXDLIN( 602)										if (img1->useVirtualPos) {
HXDLIN( 602)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 602)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 602)										int here60;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											here60 = c37;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 602)				here = img1;
            			}
            			break;
            		}
HXDLIN( 602)		{
HXDLIN( 602)			int _g80 = 2;
HXDLIN( 602)			int _g81 = (this1->height - 3);
HXDLIN( 602)			while((_g80 < _g81)){
HXDLIN( 602)				_g80 = (_g80 + 1);
HXDLIN( 602)				int y30 = (_g80 - 1);
HXDLIN( 602)				{
HXDLIN( 602)					int _g82 = 2;
HXDLIN( 602)					int _g83 = (this1->width - 3);
HXDLIN( 602)					while((_g82 < _g83)){
HXDLIN( 602)						_g82 = (_g82 + 1);
HXDLIN( 602)						int x30 = (_g82 - 1);
HXDLIN( 602)						if ((x30 == 2)) {
HXDLIN( 602)							int x31 = (x30 - 2);
HXDLIN( 602)							int y31 = (y30 - 2);
HXDLIN( 602)							::Dynamic this242 = here->image;
HXDLIN( 602)							int index40;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 602)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								a0 = c38;
            							}
HXDLIN( 602)							int x32 = (x30 - 1);
HXDLIN( 602)							int y32 = (y30 - 2);
HXDLIN( 602)							::Dynamic this243 = here->image;
HXDLIN( 602)							int index41;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x32)) ));
            							}
HXDLIN( 602)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								b0 = c39;
            							}
HXDLIN( 602)							int y33 = (y30 - 2);
HXDLIN( 602)							::Dynamic this244 = here->image;
HXDLIN( 602)							int index42;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x30)) ));
            							}
HXDLIN( 602)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								c0 = c40;
            							}
HXDLIN( 602)							int x33 = (x30 + 1);
HXDLIN( 602)							int y34 = (y30 - 2);
HXDLIN( 602)							::Dynamic this245 = here->image;
HXDLIN( 602)							int index43;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index43 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index43 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x33)) ));
            							}
HXDLIN( 602)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								d0 = c41;
            							}
HXDLIN( 602)							int x34 = (x30 + 2);
HXDLIN( 602)							int y35 = (y30 - 2);
HXDLIN( 602)							::Dynamic this246 = here->image;
HXDLIN( 602)							int index44;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index44 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index44 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x34)) ));
            							}
HXDLIN( 602)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								e0 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								e0 = c42;
            							}
HXDLIN( 602)							int x35 = (x30 - 2);
HXDLIN( 602)							int y36 = (y30 - 1);
HXDLIN( 602)							::Dynamic this247 = here->image;
HXDLIN( 602)							int index45;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index45 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index45 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x35)) ));
            							}
HXDLIN( 602)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								f0 = c43;
            							}
HXDLIN( 602)							int x36 = (x30 - 1);
HXDLIN( 602)							int y37 = (y30 - 1);
HXDLIN( 602)							::Dynamic this248 = here->image;
HXDLIN( 602)							int index46;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index46 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index46 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x36)) ));
            							}
HXDLIN( 602)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								g0 = c44;
            							}
HXDLIN( 602)							int y38 = (y30 - 1);
HXDLIN( 602)							::Dynamic this249 = here->image;
HXDLIN( 602)							int index47;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index47 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index47 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x30)) ));
            							}
HXDLIN( 602)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								h0 = c45;
            							}
HXDLIN( 602)							int x37 = (x30 + 1);
HXDLIN( 602)							int y39 = (y30 - 1);
HXDLIN( 602)							::Dynamic this250 = here->image;
HXDLIN( 602)							int index48;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index48 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index48 = ::Std_obj::_hx_int(( (Float)(((y39 * here->width) + x37)) ));
            							}
HXDLIN( 602)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								i0 = c46;
            							}
HXDLIN( 602)							int x38 = (x30 + 2);
HXDLIN( 602)							int y40 = (y30 - 1);
HXDLIN( 602)							::Dynamic this251 = here->image;
HXDLIN( 602)							int index49;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index49 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index49 = ::Std_obj::_hx_int(( (Float)(((y40 * here->width) + x38)) ));
            							}
HXDLIN( 602)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								j0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								j0 = c47;
            							}
HXDLIN( 602)							int x39 = (x30 - 2);
HXDLIN( 602)							::Dynamic this252 = here->image;
HXDLIN( 602)							int index50;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x39)) ));
            							}
HXDLIN( 602)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								k0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								k0 = c48;
            							}
HXDLIN( 602)							int x40 = (x30 - 1);
HXDLIN( 602)							::Dynamic this253 = here->image;
HXDLIN( 602)							int index51;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index51 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x40) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index51 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x40)) ));
            							}
HXDLIN( 602)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								l0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								l0 = c49;
            							}
HXDLIN( 602)							::Dynamic this254 = here->image;
HXDLIN( 602)							int index52;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index52 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index52 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 602)							int c50 = ::iterMagic::Iimg_obj::get(this254,index52);
HXDLIN( 602)							int m03;
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								m03 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								m03 = c50;
            							}
HXLINE( 336)							m0 = m03;
HXLINE( 602)							int x41 = (x30 + 1);
HXDLIN( 602)							::Dynamic this255 = here->image;
HXDLIN( 602)							int index53;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index53 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x41)) ));
            							}
HXDLIN( 602)							int c51 = ::iterMagic::Iimg_obj::get(this255,index53);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								n0 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								n0 = c51;
            							}
HXDLIN( 602)							int x42 = (x30 + 2);
HXDLIN( 602)							::Dynamic this256 = here->image;
HXDLIN( 602)							int index54;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index54 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index54 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x42)) ));
            							}
HXDLIN( 602)							int c52 = ::iterMagic::Iimg_obj::get(this256,index54);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								o0 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								o0 = c52;
            							}
HXDLIN( 602)							int x43 = (x30 - 2);
HXDLIN( 602)							int y41 = (y30 + 1);
HXDLIN( 602)							::Dynamic this257 = here->image;
HXDLIN( 602)							int index55;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index55 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index55 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x43)) ));
            							}
HXDLIN( 602)							int c53 = ::iterMagic::Iimg_obj::get(this257,index55);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								p0 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								p0 = c53;
            							}
HXDLIN( 602)							int x44 = (x30 - 1);
HXDLIN( 602)							int y42 = (y30 + 1);
HXDLIN( 602)							::Dynamic this258 = here->image;
HXDLIN( 602)							int index56;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index56 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x44) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index56 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x44)) ));
            							}
HXDLIN( 602)							int c54 = ::iterMagic::Iimg_obj::get(this258,index56);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								q0 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								q0 = c54;
            							}
HXDLIN( 602)							int y43 = (y30 + 1);
HXDLIN( 602)							::Dynamic this259 = here->image;
HXDLIN( 602)							int index57;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index57 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index57 = ::Std_obj::_hx_int(( (Float)(((y43 * here->width) + x30)) ));
            							}
HXDLIN( 602)							int c55 = ::iterMagic::Iimg_obj::get(this259,index57);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								r0 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								r0 = c55;
            							}
HXDLIN( 602)							int x45 = (x30 + 1);
HXDLIN( 602)							int y44 = (y30 + 1);
HXDLIN( 602)							::Dynamic this260 = here->image;
HXDLIN( 602)							int index58;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index58 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - here->virtualY) * ( (Float)(here->width) )) + x45) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index58 = ::Std_obj::_hx_int(( (Float)(((y44 * here->width) + x45)) ));
            							}
HXDLIN( 602)							int c56 = ::iterMagic::Iimg_obj::get(this260,index58);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								s0 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								s0 = c56;
            							}
HXDLIN( 602)							int x46 = (x30 + 2);
HXDLIN( 602)							int y45 = (y30 + 1);
HXDLIN( 602)							::Dynamic this261 = here->image;
HXDLIN( 602)							int index59;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index59 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - here->virtualY) * ( (Float)(here->width) )) + x46) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index59 = ::Std_obj::_hx_int(( (Float)(((y45 * here->width) + x46)) ));
            							}
HXDLIN( 602)							int c57 = ::iterMagic::Iimg_obj::get(this261,index59);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								t0 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								t0 = c57;
            							}
HXDLIN( 602)							int x47 = (x30 - 2);
HXDLIN( 602)							int y46 = (y30 + 2);
HXDLIN( 602)							::Dynamic this262 = here->image;
HXDLIN( 602)							int index60;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index60 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - here->virtualY) * ( (Float)(here->width) )) + x47) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index60 = ::Std_obj::_hx_int(( (Float)(((y46 * here->width) + x47)) ));
            							}
HXDLIN( 602)							int c58 = ::iterMagic::Iimg_obj::get(this262,index60);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								u0 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								u0 = c58;
            							}
HXDLIN( 602)							int x48 = (x30 - 1);
HXDLIN( 602)							int y47 = (y30 + 2);
HXDLIN( 602)							::Dynamic this263 = here->image;
HXDLIN( 602)							int index61;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index61 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - here->virtualY) * ( (Float)(here->width) )) + x48) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index61 = ::Std_obj::_hx_int(( (Float)(((y47 * here->width) + x48)) ));
            							}
HXDLIN( 602)							int c59 = ::iterMagic::Iimg_obj::get(this263,index61);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								v0 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								v0 = c59;
            							}
HXDLIN( 602)							int y48 = (y30 + 2);
HXDLIN( 602)							::Dynamic this264 = here->image;
HXDLIN( 602)							int index62;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index62 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index62 = ::Std_obj::_hx_int(( (Float)(((y48 * here->width) + x30)) ));
            							}
HXDLIN( 602)							int c60 = ::iterMagic::Iimg_obj::get(this264,index62);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								w0 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								w0 = c60;
            							}
HXDLIN( 602)							int x49 = (x30 + 1);
HXDLIN( 602)							int y49 = (y30 + 2);
HXDLIN( 602)							::Dynamic this265 = here->image;
HXDLIN( 602)							int index63;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index63 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - here->virtualY) * ( (Float)(here->width) )) + x49) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index63 = ::Std_obj::_hx_int(( (Float)(((y49 * here->width) + x49)) ));
            							}
HXDLIN( 602)							int c61 = ::iterMagic::Iimg_obj::get(this265,index63);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								x0 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								x0 = c61;
            							}
HXDLIN( 602)							int x50 = (x30 + 2);
HXDLIN( 602)							int y50 = (y30 + 2);
HXDLIN( 602)							::Dynamic this266 = here->image;
HXDLIN( 602)							int index64;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index64 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - here->virtualY) * ( (Float)(here->width) )) + x50) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index64 = ::Std_obj::_hx_int(( (Float)(((y50 * here->width) + x50)) ));
            							}
HXDLIN( 602)							int c62 = ::iterMagic::Iimg_obj::get(this266,index64);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								y0 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								y0 = c62;
            							}
            						}
            						else {
HXLINE( 353)							a0 = b0;
HXLINE( 354)							b0 = c0;
HXLINE( 355)							c0 = d0;
HXLINE( 356)							d0 = e0;
HXLINE( 602)							int x51 = (x30 + 1);
HXDLIN( 602)							int y51 = (y30 - 2);
HXDLIN( 602)							::Dynamic this267 = here->image;
HXDLIN( 602)							int index65;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index65 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - here->virtualY) * ( (Float)(here->width) )) + x51) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index65 = ::Std_obj::_hx_int(( (Float)(((y51 * here->width) + x51)) ));
            							}
HXDLIN( 602)							int c63 = ::iterMagic::Iimg_obj::get(this267,index65);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								e0 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								e0 = c63;
            							}
HXLINE( 359)							f0 = g0;
HXLINE( 360)							g0 = h0;
HXLINE( 361)							h0 = i0;
HXLINE( 362)							i0 = h0;
HXLINE( 602)							int x52 = (x30 + 1);
HXDLIN( 602)							int y52 = (y30 - 1);
HXDLIN( 602)							::Dynamic this268 = here->image;
HXDLIN( 602)							int index66;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index66 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - here->virtualY) * ( (Float)(here->width) )) + x52) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index66 = ::Std_obj::_hx_int(( (Float)(((y52 * here->width) + x52)) ));
            							}
HXDLIN( 602)							int c64 = ::iterMagic::Iimg_obj::get(this268,index66);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								j0 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								j0 = c64;
            							}
HXLINE( 365)							k0 = l0;
HXLINE( 366)							l0 = m0;
HXLINE( 367)							m0 = n0;
HXLINE( 368)							n0 = o0;
HXLINE( 602)							int x53 = (x30 + 1);
HXDLIN( 602)							::Dynamic this269 = here->image;
HXDLIN( 602)							int index67;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index67 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x53) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index67 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x53)) ));
            							}
HXDLIN( 602)							int c65 = ::iterMagic::Iimg_obj::get(this269,index67);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								o0 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								o0 = c65;
            							}
HXLINE( 371)							p0 = q0;
HXLINE( 372)							q0 = r0;
HXLINE( 373)							r0 = s0;
HXLINE( 374)							s0 = t0;
HXLINE( 602)							int x54 = (x30 + 1);
HXDLIN( 602)							int y53 = (y30 + 1);
HXDLIN( 602)							::Dynamic this270 = here->image;
HXDLIN( 602)							int index68;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index68 = ::Std_obj::_hx_int(((((( (Float)(y53) ) - here->virtualY) * ( (Float)(here->width) )) + x54) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index68 = ::Std_obj::_hx_int(( (Float)(((y53 * here->width) + x54)) ));
            							}
HXDLIN( 602)							int c66 = ::iterMagic::Iimg_obj::get(this270,index68);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								t0 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								t0 = c66;
            							}
HXLINE( 377)							u0 = v0;
HXLINE( 378)							v0 = w0;
HXLINE( 379)							w0 = x0;
HXLINE( 380)							x0 = v0;
HXLINE( 602)							int x55 = (x30 + 1);
HXDLIN( 602)							int y54 = (y30 + 2);
HXDLIN( 602)							::Dynamic this271 = here->image;
HXDLIN( 602)							int index69;
HXDLIN( 602)							if (here->useVirtualPos) {
HXDLIN( 602)								index69 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - here->virtualY) * ( (Float)(here->width) )) + x55) - here->virtualX));
            							}
            							else {
HXDLIN( 602)								index69 = ::Std_obj::_hx_int(( (Float)(((y54 * here->width) + x55)) ));
            							}
HXDLIN( 602)							int c67 = ::iterMagic::Iimg_obj::get(this271,index69);
HXDLIN( 602)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)								v0 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            							}
            							else {
HXDLIN( 602)								v0 = c67;
            							}
            						}
HXDLIN( 602)						if (adjustRed) {
HXLINE( 384)							r_ = ((Float)0.);
HXLINE( 602)							bool _hx_tmp2;
HXDLIN( 602)							if ((m55_a != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp2 = false;
            							}
HXDLIN( 602)							if (_hx_tmp2) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 602)							bool _hx_tmp3;
HXDLIN( 602)							if ((m55_b != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp3 = false;
            							}
HXDLIN( 602)							if (_hx_tmp3) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 602)							bool _hx_tmp4;
HXDLIN( 602)							if ((m55_c != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp4 = false;
            							}
HXDLIN( 602)							if (_hx_tmp4) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 602)							bool _hx_tmp5;
HXDLIN( 602)							if ((m55_d != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp5 = false;
            							}
HXDLIN( 602)							if (_hx_tmp5) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 602)							bool _hx_tmp6;
HXDLIN( 602)							if ((m55_e != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp6 = false;
            							}
HXDLIN( 602)							if (_hx_tmp6) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 602)							bool _hx_tmp7;
HXDLIN( 602)							if ((m55_f != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp7 = false;
            							}
HXDLIN( 602)							if (_hx_tmp7) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 602)							bool _hx_tmp8;
HXDLIN( 602)							if ((m55_g != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp8 = false;
            							}
HXDLIN( 602)							if (_hx_tmp8) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 602)							bool _hx_tmp9;
HXDLIN( 602)							if ((m55_h != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp9 = false;
            							}
HXDLIN( 602)							if (_hx_tmp9) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 602)							bool _hx_tmp10;
HXDLIN( 602)							if ((m55_i != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp10 = false;
            							}
HXDLIN( 602)							if (_hx_tmp10) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 602)							bool _hx_tmp11;
HXDLIN( 602)							if ((m55_j != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp11 = (j0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp11 = false;
            							}
HXDLIN( 602)							if (_hx_tmp11) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((j0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 602)							bool _hx_tmp12;
HXDLIN( 602)							if ((m55_k != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp12 = (k0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp12 = false;
            							}
HXDLIN( 602)							if (_hx_tmp12) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((k0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 602)							bool _hx_tmp13;
HXDLIN( 602)							if ((m55_l != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp13 = (l0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp13 = false;
            							}
HXDLIN( 602)							if (_hx_tmp13) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((l0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 602)							bool _hx_tmp14;
HXDLIN( 602)							if ((m55_m != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp14 = (m0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp14 = false;
            							}
HXDLIN( 602)							if (_hx_tmp14) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((m0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 602)							bool _hx_tmp15;
HXDLIN( 602)							if ((m55_n != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp15 = (n0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp15 = false;
            							}
HXDLIN( 602)							if (_hx_tmp15) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((n0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 602)							bool _hx_tmp16;
HXDLIN( 602)							if ((m55_o != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp16 = (o0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp16 = false;
            							}
HXDLIN( 602)							if (_hx_tmp16) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((o0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 602)							bool _hx_tmp17;
HXDLIN( 602)							if ((m55_p != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp17 = (p0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp17 = false;
            							}
HXDLIN( 602)							if (_hx_tmp17) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((p0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 602)							bool _hx_tmp18;
HXDLIN( 602)							if ((m55_q != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp18 = (q0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp18 = false;
            							}
HXDLIN( 602)							if (_hx_tmp18) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((q0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 602)							bool _hx_tmp19;
HXDLIN( 602)							if ((m55_r != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp19 = (r0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp19 = false;
            							}
HXDLIN( 602)							if (_hx_tmp19) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((r0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 602)							bool _hx_tmp20;
HXDLIN( 602)							if ((m55_s != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp20 = (s0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp20 = false;
            							}
HXDLIN( 602)							if (_hx_tmp20) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((s0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 602)							bool _hx_tmp21;
HXDLIN( 602)							if ((m55_t != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp21 = (t0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp21 = false;
            							}
HXDLIN( 602)							if (_hx_tmp21) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((t0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 602)							bool _hx_tmp22;
HXDLIN( 602)							if ((m55_u != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp22 = (u0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp22 = false;
            							}
HXDLIN( 602)							if (_hx_tmp22) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((u0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 602)							bool _hx_tmp23;
HXDLIN( 602)							if ((m55_v != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp23 = (v0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp23 = false;
            							}
HXDLIN( 602)							if (_hx_tmp23) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((v0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 602)							bool _hx_tmp24;
HXDLIN( 602)							if ((m55_w != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp24 = (w0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp24 = false;
            							}
HXDLIN( 602)							if (_hx_tmp24) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((w0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 602)							bool _hx_tmp25;
HXDLIN( 602)							if ((m55_x != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp25 = (x0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp25 = false;
            							}
HXDLIN( 602)							if (_hx_tmp25) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((x0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 602)							bool _hx_tmp26;
HXDLIN( 602)							if ((m55_y != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp26 = (y0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp26 = false;
            							}
HXDLIN( 602)							if (_hx_tmp26) {
HXDLIN( 602)								r_ = (r_ + ((( (Float)(((y0 >> 16) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 416)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 602)						if (adjustGreen) {
HXLINE( 419)							g_ = ((Float)0.);
HXLINE( 602)							bool _hx_tmp27;
HXDLIN( 602)							if ((m55_a != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp27 = (a0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp27 = false;
            							}
HXDLIN( 602)							if (_hx_tmp27) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 602)							bool _hx_tmp28;
HXDLIN( 602)							if ((m55_b != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp28 = (b0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp28 = false;
            							}
HXDLIN( 602)							if (_hx_tmp28) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 602)							bool _hx_tmp29;
HXDLIN( 602)							if ((m55_c != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp29 = (c0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp29 = false;
            							}
HXDLIN( 602)							if (_hx_tmp29) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 602)							bool _hx_tmp30;
HXDLIN( 602)							if ((m55_d != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp30 = (d0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp30 = false;
            							}
HXDLIN( 602)							if (_hx_tmp30) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 602)							bool _hx_tmp31;
HXDLIN( 602)							if ((m55_e != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp31 = (e0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp31 = false;
            							}
HXDLIN( 602)							if (_hx_tmp31) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 602)							bool _hx_tmp32;
HXDLIN( 602)							if ((m55_f != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp32 = (f0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp32 = false;
            							}
HXDLIN( 602)							if (_hx_tmp32) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 602)							bool _hx_tmp33;
HXDLIN( 602)							if ((m55_g != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp33 = (g0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp33 = false;
            							}
HXDLIN( 602)							if (_hx_tmp33) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 602)							bool _hx_tmp34;
HXDLIN( 602)							if ((m55_h != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp34 = (h0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp34 = false;
            							}
HXDLIN( 602)							if (_hx_tmp34) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 602)							bool _hx_tmp35;
HXDLIN( 602)							if ((m55_i != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp35 = (i0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp35 = false;
            							}
HXDLIN( 602)							if (_hx_tmp35) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 602)							bool _hx_tmp36;
HXDLIN( 602)							if ((m55_j != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp36 = (j0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp36 = false;
            							}
HXDLIN( 602)							if (_hx_tmp36) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((j0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 602)							bool _hx_tmp37;
HXDLIN( 602)							if ((m55_k != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp37 = (k0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp37 = false;
            							}
HXDLIN( 602)							if (_hx_tmp37) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((k0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 602)							bool _hx_tmp38;
HXDLIN( 602)							if ((m55_l != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp38 = (l0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp38 = false;
            							}
HXDLIN( 602)							if (_hx_tmp38) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((l0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 602)							bool _hx_tmp39;
HXDLIN( 602)							if ((m55_m != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp39 = (m0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp39 = false;
            							}
HXDLIN( 602)							if (_hx_tmp39) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((m0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 602)							bool _hx_tmp40;
HXDLIN( 602)							if ((m55_n != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp40 = (n0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp40 = false;
            							}
HXDLIN( 602)							if (_hx_tmp40) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((n0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 602)							bool _hx_tmp41;
HXDLIN( 602)							if ((m55_o != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp41 = (o0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp41 = false;
            							}
HXDLIN( 602)							if (_hx_tmp41) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((o0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 602)							bool _hx_tmp42;
HXDLIN( 602)							if ((m55_p != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp42 = (p0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp42 = false;
            							}
HXDLIN( 602)							if (_hx_tmp42) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((p0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 602)							bool _hx_tmp43;
HXDLIN( 602)							if ((m55_q != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp43 = (q0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp43 = false;
            							}
HXDLIN( 602)							if (_hx_tmp43) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((q0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 602)							bool _hx_tmp44;
HXDLIN( 602)							if ((m55_r != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp44 = (r0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp44 = false;
            							}
HXDLIN( 602)							if (_hx_tmp44) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((r0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 602)							bool _hx_tmp45;
HXDLIN( 602)							if ((m55_s != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp45 = (s0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp45 = false;
            							}
HXDLIN( 602)							if (_hx_tmp45) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((s0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 602)							bool _hx_tmp46;
HXDLIN( 602)							if ((m55_t != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp46 = (t0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp46 = false;
            							}
HXDLIN( 602)							if (_hx_tmp46) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((t0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 602)							bool _hx_tmp47;
HXDLIN( 602)							if ((m55_u != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp47 = (u0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp47 = false;
            							}
HXDLIN( 602)							if (_hx_tmp47) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((u0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 602)							bool _hx_tmp48;
HXDLIN( 602)							if ((m55_v != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp48 = (v0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp48 = false;
            							}
HXDLIN( 602)							if (_hx_tmp48) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((v0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 602)							bool _hx_tmp49;
HXDLIN( 602)							if ((m55_w != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp49 = (w0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp49 = false;
            							}
HXDLIN( 602)							if (_hx_tmp49) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((w0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 602)							bool _hx_tmp50;
HXDLIN( 602)							if ((m55_y != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp50 = (x0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp50 = false;
            							}
HXDLIN( 602)							if (_hx_tmp50) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((x0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 602)							bool _hx_tmp51;
HXDLIN( 602)							if ((m55_y != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp51 = (y0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp51 = false;
            							}
HXDLIN( 602)							if (_hx_tmp51) {
HXDLIN( 602)								g_ = (g_ + ((( (Float)(((y0 >> 8) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 450)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 602)						if (adjustBlue) {
HXLINE( 453)							b_ = ((Float)0.);
HXLINE( 602)							bool _hx_tmp52;
HXDLIN( 602)							if ((m55_a != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp52 = (a0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp52 = false;
            							}
HXDLIN( 602)							if (_hx_tmp52) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 602)							bool _hx_tmp53;
HXDLIN( 602)							if ((m55_b != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp53 = (b0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp53 = false;
            							}
HXDLIN( 602)							if (_hx_tmp53) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 602)							bool _hx_tmp54;
HXDLIN( 602)							if ((m55_c != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp54 = (c0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp54 = false;
            							}
HXDLIN( 602)							if (_hx_tmp54) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 602)							bool _hx_tmp55;
HXDLIN( 602)							if ((m55_d != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp55 = (d0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp55 = false;
            							}
HXDLIN( 602)							if (_hx_tmp55) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 602)							bool _hx_tmp56;
HXDLIN( 602)							if ((m55_e != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp56 = (e0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp56 = false;
            							}
HXDLIN( 602)							if (_hx_tmp56) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 602)							bool _hx_tmp57;
HXDLIN( 602)							if ((m55_f != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp57 = (f0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp57 = false;
            							}
HXDLIN( 602)							if (_hx_tmp57) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 602)							bool _hx_tmp58;
HXDLIN( 602)							if ((m55_g != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp58 = (g0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp58 = false;
            							}
HXDLIN( 602)							if (_hx_tmp58) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 602)							bool _hx_tmp59;
HXDLIN( 602)							if ((m55_h != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp59 = (h0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp59 = false;
            							}
HXDLIN( 602)							if (_hx_tmp59) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 602)							bool _hx_tmp60;
HXDLIN( 602)							if ((m55_i != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp60 = (i0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp60 = false;
            							}
HXDLIN( 602)							if (_hx_tmp60) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 602)							bool _hx_tmp61;
HXDLIN( 602)							if ((m55_j != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp61 = (j0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp61 = false;
            							}
HXDLIN( 602)							if (_hx_tmp61) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((j0 & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 602)							bool _hx_tmp62;
HXDLIN( 602)							if ((m55_k != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp62 = (k0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp62 = false;
            							}
HXDLIN( 602)							if (_hx_tmp62) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((k0 & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 602)							bool _hx_tmp63;
HXDLIN( 602)							if ((m55_l != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp63 = (l0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp63 = false;
            							}
HXDLIN( 602)							if (_hx_tmp63) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((l0 & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 602)							bool _hx_tmp64;
HXDLIN( 602)							if ((m55_m != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp64 = (m0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp64 = false;
            							}
HXDLIN( 602)							if (_hx_tmp64) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((m0 & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 602)							bool _hx_tmp65;
HXDLIN( 602)							if ((m55_n != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp65 = (n0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp65 = false;
            							}
HXDLIN( 602)							if (_hx_tmp65) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((n0 & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 602)							bool _hx_tmp66;
HXDLIN( 602)							if ((m55_o != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp66 = (o0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp66 = false;
            							}
HXDLIN( 602)							if (_hx_tmp66) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((o0 & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 602)							bool _hx_tmp67;
HXDLIN( 602)							if ((m55_p != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp67 = (p0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp67 = false;
            							}
HXDLIN( 602)							if (_hx_tmp67) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((p0 & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 602)							bool _hx_tmp68;
HXDLIN( 602)							if ((m55_q != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp68 = (q0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp68 = false;
            							}
HXDLIN( 602)							if (_hx_tmp68) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((q0 & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 602)							bool _hx_tmp69;
HXDLIN( 602)							if ((m55_r != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp69 = (r0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp69 = false;
            							}
HXDLIN( 602)							if (_hx_tmp69) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((r0 & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 602)							bool _hx_tmp70;
HXDLIN( 602)							if ((m55_s != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp70 = (s0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp70 = false;
            							}
HXDLIN( 602)							if (_hx_tmp70) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((s0 & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 602)							bool _hx_tmp71;
HXDLIN( 602)							if ((m55_t != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp71 = (t0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp71 = false;
            							}
HXDLIN( 602)							if (_hx_tmp71) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((t0 & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 602)							bool _hx_tmp72;
HXDLIN( 602)							if ((m55_u != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp72 = (u0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp72 = false;
            							}
HXDLIN( 602)							if (_hx_tmp72) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((u0 & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 602)							bool _hx_tmp73;
HXDLIN( 602)							if ((m55_v != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp73 = (v0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp73 = false;
            							}
HXDLIN( 602)							if (_hx_tmp73) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((v0 & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 602)							bool _hx_tmp74;
HXDLIN( 602)							if ((m55_w != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp74 = (w0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp74 = false;
            							}
HXDLIN( 602)							if (_hx_tmp74) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((w0 & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 602)							bool _hx_tmp75;
HXDLIN( 602)							if ((m55_x != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp75 = (x0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp75 = false;
            							}
HXDLIN( 602)							if (_hx_tmp75) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((x0 & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 602)							bool _hx_tmp76;
HXDLIN( 602)							if ((m55_y != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp76 = (y0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp76 = false;
            							}
HXDLIN( 602)							if (_hx_tmp76) {
HXDLIN( 602)								b_ = (b_ + ((( (Float)((y0 & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 484)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 602)						if (adjustAlpha) {
HXLINE( 487)							a_ = ((Float)0.);
HXLINE( 602)							bool _hx_tmp77;
HXDLIN( 602)							if ((m55_a != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp77 = (a0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp77 = false;
            							}
HXDLIN( 602)							if (_hx_tmp77) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_a));
            							}
HXDLIN( 602)							bool _hx_tmp78;
HXDLIN( 602)							if ((m55_b != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp78 = (b0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp78 = false;
            							}
HXDLIN( 602)							if (_hx_tmp78) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_b));
            							}
HXDLIN( 602)							bool _hx_tmp79;
HXDLIN( 602)							if ((m55_c != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp79 = (c0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp79 = false;
            							}
HXDLIN( 602)							if (_hx_tmp79) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_c));
            							}
HXDLIN( 602)							bool _hx_tmp80;
HXDLIN( 602)							if ((m55_d != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp80 = (d0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp80 = false;
            							}
HXDLIN( 602)							if (_hx_tmp80) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_d));
            							}
HXDLIN( 602)							bool _hx_tmp81;
HXDLIN( 602)							if ((m55_e != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp81 = (e0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp81 = false;
            							}
HXDLIN( 602)							if (_hx_tmp81) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_e));
            							}
HXDLIN( 602)							bool _hx_tmp82;
HXDLIN( 602)							if ((m55_f != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp82 = (f0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp82 = false;
            							}
HXDLIN( 602)							if (_hx_tmp82) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_f));
            							}
HXDLIN( 602)							bool _hx_tmp83;
HXDLIN( 602)							if ((m55_g != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp83 = (g0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp83 = false;
            							}
HXDLIN( 602)							if (_hx_tmp83) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_g));
            							}
HXDLIN( 602)							bool _hx_tmp84;
HXDLIN( 602)							if ((m55_h != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp84 = (h0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp84 = false;
            							}
HXDLIN( 602)							if (_hx_tmp84) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_h));
            							}
HXDLIN( 602)							bool _hx_tmp85;
HXDLIN( 602)							if ((m55_i != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp85 = (i0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp85 = false;
            							}
HXDLIN( 602)							if (_hx_tmp85) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_i));
            							}
HXDLIN( 602)							bool _hx_tmp86;
HXDLIN( 602)							if ((m55_j != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp86 = (j0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp86 = false;
            							}
HXDLIN( 602)							if (_hx_tmp86) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((j0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_j));
            							}
HXDLIN( 602)							bool _hx_tmp87;
HXDLIN( 602)							if ((m55_k != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp87 = (k0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp87 = false;
            							}
HXDLIN( 602)							if (_hx_tmp87) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((k0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_k));
            							}
HXDLIN( 602)							bool _hx_tmp88;
HXDLIN( 602)							if ((m55_l != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp88 = (l0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp88 = false;
            							}
HXDLIN( 602)							if (_hx_tmp88) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((l0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_l));
            							}
HXDLIN( 602)							bool _hx_tmp89;
HXDLIN( 602)							if ((m55_m != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp89 = (m0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp89 = false;
            							}
HXDLIN( 602)							if (_hx_tmp89) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((m0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_m));
            							}
HXDLIN( 602)							bool _hx_tmp90;
HXDLIN( 602)							if ((m55_n != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp90 = (n0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp90 = false;
            							}
HXDLIN( 602)							if (_hx_tmp90) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((n0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_n));
            							}
HXDLIN( 602)							bool _hx_tmp91;
HXDLIN( 602)							if ((m55_o != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp91 = (o0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp91 = false;
            							}
HXDLIN( 602)							if (_hx_tmp91) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((o0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_o));
            							}
HXDLIN( 602)							bool _hx_tmp92;
HXDLIN( 602)							if ((m55_p != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp92 = (p0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp92 = false;
            							}
HXDLIN( 602)							if (_hx_tmp92) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((p0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_p));
            							}
HXDLIN( 602)							bool _hx_tmp93;
HXDLIN( 602)							if ((m55_q != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp93 = (q0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp93 = false;
            							}
HXDLIN( 602)							if (_hx_tmp93) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((q0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_q));
            							}
HXDLIN( 602)							bool _hx_tmp94;
HXDLIN( 602)							if ((m55_r != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp94 = (r0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp94 = false;
            							}
HXDLIN( 602)							if (_hx_tmp94) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((r0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_r));
            							}
HXDLIN( 602)							bool _hx_tmp95;
HXDLIN( 602)							if ((m55_s != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp95 = (s0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp95 = false;
            							}
HXDLIN( 602)							if (_hx_tmp95) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((s0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_s));
            							}
HXDLIN( 602)							bool _hx_tmp96;
HXDLIN( 602)							if ((m55_t != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp96 = (t0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp96 = false;
            							}
HXDLIN( 602)							if (_hx_tmp96) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((t0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_t));
            							}
HXDLIN( 602)							bool _hx_tmp97;
HXDLIN( 602)							if ((m55_u != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp97 = (u0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp97 = false;
            							}
HXDLIN( 602)							if (_hx_tmp97) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((u0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_u));
            							}
HXDLIN( 602)							bool _hx_tmp98;
HXDLIN( 602)							if ((m55_v != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp98 = (v0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp98 = false;
            							}
HXDLIN( 602)							if (_hx_tmp98) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((v0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_v));
            							}
HXDLIN( 602)							bool _hx_tmp99;
HXDLIN( 602)							if ((m55_w != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp99 = (w0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp99 = false;
            							}
HXDLIN( 602)							if (_hx_tmp99) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((w0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_w));
            							}
HXDLIN( 602)							bool _hx_tmp100;
HXDLIN( 602)							if ((m55_x != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp100 = (x0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp100 = false;
            							}
HXDLIN( 602)							if (_hx_tmp100) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((x0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_x));
            							}
HXDLIN( 602)							bool _hx_tmp101;
HXDLIN( 602)							if ((m55_y != ((Float)0.))) {
HXDLIN( 602)								_hx_tmp101 = (y0 != 0);
            							}
            							else {
HXDLIN( 602)								_hx_tmp101 = false;
            							}
HXDLIN( 602)							if (_hx_tmp101) {
HXDLIN( 602)								a_ = (a_ + ((( (Float)(((y0 >> 24) & 255)) ) / ( (Float)(255) )) * m55_y));
            							}
            						}
            						else {
HXLINE( 518)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 602)						bool _hx_tmp102;
HXDLIN( 602)						if ((borderMode != 0)) {
HXDLIN( 602)							_hx_tmp102 = (borderMode == 2);
            						}
            						else {
HXDLIN( 602)							_hx_tmp102 = true;
            						}
HXDLIN( 602)						if (_hx_tmp102) {
HXDLIN( 602)							int x56 = (x30 - 2);
HXDLIN( 602)							int y55 = (y30 - 2);
HXDLIN( 602)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 602)							{
HXDLIN( 602)								int c68 = color20;
HXDLIN( 602)								bool _hx_tmp103;
HXDLIN( 602)								if ((((c68 >> 24) & 255) < 254)) {
HXDLIN( 602)									_hx_tmp103 = out->transparent;
            								}
            								else {
HXDLIN( 602)									_hx_tmp103 = false;
            								}
HXDLIN( 602)								if (_hx_tmp103) {
HXDLIN( 602)									int location18;
HXDLIN( 602)									if (out->useVirtualPos) {
HXDLIN( 602)										location18 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXDLIN( 602)										location18 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 602)									int this272 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 602)									int this273;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										this273 = ((((((this272 >> 24) & 255) << 24) | ((this272 & 255) << 16)) | (((this272 >> 8) & 255) << 8)) | ((this272 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										this273 = this272;
            									}
HXDLIN( 602)									Float a120;
HXDLIN( 602)									int this274 = ((this273 >> 24) & 255);
HXDLIN( 602)									if ((this274 == 0)) {
HXDLIN( 602)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a120 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r118;
HXDLIN( 602)									int this275 = ((this273 >> 16) & 255);
HXDLIN( 602)									if ((this275 == 0)) {
HXDLIN( 602)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r118 = (( (Float)(this275) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g118;
HXDLIN( 602)									int this276 = ((this273 >> 8) & 255);
HXDLIN( 602)									if ((this276 == 0)) {
HXDLIN( 602)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g118 = (( (Float)(this276) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b121;
HXDLIN( 602)									int this277 = (this273 & 255);
HXDLIN( 602)									if ((this277 == 0)) {
HXDLIN( 602)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b121 = (( (Float)(this277) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a219;
HXDLIN( 602)									int this278 = ((color20 >> 24) & 255);
HXDLIN( 602)									if ((this278 == 0)) {
HXDLIN( 602)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a219 = (( (Float)(this278) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r218;
HXDLIN( 602)									int this279 = ((color20 >> 16) & 255);
HXDLIN( 602)									if ((this279 == 0)) {
HXDLIN( 602)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r218 = (( (Float)(this279) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g218;
HXDLIN( 602)									int this280 = ((color20 >> 8) & 255);
HXDLIN( 602)									if ((this280 == 0)) {
HXDLIN( 602)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g218 = (( (Float)(this280) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b219;
HXDLIN( 602)									int this281 = (color20 & 255);
HXDLIN( 602)									if ((this281 == 0)) {
HXDLIN( 602)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b219 = (( (Float)(this281) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 602)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 602)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 602)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 602)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 602)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 602)									{
HXDLIN( 602)										int _hx_tmp104;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											_hx_tmp104 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											_hx_tmp104 = blended18;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp104);
            									}
            								}
            								else {
HXDLIN( 602)									::Dynamic this282 = out->image;
HXDLIN( 602)									int index70;
HXDLIN( 602)									if (out->useVirtualPos) {
HXDLIN( 602)										index70 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - out->virtualY) * ( (Float)(out->width) )) + x56) - out->virtualX));
            									}
            									else {
HXDLIN( 602)										index70 = ::Std_obj::_hx_int(( (Float)(((y55 * out->width) + x56)) ));
            									}
HXDLIN( 602)									int _hx_tmp105;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp105 = ((((((c68 >> 24) & 255) << 24) | ((c68 & 255) << 16)) | (((c68 >> 8) & 255) << 8)) | ((c68 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp105 = c68;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this282,index70,_hx_tmp105);
            								}
            							}
            						}
            						else {
HXDLIN( 602)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 602)							{
HXDLIN( 602)								int c69 = color21;
HXDLIN( 602)								bool _hx_tmp106;
HXDLIN( 602)								if ((((c69 >> 24) & 255) < 254)) {
HXDLIN( 602)									_hx_tmp106 = out->transparent;
            								}
            								else {
HXDLIN( 602)									_hx_tmp106 = false;
            								}
HXDLIN( 602)								if (_hx_tmp106) {
HXDLIN( 602)									int location19;
HXDLIN( 602)									if (out->useVirtualPos) {
HXDLIN( 602)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 602)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 602)									int this283 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 602)									int this284;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										this284 = ((((((this283 >> 24) & 255) << 24) | ((this283 & 255) << 16)) | (((this283 >> 8) & 255) << 8)) | ((this283 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										this284 = this283;
            									}
HXDLIN( 602)									Float a121;
HXDLIN( 602)									int this285 = ((this284 >> 24) & 255);
HXDLIN( 602)									if ((this285 == 0)) {
HXDLIN( 602)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a121 = (( (Float)(this285) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r119;
HXDLIN( 602)									int this286 = ((this284 >> 16) & 255);
HXDLIN( 602)									if ((this286 == 0)) {
HXDLIN( 602)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r119 = (( (Float)(this286) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g119;
HXDLIN( 602)									int this287 = ((this284 >> 8) & 255);
HXDLIN( 602)									if ((this287 == 0)) {
HXDLIN( 602)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g119 = (( (Float)(this287) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b122;
HXDLIN( 602)									int this288 = (this284 & 255);
HXDLIN( 602)									if ((this288 == 0)) {
HXDLIN( 602)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b122 = (( (Float)(this288) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a220;
HXDLIN( 602)									int this289 = ((color21 >> 24) & 255);
HXDLIN( 602)									if ((this289 == 0)) {
HXDLIN( 602)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										a220 = (( (Float)(this289) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float r219;
HXDLIN( 602)									int this290 = ((color21 >> 16) & 255);
HXDLIN( 602)									if ((this290 == 0)) {
HXDLIN( 602)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										r219 = (( (Float)(this290) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float g219;
HXDLIN( 602)									int this291 = ((color21 >> 8) & 255);
HXDLIN( 602)									if ((this291 == 0)) {
HXDLIN( 602)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										g219 = (( (Float)(this291) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float b220;
HXDLIN( 602)									int this292 = (color21 & 255);
HXDLIN( 602)									if ((this292 == 0)) {
HXDLIN( 602)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 602)										b220 = (( (Float)(this292) ) / ( (Float)(255) ));
            									}
HXDLIN( 602)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 602)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 602)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 602)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 602)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 602)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 602)									{
HXDLIN( 602)										int _hx_tmp107;
HXDLIN( 602)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)											_hx_tmp107 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 602)											_hx_tmp107 = blended19;
            										}
HXDLIN( 602)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp107);
            									}
            								}
            								else {
HXDLIN( 602)									::Dynamic this293 = out->image;
HXDLIN( 602)									int index71;
HXDLIN( 602)									if (out->useVirtualPos) {
HXDLIN( 602)										index71 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 602)										index71 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 602)									int _hx_tmp108;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp108 = ((((((c69 >> 24) & 255) << 24) | ((c69 & 255) << 16)) | (((c69 >> 8) & 255) << 8)) | ((c69 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp108 = c69;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(this293,index71,_hx_tmp108);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 602)		if ((borderMode == 1)) {
HXDLIN( 602)			{
HXDLIN( 602)				int _g84 = 0;
HXDLIN( 602)				int _g85 = (this1->width - 1);
HXDLIN( 602)				while((_g84 < _g85)){
HXDLIN( 602)					_g84 = (_g84 + 1);
HXDLIN( 602)					int x57 = (_g84 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						::Dynamic this294 = here->image;
HXDLIN( 602)						int index72;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index72 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index72 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x57)) ));
            						}
HXDLIN( 602)						int c70 = ::iterMagic::Iimg_obj::get(this294,index72);
HXDLIN( 602)						int color22;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color22 = ((((((c70 >> 24) & 255) << 24) | ((c70 & 255) << 16)) | (((c70 >> 8) & 255) << 8)) | ((c70 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color22 = c70;
            						}
HXDLIN( 602)						int color23 = color22;
HXDLIN( 602)						{
HXDLIN( 602)							int c71 = color23;
HXDLIN( 602)							bool _hx_tmp109;
HXDLIN( 602)							if ((((c71 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp109 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp109 = false;
            							}
HXDLIN( 602)							if (_hx_tmp109) {
HXDLIN( 602)								int location20;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int this295 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 602)								int this296;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this296 = ((((((this295 >> 24) & 255) << 24) | ((this295 & 255) << 16)) | (((this295 >> 8) & 255) << 8)) | ((this295 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this296 = this295;
            								}
HXDLIN( 602)								Float a122;
HXDLIN( 602)								int this297 = ((this296 >> 24) & 255);
HXDLIN( 602)								if ((this297 == 0)) {
HXDLIN( 602)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a122 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r120;
HXDLIN( 602)								int this298 = ((this296 >> 16) & 255);
HXDLIN( 602)								if ((this298 == 0)) {
HXDLIN( 602)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r120 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g120;
HXDLIN( 602)								int this299 = ((this296 >> 8) & 255);
HXDLIN( 602)								if ((this299 == 0)) {
HXDLIN( 602)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g120 = (( (Float)(this299) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b123;
HXDLIN( 602)								int this300 = (this296 & 255);
HXDLIN( 602)								if ((this300 == 0)) {
HXDLIN( 602)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b123 = (( (Float)(this300) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a221;
HXDLIN( 602)								int this301 = ((color23 >> 24) & 255);
HXDLIN( 602)								if ((this301 == 0)) {
HXDLIN( 602)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a221 = (( (Float)(this301) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r220;
HXDLIN( 602)								int this302 = ((color23 >> 16) & 255);
HXDLIN( 602)								if ((this302 == 0)) {
HXDLIN( 602)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r220 = (( (Float)(this302) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g220;
HXDLIN( 602)								int this303 = ((color23 >> 8) & 255);
HXDLIN( 602)								if ((this303 == 0)) {
HXDLIN( 602)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g220 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b221;
HXDLIN( 602)								int this304 = (color23 & 255);
HXDLIN( 602)								if ((this304 == 0)) {
HXDLIN( 602)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b221 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 602)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 602)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 602)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 602)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 602)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp110;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp110 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp110 = blended20;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp110);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this305 = out->image;
HXDLIN( 602)								int index73;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index73 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index73 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int _hx_tmp111;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp111 = ((((((c71 >> 24) & 255) << 24) | ((c71 & 255) << 16)) | (((c71 >> 8) & 255) << 8)) | ((c71 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp111 = c71;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this305,index73,_hx_tmp111);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						int x58 = (x57 + 1);
HXDLIN( 602)						int x59 = (x57 + 1);
HXDLIN( 602)						::Dynamic this306 = here->image;
HXDLIN( 602)						int index74;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index74 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x59) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index74 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x59)) ));
            						}
HXDLIN( 602)						int c72 = ::iterMagic::Iimg_obj::get(this306,index74);
HXDLIN( 602)						int color24;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color24 = ((((((c72 >> 24) & 255) << 24) | ((c72 & 255) << 16)) | (((c72 >> 8) & 255) << 8)) | ((c72 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color24 = c72;
            						}
HXDLIN( 602)						{
HXDLIN( 602)							int c73 = color24;
HXDLIN( 602)							bool _hx_tmp112;
HXDLIN( 602)							if ((((c73 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp112 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp112 = false;
            							}
HXDLIN( 602)							if (_hx_tmp112) {
HXDLIN( 602)								int location21;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location21 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location21 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 602)								int this307 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 602)								int this308;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this308 = ((((((this307 >> 24) & 255) << 24) | ((this307 & 255) << 16)) | (((this307 >> 8) & 255) << 8)) | ((this307 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this308 = this307;
            								}
HXDLIN( 602)								Float a123;
HXDLIN( 602)								int this309 = ((this308 >> 24) & 255);
HXDLIN( 602)								if ((this309 == 0)) {
HXDLIN( 602)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a123 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r121;
HXDLIN( 602)								int this310 = ((this308 >> 16) & 255);
HXDLIN( 602)								if ((this310 == 0)) {
HXDLIN( 602)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r121 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g121;
HXDLIN( 602)								int this311 = ((this308 >> 8) & 255);
HXDLIN( 602)								if ((this311 == 0)) {
HXDLIN( 602)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g121 = (( (Float)(this311) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b124;
HXDLIN( 602)								int this312 = (this308 & 255);
HXDLIN( 602)								if ((this312 == 0)) {
HXDLIN( 602)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b124 = (( (Float)(this312) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a222;
HXDLIN( 602)								int this313 = ((color24 >> 24) & 255);
HXDLIN( 602)								if ((this313 == 0)) {
HXDLIN( 602)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a222 = (( (Float)(this313) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r221;
HXDLIN( 602)								int this314 = ((color24 >> 16) & 255);
HXDLIN( 602)								if ((this314 == 0)) {
HXDLIN( 602)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r221 = (( (Float)(this314) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g221;
HXDLIN( 602)								int this315 = ((color24 >> 8) & 255);
HXDLIN( 602)								if ((this315 == 0)) {
HXDLIN( 602)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g221 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b222;
HXDLIN( 602)								int this316 = (color24 & 255);
HXDLIN( 602)								if ((this316 == 0)) {
HXDLIN( 602)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b222 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 602)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 602)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 602)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 602)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 602)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp113;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp113 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp113 = blended21;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp113);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this317 = out->image;
HXDLIN( 602)								int index75;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index75 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x58) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index75 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x58)) ));
            								}
HXDLIN( 602)								int _hx_tmp114;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp114 = ((((((c73 >> 24) & 255) << 24) | ((c73 & 255) << 16)) | (((c73 >> 8) & 255) << 8)) | ((c73 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp114 = c73;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this317,index75,_hx_tmp114);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						int y56 = (this1->height - 1);
HXDLIN( 602)						int y57 = (this1->height - 1);
HXDLIN( 602)						::Dynamic this318 = here->image;
HXDLIN( 602)						int index76;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index76 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index76 = ::Std_obj::_hx_int(( (Float)(((y57 * here->width) + x57)) ));
            						}
HXDLIN( 602)						int c74 = ::iterMagic::Iimg_obj::get(this318,index76);
HXDLIN( 602)						int color25;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color25 = ((((((c74 >> 24) & 255) << 24) | ((c74 & 255) << 16)) | (((c74 >> 8) & 255) << 8)) | ((c74 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color25 = c74;
            						}
HXDLIN( 602)						{
HXDLIN( 602)							int c75 = color25;
HXDLIN( 602)							bool _hx_tmp115;
HXDLIN( 602)							if ((((c75 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp115 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp115 = false;
            							}
HXDLIN( 602)							if (_hx_tmp115) {
HXDLIN( 602)								int location22;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location22 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location22 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int this319 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 602)								int this320;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this320 = ((((((this319 >> 24) & 255) << 24) | ((this319 & 255) << 16)) | (((this319 >> 8) & 255) << 8)) | ((this319 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this320 = this319;
            								}
HXDLIN( 602)								Float a124;
HXDLIN( 602)								int this321 = ((this320 >> 24) & 255);
HXDLIN( 602)								if ((this321 == 0)) {
HXDLIN( 602)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a124 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r122;
HXDLIN( 602)								int this322 = ((this320 >> 16) & 255);
HXDLIN( 602)								if ((this322 == 0)) {
HXDLIN( 602)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r122 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g122;
HXDLIN( 602)								int this323 = ((this320 >> 8) & 255);
HXDLIN( 602)								if ((this323 == 0)) {
HXDLIN( 602)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g122 = (( (Float)(this323) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b125;
HXDLIN( 602)								int this324 = (this320 & 255);
HXDLIN( 602)								if ((this324 == 0)) {
HXDLIN( 602)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b125 = (( (Float)(this324) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a223;
HXDLIN( 602)								int this325 = ((color25 >> 24) & 255);
HXDLIN( 602)								if ((this325 == 0)) {
HXDLIN( 602)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a223 = (( (Float)(this325) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r222;
HXDLIN( 602)								int this326 = ((color25 >> 16) & 255);
HXDLIN( 602)								if ((this326 == 0)) {
HXDLIN( 602)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r222 = (( (Float)(this326) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g222;
HXDLIN( 602)								int this327 = ((color25 >> 8) & 255);
HXDLIN( 602)								if ((this327 == 0)) {
HXDLIN( 602)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g222 = (( (Float)(this327) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b223;
HXDLIN( 602)								int this328 = (color25 & 255);
HXDLIN( 602)								if ((this328 == 0)) {
HXDLIN( 602)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b223 = (( (Float)(this328) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 602)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 602)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 602)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 602)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 602)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp116;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp116 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp116 = blended22;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp116);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this329 = out->image;
HXDLIN( 602)								int index77;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index77 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index77 = ::Std_obj::_hx_int(( (Float)(((y56 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int _hx_tmp117;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp117 = ((((((c75 >> 24) & 255) << 24) | ((c75 & 255) << 16)) | (((c75 >> 8) & 255) << 8)) | ((c75 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp117 = c75;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this329,index77,_hx_tmp117);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						int y58 = (this1->height - 2);
HXDLIN( 602)						int y59 = (this1->height - 2);
HXDLIN( 602)						::Dynamic this330 = here->image;
HXDLIN( 602)						int index78;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index78 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - here->virtualY) * ( (Float)(here->width) )) + x57) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index78 = ::Std_obj::_hx_int(( (Float)(((y59 * here->width) + x57)) ));
            						}
HXDLIN( 602)						int c76 = ::iterMagic::Iimg_obj::get(this330,index78);
HXDLIN( 602)						int color26;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color26 = ((((((c76 >> 24) & 255) << 24) | ((c76 & 255) << 16)) | (((c76 >> 8) & 255) << 8)) | ((c76 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color26 = c76;
            						}
HXDLIN( 602)						{
HXDLIN( 602)							int c77 = color26;
HXDLIN( 602)							bool _hx_tmp118;
HXDLIN( 602)							if ((((c77 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp118 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp118 = false;
            							}
HXDLIN( 602)							if (_hx_tmp118) {
HXDLIN( 602)								int location23;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location23 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location23 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int this331 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 602)								int this332;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this332 = ((((((this331 >> 24) & 255) << 24) | ((this331 & 255) << 16)) | (((this331 >> 8) & 255) << 8)) | ((this331 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this332 = this331;
            								}
HXDLIN( 602)								Float a125;
HXDLIN( 602)								int this333 = ((this332 >> 24) & 255);
HXDLIN( 602)								if ((this333 == 0)) {
HXDLIN( 602)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a125 = (( (Float)(this333) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r123;
HXDLIN( 602)								int this334 = ((this332 >> 16) & 255);
HXDLIN( 602)								if ((this334 == 0)) {
HXDLIN( 602)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r123 = (( (Float)(this334) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g123;
HXDLIN( 602)								int this335 = ((this332 >> 8) & 255);
HXDLIN( 602)								if ((this335 == 0)) {
HXDLIN( 602)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g123 = (( (Float)(this335) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b126;
HXDLIN( 602)								int this336 = (this332 & 255);
HXDLIN( 602)								if ((this336 == 0)) {
HXDLIN( 602)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b126 = (( (Float)(this336) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a224;
HXDLIN( 602)								int this337 = ((color26 >> 24) & 255);
HXDLIN( 602)								if ((this337 == 0)) {
HXDLIN( 602)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a224 = (( (Float)(this337) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r223;
HXDLIN( 602)								int this338 = ((color26 >> 16) & 255);
HXDLIN( 602)								if ((this338 == 0)) {
HXDLIN( 602)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r223 = (( (Float)(this338) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g223;
HXDLIN( 602)								int this339 = ((color26 >> 8) & 255);
HXDLIN( 602)								if ((this339 == 0)) {
HXDLIN( 602)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g223 = (( (Float)(this339) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b224;
HXDLIN( 602)								int this340 = (color26 & 255);
HXDLIN( 602)								if ((this340 == 0)) {
HXDLIN( 602)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b224 = (( (Float)(this340) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 602)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 602)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 602)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 602)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 602)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp119;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp119 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp119 = blended23;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp119);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this341 = out->image;
HXDLIN( 602)								int index79;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index79 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - out->virtualY) * ( (Float)(out->width) )) + x57) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index79 = ::Std_obj::_hx_int(( (Float)(((y58 * out->width) + x57)) ));
            								}
HXDLIN( 602)								int _hx_tmp120;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp120 = ((((((c77 >> 24) & 255) << 24) | ((c77 & 255) << 16)) | (((c77 >> 8) & 255) << 8)) | ((c77 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp120 = c77;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this341,index79,_hx_tmp120);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 602)			{
HXDLIN( 602)				int _g86 = 2;
HXDLIN( 602)				int _g87 = (this1->height - 3);
HXDLIN( 602)				while((_g86 < _g87)){
HXDLIN( 602)					_g86 = (_g86 + 1);
HXDLIN( 602)					int y60 = (_g86 - 1);
HXDLIN( 602)					{
HXDLIN( 602)						::Dynamic this342 = here->image;
HXDLIN( 602)						int index80;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index80 = ::Std_obj::_hx_int((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index80 = ::Std_obj::_hx_int(( (Float)((y60 * here->width)) ));
            						}
HXDLIN( 602)						int c78 = ::iterMagic::Iimg_obj::get(this342,index80);
HXDLIN( 602)						int color27;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color27 = ((((((c78 >> 24) & 255) << 24) | ((c78 & 255) << 16)) | (((c78 >> 8) & 255) << 8)) | ((c78 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color27 = c78;
            						}
HXDLIN( 602)						int color28 = color27;
HXDLIN( 602)						{
HXDLIN( 602)							int c79 = color28;
HXDLIN( 602)							bool _hx_tmp121;
HXDLIN( 602)							if ((((c79 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp121 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp121 = false;
            							}
HXDLIN( 602)							if (_hx_tmp121) {
HXDLIN( 602)								int location24;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location24 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location24 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 602)								int this343 = ::iterMagic::Iimg_obj::get(out->image,location24);
HXDLIN( 602)								int this344;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this344 = ((((((this343 >> 24) & 255) << 24) | ((this343 & 255) << 16)) | (((this343 >> 8) & 255) << 8)) | ((this343 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this344 = this343;
            								}
HXDLIN( 602)								Float a126;
HXDLIN( 602)								int this345 = ((this344 >> 24) & 255);
HXDLIN( 602)								if ((this345 == 0)) {
HXDLIN( 602)									a126 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a126 = (( (Float)(this345) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r124;
HXDLIN( 602)								int this346 = ((this344 >> 16) & 255);
HXDLIN( 602)								if ((this346 == 0)) {
HXDLIN( 602)									r124 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r124 = (( (Float)(this346) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g124;
HXDLIN( 602)								int this347 = ((this344 >> 8) & 255);
HXDLIN( 602)								if ((this347 == 0)) {
HXDLIN( 602)									g124 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g124 = (( (Float)(this347) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b127;
HXDLIN( 602)								int this348 = (this344 & 255);
HXDLIN( 602)								if ((this348 == 0)) {
HXDLIN( 602)									b127 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b127 = (( (Float)(this348) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a225;
HXDLIN( 602)								int this349 = ((color28 >> 24) & 255);
HXDLIN( 602)								if ((this349 == 0)) {
HXDLIN( 602)									a225 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a225 = (( (Float)(this349) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r224;
HXDLIN( 602)								int this350 = ((color28 >> 16) & 255);
HXDLIN( 602)								if ((this350 == 0)) {
HXDLIN( 602)									r224 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r224 = (( (Float)(this350) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g224;
HXDLIN( 602)								int this351 = ((color28 >> 8) & 255);
HXDLIN( 602)								if ((this351 == 0)) {
HXDLIN( 602)									g224 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g224 = (( (Float)(this351) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b225;
HXDLIN( 602)								int this352 = (color28 & 255);
HXDLIN( 602)								if ((this352 == 0)) {
HXDLIN( 602)									b225 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b225 = (( (Float)(this352) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a324 = (a126 * (( (Float)(1) ) - a225));
HXDLIN( 602)								int r44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 602)								int g44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 602)								int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a324) + (b225 * a225))));
HXDLIN( 602)								int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 602)								int blended24 = ((((a54 << 24) | (r44 << 16)) | (g44 << 8)) | b49);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp122;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp122 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp122 = blended24;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location24,_hx_tmp122);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this353 = out->image;
HXDLIN( 602)								int index81;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index81 = ::Std_obj::_hx_int((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index81 = ::Std_obj::_hx_int(( (Float)((y60 * out->width)) ));
            								}
HXDLIN( 602)								int _hx_tmp123;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp123 = ((((((c79 >> 24) & 255) << 24) | ((c79 & 255) << 16)) | (((c79 >> 8) & 255) << 8)) | ((c79 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp123 = c79;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this353,index81,_hx_tmp123);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						::Dynamic this354 = here->image;
HXDLIN( 602)						int index82;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index82 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + 1) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index82 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + 1)) ));
            						}
HXDLIN( 602)						int c80 = ::iterMagic::Iimg_obj::get(this354,index82);
HXDLIN( 602)						int color29;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color29 = ((((((c80 >> 24) & 255) << 24) | ((c80 & 255) << 16)) | (((c80 >> 8) & 255) << 8)) | ((c80 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color29 = c80;
            						}
HXDLIN( 602)						int color30 = color29;
HXDLIN( 602)						{
HXDLIN( 602)							int c81 = color30;
HXDLIN( 602)							bool _hx_tmp124;
HXDLIN( 602)							if ((((c81 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp124 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp124 = false;
            							}
HXDLIN( 602)							if (_hx_tmp124) {
HXDLIN( 602)								int location25;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location25 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location25 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 602)								int this355 = ::iterMagic::Iimg_obj::get(out->image,location25);
HXDLIN( 602)								int this356;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this356 = ((((((this355 >> 24) & 255) << 24) | ((this355 & 255) << 16)) | (((this355 >> 8) & 255) << 8)) | ((this355 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this356 = this355;
            								}
HXDLIN( 602)								Float a127;
HXDLIN( 602)								int this357 = ((this356 >> 24) & 255);
HXDLIN( 602)								if ((this357 == 0)) {
HXDLIN( 602)									a127 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a127 = (( (Float)(this357) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r125;
HXDLIN( 602)								int this358 = ((this356 >> 16) & 255);
HXDLIN( 602)								if ((this358 == 0)) {
HXDLIN( 602)									r125 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r125 = (( (Float)(this358) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g125;
HXDLIN( 602)								int this359 = ((this356 >> 8) & 255);
HXDLIN( 602)								if ((this359 == 0)) {
HXDLIN( 602)									g125 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g125 = (( (Float)(this359) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b128;
HXDLIN( 602)								int this360 = (this356 & 255);
HXDLIN( 602)								if ((this360 == 0)) {
HXDLIN( 602)									b128 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b128 = (( (Float)(this360) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a226;
HXDLIN( 602)								int this361 = ((color30 >> 24) & 255);
HXDLIN( 602)								if ((this361 == 0)) {
HXDLIN( 602)									a226 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a226 = (( (Float)(this361) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r225;
HXDLIN( 602)								int this362 = ((color30 >> 16) & 255);
HXDLIN( 602)								if ((this362 == 0)) {
HXDLIN( 602)									r225 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r225 = (( (Float)(this362) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g225;
HXDLIN( 602)								int this363 = ((color30 >> 8) & 255);
HXDLIN( 602)								if ((this363 == 0)) {
HXDLIN( 602)									g225 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g225 = (( (Float)(this363) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b226;
HXDLIN( 602)								int this364 = (color30 & 255);
HXDLIN( 602)								if ((this364 == 0)) {
HXDLIN( 602)									b226 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b226 = (( (Float)(this364) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a325 = (a127 * (( (Float)(1) ) - a226));
HXDLIN( 602)								int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 602)								int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 602)								int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a325) + (b226 * a226))));
HXDLIN( 602)								int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 602)								int blended25 = ((((a55 << 24) | (r45 << 16)) | (g45 << 8)) | b50);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp125;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp125 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp125 = blended25;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location25,_hx_tmp125);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this365 = out->image;
HXDLIN( 602)								int index83;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index83 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + 1) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index83 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + 1)) ));
            								}
HXDLIN( 602)								int _hx_tmp126;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp126 = ((((((c81 >> 24) & 255) << 24) | ((c81 & 255) << 16)) | (((c81 >> 8) & 255) << 8)) | ((c81 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp126 = c81;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this365,index83,_hx_tmp126);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						int x60 = (this1->width - 1);
HXDLIN( 602)						int x61 = (this1->width - 1);
HXDLIN( 602)						::Dynamic this366 = here->image;
HXDLIN( 602)						int index84;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index84 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x61) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index84 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x61)) ));
            						}
HXDLIN( 602)						int c82 = ::iterMagic::Iimg_obj::get(this366,index84);
HXDLIN( 602)						int color31;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color31 = ((((((c82 >> 24) & 255) << 24) | ((c82 & 255) << 16)) | (((c82 >> 8) & 255) << 8)) | ((c82 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color31 = c82;
            						}
HXDLIN( 602)						{
HXDLIN( 602)							int c83 = color31;
HXDLIN( 602)							bool _hx_tmp127;
HXDLIN( 602)							if ((((c83 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp127 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp127 = false;
            							}
HXDLIN( 602)							if (_hx_tmp127) {
HXDLIN( 602)								int location26;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location26 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location26 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 602)								int this367 = ::iterMagic::Iimg_obj::get(out->image,location26);
HXDLIN( 602)								int this368;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this368 = ((((((this367 >> 24) & 255) << 24) | ((this367 & 255) << 16)) | (((this367 >> 8) & 255) << 8)) | ((this367 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this368 = this367;
            								}
HXDLIN( 602)								Float a128;
HXDLIN( 602)								int this369 = ((this368 >> 24) & 255);
HXDLIN( 602)								if ((this369 == 0)) {
HXDLIN( 602)									a128 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a128 = (( (Float)(this369) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r126;
HXDLIN( 602)								int this370 = ((this368 >> 16) & 255);
HXDLIN( 602)								if ((this370 == 0)) {
HXDLIN( 602)									r126 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r126 = (( (Float)(this370) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g126;
HXDLIN( 602)								int this371 = ((this368 >> 8) & 255);
HXDLIN( 602)								if ((this371 == 0)) {
HXDLIN( 602)									g126 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g126 = (( (Float)(this371) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b129;
HXDLIN( 602)								int this372 = (this368 & 255);
HXDLIN( 602)								if ((this372 == 0)) {
HXDLIN( 602)									b129 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b129 = (( (Float)(this372) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a227;
HXDLIN( 602)								int this373 = ((color31 >> 24) & 255);
HXDLIN( 602)								if ((this373 == 0)) {
HXDLIN( 602)									a227 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a227 = (( (Float)(this373) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r226;
HXDLIN( 602)								int this374 = ((color31 >> 16) & 255);
HXDLIN( 602)								if ((this374 == 0)) {
HXDLIN( 602)									r226 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r226 = (( (Float)(this374) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g226;
HXDLIN( 602)								int this375 = ((color31 >> 8) & 255);
HXDLIN( 602)								if ((this375 == 0)) {
HXDLIN( 602)									g226 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g226 = (( (Float)(this375) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b227;
HXDLIN( 602)								int this376 = (color31 & 255);
HXDLIN( 602)								if ((this376 == 0)) {
HXDLIN( 602)									b227 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b227 = (( (Float)(this376) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a326 = (a128 * (( (Float)(1) ) - a227));
HXDLIN( 602)								int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 602)								int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 602)								int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a326) + (b227 * a227))));
HXDLIN( 602)								int a56 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 602)								int blended26 = ((((a56 << 24) | (r46 << 16)) | (g46 << 8)) | b51);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp128;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp128 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp128 = blended26;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location26,_hx_tmp128);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this377 = out->image;
HXDLIN( 602)								int index85;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index85 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x60) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index85 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x60)) ));
            								}
HXDLIN( 602)								int _hx_tmp129;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp129 = ((((((c83 >> 24) & 255) << 24) | ((c83 & 255) << 16)) | (((c83 >> 8) & 255) << 8)) | ((c83 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp129 = c83;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this377,index85,_hx_tmp129);
            							}
            						}
            					}
HXDLIN( 602)					{
HXDLIN( 602)						int x62 = (this1->width - 2);
HXDLIN( 602)						int x63 = (this1->width - 2);
HXDLIN( 602)						::Dynamic this378 = here->image;
HXDLIN( 602)						int index86;
HXDLIN( 602)						if (here->useVirtualPos) {
HXDLIN( 602)							index86 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - here->virtualY) * ( (Float)(here->width) )) + x63) - here->virtualX));
            						}
            						else {
HXDLIN( 602)							index86 = ::Std_obj::_hx_int(( (Float)(((y60 * here->width) + x63)) ));
            						}
HXDLIN( 602)						int c84 = ::iterMagic::Iimg_obj::get(this378,index86);
HXDLIN( 602)						int color32;
HXDLIN( 602)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)							color32 = ((((((c84 >> 24) & 255) << 24) | ((c84 & 255) << 16)) | (((c84 >> 8) & 255) << 8)) | ((c84 >> 16) & 255));
            						}
            						else {
HXDLIN( 602)							color32 = c84;
            						}
HXDLIN( 602)						{
HXDLIN( 602)							int c85 = color32;
HXDLIN( 602)							bool _hx_tmp130;
HXDLIN( 602)							if ((((c85 >> 24) & 255) < 254)) {
HXDLIN( 602)								_hx_tmp130 = out->transparent;
            							}
            							else {
HXDLIN( 602)								_hx_tmp130 = false;
            							}
HXDLIN( 602)							if (_hx_tmp130) {
HXDLIN( 602)								int location27;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									location27 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									location27 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 602)								int this379 = ::iterMagic::Iimg_obj::get(out->image,location27);
HXDLIN( 602)								int this380;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									this380 = ((((((this379 >> 24) & 255) << 24) | ((this379 & 255) << 16)) | (((this379 >> 8) & 255) << 8)) | ((this379 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									this380 = this379;
            								}
HXDLIN( 602)								Float a129;
HXDLIN( 602)								int this381 = ((this380 >> 24) & 255);
HXDLIN( 602)								if ((this381 == 0)) {
HXDLIN( 602)									a129 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a129 = (( (Float)(this381) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r127;
HXDLIN( 602)								int this382 = ((this380 >> 16) & 255);
HXDLIN( 602)								if ((this382 == 0)) {
HXDLIN( 602)									r127 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r127 = (( (Float)(this382) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g127;
HXDLIN( 602)								int this383 = ((this380 >> 8) & 255);
HXDLIN( 602)								if ((this383 == 0)) {
HXDLIN( 602)									g127 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g127 = (( (Float)(this383) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b130;
HXDLIN( 602)								int this384 = (this380 & 255);
HXDLIN( 602)								if ((this384 == 0)) {
HXDLIN( 602)									b130 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b130 = (( (Float)(this384) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a228;
HXDLIN( 602)								int this385 = ((color32 >> 24) & 255);
HXDLIN( 602)								if ((this385 == 0)) {
HXDLIN( 602)									a228 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									a228 = (( (Float)(this385) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float r227;
HXDLIN( 602)								int this386 = ((color32 >> 16) & 255);
HXDLIN( 602)								if ((this386 == 0)) {
HXDLIN( 602)									r227 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									r227 = (( (Float)(this386) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float g227;
HXDLIN( 602)								int this387 = ((color32 >> 8) & 255);
HXDLIN( 602)								if ((this387 == 0)) {
HXDLIN( 602)									g227 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									g227 = (( (Float)(this387) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float b228;
HXDLIN( 602)								int this388 = (color32 & 255);
HXDLIN( 602)								if ((this388 == 0)) {
HXDLIN( 602)									b228 = ((Float)0.);
            								}
            								else {
HXDLIN( 602)									b228 = (( (Float)(this388) ) / ( (Float)(255) ));
            								}
HXDLIN( 602)								Float a327 = (a129 * (( (Float)(1) ) - a228));
HXDLIN( 602)								int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 602)								int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 602)								int b52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a327) + (b228 * a228))));
HXDLIN( 602)								int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 602)								int blended27 = ((((a57 << 24) | (r47 << 16)) | (g47 << 8)) | b52);
HXDLIN( 602)								{
HXDLIN( 602)									int _hx_tmp131;
HXDLIN( 602)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)										_hx_tmp131 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            									}
            									else {
HXDLIN( 602)										_hx_tmp131 = blended27;
            									}
HXDLIN( 602)									::iterMagic::Iimg_obj::set(out->image,location27,_hx_tmp131);
            								}
            							}
            							else {
HXDLIN( 602)								::Dynamic this389 = out->image;
HXDLIN( 602)								int index87;
HXDLIN( 602)								if (out->useVirtualPos) {
HXDLIN( 602)									index87 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - out->virtualY) * ( (Float)(out->width) )) + x62) - out->virtualX));
            								}
            								else {
HXDLIN( 602)									index87 = ::Std_obj::_hx_int(( (Float)(((y60 * out->width) + x62)) ));
            								}
HXDLIN( 602)								int _hx_tmp132;
HXDLIN( 602)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 602)									_hx_tmp132 = ((((((c85 >> 24) & 255) << 24) | ((c85 & 255) << 16)) | (((c85 >> 8) & 255) << 8)) | ((c85 >> 16) & 255));
            								}
            								else {
HXDLIN( 602)									_hx_tmp132 = c85;
            								}
HXDLIN( 602)								::iterMagic::Iimg_obj::set(this389,index87,_hx_tmp132);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 602)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,unsharpenMask0_5x5,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::edgeEnhance0_3x3( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_608_edgeEnhance0_3x3)
HXDLIN( 608)		Float m33_a = ((Float)0.);
HXDLIN( 608)		Float m33_b = ((Float)0.);
HXDLIN( 608)		Float m33_c = ((Float)0.);
HXDLIN( 608)		Float m33_d = ((Float)-1.);
HXDLIN( 608)		Float m33_e = ((Float)1.);
HXDLIN( 608)		Float m33_f = ((Float)0.);
HXDLIN( 608)		Float m33_g = ((Float)0.);
HXDLIN( 608)		Float m33_h = ((Float)0.);
HXDLIN( 608)		Float m33_i = ((Float)0.);
HXDLIN( 608)		bool adjustRed = true;
HXDLIN( 608)		bool adjustGreen = true;
HXDLIN( 608)		bool adjustBlue = true;
HXDLIN( 608)		int a0 = 0;
HXDLIN( 608)		int b0 = 0;
HXDLIN( 608)		int c0 = 0;
HXDLIN( 608)		int d0 = 0;
HXDLIN( 608)		int e0 = 0;
HXDLIN( 608)		int f0 = 0;
HXDLIN( 608)		int g0 = 0;
HXDLIN( 608)		int h0 = 0;
HXDLIN( 608)		int i0 = 0;
HXDLIN( 608)		Float r_ = ((Float)0.);
HXDLIN( 608)		Float g_ = ((Float)0.);
HXDLIN( 608)		Float b_ = ((Float)0.);
HXDLIN( 608)		Float a_ = ((Float)0.);
HXDLIN( 608)		int width = this1->width;
HXDLIN( 608)		int height = this1->height;
HXDLIN( 608)		 ::Dynamic imageType = null();
HXDLIN( 608)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 608)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 608)		::Dynamic _hx_tmp;
HXDLIN( 608)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 608)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 608)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 608)				{
HXDLIN( 608)					b->width = width;
HXDLIN( 608)					b->height = height;
HXDLIN( 608)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 608)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 608)					{
HXDLIN( 608)						int len = b->length;
HXDLIN( 608)						int w = 0;
HXDLIN( 608)						{
HXDLIN( 608)							int _g = 0;
HXDLIN( 608)							int _g1 = b->height;
HXDLIN( 608)							while((_g < _g1)){
HXDLIN( 608)								_g = (_g + 1);
HXDLIN( 608)								int y = (_g - 1);
HXDLIN( 608)								{
HXDLIN( 608)									int _g2 = 0;
HXDLIN( 608)									int _g3 = b->width;
HXDLIN( 608)									while((_g2 < _g3)){
HXDLIN( 608)										_g2 = (_g2 + 1);
HXDLIN( 608)										int x = (_g2 - 1);
HXDLIN( 608)										{
HXDLIN( 608)											w = (w + 1);
HXDLIN( 608)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 608)										{
HXDLIN( 608)											w = (w + 1);
HXDLIN( 608)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 608)										{
HXDLIN( 608)											w = (w + 1);
HXDLIN( 608)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 608)										{
HXDLIN( 608)											w = (w + 1);
HXDLIN( 608)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 608)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 608)				{
HXDLIN( 608)					a->width = width;
HXDLIN( 608)					a->height = height;
HXDLIN( 608)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 608)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 608)					{
HXDLIN( 608)						int _g4 = 0;
HXDLIN( 608)						int _g5 = a->length;
HXDLIN( 608)						while((_g4 < _g5)){
HXDLIN( 608)							_g4 = (_g4 + 1);
HXDLIN( 608)							int i = (_g4 - 1);
HXDLIN( 608)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 608)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 608)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 608)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 608)				{
HXDLIN( 608)					b1->width = width;
HXDLIN( 608)					b1->height = height;
HXDLIN( 608)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 608)					int size = (b1->length * 4);
HXDLIN( 608)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 608)					{
HXDLIN( 608)						int _g6 = 0;
HXDLIN( 608)						int _g7 = b1->length;
HXDLIN( 608)						while((_g6 < _g7)){
HXDLIN( 608)							_g6 = (_g6 + 1);
HXDLIN( 608)							int i1 = (_g6 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 608)								bool _hx_tmp1;
HXDLIN( 608)								if ((i1 >= 0)) {
HXDLIN( 608)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 608)									_hx_tmp1 = false;
            								}
HXDLIN( 608)								if (_hx_tmp1) {
HXDLIN( 608)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 608)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 608)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 608)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 608)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 608)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 608)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 608)				{
HXDLIN( 608)					v->width = width;
HXDLIN( 608)					v->height = height;
HXDLIN( 608)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 608)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 608)					{
HXDLIN( 608)						int _g8 = 0;
HXDLIN( 608)						int _g9 = v->length;
HXDLIN( 608)						while((_g8 < _g9)){
HXDLIN( 608)							_g8 = (_g8 + 1);
HXDLIN( 608)							int i2 = (_g8 - 1);
HXDLIN( 608)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 608)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 608)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 608)				{
HXDLIN( 608)					b2->width = width;
HXDLIN( 608)					b2->height = height;
HXDLIN( 608)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 608)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 608)					{
HXDLIN( 608)						int len1 = b2->length;
HXDLIN( 608)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 608)						if (::hx::IsNull( d->head )) {
HXDLIN( 608)							int _g10 = 0;
HXDLIN( 608)							int _g11 = len1;
HXDLIN( 608)							while((_g10 < _g11)){
HXDLIN( 608)								_g10 = (_g10 + 1);
HXDLIN( 608)								int i3 = (_g10 - 1);
HXDLIN( 608)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 608)							int _g12 = 0;
HXDLIN( 608)							int _g13 = len1;
HXDLIN( 608)							while((_g12 < _g13)){
HXDLIN( 608)								_g12 = (_g12 + 1);
HXDLIN( 608)								int i4 = (_g12 - 1);
HXDLIN( 608)								{
HXDLIN( 608)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 608)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 608)									{
HXDLIN( 608)										int _g14 = 0;
HXDLIN( 608)										int _g15 = i4;
HXDLIN( 608)										while((_g14 < _g15)){
HXDLIN( 608)											_g14 = (_g14 + 1);
HXDLIN( 608)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 608)									if (::hx::IsNull( prev )) {
HXDLIN( 608)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 608)										l = null();
            									}
            									else {
HXDLIN( 608)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 608)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 608)		this2->image = _hx_tmp;
HXDLIN( 608)		this2->width = width;
HXDLIN( 608)		this2->height = height;
HXDLIN( 608)		this2->imageType = ( (int)(imageType) );
HXDLIN( 608)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 608)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 608)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 608)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 608)				int width1 = (this4->width + 2);
HXDLIN( 608)				int height1 = (this4->height + 2);
HXDLIN( 608)				 ::Dynamic imageType1 = null();
HXDLIN( 608)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 608)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 608)				::Dynamic here1;
HXDLIN( 608)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 608)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 608)						{
HXDLIN( 608)							b3->width = width1;
HXDLIN( 608)							b3->height = height1;
HXDLIN( 608)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 608)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 608)							{
HXDLIN( 608)								int len2 = b3->length;
HXDLIN( 608)								int w1 = 0;
HXDLIN( 608)								{
HXDLIN( 608)									int _g16 = 0;
HXDLIN( 608)									int _g17 = b3->height;
HXDLIN( 608)									while((_g16 < _g17)){
HXDLIN( 608)										_g16 = (_g16 + 1);
HXDLIN( 608)										int y1 = (_g16 - 1);
HXDLIN( 608)										{
HXDLIN( 608)											int _g18 = 0;
HXDLIN( 608)											int _g19 = b3->width;
HXDLIN( 608)											while((_g18 < _g19)){
HXDLIN( 608)												_g18 = (_g18 + 1);
HXDLIN( 608)												int x1 = (_g18 - 1);
HXDLIN( 608)												{
HXDLIN( 608)													w1 = (w1 + 1);
HXDLIN( 608)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w1 = (w1 + 1);
HXDLIN( 608)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w1 = (w1 + 1);
HXDLIN( 608)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w1 = (w1 + 1);
HXDLIN( 608)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 608)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 608)						{
HXDLIN( 608)							a1->width = width1;
HXDLIN( 608)							a1->height = height1;
HXDLIN( 608)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 608)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 608)							{
HXDLIN( 608)								int _g20 = 0;
HXDLIN( 608)								int _g21 = a1->length;
HXDLIN( 608)								while((_g20 < _g21)){
HXDLIN( 608)									_g20 = (_g20 + 1);
HXDLIN( 608)									int i6 = (_g20 - 1);
HXDLIN( 608)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 608)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 608)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 608)						{
HXDLIN( 608)							b4->width = width1;
HXDLIN( 608)							b4->height = height1;
HXDLIN( 608)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 608)							int size1 = (b4->length * 4);
HXDLIN( 608)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 608)							{
HXDLIN( 608)								int _g22 = 0;
HXDLIN( 608)								int _g23 = b4->length;
HXDLIN( 608)								while((_g22 < _g23)){
HXDLIN( 608)									_g22 = (_g22 + 1);
HXDLIN( 608)									int i7 = (_g22 - 1);
HXDLIN( 608)									{
HXDLIN( 608)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 608)										bool here2;
HXDLIN( 608)										if ((i7 >= 0)) {
HXDLIN( 608)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 608)											here2 = false;
            										}
HXDLIN( 608)										if (here2) {
HXDLIN( 608)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 608)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 608)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 608)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 608)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 608)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 608)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 608)						{
HXDLIN( 608)							v1->width = width1;
HXDLIN( 608)							v1->height = height1;
HXDLIN( 608)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 608)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 608)							{
HXDLIN( 608)								int _g24 = 0;
HXDLIN( 608)								int _g25 = v1->length;
HXDLIN( 608)								while((_g24 < _g25)){
HXDLIN( 608)									_g24 = (_g24 + 1);
HXDLIN( 608)									int i8 = (_g24 - 1);
HXDLIN( 608)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 608)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 608)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 608)						{
HXDLIN( 608)							b5->width = width1;
HXDLIN( 608)							b5->height = height1;
HXDLIN( 608)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 608)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 608)							{
HXDLIN( 608)								int len3 = b5->length;
HXDLIN( 608)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 608)								if (::hx::IsNull( d1->head )) {
HXDLIN( 608)									int _g26 = 0;
HXDLIN( 608)									int _g27 = len3;
HXDLIN( 608)									while((_g26 < _g27)){
HXDLIN( 608)										_g26 = (_g26 + 1);
HXDLIN( 608)										int i9 = (_g26 - 1);
HXDLIN( 608)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 608)									int _g28 = 0;
HXDLIN( 608)									int _g29 = len3;
HXDLIN( 608)									while((_g28 < _g29)){
HXDLIN( 608)										_g28 = (_g28 + 1);
HXDLIN( 608)										int i10 = (_g28 - 1);
HXDLIN( 608)										{
HXDLIN( 608)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 608)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 608)											{
HXDLIN( 608)												int _g30 = 0;
HXDLIN( 608)												int _g31 = i10;
HXDLIN( 608)												while((_g30 < _g31)){
HXDLIN( 608)													_g30 = (_g30 + 1);
HXDLIN( 608)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 608)											if (::hx::IsNull( prev1 )) {
HXDLIN( 608)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 608)												l1 = null();
            											}
            											else {
HXDLIN( 608)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 608)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 608)				this5->image = here1;
HXDLIN( 608)				this5->width = width1;
HXDLIN( 608)				this5->height = height1;
HXDLIN( 608)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 608)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 608)				bool forceClear = false;
HXDLIN( 608)				int _g32 = 0;
HXDLIN( 608)				int _g33 = this4->height;
HXDLIN( 608)				while((_g32 < _g33)){
HXDLIN( 608)					_g32 = (_g32 + 1);
HXDLIN( 608)					int dy = (_g32 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g34 = 0;
HXDLIN( 608)						int _g35 = this4->width;
HXDLIN( 608)						while((_g34 < _g35)){
HXDLIN( 608)							_g34 = (_g34 + 1);
HXDLIN( 608)							int dx = (_g34 - 1);
HXDLIN( 608)							::Dynamic this7 = this4->image;
HXDLIN( 608)							int index;
HXDLIN( 608)							if (this4->useVirtualPos) {
HXDLIN( 608)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 608)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 608)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 608)							int col;
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								col = c;
            							}
HXDLIN( 608)							bool here3;
HXDLIN( 608)							if (this4->useMask) {
HXDLIN( 608)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 608)								here3 = false;
            							}
HXDLIN( 608)							if (here3) {
HXDLIN( 608)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 608)								::Dynamic this9 = this8->image;
HXDLIN( 608)								int index1;
HXDLIN( 608)								if (this8->useVirtualPos) {
HXDLIN( 608)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 608)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 608)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 608)								int v2;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									v2 = c1;
            								}
HXDLIN( 608)								int maskPixel = v2;
HXDLIN( 608)								int this10 = col;
HXDLIN( 608)								if ((maskPixel == 0)) {
HXDLIN( 608)									col = this10;
            								}
            								else {
HXDLIN( 608)									Float m0;
HXDLIN( 608)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 608)									if ((this11 == 0)) {
HXDLIN( 608)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m1;
HXDLIN( 608)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 608)									if ((this12 == 0)) {
HXDLIN( 608)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m2;
HXDLIN( 608)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 608)									if ((this13 == 0)) {
HXDLIN( 608)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m3;
HXDLIN( 608)									int this14 = (maskPixel & 255);
HXDLIN( 608)									if ((this14 == 0)) {
HXDLIN( 608)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 608)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 608)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 608)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 608)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 608)							if ((col != 0)) {
HXDLIN( 608)								int x2 = (1 + dx);
HXDLIN( 608)								int y2 = (1 + dy);
HXDLIN( 608)								int c2 = col;
HXDLIN( 608)								bool here4;
HXDLIN( 608)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 608)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 608)									here4 = false;
            								}
HXDLIN( 608)								if (here4) {
HXDLIN( 608)									int location;
HXDLIN( 608)									if (img->useVirtualPos) {
HXDLIN( 608)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 608)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 608)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 608)									int this16;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										this16 = this15;
            									}
HXDLIN( 608)									Float a11;
HXDLIN( 608)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 608)									if ((this17 == 0)) {
HXDLIN( 608)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r1;
HXDLIN( 608)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 608)									if ((this18 == 0)) {
HXDLIN( 608)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g1;
HXDLIN( 608)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 608)									if ((this19 == 0)) {
HXDLIN( 608)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b11;
HXDLIN( 608)									int this20 = (this16 & 255);
HXDLIN( 608)									if ((this20 == 0)) {
HXDLIN( 608)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a2;
HXDLIN( 608)									int this21 = ((col >> 24) & 255);
HXDLIN( 608)									if ((this21 == 0)) {
HXDLIN( 608)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r2;
HXDLIN( 608)									int this22 = ((col >> 16) & 255);
HXDLIN( 608)									if ((this22 == 0)) {
HXDLIN( 608)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g2;
HXDLIN( 608)									int this23 = ((col >> 8) & 255);
HXDLIN( 608)									if ((this23 == 0)) {
HXDLIN( 608)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b21;
HXDLIN( 608)									int this24 = (col & 255);
HXDLIN( 608)									if ((this24 == 0)) {
HXDLIN( 608)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 608)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 608)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 608)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 608)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 608)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 608)									{
HXDLIN( 608)										int here5;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here5 = blended;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 608)									::Dynamic this25 = img->image;
HXDLIN( 608)									int index2;
HXDLIN( 608)									if (img->useVirtualPos) {
HXDLIN( 608)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 608)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 608)									int here6;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										here6 = c2;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 608)								if (forceClear) {
HXDLIN( 608)									::Dynamic this26 = img->image;
HXDLIN( 608)									int x3 = (1 + dx);
HXDLIN( 608)									int y3 = (1 + dy);
HXDLIN( 608)									int index3;
HXDLIN( 608)									if (img->useVirtualPos) {
HXDLIN( 608)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 608)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g36 = 0;
HXDLIN( 608)				int _g37 = this4->width;
HXDLIN( 608)				while((_g36 < _g37)){
HXDLIN( 608)					_g36 = (_g36 + 1);
HXDLIN( 608)					int x4 = (_g36 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g38 = 0;
HXDLIN( 608)						int _g39 = 1;
HXDLIN( 608)						while((_g38 < _g39)){
HXDLIN( 608)							_g38 = (_g38 + 1);
HXDLIN( 608)							int y4 = (_g38 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								int x5 = (x4 + 1);
HXDLIN( 608)								::Dynamic this27 = this4->image;
HXDLIN( 608)								int index4;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 608)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 608)								int color;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color = c3;
            								}
HXDLIN( 608)								int color1 = color;
HXDLIN( 608)								{
HXDLIN( 608)									int c4 = color1;
HXDLIN( 608)									bool here7;
HXDLIN( 608)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 608)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here7 = false;
            									}
HXDLIN( 608)									if (here7) {
HXDLIN( 608)										int location1;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 608)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 608)										int this29;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this29 = this28;
            										}
HXDLIN( 608)										Float a12;
HXDLIN( 608)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 608)										if ((this30 == 0)) {
HXDLIN( 608)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r11;
HXDLIN( 608)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 608)										if ((this31 == 0)) {
HXDLIN( 608)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g11;
HXDLIN( 608)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 608)										if ((this32 == 0)) {
HXDLIN( 608)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b12;
HXDLIN( 608)										int this33 = (this29 & 255);
HXDLIN( 608)										if ((this33 == 0)) {
HXDLIN( 608)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a21;
HXDLIN( 608)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 608)										if ((this34 == 0)) {
HXDLIN( 608)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r21;
HXDLIN( 608)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 608)										if ((this35 == 0)) {
HXDLIN( 608)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g21;
HXDLIN( 608)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 608)										if ((this36 == 0)) {
HXDLIN( 608)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b22;
HXDLIN( 608)										int this37 = (color1 & 255);
HXDLIN( 608)										if ((this37 == 0)) {
HXDLIN( 608)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 608)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 608)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 608)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 608)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 608)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 608)										{
HXDLIN( 608)											int here8;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here8 = blended1;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this38 = img->image;
HXDLIN( 608)										int index5;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 608)										int here9;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here9 = c4;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x6 = (x4 + 1);
HXDLIN( 608)								int y5 = ((img->height - y4) - 1);
HXDLIN( 608)								int y6 = (this4->height - 1);
HXDLIN( 608)								::Dynamic this39 = this4->image;
HXDLIN( 608)								int index6;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 608)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 608)								int color2;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color2 = c5;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c6 = color2;
HXDLIN( 608)									bool here10;
HXDLIN( 608)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 608)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here10 = false;
            									}
HXDLIN( 608)									if (here10) {
HXDLIN( 608)										int location2;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 608)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 608)										int this41;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this41 = this40;
            										}
HXDLIN( 608)										Float a13;
HXDLIN( 608)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 608)										if ((this42 == 0)) {
HXDLIN( 608)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r12;
HXDLIN( 608)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 608)										if ((this43 == 0)) {
HXDLIN( 608)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g12;
HXDLIN( 608)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 608)										if ((this44 == 0)) {
HXDLIN( 608)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b13;
HXDLIN( 608)										int this45 = (this41 & 255);
HXDLIN( 608)										if ((this45 == 0)) {
HXDLIN( 608)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a22;
HXDLIN( 608)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 608)										if ((this46 == 0)) {
HXDLIN( 608)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r22;
HXDLIN( 608)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 608)										if ((this47 == 0)) {
HXDLIN( 608)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g22;
HXDLIN( 608)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 608)										if ((this48 == 0)) {
HXDLIN( 608)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b23;
HXDLIN( 608)										int this49 = (color2 & 255);
HXDLIN( 608)										if ((this49 == 0)) {
HXDLIN( 608)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 608)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 608)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 608)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 608)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 608)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 608)										{
HXDLIN( 608)											int here11;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here11 = blended2;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this50 = img->image;
HXDLIN( 608)										int index7;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 608)										int here12;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here12 = c6;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g40 = 0;
HXDLIN( 608)				int _g41 = this4->height;
HXDLIN( 608)				while((_g40 < _g41)){
HXDLIN( 608)					_g40 = (_g40 + 1);
HXDLIN( 608)					int y7 = (_g40 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g42 = 0;
HXDLIN( 608)						int _g43 = 1;
HXDLIN( 608)						while((_g42 < _g43)){
HXDLIN( 608)							_g42 = (_g42 + 1);
HXDLIN( 608)							int x7 = (_g42 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								int y8 = (y7 + 1);
HXDLIN( 608)								::Dynamic this51 = this4->image;
HXDLIN( 608)								int index8;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 608)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 608)								int color3;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color3 = c7;
            								}
HXDLIN( 608)								int color4 = color3;
HXDLIN( 608)								{
HXDLIN( 608)									int c8 = color4;
HXDLIN( 608)									bool here13;
HXDLIN( 608)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 608)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here13 = false;
            									}
HXDLIN( 608)									if (here13) {
HXDLIN( 608)										int location3;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 608)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 608)										int this53;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this53 = this52;
            										}
HXDLIN( 608)										Float a14;
HXDLIN( 608)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 608)										if ((this54 == 0)) {
HXDLIN( 608)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r13;
HXDLIN( 608)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 608)										if ((this55 == 0)) {
HXDLIN( 608)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g13;
HXDLIN( 608)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 608)										if ((this56 == 0)) {
HXDLIN( 608)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b14;
HXDLIN( 608)										int this57 = (this53 & 255);
HXDLIN( 608)										if ((this57 == 0)) {
HXDLIN( 608)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a23;
HXDLIN( 608)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 608)										if ((this58 == 0)) {
HXDLIN( 608)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r23;
HXDLIN( 608)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 608)										if ((this59 == 0)) {
HXDLIN( 608)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g23;
HXDLIN( 608)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 608)										if ((this60 == 0)) {
HXDLIN( 608)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b24;
HXDLIN( 608)										int this61 = (color4 & 255);
HXDLIN( 608)										if ((this61 == 0)) {
HXDLIN( 608)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 608)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 608)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 608)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 608)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 608)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 608)										{
HXDLIN( 608)											int here14;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here14 = blended3;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this62 = img->image;
HXDLIN( 608)										int index9;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 608)										int here15;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here15 = c8;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x8 = ((img->width - x7) - 1);
HXDLIN( 608)								int y9 = (y7 + 1);
HXDLIN( 608)								int x9 = (this4->width - 1);
HXDLIN( 608)								::Dynamic this63 = this4->image;
HXDLIN( 608)								int index10;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 608)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 608)								int color5;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color5 = c9;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c10 = color5;
HXDLIN( 608)									bool here16;
HXDLIN( 608)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 608)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here16 = false;
            									}
HXDLIN( 608)									if (here16) {
HXDLIN( 608)										int location4;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 608)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 608)										int this65;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this65 = this64;
            										}
HXDLIN( 608)										Float a15;
HXDLIN( 608)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 608)										if ((this66 == 0)) {
HXDLIN( 608)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r14;
HXDLIN( 608)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 608)										if ((this67 == 0)) {
HXDLIN( 608)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g14;
HXDLIN( 608)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 608)										if ((this68 == 0)) {
HXDLIN( 608)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b15;
HXDLIN( 608)										int this69 = (this65 & 255);
HXDLIN( 608)										if ((this69 == 0)) {
HXDLIN( 608)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a24;
HXDLIN( 608)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 608)										if ((this70 == 0)) {
HXDLIN( 608)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r24;
HXDLIN( 608)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 608)										if ((this71 == 0)) {
HXDLIN( 608)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g24;
HXDLIN( 608)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 608)										if ((this72 == 0)) {
HXDLIN( 608)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b25;
HXDLIN( 608)										int this73 = (color5 & 255);
HXDLIN( 608)										if ((this73 == 0)) {
HXDLIN( 608)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 608)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 608)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 608)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 608)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 608)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 608)										{
HXDLIN( 608)											int here17;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here17 = blended4;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this74 = img->image;
HXDLIN( 608)										int index11;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 608)										int here18;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here18 = c10;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g44 = 0;
HXDLIN( 608)				int _g45 = 1;
HXDLIN( 608)				while((_g44 < _g45)){
HXDLIN( 608)					_g44 = (_g44 + 1);
HXDLIN( 608)					int x10 = (_g44 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g46 = 0;
HXDLIN( 608)						int _g47 = 1;
HXDLIN( 608)						while((_g46 < _g47)){
HXDLIN( 608)							_g46 = (_g46 + 1);
HXDLIN( 608)							int y10 = (_g46 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								::Dynamic this75 = this4->image;
HXDLIN( 608)								int index12;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 608)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 608)								int color6;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color6 = c11;
            								}
HXDLIN( 608)								int color7 = color6;
HXDLIN( 608)								{
HXDLIN( 608)									int c12 = color7;
HXDLIN( 608)									bool here19;
HXDLIN( 608)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 608)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here19 = false;
            									}
HXDLIN( 608)									if (here19) {
HXDLIN( 608)										int location5;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 608)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 608)										int this77;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this77 = this76;
            										}
HXDLIN( 608)										Float a16;
HXDLIN( 608)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 608)										if ((this78 == 0)) {
HXDLIN( 608)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r15;
HXDLIN( 608)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 608)										if ((this79 == 0)) {
HXDLIN( 608)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g15;
HXDLIN( 608)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 608)										if ((this80 == 0)) {
HXDLIN( 608)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b16;
HXDLIN( 608)										int this81 = (this77 & 255);
HXDLIN( 608)										if ((this81 == 0)) {
HXDLIN( 608)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a25;
HXDLIN( 608)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 608)										if ((this82 == 0)) {
HXDLIN( 608)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r25;
HXDLIN( 608)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 608)										if ((this83 == 0)) {
HXDLIN( 608)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g25;
HXDLIN( 608)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 608)										if ((this84 == 0)) {
HXDLIN( 608)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b26;
HXDLIN( 608)										int this85 = (color7 & 255);
HXDLIN( 608)										if ((this85 == 0)) {
HXDLIN( 608)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 608)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 608)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 608)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 608)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 608)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 608)										{
HXDLIN( 608)											int here20;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here20 = blended5;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this86 = img->image;
HXDLIN( 608)										int index13;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 608)										int here21;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here21 = c12;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x11 = ((x10 + 1) + this4->width);
HXDLIN( 608)								int x12 = (this4->width - 1);
HXDLIN( 608)								::Dynamic this87 = this4->image;
HXDLIN( 608)								int index14;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 608)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 608)								int color8;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color8 = c13;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c14 = color8;
HXDLIN( 608)									bool here22;
HXDLIN( 608)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 608)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here22 = false;
            									}
HXDLIN( 608)									if (here22) {
HXDLIN( 608)										int location6;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 608)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 608)										int this89;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this89 = this88;
            										}
HXDLIN( 608)										Float a17;
HXDLIN( 608)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 608)										if ((this90 == 0)) {
HXDLIN( 608)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r16;
HXDLIN( 608)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 608)										if ((this91 == 0)) {
HXDLIN( 608)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g16;
HXDLIN( 608)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 608)										if ((this92 == 0)) {
HXDLIN( 608)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b18;
HXDLIN( 608)										int this93 = (this89 & 255);
HXDLIN( 608)										if ((this93 == 0)) {
HXDLIN( 608)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a26;
HXDLIN( 608)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 608)										if ((this94 == 0)) {
HXDLIN( 608)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r26;
HXDLIN( 608)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 608)										if ((this95 == 0)) {
HXDLIN( 608)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g26;
HXDLIN( 608)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 608)										if ((this96 == 0)) {
HXDLIN( 608)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b27;
HXDLIN( 608)										int this97 = (color8 & 255);
HXDLIN( 608)										if ((this97 == 0)) {
HXDLIN( 608)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 608)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 608)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 608)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 608)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 608)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 608)										{
HXDLIN( 608)											int here23;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here23 = blended6;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this98 = img->image;
HXDLIN( 608)										int index15;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 608)										int here24;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here24 = c14;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x13 = ((x10 + 1) + this4->width);
HXDLIN( 608)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 608)								int x14 = (this4->width - 1);
HXDLIN( 608)								int y12 = (this4->height - 1);
HXDLIN( 608)								::Dynamic this99 = this4->image;
HXDLIN( 608)								int index16;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 608)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 608)								int color9;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color9 = c15;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c16 = color9;
HXDLIN( 608)									bool here25;
HXDLIN( 608)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 608)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here25 = false;
            									}
HXDLIN( 608)									if (here25) {
HXDLIN( 608)										int location7;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 608)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 608)										int this101;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this101 = this100;
            										}
HXDLIN( 608)										Float a18;
HXDLIN( 608)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 608)										if ((this102 == 0)) {
HXDLIN( 608)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r17;
HXDLIN( 608)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 608)										if ((this103 == 0)) {
HXDLIN( 608)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g17;
HXDLIN( 608)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 608)										if ((this104 == 0)) {
HXDLIN( 608)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b110;
HXDLIN( 608)										int this105 = (this101 & 255);
HXDLIN( 608)										if ((this105 == 0)) {
HXDLIN( 608)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a27;
HXDLIN( 608)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 608)										if ((this106 == 0)) {
HXDLIN( 608)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r27;
HXDLIN( 608)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 608)										if ((this107 == 0)) {
HXDLIN( 608)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g27;
HXDLIN( 608)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 608)										if ((this108 == 0)) {
HXDLIN( 608)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b28;
HXDLIN( 608)										int this109 = (color9 & 255);
HXDLIN( 608)										if ((this109 == 0)) {
HXDLIN( 608)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 608)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 608)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 608)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 608)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 608)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 608)										{
HXDLIN( 608)											int here26;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here26 = blended7;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this110 = img->image;
HXDLIN( 608)										int index17;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 608)										int here27;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here27 = c16;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 608)								int y14 = (this4->height - 1);
HXDLIN( 608)								::Dynamic this111 = this4->image;
HXDLIN( 608)								int index18;
HXDLIN( 608)								if (this4->useVirtualPos) {
HXDLIN( 608)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 608)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 608)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 608)								int color10;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color10 = c17;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c18 = color10;
HXDLIN( 608)									bool here28;
HXDLIN( 608)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 608)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 608)										here28 = false;
            									}
HXDLIN( 608)									if (here28) {
HXDLIN( 608)										int location8;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 608)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 608)										int this113;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this113 = this112;
            										}
HXDLIN( 608)										Float a110;
HXDLIN( 608)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 608)										if ((this114 == 0)) {
HXDLIN( 608)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r18;
HXDLIN( 608)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 608)										if ((this115 == 0)) {
HXDLIN( 608)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g18;
HXDLIN( 608)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 608)										if ((this116 == 0)) {
HXDLIN( 608)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b111;
HXDLIN( 608)										int this117 = (this113 & 255);
HXDLIN( 608)										if ((this117 == 0)) {
HXDLIN( 608)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a28;
HXDLIN( 608)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 608)										if ((this118 == 0)) {
HXDLIN( 608)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r28;
HXDLIN( 608)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 608)										if ((this119 == 0)) {
HXDLIN( 608)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g28;
HXDLIN( 608)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 608)										if ((this120 == 0)) {
HXDLIN( 608)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b29;
HXDLIN( 608)										int this121 = (color10 & 255);
HXDLIN( 608)										if ((this121 == 0)) {
HXDLIN( 608)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 608)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 608)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 608)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 608)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 608)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 608)										{
HXDLIN( 608)											int here29;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here29 = blended8;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this122 = img->image;
HXDLIN( 608)										int index19;
HXDLIN( 608)										if (img->useVirtualPos) {
HXDLIN( 608)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 608)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 608)										int here30;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here30 = c18;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 608)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 608)				int width2 = (this123->width + 2);
HXDLIN( 608)				int height2 = (this123->height + 2);
HXDLIN( 608)				 ::Dynamic imageType2 = null();
HXDLIN( 608)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 608)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 608)				::Dynamic here31;
HXDLIN( 608)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 608)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 608)						{
HXDLIN( 608)							b31->width = width2;
HXDLIN( 608)							b31->height = height2;
HXDLIN( 608)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 608)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 608)							{
HXDLIN( 608)								int len4 = b31->length;
HXDLIN( 608)								int w2 = 0;
HXDLIN( 608)								{
HXDLIN( 608)									int _g48 = 0;
HXDLIN( 608)									int _g49 = b31->height;
HXDLIN( 608)									while((_g48 < _g49)){
HXDLIN( 608)										_g48 = (_g48 + 1);
HXDLIN( 608)										int y15 = (_g48 - 1);
HXDLIN( 608)										{
HXDLIN( 608)											int _g50 = 0;
HXDLIN( 608)											int _g51 = b31->width;
HXDLIN( 608)											while((_g50 < _g51)){
HXDLIN( 608)												_g50 = (_g50 + 1);
HXDLIN( 608)												int x15 = (_g50 - 1);
HXDLIN( 608)												{
HXDLIN( 608)													w2 = (w2 + 1);
HXDLIN( 608)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w2 = (w2 + 1);
HXDLIN( 608)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w2 = (w2 + 1);
HXDLIN( 608)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 608)												{
HXDLIN( 608)													w2 = (w2 + 1);
HXDLIN( 608)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 608)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 608)						{
HXDLIN( 608)							a29->width = width2;
HXDLIN( 608)							a29->height = height2;
HXDLIN( 608)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 608)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 608)							{
HXDLIN( 608)								int _g52 = 0;
HXDLIN( 608)								int _g53 = a29->length;
HXDLIN( 608)								while((_g52 < _g53)){
HXDLIN( 608)									_g52 = (_g52 + 1);
HXDLIN( 608)									int i12 = (_g52 - 1);
HXDLIN( 608)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 608)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 608)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 608)						{
HXDLIN( 608)							b32->width = width2;
HXDLIN( 608)							b32->height = height2;
HXDLIN( 608)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 608)							int size2 = (b32->length * 4);
HXDLIN( 608)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 608)							{
HXDLIN( 608)								int _g54 = 0;
HXDLIN( 608)								int _g55 = b32->length;
HXDLIN( 608)								while((_g54 < _g55)){
HXDLIN( 608)									_g54 = (_g54 + 1);
HXDLIN( 608)									int i13 = (_g54 - 1);
HXDLIN( 608)									{
HXDLIN( 608)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 608)										bool here32;
HXDLIN( 608)										if ((i13 >= 0)) {
HXDLIN( 608)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 608)											here32 = false;
            										}
HXDLIN( 608)										if (here32) {
HXDLIN( 608)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 608)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 608)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 608)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 608)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 608)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 608)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 608)						{
HXDLIN( 608)							v3->width = width2;
HXDLIN( 608)							v3->height = height2;
HXDLIN( 608)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 608)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 608)							{
HXDLIN( 608)								int _g56 = 0;
HXDLIN( 608)								int _g57 = v3->length;
HXDLIN( 608)								while((_g56 < _g57)){
HXDLIN( 608)									_g56 = (_g56 + 1);
HXDLIN( 608)									int i14 = (_g56 - 1);
HXDLIN( 608)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 608)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 608)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 608)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 608)						{
HXDLIN( 608)							b33->width = width2;
HXDLIN( 608)							b33->height = height2;
HXDLIN( 608)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 608)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 608)							{
HXDLIN( 608)								int len5 = b33->length;
HXDLIN( 608)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 608)								if (::hx::IsNull( d2->head )) {
HXDLIN( 608)									int _g58 = 0;
HXDLIN( 608)									int _g59 = len5;
HXDLIN( 608)									while((_g58 < _g59)){
HXDLIN( 608)										_g58 = (_g58 + 1);
HXDLIN( 608)										int i15 = (_g58 - 1);
HXDLIN( 608)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 608)									int _g60 = 0;
HXDLIN( 608)									int _g61 = len5;
HXDLIN( 608)									while((_g60 < _g61)){
HXDLIN( 608)										_g60 = (_g60 + 1);
HXDLIN( 608)										int i16 = (_g60 - 1);
HXDLIN( 608)										{
HXDLIN( 608)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 608)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 608)											{
HXDLIN( 608)												int _g62 = 0;
HXDLIN( 608)												int _g63 = i16;
HXDLIN( 608)												while((_g62 < _g63)){
HXDLIN( 608)													_g62 = (_g62 + 1);
HXDLIN( 608)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 608)											if (::hx::IsNull( prev2 )) {
HXDLIN( 608)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 608)												l2 = null();
            											}
            											else {
HXDLIN( 608)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 608)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 608)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 608)				this124->image = here31;
HXDLIN( 608)				this124->width = width2;
HXDLIN( 608)				this124->height = height2;
HXDLIN( 608)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 608)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 608)				bool forceClear1 = false;
HXDLIN( 608)				int _g64 = 0;
HXDLIN( 608)				int _g65 = this123->height;
HXDLIN( 608)				while((_g64 < _g65)){
HXDLIN( 608)					_g64 = (_g64 + 1);
HXDLIN( 608)					int dy1 = (_g64 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g66 = 0;
HXDLIN( 608)						int _g67 = this123->width;
HXDLIN( 608)						while((_g66 < _g67)){
HXDLIN( 608)							_g66 = (_g66 + 1);
HXDLIN( 608)							int dx1 = (_g66 - 1);
HXDLIN( 608)							::Dynamic this126 = this123->image;
HXDLIN( 608)							int index20;
HXDLIN( 608)							if (this123->useVirtualPos) {
HXDLIN( 608)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 608)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 608)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 608)							int col1;
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								col1 = c19;
            							}
HXDLIN( 608)							bool here33;
HXDLIN( 608)							if (this123->useMask) {
HXDLIN( 608)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 608)								here33 = false;
            							}
HXDLIN( 608)							if (here33) {
HXDLIN( 608)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 608)								::Dynamic this128 = this127->image;
HXDLIN( 608)								int index21;
HXDLIN( 608)								if (this127->useVirtualPos) {
HXDLIN( 608)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 608)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 608)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 608)								int v4;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									v4 = c20;
            								}
HXDLIN( 608)								int maskPixel1 = v4;
HXDLIN( 608)								int this129 = col1;
HXDLIN( 608)								if ((maskPixel1 == 0)) {
HXDLIN( 608)									col1 = this129;
            								}
            								else {
HXDLIN( 608)									Float m01;
HXDLIN( 608)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 608)									if ((this130 == 0)) {
HXDLIN( 608)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m11;
HXDLIN( 608)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 608)									if ((this131 == 0)) {
HXDLIN( 608)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m21;
HXDLIN( 608)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 608)									if ((this132 == 0)) {
HXDLIN( 608)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float m31;
HXDLIN( 608)									int this133 = (maskPixel1 & 255);
HXDLIN( 608)									if ((this133 == 0)) {
HXDLIN( 608)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 608)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 608)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 608)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 608)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 608)							if ((col1 != 0)) {
HXDLIN( 608)								int x16 = (1 + dx1);
HXDLIN( 608)								int y16 = (1 + dy1);
HXDLIN( 608)								int c21 = col1;
HXDLIN( 608)								bool here34;
HXDLIN( 608)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 608)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 608)									here34 = false;
            								}
HXDLIN( 608)								if (here34) {
HXDLIN( 608)									int location9;
HXDLIN( 608)									if (img1->useVirtualPos) {
HXDLIN( 608)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 608)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 608)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 608)									int this135;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										this135 = this134;
            									}
HXDLIN( 608)									Float a111;
HXDLIN( 608)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 608)									if ((this136 == 0)) {
HXDLIN( 608)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r19;
HXDLIN( 608)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 608)									if ((this137 == 0)) {
HXDLIN( 608)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g19;
HXDLIN( 608)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 608)									if ((this138 == 0)) {
HXDLIN( 608)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b112;
HXDLIN( 608)									int this139 = (this135 & 255);
HXDLIN( 608)									if ((this139 == 0)) {
HXDLIN( 608)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a210;
HXDLIN( 608)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 608)									if ((this140 == 0)) {
HXDLIN( 608)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r29;
HXDLIN( 608)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 608)									if ((this141 == 0)) {
HXDLIN( 608)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g29;
HXDLIN( 608)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 608)									if ((this142 == 0)) {
HXDLIN( 608)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b210;
HXDLIN( 608)									int this143 = (col1 & 255);
HXDLIN( 608)									if ((this143 == 0)) {
HXDLIN( 608)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 608)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 608)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 608)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 608)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 608)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 608)									{
HXDLIN( 608)										int here35;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here35 = blended9;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 608)									::Dynamic this144 = img1->image;
HXDLIN( 608)									int index22;
HXDLIN( 608)									if (img1->useVirtualPos) {
HXDLIN( 608)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 608)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 608)									int here36;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										here36 = c21;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 608)								if (forceClear1) {
HXDLIN( 608)									::Dynamic this145 = img1->image;
HXDLIN( 608)									int x17 = (1 + dx1);
HXDLIN( 608)									int y17 = (1 + dy1);
HXDLIN( 608)									int index23;
HXDLIN( 608)									if (img1->useVirtualPos) {
HXDLIN( 608)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 608)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g68 = 0;
HXDLIN( 608)				int _g69 = this123->width;
HXDLIN( 608)				while((_g68 < _g69)){
HXDLIN( 608)					_g68 = (_g68 + 1);
HXDLIN( 608)					int x18 = (_g68 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g70 = 0;
HXDLIN( 608)						int _g71 = 1;
HXDLIN( 608)						while((_g70 < _g71)){
HXDLIN( 608)							_g70 = (_g70 + 1);
HXDLIN( 608)							int y18 = (_g70 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								int x19 = (x18 + 1);
HXDLIN( 608)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 608)								::Dynamic this146 = this123->image;
HXDLIN( 608)								int index24;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 608)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 608)								int color11;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color11 = c22;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c23 = color11;
HXDLIN( 608)									bool here37;
HXDLIN( 608)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 608)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here37 = false;
            									}
HXDLIN( 608)									if (here37) {
HXDLIN( 608)										int location10;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 608)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 608)										int this148;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this148 = this147;
            										}
HXDLIN( 608)										Float a112;
HXDLIN( 608)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 608)										if ((this149 == 0)) {
HXDLIN( 608)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r110;
HXDLIN( 608)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 608)										if ((this150 == 0)) {
HXDLIN( 608)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g110;
HXDLIN( 608)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 608)										if ((this151 == 0)) {
HXDLIN( 608)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b113;
HXDLIN( 608)										int this152 = (this148 & 255);
HXDLIN( 608)										if ((this152 == 0)) {
HXDLIN( 608)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a211;
HXDLIN( 608)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 608)										if ((this153 == 0)) {
HXDLIN( 608)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r210;
HXDLIN( 608)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 608)										if ((this154 == 0)) {
HXDLIN( 608)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g210;
HXDLIN( 608)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 608)										if ((this155 == 0)) {
HXDLIN( 608)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b211;
HXDLIN( 608)										int this156 = (color11 & 255);
HXDLIN( 608)										if ((this156 == 0)) {
HXDLIN( 608)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 608)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 608)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 608)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 608)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 608)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 608)										{
HXDLIN( 608)											int here38;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here38 = blended10;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this157 = img1->image;
HXDLIN( 608)										int index25;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 608)										int here39;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here39 = c23;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x20 = (x18 + 1);
HXDLIN( 608)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 608)								int y21 = (1 - y18);
HXDLIN( 608)								::Dynamic this158 = this123->image;
HXDLIN( 608)								int index26;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 608)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 608)								int color12;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color12 = c24;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c25 = color12;
HXDLIN( 608)									bool here40;
HXDLIN( 608)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 608)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here40 = false;
            									}
HXDLIN( 608)									if (here40) {
HXDLIN( 608)										int location11;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 608)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 608)										int this160;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this160 = this159;
            										}
HXDLIN( 608)										Float a113;
HXDLIN( 608)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 608)										if ((this161 == 0)) {
HXDLIN( 608)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r111;
HXDLIN( 608)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 608)										if ((this162 == 0)) {
HXDLIN( 608)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g111;
HXDLIN( 608)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 608)										if ((this163 == 0)) {
HXDLIN( 608)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b114;
HXDLIN( 608)										int this164 = (this160 & 255);
HXDLIN( 608)										if ((this164 == 0)) {
HXDLIN( 608)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a212;
HXDLIN( 608)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 608)										if ((this165 == 0)) {
HXDLIN( 608)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r211;
HXDLIN( 608)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 608)										if ((this166 == 0)) {
HXDLIN( 608)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g211;
HXDLIN( 608)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 608)										if ((this167 == 0)) {
HXDLIN( 608)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b212;
HXDLIN( 608)										int this168 = (color12 & 255);
HXDLIN( 608)										if ((this168 == 0)) {
HXDLIN( 608)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 608)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 608)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 608)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 608)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 608)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 608)										{
HXDLIN( 608)											int here41;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here41 = blended11;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this169 = img1->image;
HXDLIN( 608)										int index27;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 608)										int here42;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here42 = c25;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g72 = 0;
HXDLIN( 608)				int _g73 = this123->height;
HXDLIN( 608)				while((_g72 < _g73)){
HXDLIN( 608)					_g72 = (_g72 + 1);
HXDLIN( 608)					int y22 = (_g72 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g74 = 0;
HXDLIN( 608)						int _g75 = 1;
HXDLIN( 608)						while((_g74 < _g75)){
HXDLIN( 608)							_g74 = (_g74 + 1);
HXDLIN( 608)							int x21 = (_g74 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								int y23 = (y22 + 1);
HXDLIN( 608)								int x22 = (((this123->width - 1) - 1) + x21);
HXDLIN( 608)								::Dynamic this170 = this123->image;
HXDLIN( 608)								int index28;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 608)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 608)								int color13;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color13 = c26;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c27 = color13;
HXDLIN( 608)									bool here43;
HXDLIN( 608)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 608)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here43 = false;
            									}
HXDLIN( 608)									if (here43) {
HXDLIN( 608)										int location12;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 608)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 608)										int this172;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this172 = this171;
            										}
HXDLIN( 608)										Float a114;
HXDLIN( 608)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 608)										if ((this173 == 0)) {
HXDLIN( 608)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r112;
HXDLIN( 608)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 608)										if ((this174 == 0)) {
HXDLIN( 608)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g112;
HXDLIN( 608)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 608)										if ((this175 == 0)) {
HXDLIN( 608)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b115;
HXDLIN( 608)										int this176 = (this172 & 255);
HXDLIN( 608)										if ((this176 == 0)) {
HXDLIN( 608)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a213;
HXDLIN( 608)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 608)										if ((this177 == 0)) {
HXDLIN( 608)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r212;
HXDLIN( 608)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 608)										if ((this178 == 0)) {
HXDLIN( 608)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g212;
HXDLIN( 608)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 608)										if ((this179 == 0)) {
HXDLIN( 608)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b213;
HXDLIN( 608)										int this180 = (color13 & 255);
HXDLIN( 608)										if ((this180 == 0)) {
HXDLIN( 608)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 608)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 608)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 608)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 608)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 608)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 608)										{
HXDLIN( 608)											int here44;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here44 = blended12;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this181 = img1->image;
HXDLIN( 608)										int index29;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 608)										int here45;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here45 = c27;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 608)								int y24 = (y22 + 1);
HXDLIN( 608)								int x24 = (1 - x21);
HXDLIN( 608)								::Dynamic this182 = this123->image;
HXDLIN( 608)								int index30;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 608)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 608)								int color14;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color14 = c28;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c29 = color14;
HXDLIN( 608)									bool here46;
HXDLIN( 608)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 608)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here46 = false;
            									}
HXDLIN( 608)									if (here46) {
HXDLIN( 608)										int location13;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 608)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 608)										int this184;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this184 = this183;
            										}
HXDLIN( 608)										Float a115;
HXDLIN( 608)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 608)										if ((this185 == 0)) {
HXDLIN( 608)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r113;
HXDLIN( 608)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 608)										if ((this186 == 0)) {
HXDLIN( 608)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g113;
HXDLIN( 608)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 608)										if ((this187 == 0)) {
HXDLIN( 608)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b116;
HXDLIN( 608)										int this188 = (this184 & 255);
HXDLIN( 608)										if ((this188 == 0)) {
HXDLIN( 608)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a214;
HXDLIN( 608)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 608)										if ((this189 == 0)) {
HXDLIN( 608)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r213;
HXDLIN( 608)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 608)										if ((this190 == 0)) {
HXDLIN( 608)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g213;
HXDLIN( 608)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 608)										if ((this191 == 0)) {
HXDLIN( 608)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b214;
HXDLIN( 608)										int this192 = (color14 & 255);
HXDLIN( 608)										if ((this192 == 0)) {
HXDLIN( 608)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 608)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 608)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 608)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 608)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 608)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 608)										{
HXDLIN( 608)											int here47;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here47 = blended13;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this193 = img1->image;
HXDLIN( 608)										int index31;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 608)										int here48;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here48 = c29;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				int _g76 = 0;
HXDLIN( 608)				int _g77 = 1;
HXDLIN( 608)				while((_g76 < _g77)){
HXDLIN( 608)					_g76 = (_g76 + 1);
HXDLIN( 608)					int x25 = (_g76 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						int _g78 = 0;
HXDLIN( 608)						int _g79 = 1;
HXDLIN( 608)						while((_g78 < _g79)){
HXDLIN( 608)							_g78 = (_g78 + 1);
HXDLIN( 608)							int y25 = (_g78 - 1);
HXDLIN( 608)							{
HXDLIN( 608)								int x26 = (((this123->width - 1) - 1) + x25);
HXDLIN( 608)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 608)								::Dynamic this194 = this123->image;
HXDLIN( 608)								int index32;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 608)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 608)								int color15;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color15 = c30;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c31 = color15;
HXDLIN( 608)									bool here49;
HXDLIN( 608)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 608)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here49 = false;
            									}
HXDLIN( 608)									if (here49) {
HXDLIN( 608)										int location14;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 608)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 608)										int this196;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this196 = this195;
            										}
HXDLIN( 608)										Float a116;
HXDLIN( 608)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 608)										if ((this197 == 0)) {
HXDLIN( 608)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r114;
HXDLIN( 608)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 608)										if ((this198 == 0)) {
HXDLIN( 608)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g114;
HXDLIN( 608)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 608)										if ((this199 == 0)) {
HXDLIN( 608)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b117;
HXDLIN( 608)										int this200 = (this196 & 255);
HXDLIN( 608)										if ((this200 == 0)) {
HXDLIN( 608)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a215;
HXDLIN( 608)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 608)										if ((this201 == 0)) {
HXDLIN( 608)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r214;
HXDLIN( 608)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 608)										if ((this202 == 0)) {
HXDLIN( 608)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g214;
HXDLIN( 608)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 608)										if ((this203 == 0)) {
HXDLIN( 608)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b215;
HXDLIN( 608)										int this204 = (color15 & 255);
HXDLIN( 608)										if ((this204 == 0)) {
HXDLIN( 608)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 608)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 608)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 608)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 608)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 608)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 608)										{
HXDLIN( 608)											int here50;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here50 = blended14;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this205 = img1->image;
HXDLIN( 608)										int index33;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 608)										int here51;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here51 = c31;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x27 = ((x25 + 1) + this123->width);
HXDLIN( 608)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 608)								::Dynamic this206 = this123->image;
HXDLIN( 608)								int index34;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 608)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 608)								int color16;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color16 = c32;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c33 = color16;
HXDLIN( 608)									bool here52;
HXDLIN( 608)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 608)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here52 = false;
            									}
HXDLIN( 608)									if (here52) {
HXDLIN( 608)										int location15;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 608)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 608)										int this208;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this208 = this207;
            										}
HXDLIN( 608)										Float a117;
HXDLIN( 608)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 608)										if ((this209 == 0)) {
HXDLIN( 608)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r115;
HXDLIN( 608)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 608)										if ((this210 == 0)) {
HXDLIN( 608)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g115;
HXDLIN( 608)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 608)										if ((this211 == 0)) {
HXDLIN( 608)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b118;
HXDLIN( 608)										int this212 = (this208 & 255);
HXDLIN( 608)										if ((this212 == 0)) {
HXDLIN( 608)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a216;
HXDLIN( 608)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 608)										if ((this213 == 0)) {
HXDLIN( 608)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r215;
HXDLIN( 608)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 608)										if ((this214 == 0)) {
HXDLIN( 608)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g215;
HXDLIN( 608)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 608)										if ((this215 == 0)) {
HXDLIN( 608)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b216;
HXDLIN( 608)										int this216 = (color16 & 255);
HXDLIN( 608)										if ((this216 == 0)) {
HXDLIN( 608)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 608)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 608)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 608)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 608)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 608)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 608)										{
HXDLIN( 608)											int here53;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here53 = blended15;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this217 = img1->image;
HXDLIN( 608)										int index35;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 608)										int here54;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here54 = c33;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int x28 = ((x25 + 1) + this123->width);
HXDLIN( 608)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 608)								::Dynamic this218 = this123->image;
HXDLIN( 608)								int index36;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 608)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 608)								int color17;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color17 = c34;
            								}
HXDLIN( 608)								int color18 = color17;
HXDLIN( 608)								{
HXDLIN( 608)									int c35 = color18;
HXDLIN( 608)									bool here55;
HXDLIN( 608)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 608)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here55 = false;
            									}
HXDLIN( 608)									if (here55) {
HXDLIN( 608)										int location16;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 608)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 608)										int this220;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this220 = this219;
            										}
HXDLIN( 608)										Float a118;
HXDLIN( 608)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 608)										if ((this221 == 0)) {
HXDLIN( 608)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r116;
HXDLIN( 608)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 608)										if ((this222 == 0)) {
HXDLIN( 608)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g116;
HXDLIN( 608)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 608)										if ((this223 == 0)) {
HXDLIN( 608)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b119;
HXDLIN( 608)										int this224 = (this220 & 255);
HXDLIN( 608)										if ((this224 == 0)) {
HXDLIN( 608)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a217;
HXDLIN( 608)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 608)										if ((this225 == 0)) {
HXDLIN( 608)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r216;
HXDLIN( 608)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 608)										if ((this226 == 0)) {
HXDLIN( 608)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g216;
HXDLIN( 608)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 608)										if ((this227 == 0)) {
HXDLIN( 608)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b217;
HXDLIN( 608)										int this228 = (color18 & 255);
HXDLIN( 608)										if ((this228 == 0)) {
HXDLIN( 608)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 608)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 608)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 608)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 608)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 608)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 608)										{
HXDLIN( 608)											int here56;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here56 = blended16;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this229 = img1->image;
HXDLIN( 608)										int index37;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 608)										int here57;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here57 = c35;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 608)							{
HXDLIN( 608)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 608)								int x29 = (((this123->width - 1) - 1) + x25);
HXDLIN( 608)								::Dynamic this230 = this123->image;
HXDLIN( 608)								int index38;
HXDLIN( 608)								if (this123->useVirtualPos) {
HXDLIN( 608)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 608)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 608)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 608)								int color19;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									color19 = c36;
            								}
HXDLIN( 608)								{
HXDLIN( 608)									int c37 = color19;
HXDLIN( 608)									bool here58;
HXDLIN( 608)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 608)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 608)										here58 = false;
            									}
HXDLIN( 608)									if (here58) {
HXDLIN( 608)										int location17;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 608)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 608)										int this232;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											this232 = this231;
            										}
HXDLIN( 608)										Float a119;
HXDLIN( 608)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 608)										if ((this233 == 0)) {
HXDLIN( 608)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r117;
HXDLIN( 608)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 608)										if ((this234 == 0)) {
HXDLIN( 608)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g117;
HXDLIN( 608)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 608)										if ((this235 == 0)) {
HXDLIN( 608)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b120;
HXDLIN( 608)										int this236 = (this232 & 255);
HXDLIN( 608)										if ((this236 == 0)) {
HXDLIN( 608)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a218;
HXDLIN( 608)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 608)										if ((this237 == 0)) {
HXDLIN( 608)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float r217;
HXDLIN( 608)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 608)										if ((this238 == 0)) {
HXDLIN( 608)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float g217;
HXDLIN( 608)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 608)										if ((this239 == 0)) {
HXDLIN( 608)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float b218;
HXDLIN( 608)										int this240 = (color19 & 255);
HXDLIN( 608)										if ((this240 == 0)) {
HXDLIN( 608)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 608)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 608)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 608)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 608)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 608)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 608)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 608)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 608)										{
HXDLIN( 608)											int here59;
HXDLIN( 608)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 608)												here59 = blended17;
            											}
HXDLIN( 608)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 608)										::Dynamic this241 = img1->image;
HXDLIN( 608)										int index39;
HXDLIN( 608)										if (img1->useVirtualPos) {
HXDLIN( 608)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 608)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 608)										int here60;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											here60 = c37;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 608)				here = img1;
            			}
            			break;
            		}
HXDLIN( 608)		{
HXDLIN( 608)			int _g80 = 1;
HXDLIN( 608)			int _g81 = (this1->height - 2);
HXDLIN( 608)			while((_g80 < _g81)){
HXDLIN( 608)				_g80 = (_g80 + 1);
HXDLIN( 608)				int y30 = (_g80 - 1);
HXDLIN( 608)				{
HXDLIN( 608)					int _g82 = 1;
HXDLIN( 608)					int _g83 = (this1->width - 2);
HXDLIN( 608)					while((_g82 < _g83)){
HXDLIN( 608)						_g82 = (_g82 + 1);
HXDLIN( 608)						int x30 = (_g82 - 1);
HXDLIN( 608)						if ((x30 == 1)) {
HXDLIN( 608)							int x31 = (x30 - 1);
HXDLIN( 608)							int y31 = (y30 - 1);
HXDLIN( 608)							::Dynamic this242 = here->image;
HXDLIN( 608)							int index40;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 608)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								a0 = c38;
            							}
HXDLIN( 608)							int y32 = (y30 - 1);
HXDLIN( 608)							::Dynamic this243 = here->image;
HXDLIN( 608)							int index41;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x30)) ));
            							}
HXDLIN( 608)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								b0 = c39;
            							}
HXDLIN( 608)							int x32 = (x30 + 1);
HXDLIN( 608)							int y33 = (y30 - 1);
HXDLIN( 608)							::Dynamic this244 = here->image;
HXDLIN( 608)							int index42;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x32)) ));
            							}
HXDLIN( 608)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								c0 = c40;
            							}
HXDLIN( 608)							int x33 = (x30 - 1);
HXDLIN( 608)							::Dynamic this245 = here->image;
HXDLIN( 608)							int index43;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x33)) ));
            							}
HXDLIN( 608)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								d0 = c41;
            							}
HXDLIN( 608)							::Dynamic this246 = here->image;
HXDLIN( 608)							int index44;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 608)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 608)							int e01;
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 608)							int x34 = (x30 + 1);
HXDLIN( 608)							::Dynamic this247 = here->image;
HXDLIN( 608)							int index45;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 608)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								f0 = c43;
            							}
HXDLIN( 608)							int x35 = (x30 - 1);
HXDLIN( 608)							int y34 = (y30 + 1);
HXDLIN( 608)							::Dynamic this248 = here->image;
HXDLIN( 608)							int index46;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x35)) ));
            							}
HXDLIN( 608)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								g0 = c44;
            							}
HXDLIN( 608)							int y35 = (y30 + 1);
HXDLIN( 608)							::Dynamic this249 = here->image;
HXDLIN( 608)							int index47;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x30)) ));
            							}
HXDLIN( 608)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								h0 = c45;
            							}
HXDLIN( 608)							int x36 = (x30 + 1);
HXDLIN( 608)							int y36 = (y30 + 1);
HXDLIN( 608)							::Dynamic this250 = here->image;
HXDLIN( 608)							int index48;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x36)) ));
            							}
HXDLIN( 608)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 608)							int x37 = (x30 + 1);
HXDLIN( 608)							int y37 = (y30 - 1);
HXDLIN( 608)							::Dynamic this251 = here->image;
HXDLIN( 608)							int index49;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x37)) ));
            							}
HXDLIN( 608)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 608)							int x38 = (x30 + 1);
HXDLIN( 608)							::Dynamic this252 = here->image;
HXDLIN( 608)							int index50;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x38)) ));
            							}
HXDLIN( 608)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 608)							int x39 = (x30 + 1);
HXDLIN( 608)							int y38 = (y30 + 1);
HXDLIN( 608)							::Dynamic this253 = here->image;
HXDLIN( 608)							int index51;
HXDLIN( 608)							if (here->useVirtualPos) {
HXDLIN( 608)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 608)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x39)) ));
            							}
HXDLIN( 608)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 608)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 608)								i0 = c49;
            							}
            						}
HXDLIN( 608)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 608)							bool _hx_tmp2;
HXDLIN( 608)							if ((m33_a != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp2 = false;
            							}
HXDLIN( 608)							if (_hx_tmp2) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 608)							bool _hx_tmp3;
HXDLIN( 608)							if ((m33_b != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp3 = false;
            							}
HXDLIN( 608)							if (_hx_tmp3) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 608)							bool _hx_tmp4;
HXDLIN( 608)							if ((m33_c != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp4 = false;
            							}
HXDLIN( 608)							if (_hx_tmp4) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 608)							bool _hx_tmp5;
HXDLIN( 608)							if ((m33_d != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp5 = false;
            							}
HXDLIN( 608)							if (_hx_tmp5) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 608)							bool _hx_tmp6;
HXDLIN( 608)							if ((m33_e != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp6 = false;
            							}
HXDLIN( 608)							if (_hx_tmp6) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 608)							bool _hx_tmp7;
HXDLIN( 608)							if ((m33_f != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp7 = false;
            							}
HXDLIN( 608)							if (_hx_tmp7) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 608)							bool _hx_tmp8;
HXDLIN( 608)							if ((m33_g != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp8 = false;
            							}
HXDLIN( 608)							if (_hx_tmp8) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 608)							bool _hx_tmp9;
HXDLIN( 608)							if ((m33_h != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp9 = false;
            							}
HXDLIN( 608)							if (_hx_tmp9) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 608)							bool _hx_tmp10;
HXDLIN( 608)							if ((m33_i != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp10 = false;
            							}
HXDLIN( 608)							if (_hx_tmp10) {
HXDLIN( 608)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 608)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 608)							bool _hx_tmp11;
HXDLIN( 608)							if ((m33_a != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp11 = false;
            							}
HXDLIN( 608)							if (_hx_tmp11) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 608)							bool _hx_tmp12;
HXDLIN( 608)							if ((m33_b != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp12 = false;
            							}
HXDLIN( 608)							if (_hx_tmp12) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 608)							bool _hx_tmp13;
HXDLIN( 608)							if ((m33_c != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp13 = false;
            							}
HXDLIN( 608)							if (_hx_tmp13) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 608)							bool _hx_tmp14;
HXDLIN( 608)							if ((m33_d != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp14 = false;
            							}
HXDLIN( 608)							if (_hx_tmp14) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 608)							bool _hx_tmp15;
HXDLIN( 608)							if ((m33_e != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp15 = false;
            							}
HXDLIN( 608)							if (_hx_tmp15) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 608)							bool _hx_tmp16;
HXDLIN( 608)							if ((m33_f != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp16 = false;
            							}
HXDLIN( 608)							if (_hx_tmp16) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 608)							bool _hx_tmp17;
HXDLIN( 608)							if ((m33_g != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp17 = false;
            							}
HXDLIN( 608)							if (_hx_tmp17) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 608)							bool _hx_tmp18;
HXDLIN( 608)							if ((m33_h != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp18 = false;
            							}
HXDLIN( 608)							if (_hx_tmp18) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 608)							bool _hx_tmp19;
HXDLIN( 608)							if ((m33_i != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp19 = false;
            							}
HXDLIN( 608)							if (_hx_tmp19) {
HXDLIN( 608)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 608)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 608)							bool _hx_tmp20;
HXDLIN( 608)							if ((m33_a != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp20 = false;
            							}
HXDLIN( 608)							if (_hx_tmp20) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 608)							bool _hx_tmp21;
HXDLIN( 608)							if ((m33_b != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp21 = false;
            							}
HXDLIN( 608)							if (_hx_tmp21) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 608)							bool _hx_tmp22;
HXDLIN( 608)							if ((m33_c != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp22 = false;
            							}
HXDLIN( 608)							if (_hx_tmp22) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 608)							bool _hx_tmp23;
HXDLIN( 608)							if ((m33_d != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp23 = false;
            							}
HXDLIN( 608)							if (_hx_tmp23) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 608)							bool _hx_tmp24;
HXDLIN( 608)							if ((m33_e != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp24 = false;
            							}
HXDLIN( 608)							if (_hx_tmp24) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 608)							bool _hx_tmp25;
HXDLIN( 608)							if ((m33_f != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp25 = false;
            							}
HXDLIN( 608)							if (_hx_tmp25) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 608)							bool _hx_tmp26;
HXDLIN( 608)							if ((m33_g != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp26 = false;
            							}
HXDLIN( 608)							if (_hx_tmp26) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 608)							bool _hx_tmp27;
HXDLIN( 608)							if ((m33_h != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp27 = false;
            							}
HXDLIN( 608)							if (_hx_tmp27) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 608)							bool _hx_tmp28;
HXDLIN( 608)							if ((m33_i != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp28 = false;
            							}
HXDLIN( 608)							if (_hx_tmp28) {
HXDLIN( 608)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 608)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 608)							bool _hx_tmp29;
HXDLIN( 608)							if ((m33_a != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp29 = false;
            							}
HXDLIN( 608)							if (_hx_tmp29) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 608)							bool _hx_tmp30;
HXDLIN( 608)							if ((m33_b != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp30 = false;
            							}
HXDLIN( 608)							if (_hx_tmp30) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 608)							bool _hx_tmp31;
HXDLIN( 608)							if ((m33_c != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp31 = false;
            							}
HXDLIN( 608)							if (_hx_tmp31) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 608)							bool _hx_tmp32;
HXDLIN( 608)							if ((m33_d != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp32 = false;
            							}
HXDLIN( 608)							if (_hx_tmp32) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 608)							bool _hx_tmp33;
HXDLIN( 608)							if ((m33_e != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp33 = false;
            							}
HXDLIN( 608)							if (_hx_tmp33) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 608)							bool _hx_tmp34;
HXDLIN( 608)							if ((m33_f != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp34 = false;
            							}
HXDLIN( 608)							if (_hx_tmp34) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 608)							bool _hx_tmp35;
HXDLIN( 608)							if ((m33_g != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp35 = false;
            							}
HXDLIN( 608)							if (_hx_tmp35) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 608)							bool _hx_tmp36;
HXDLIN( 608)							if ((m33_h != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp36 = false;
            							}
HXDLIN( 608)							if (_hx_tmp36) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 608)							bool _hx_tmp37;
HXDLIN( 608)							if ((m33_i != ((Float)0.))) {
HXDLIN( 608)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXDLIN( 608)								_hx_tmp37 = false;
            							}
HXDLIN( 608)							if (_hx_tmp37) {
HXDLIN( 608)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 608)						bool _hx_tmp38;
HXDLIN( 608)						if ((borderMode != 0)) {
HXDLIN( 608)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXDLIN( 608)							_hx_tmp38 = true;
            						}
HXDLIN( 608)						if (_hx_tmp38) {
HXDLIN( 608)							int x40 = (x30 - 1);
HXDLIN( 608)							int y39 = (y30 - 1);
HXDLIN( 608)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 608)							{
HXDLIN( 608)								int c50 = color20;
HXDLIN( 608)								bool _hx_tmp39;
HXDLIN( 608)								if ((((c50 >> 24) & 255) < 254)) {
HXDLIN( 608)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXDLIN( 608)									_hx_tmp39 = false;
            								}
HXDLIN( 608)								if (_hx_tmp39) {
HXDLIN( 608)									int location18;
HXDLIN( 608)									if (out->useVirtualPos) {
HXDLIN( 608)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 608)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 608)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 608)									int this255;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										this255 = this254;
            									}
HXDLIN( 608)									Float a120;
HXDLIN( 608)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 608)									if ((this256 == 0)) {
HXDLIN( 608)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r118;
HXDLIN( 608)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 608)									if ((this257 == 0)) {
HXDLIN( 608)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g118;
HXDLIN( 608)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 608)									if ((this258 == 0)) {
HXDLIN( 608)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b121;
HXDLIN( 608)									int this259 = (this255 & 255);
HXDLIN( 608)									if ((this259 == 0)) {
HXDLIN( 608)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a219;
HXDLIN( 608)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 608)									if ((this260 == 0)) {
HXDLIN( 608)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r218;
HXDLIN( 608)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 608)									if ((this261 == 0)) {
HXDLIN( 608)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g218;
HXDLIN( 608)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 608)									if ((this262 == 0)) {
HXDLIN( 608)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b219;
HXDLIN( 608)									int this263 = (color20 & 255);
HXDLIN( 608)									if ((this263 == 0)) {
HXDLIN( 608)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 608)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 608)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 608)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 608)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 608)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 608)									{
HXDLIN( 608)										int _hx_tmp40;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											_hx_tmp40 = blended18;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXDLIN( 608)									::Dynamic this264 = out->image;
HXDLIN( 608)									int index52;
HXDLIN( 608)									if (out->useVirtualPos) {
HXDLIN( 608)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 608)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 608)									int _hx_tmp41;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp41 = c50;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXDLIN( 608)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 608)							{
HXDLIN( 608)								int c51 = color21;
HXDLIN( 608)								bool _hx_tmp42;
HXDLIN( 608)								if ((((c51 >> 24) & 255) < 254)) {
HXDLIN( 608)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXDLIN( 608)									_hx_tmp42 = false;
            								}
HXDLIN( 608)								if (_hx_tmp42) {
HXDLIN( 608)									int location19;
HXDLIN( 608)									if (out->useVirtualPos) {
HXDLIN( 608)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 608)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 608)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 608)									int this266;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										this266 = this265;
            									}
HXDLIN( 608)									Float a121;
HXDLIN( 608)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 608)									if ((this267 == 0)) {
HXDLIN( 608)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r119;
HXDLIN( 608)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 608)									if ((this268 == 0)) {
HXDLIN( 608)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g119;
HXDLIN( 608)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 608)									if ((this269 == 0)) {
HXDLIN( 608)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b122;
HXDLIN( 608)									int this270 = (this266 & 255);
HXDLIN( 608)									if ((this270 == 0)) {
HXDLIN( 608)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a220;
HXDLIN( 608)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 608)									if ((this271 == 0)) {
HXDLIN( 608)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float r219;
HXDLIN( 608)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 608)									if ((this272 == 0)) {
HXDLIN( 608)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float g219;
HXDLIN( 608)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 608)									if ((this273 == 0)) {
HXDLIN( 608)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float b220;
HXDLIN( 608)									int this274 = (color21 & 255);
HXDLIN( 608)									if ((this274 == 0)) {
HXDLIN( 608)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 608)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 608)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 608)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 608)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 608)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 608)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 608)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 608)									{
HXDLIN( 608)										int _hx_tmp43;
HXDLIN( 608)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 608)											_hx_tmp43 = blended19;
            										}
HXDLIN( 608)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXDLIN( 608)									::Dynamic this275 = out->image;
HXDLIN( 608)									int index53;
HXDLIN( 608)									if (out->useVirtualPos) {
HXDLIN( 608)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 608)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 608)									int _hx_tmp44;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp44 = c51;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 608)		if ((borderMode == 1)) {
HXDLIN( 608)			{
HXDLIN( 608)				int _g84 = 0;
HXDLIN( 608)				int _g85 = (this1->width - 1);
HXDLIN( 608)				while((_g84 < _g85)){
HXDLIN( 608)					_g84 = (_g84 + 1);
HXDLIN( 608)					int x41 = (_g84 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						::Dynamic this276 = here->image;
HXDLIN( 608)						int index54;
HXDLIN( 608)						if (here->useVirtualPos) {
HXDLIN( 608)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 608)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x41)) ));
            						}
HXDLIN( 608)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 608)						int color22;
HXDLIN( 608)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXDLIN( 608)							color22 = c52;
            						}
HXDLIN( 608)						int color23 = color22;
HXDLIN( 608)						{
HXDLIN( 608)							int c53 = color23;
HXDLIN( 608)							bool _hx_tmp45;
HXDLIN( 608)							if ((((c53 >> 24) & 255) < 254)) {
HXDLIN( 608)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXDLIN( 608)								_hx_tmp45 = false;
            							}
HXDLIN( 608)							if (_hx_tmp45) {
HXDLIN( 608)								int location20;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 608)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 608)								int this278;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									this278 = this277;
            								}
HXDLIN( 608)								Float a122;
HXDLIN( 608)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 608)								if ((this279 == 0)) {
HXDLIN( 608)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r120;
HXDLIN( 608)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 608)								if ((this280 == 0)) {
HXDLIN( 608)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g120;
HXDLIN( 608)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 608)								if ((this281 == 0)) {
HXDLIN( 608)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b123;
HXDLIN( 608)								int this282 = (this278 & 255);
HXDLIN( 608)								if ((this282 == 0)) {
HXDLIN( 608)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a221;
HXDLIN( 608)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 608)								if ((this283 == 0)) {
HXDLIN( 608)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r220;
HXDLIN( 608)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 608)								if ((this284 == 0)) {
HXDLIN( 608)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g220;
HXDLIN( 608)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 608)								if ((this285 == 0)) {
HXDLIN( 608)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b221;
HXDLIN( 608)								int this286 = (color23 & 255);
HXDLIN( 608)								if ((this286 == 0)) {
HXDLIN( 608)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 608)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 608)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 608)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 608)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 608)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 608)								{
HXDLIN( 608)									int _hx_tmp46;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp46 = blended20;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXDLIN( 608)								::Dynamic this287 = out->image;
HXDLIN( 608)								int index55;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 608)								int _hx_tmp47;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									_hx_tmp47 = c53;
            								}
HXDLIN( 608)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 608)					{
HXDLIN( 608)						int y40 = (this1->height - 1);
HXDLIN( 608)						int y41 = (this1->height - 1);
HXDLIN( 608)						::Dynamic this288 = here->image;
HXDLIN( 608)						int index56;
HXDLIN( 608)						if (here->useVirtualPos) {
HXDLIN( 608)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 608)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x41)) ));
            						}
HXDLIN( 608)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 608)						int color24;
HXDLIN( 608)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXDLIN( 608)							color24 = c54;
            						}
HXDLIN( 608)						{
HXDLIN( 608)							int c55 = color24;
HXDLIN( 608)							bool _hx_tmp48;
HXDLIN( 608)							if ((((c55 >> 24) & 255) < 254)) {
HXDLIN( 608)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXDLIN( 608)								_hx_tmp48 = false;
            							}
HXDLIN( 608)							if (_hx_tmp48) {
HXDLIN( 608)								int location21;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 608)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 608)								int this290;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									this290 = this289;
            								}
HXDLIN( 608)								Float a123;
HXDLIN( 608)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 608)								if ((this291 == 0)) {
HXDLIN( 608)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r121;
HXDLIN( 608)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 608)								if ((this292 == 0)) {
HXDLIN( 608)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g121;
HXDLIN( 608)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 608)								if ((this293 == 0)) {
HXDLIN( 608)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b124;
HXDLIN( 608)								int this294 = (this290 & 255);
HXDLIN( 608)								if ((this294 == 0)) {
HXDLIN( 608)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a222;
HXDLIN( 608)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 608)								if ((this295 == 0)) {
HXDLIN( 608)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r221;
HXDLIN( 608)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 608)								if ((this296 == 0)) {
HXDLIN( 608)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g221;
HXDLIN( 608)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 608)								if ((this297 == 0)) {
HXDLIN( 608)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b222;
HXDLIN( 608)								int this298 = (color24 & 255);
HXDLIN( 608)								if ((this298 == 0)) {
HXDLIN( 608)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 608)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 608)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 608)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 608)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 608)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 608)								{
HXDLIN( 608)									int _hx_tmp49;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp49 = blended21;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXDLIN( 608)								::Dynamic this299 = out->image;
HXDLIN( 608)								int index57;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 608)								int _hx_tmp50;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									_hx_tmp50 = c55;
            								}
HXDLIN( 608)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 608)			{
HXDLIN( 608)				int _g86 = 1;
HXDLIN( 608)				int _g87 = (this1->height - 2);
HXDLIN( 608)				while((_g86 < _g87)){
HXDLIN( 608)					_g86 = (_g86 + 1);
HXDLIN( 608)					int y42 = (_g86 - 1);
HXDLIN( 608)					{
HXDLIN( 608)						::Dynamic this300 = here->image;
HXDLIN( 608)						int index58;
HXDLIN( 608)						if (here->useVirtualPos) {
HXDLIN( 608)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 608)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 608)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 608)						int color25;
HXDLIN( 608)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXDLIN( 608)							color25 = c56;
            						}
HXDLIN( 608)						int color26 = color25;
HXDLIN( 608)						{
HXDLIN( 608)							int c57 = color26;
HXDLIN( 608)							bool _hx_tmp51;
HXDLIN( 608)							if ((((c57 >> 24) & 255) < 254)) {
HXDLIN( 608)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXDLIN( 608)								_hx_tmp51 = false;
            							}
HXDLIN( 608)							if (_hx_tmp51) {
HXDLIN( 608)								int location22;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 608)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 608)								int this302;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									this302 = this301;
            								}
HXDLIN( 608)								Float a124;
HXDLIN( 608)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 608)								if ((this303 == 0)) {
HXDLIN( 608)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r122;
HXDLIN( 608)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 608)								if ((this304 == 0)) {
HXDLIN( 608)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g122;
HXDLIN( 608)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 608)								if ((this305 == 0)) {
HXDLIN( 608)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b125;
HXDLIN( 608)								int this306 = (this302 & 255);
HXDLIN( 608)								if ((this306 == 0)) {
HXDLIN( 608)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a223;
HXDLIN( 608)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 608)								if ((this307 == 0)) {
HXDLIN( 608)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r222;
HXDLIN( 608)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 608)								if ((this308 == 0)) {
HXDLIN( 608)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g222;
HXDLIN( 608)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 608)								if ((this309 == 0)) {
HXDLIN( 608)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b223;
HXDLIN( 608)								int this310 = (color26 & 255);
HXDLIN( 608)								if ((this310 == 0)) {
HXDLIN( 608)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 608)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 608)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 608)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 608)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 608)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 608)								{
HXDLIN( 608)									int _hx_tmp52;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp52 = blended22;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXDLIN( 608)								::Dynamic this311 = out->image;
HXDLIN( 608)								int index59;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 608)								int _hx_tmp53;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									_hx_tmp53 = c57;
            								}
HXDLIN( 608)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 608)					{
HXDLIN( 608)						int x42 = (this1->width - 1);
HXDLIN( 608)						int x43 = (this1->width - 1);
HXDLIN( 608)						::Dynamic this312 = here->image;
HXDLIN( 608)						int index60;
HXDLIN( 608)						if (here->useVirtualPos) {
HXDLIN( 608)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            						}
            						else {
HXDLIN( 608)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x43)) ));
            						}
HXDLIN( 608)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 608)						int color27;
HXDLIN( 608)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXDLIN( 608)							color27 = c58;
            						}
HXDLIN( 608)						{
HXDLIN( 608)							int c59 = color27;
HXDLIN( 608)							bool _hx_tmp54;
HXDLIN( 608)							if ((((c59 >> 24) & 255) < 254)) {
HXDLIN( 608)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXDLIN( 608)								_hx_tmp54 = false;
            							}
HXDLIN( 608)							if (_hx_tmp54) {
HXDLIN( 608)								int location23;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 608)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 608)								int this314;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									this314 = this313;
            								}
HXDLIN( 608)								Float a125;
HXDLIN( 608)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 608)								if ((this315 == 0)) {
HXDLIN( 608)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r123;
HXDLIN( 608)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 608)								if ((this316 == 0)) {
HXDLIN( 608)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g123;
HXDLIN( 608)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 608)								if ((this317 == 0)) {
HXDLIN( 608)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b126;
HXDLIN( 608)								int this318 = (this314 & 255);
HXDLIN( 608)								if ((this318 == 0)) {
HXDLIN( 608)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a224;
HXDLIN( 608)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 608)								if ((this319 == 0)) {
HXDLIN( 608)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float r223;
HXDLIN( 608)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 608)								if ((this320 == 0)) {
HXDLIN( 608)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float g223;
HXDLIN( 608)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 608)								if ((this321 == 0)) {
HXDLIN( 608)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float b224;
HXDLIN( 608)								int this322 = (color27 & 255);
HXDLIN( 608)								if ((this322 == 0)) {
HXDLIN( 608)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 608)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 608)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 608)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 608)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 608)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 608)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 608)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 608)								{
HXDLIN( 608)									int _hx_tmp55;
HXDLIN( 608)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 608)										_hx_tmp55 = blended23;
            									}
HXDLIN( 608)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXDLIN( 608)								::Dynamic this323 = out->image;
HXDLIN( 608)								int index61;
HXDLIN( 608)								if (out->useVirtualPos) {
HXDLIN( 608)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 608)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 608)								int _hx_tmp56;
HXDLIN( 608)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 608)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXDLIN( 608)									_hx_tmp56 = c59;
            								}
HXDLIN( 608)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 608)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,edgeEnhance0_3x3,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::edgeDetect0_3x3( ::pi_xy::ImageStruct this1,::hx::Null< Float >  __o_strength,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		Float strength = __o_strength.Default(4);
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_614_edgeDetect0_3x3)
HXLINE( 615)		Float x = ((strength - ( (Float)(1) )) / ((Float)4.));
HXLINE( 616)		Float m33_a = ((Float)0.);
HXDLIN( 616)		Float m33_b = x;
HXDLIN( 616)		Float m33_c = ((Float)0.);
HXDLIN( 616)		Float m33_d = x;
HXDLIN( 616)		Float m33_e = -(strength);
HXDLIN( 616)		Float m33_f = x;
HXDLIN( 616)		Float m33_g = ( (Float)(0) );
HXDLIN( 616)		Float m33_h = x;
HXDLIN( 616)		Float m33_i = ((Float)0.);
HXDLIN( 616)		bool adjustRed = true;
HXDLIN( 616)		bool adjustGreen = true;
HXDLIN( 616)		bool adjustBlue = true;
HXDLIN( 616)		int a0 = 0;
HXDLIN( 616)		int b0 = 0;
HXDLIN( 616)		int c0 = 0;
HXDLIN( 616)		int d0 = 0;
HXDLIN( 616)		int e0 = 0;
HXDLIN( 616)		int f0 = 0;
HXDLIN( 616)		int g0 = 0;
HXDLIN( 616)		int h0 = 0;
HXDLIN( 616)		int i0 = 0;
HXDLIN( 616)		Float r_ = ((Float)0.);
HXDLIN( 616)		Float g_ = ((Float)0.);
HXDLIN( 616)		Float b_ = ((Float)0.);
HXDLIN( 616)		Float a_ = ((Float)0.);
HXDLIN( 616)		int width = this1->width;
HXDLIN( 616)		int height = this1->height;
HXDLIN( 616)		 ::Dynamic imageType = null();
HXDLIN( 616)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 616)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 616)		::Dynamic _hx_tmp;
HXDLIN( 616)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 616)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 616)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 616)				{
HXLINE( 616)					b->width = width;
HXDLIN( 616)					b->height = height;
HXDLIN( 616)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 616)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 616)					{
HXLINE( 616)						int len = b->length;
HXDLIN( 616)						int w = 0;
HXDLIN( 616)						{
HXLINE( 616)							int _g = 0;
HXDLIN( 616)							int _g1 = b->height;
HXDLIN( 616)							while((_g < _g1)){
HXLINE( 616)								_g = (_g + 1);
HXDLIN( 616)								int y = (_g - 1);
HXDLIN( 616)								{
HXLINE( 616)									int _g2 = 0;
HXDLIN( 616)									int _g3 = b->width;
HXDLIN( 616)									while((_g2 < _g3)){
HXLINE( 616)										_g2 = (_g2 + 1);
HXDLIN( 616)										int x1 = (_g2 - 1);
HXDLIN( 616)										{
HXLINE( 616)											w = (w + 1);
HXDLIN( 616)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 616)										{
HXLINE( 616)											w = (w + 1);
HXDLIN( 616)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 616)										{
HXLINE( 616)											w = (w + 1);
HXDLIN( 616)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 616)										{
HXLINE( 616)											w = (w + 1);
HXDLIN( 616)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 616)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 616)				{
HXLINE( 616)					a->width = width;
HXDLIN( 616)					a->height = height;
HXDLIN( 616)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 616)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 616)					{
HXLINE( 616)						int _g4 = 0;
HXDLIN( 616)						int _g5 = a->length;
HXDLIN( 616)						while((_g4 < _g5)){
HXLINE( 616)							_g4 = (_g4 + 1);
HXDLIN( 616)							int i = (_g4 - 1);
HXDLIN( 616)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 616)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 616)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 616)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 616)				{
HXLINE( 616)					b1->width = width;
HXDLIN( 616)					b1->height = height;
HXDLIN( 616)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 616)					int size = (b1->length * 4);
HXDLIN( 616)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 616)					{
HXLINE( 616)						int _g6 = 0;
HXDLIN( 616)						int _g7 = b1->length;
HXDLIN( 616)						while((_g6 < _g7)){
HXLINE( 616)							_g6 = (_g6 + 1);
HXDLIN( 616)							int i1 = (_g6 - 1);
HXDLIN( 616)							{
HXLINE( 616)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 616)								bool _hx_tmp1;
HXDLIN( 616)								if ((i1 >= 0)) {
HXLINE( 616)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 616)									_hx_tmp1 = false;
            								}
HXDLIN( 616)								if (_hx_tmp1) {
HXLINE( 616)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 616)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 616)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 616)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 616)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 616)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 616)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 616)				{
HXLINE( 616)					v->width = width;
HXDLIN( 616)					v->height = height;
HXDLIN( 616)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 616)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 616)					{
HXLINE( 616)						int _g8 = 0;
HXDLIN( 616)						int _g9 = v->length;
HXDLIN( 616)						while((_g8 < _g9)){
HXLINE( 616)							_g8 = (_g8 + 1);
HXDLIN( 616)							int i2 = (_g8 - 1);
HXDLIN( 616)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 616)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 616)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 616)				{
HXLINE( 616)					b2->width = width;
HXDLIN( 616)					b2->height = height;
HXDLIN( 616)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 616)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 616)					{
HXLINE( 616)						int len1 = b2->length;
HXDLIN( 616)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 616)						if (::hx::IsNull( d->head )) {
HXLINE( 616)							int _g10 = 0;
HXDLIN( 616)							int _g11 = len1;
HXDLIN( 616)							while((_g10 < _g11)){
HXLINE( 616)								_g10 = (_g10 + 1);
HXDLIN( 616)								int i3 = (_g10 - 1);
HXDLIN( 616)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 616)							int _g12 = 0;
HXDLIN( 616)							int _g13 = len1;
HXDLIN( 616)							while((_g12 < _g13)){
HXLINE( 616)								_g12 = (_g12 + 1);
HXDLIN( 616)								int i4 = (_g12 - 1);
HXDLIN( 616)								{
HXLINE( 616)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 616)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 616)									{
HXLINE( 616)										int _g14 = 0;
HXDLIN( 616)										int _g15 = i4;
HXDLIN( 616)										while((_g14 < _g15)){
HXLINE( 616)											_g14 = (_g14 + 1);
HXDLIN( 616)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 616)									if (::hx::IsNull( prev )) {
HXLINE( 616)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 616)										l = null();
            									}
            									else {
HXLINE( 616)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 616)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 616)		this2->image = _hx_tmp;
HXDLIN( 616)		this2->width = width;
HXDLIN( 616)		this2->height = height;
HXDLIN( 616)		this2->imageType = ( (int)(imageType) );
HXDLIN( 616)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 616)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 616)		switch((int)(borderMode)){
            			case (int)0: {
HXLINE( 616)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 616)				int width1 = (this4->width + 2);
HXDLIN( 616)				int height1 = (this4->height + 2);
HXDLIN( 616)				 ::Dynamic imageType1 = null();
HXDLIN( 616)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 616)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 616)				::Dynamic here1;
HXDLIN( 616)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 616)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 616)						{
HXLINE( 616)							b3->width = width1;
HXDLIN( 616)							b3->height = height1;
HXDLIN( 616)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 616)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 616)							{
HXLINE( 616)								int len2 = b3->length;
HXDLIN( 616)								int w1 = 0;
HXDLIN( 616)								{
HXLINE( 616)									int _g16 = 0;
HXDLIN( 616)									int _g17 = b3->height;
HXDLIN( 616)									while((_g16 < _g17)){
HXLINE( 616)										_g16 = (_g16 + 1);
HXDLIN( 616)										int y1 = (_g16 - 1);
HXDLIN( 616)										{
HXLINE( 616)											int _g18 = 0;
HXDLIN( 616)											int _g19 = b3->width;
HXDLIN( 616)											while((_g18 < _g19)){
HXLINE( 616)												_g18 = (_g18 + 1);
HXDLIN( 616)												int x2 = (_g18 - 1);
HXDLIN( 616)												{
HXLINE( 616)													w1 = (w1 + 1);
HXDLIN( 616)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w1 = (w1 + 1);
HXDLIN( 616)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w1 = (w1 + 1);
HXDLIN( 616)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w1 = (w1 + 1);
HXDLIN( 616)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXLINE( 616)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 616)						{
HXLINE( 616)							a1->width = width1;
HXDLIN( 616)							a1->height = height1;
HXDLIN( 616)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 616)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 616)							{
HXLINE( 616)								int _g20 = 0;
HXDLIN( 616)								int _g21 = a1->length;
HXDLIN( 616)								while((_g20 < _g21)){
HXLINE( 616)									_g20 = (_g20 + 1);
HXDLIN( 616)									int i6 = (_g20 - 1);
HXDLIN( 616)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 616)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXLINE( 616)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 616)						{
HXLINE( 616)							b4->width = width1;
HXDLIN( 616)							b4->height = height1;
HXDLIN( 616)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 616)							int size1 = (b4->length * 4);
HXDLIN( 616)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 616)							{
HXLINE( 616)								int _g22 = 0;
HXDLIN( 616)								int _g23 = b4->length;
HXDLIN( 616)								while((_g22 < _g23)){
HXLINE( 616)									_g22 = (_g22 + 1);
HXDLIN( 616)									int i7 = (_g22 - 1);
HXDLIN( 616)									{
HXLINE( 616)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 616)										bool here2;
HXDLIN( 616)										if ((i7 >= 0)) {
HXLINE( 616)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXLINE( 616)											here2 = false;
            										}
HXDLIN( 616)										if (here2) {
HXLINE( 616)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 616)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 616)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 616)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 616)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 616)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXLINE( 616)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 616)						{
HXLINE( 616)							v1->width = width1;
HXDLIN( 616)							v1->height = height1;
HXDLIN( 616)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 616)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 616)							{
HXLINE( 616)								int _g24 = 0;
HXDLIN( 616)								int _g25 = v1->length;
HXDLIN( 616)								while((_g24 < _g25)){
HXLINE( 616)									_g24 = (_g24 + 1);
HXDLIN( 616)									int i8 = (_g24 - 1);
HXDLIN( 616)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 616)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXLINE( 616)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 616)						{
HXLINE( 616)							b5->width = width1;
HXDLIN( 616)							b5->height = height1;
HXDLIN( 616)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 616)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 616)							{
HXLINE( 616)								int len3 = b5->length;
HXDLIN( 616)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 616)								if (::hx::IsNull( d1->head )) {
HXLINE( 616)									int _g26 = 0;
HXDLIN( 616)									int _g27 = len3;
HXDLIN( 616)									while((_g26 < _g27)){
HXLINE( 616)										_g26 = (_g26 + 1);
HXDLIN( 616)										int i9 = (_g26 - 1);
HXDLIN( 616)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 616)									int _g28 = 0;
HXDLIN( 616)									int _g29 = len3;
HXDLIN( 616)									while((_g28 < _g29)){
HXLINE( 616)										_g28 = (_g28 + 1);
HXDLIN( 616)										int i10 = (_g28 - 1);
HXDLIN( 616)										{
HXLINE( 616)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 616)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 616)											{
HXLINE( 616)												int _g30 = 0;
HXDLIN( 616)												int _g31 = i10;
HXDLIN( 616)												while((_g30 < _g31)){
HXLINE( 616)													_g30 = (_g30 + 1);
HXDLIN( 616)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 616)											if (::hx::IsNull( prev1 )) {
HXLINE( 616)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 616)												l1 = null();
            											}
            											else {
HXLINE( 616)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 616)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 616)				this5->image = here1;
HXDLIN( 616)				this5->width = width1;
HXDLIN( 616)				this5->height = height1;
HXDLIN( 616)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 616)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 616)				bool forceClear = false;
HXDLIN( 616)				int _g32 = 0;
HXDLIN( 616)				int _g33 = this4->height;
HXDLIN( 616)				while((_g32 < _g33)){
HXLINE( 616)					_g32 = (_g32 + 1);
HXDLIN( 616)					int dy = (_g32 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g34 = 0;
HXDLIN( 616)						int _g35 = this4->width;
HXDLIN( 616)						while((_g34 < _g35)){
HXLINE( 616)							_g34 = (_g34 + 1);
HXDLIN( 616)							int dx = (_g34 - 1);
HXDLIN( 616)							::Dynamic this7 = this4->image;
HXDLIN( 616)							int index;
HXDLIN( 616)							if (this4->useVirtualPos) {
HXLINE( 616)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXLINE( 616)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 616)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 616)							int col;
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 616)								col = c;
            							}
HXDLIN( 616)							bool here3;
HXDLIN( 616)							if (this4->useMask) {
HXLINE( 616)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXLINE( 616)								here3 = false;
            							}
HXDLIN( 616)							if (here3) {
HXLINE( 616)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 616)								::Dynamic this9 = this8->image;
HXDLIN( 616)								int index1;
HXDLIN( 616)								if (this8->useVirtualPos) {
HXLINE( 616)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXLINE( 616)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 616)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 616)								int v2;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									v2 = c1;
            								}
HXDLIN( 616)								int maskPixel = v2;
HXDLIN( 616)								int this10 = col;
HXDLIN( 616)								if ((maskPixel == 0)) {
HXLINE( 616)									col = this10;
            								}
            								else {
HXLINE( 616)									Float m0;
HXDLIN( 616)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 616)									if ((this11 == 0)) {
HXLINE( 616)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m1;
HXDLIN( 616)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 616)									if ((this12 == 0)) {
HXLINE( 616)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m2;
HXDLIN( 616)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 616)									if ((this13 == 0)) {
HXLINE( 616)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m3;
HXDLIN( 616)									int this14 = (maskPixel & 255);
HXDLIN( 616)									if ((this14 == 0)) {
HXLINE( 616)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 616)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 616)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 616)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 616)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 616)							if ((col != 0)) {
HXLINE( 616)								int x3 = (1 + dx);
HXDLIN( 616)								int y2 = (1 + dy);
HXDLIN( 616)								int c2 = col;
HXDLIN( 616)								bool here4;
HXDLIN( 616)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 616)									here4 = img->transparent;
            								}
            								else {
HXLINE( 616)									here4 = false;
            								}
HXDLIN( 616)								if (here4) {
HXLINE( 616)									int location;
HXDLIN( 616)									if (img->useVirtualPos) {
HXLINE( 616)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXLINE( 616)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x3)) ));
            									}
HXDLIN( 616)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 616)									int this16;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										this16 = this15;
            									}
HXDLIN( 616)									Float a11;
HXDLIN( 616)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 616)									if ((this17 == 0)) {
HXLINE( 616)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r1;
HXDLIN( 616)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 616)									if ((this18 == 0)) {
HXLINE( 616)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g1;
HXDLIN( 616)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 616)									if ((this19 == 0)) {
HXLINE( 616)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b11;
HXDLIN( 616)									int this20 = (this16 & 255);
HXDLIN( 616)									if ((this20 == 0)) {
HXLINE( 616)										b11 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a2;
HXDLIN( 616)									int this21 = ((col >> 24) & 255);
HXDLIN( 616)									if ((this21 == 0)) {
HXLINE( 616)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r2;
HXDLIN( 616)									int this22 = ((col >> 16) & 255);
HXDLIN( 616)									if ((this22 == 0)) {
HXLINE( 616)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g2;
HXDLIN( 616)									int this23 = ((col >> 8) & 255);
HXDLIN( 616)									if ((this23 == 0)) {
HXLINE( 616)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b21;
HXDLIN( 616)									int this24 = (col & 255);
HXDLIN( 616)									if ((this24 == 0)) {
HXLINE( 616)										b21 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 616)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 616)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 616)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 616)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 616)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 616)									{
HXLINE( 616)										int here5;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here5 = blended;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXLINE( 616)									::Dynamic this25 = img->image;
HXDLIN( 616)									int index2;
HXDLIN( 616)									if (img->useVirtualPos) {
HXLINE( 616)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXLINE( 616)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x3)) ));
            									}
HXDLIN( 616)									int here6;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										here6 = c2;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXLINE( 616)								if (forceClear) {
HXLINE( 616)									::Dynamic this26 = img->image;
HXDLIN( 616)									int x4 = (1 + dx);
HXDLIN( 616)									int y3 = (1 + dy);
HXDLIN( 616)									int index3;
HXDLIN( 616)									if (img->useVirtualPos) {
HXLINE( 616)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x4) - img->virtualX));
            									}
            									else {
HXLINE( 616)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x4)) ));
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g36 = 0;
HXDLIN( 616)				int _g37 = this4->width;
HXDLIN( 616)				while((_g36 < _g37)){
HXLINE( 616)					_g36 = (_g36 + 1);
HXDLIN( 616)					int x5 = (_g36 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g38 = 0;
HXDLIN( 616)						int _g39 = 1;
HXDLIN( 616)						while((_g38 < _g39)){
HXLINE( 616)							_g38 = (_g38 + 1);
HXDLIN( 616)							int y4 = (_g38 - 1);
HXDLIN( 616)							{
HXLINE( 616)								int x6 = (x5 + 1);
HXDLIN( 616)								::Dynamic this27 = this4->image;
HXDLIN( 616)								int index4;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x5) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x5)) ));
            								}
HXDLIN( 616)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 616)								int color;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color = c3;
            								}
HXDLIN( 616)								int color1 = color;
HXDLIN( 616)								{
HXLINE( 616)									int c4 = color1;
HXDLIN( 616)									bool here7;
HXDLIN( 616)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 616)										here7 = img->transparent;
            									}
            									else {
HXLINE( 616)										here7 = false;
            									}
HXDLIN( 616)									if (here7) {
HXLINE( 616)										int location1;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x6)) ));
            										}
HXDLIN( 616)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 616)										int this29;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this29 = this28;
            										}
HXDLIN( 616)										Float a12;
HXDLIN( 616)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 616)										if ((this30 == 0)) {
HXLINE( 616)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r11;
HXDLIN( 616)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 616)										if ((this31 == 0)) {
HXLINE( 616)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g11;
HXDLIN( 616)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 616)										if ((this32 == 0)) {
HXLINE( 616)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b12;
HXDLIN( 616)										int this33 = (this29 & 255);
HXDLIN( 616)										if ((this33 == 0)) {
HXLINE( 616)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a21;
HXDLIN( 616)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 616)										if ((this34 == 0)) {
HXLINE( 616)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r21;
HXDLIN( 616)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 616)										if ((this35 == 0)) {
HXLINE( 616)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g21;
HXDLIN( 616)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 616)										if ((this36 == 0)) {
HXLINE( 616)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b22;
HXDLIN( 616)										int this37 = (color1 & 255);
HXDLIN( 616)										if ((this37 == 0)) {
HXLINE( 616)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 616)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 616)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 616)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 616)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 616)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 616)										{
HXLINE( 616)											int here8;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here8 = blended1;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this38 = img->image;
HXDLIN( 616)										int index5;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x6)) ));
            										}
HXDLIN( 616)										int here9;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here9 = c4;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x7 = (x5 + 1);
HXDLIN( 616)								int y5 = ((img->height - y4) - 1);
HXDLIN( 616)								int y6 = (this4->height - 1);
HXDLIN( 616)								::Dynamic this39 = this4->image;
HXDLIN( 616)								int index6;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x5) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x5)) ));
            								}
HXDLIN( 616)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 616)								int color2;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color2 = c5;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c6 = color2;
HXDLIN( 616)									bool here10;
HXDLIN( 616)									if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 616)										here10 = img->transparent;
            									}
            									else {
HXLINE( 616)										here10 = false;
            									}
HXDLIN( 616)									if (here10) {
HXLINE( 616)										int location2;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x7)) ));
            										}
HXDLIN( 616)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 616)										int this41;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this41 = this40;
            										}
HXDLIN( 616)										Float a13;
HXDLIN( 616)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 616)										if ((this42 == 0)) {
HXLINE( 616)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r12;
HXDLIN( 616)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 616)										if ((this43 == 0)) {
HXLINE( 616)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g12;
HXDLIN( 616)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 616)										if ((this44 == 0)) {
HXLINE( 616)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b13;
HXDLIN( 616)										int this45 = (this41 & 255);
HXDLIN( 616)										if ((this45 == 0)) {
HXLINE( 616)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a22;
HXDLIN( 616)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 616)										if ((this46 == 0)) {
HXLINE( 616)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r22;
HXDLIN( 616)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 616)										if ((this47 == 0)) {
HXLINE( 616)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g22;
HXDLIN( 616)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 616)										if ((this48 == 0)) {
HXLINE( 616)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b23;
HXDLIN( 616)										int this49 = (color2 & 255);
HXDLIN( 616)										if ((this49 == 0)) {
HXLINE( 616)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 616)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 616)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 616)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 616)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 616)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 616)										{
HXLINE( 616)											int here11;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here11 = blended2;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this50 = img->image;
HXDLIN( 616)										int index7;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x7)) ));
            										}
HXDLIN( 616)										int here12;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here12 = c6;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g40 = 0;
HXDLIN( 616)				int _g41 = this4->height;
HXDLIN( 616)				while((_g40 < _g41)){
HXLINE( 616)					_g40 = (_g40 + 1);
HXDLIN( 616)					int y7 = (_g40 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g42 = 0;
HXDLIN( 616)						int _g43 = 1;
HXDLIN( 616)						while((_g42 < _g43)){
HXLINE( 616)							_g42 = (_g42 + 1);
HXDLIN( 616)							int x8 = (_g42 - 1);
HXDLIN( 616)							{
HXLINE( 616)								int y8 = (y7 + 1);
HXDLIN( 616)								::Dynamic this51 = this4->image;
HXDLIN( 616)								int index8;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 616)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 616)								int color3;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color3 = c7;
            								}
HXDLIN( 616)								int color4 = color3;
HXDLIN( 616)								{
HXLINE( 616)									int c8 = color4;
HXDLIN( 616)									bool here13;
HXDLIN( 616)									if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 616)										here13 = img->transparent;
            									}
            									else {
HXLINE( 616)										here13 = false;
            									}
HXDLIN( 616)									if (here13) {
HXLINE( 616)										int location3;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            										}
HXDLIN( 616)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 616)										int this53;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this53 = this52;
            										}
HXDLIN( 616)										Float a14;
HXDLIN( 616)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 616)										if ((this54 == 0)) {
HXLINE( 616)											a14 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r13;
HXDLIN( 616)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 616)										if ((this55 == 0)) {
HXLINE( 616)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g13;
HXDLIN( 616)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 616)										if ((this56 == 0)) {
HXLINE( 616)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b14;
HXDLIN( 616)										int this57 = (this53 & 255);
HXDLIN( 616)										if ((this57 == 0)) {
HXLINE( 616)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a23;
HXDLIN( 616)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 616)										if ((this58 == 0)) {
HXLINE( 616)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r23;
HXDLIN( 616)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 616)										if ((this59 == 0)) {
HXLINE( 616)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g23;
HXDLIN( 616)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 616)										if ((this60 == 0)) {
HXLINE( 616)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b24;
HXDLIN( 616)										int this61 = (color4 & 255);
HXDLIN( 616)										if ((this61 == 0)) {
HXLINE( 616)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 616)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 616)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 616)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 616)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 616)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 616)										{
HXLINE( 616)											int here14;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here14 = blended3;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this62 = img->image;
HXDLIN( 616)										int index9;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x8)) ));
            										}
HXDLIN( 616)										int here15;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here15 = c8;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x9 = ((img->width - x8) - 1);
HXDLIN( 616)								int y9 = (y7 + 1);
HXDLIN( 616)								int x10 = (this4->width - 1);
HXDLIN( 616)								::Dynamic this63 = this4->image;
HXDLIN( 616)								int index10;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x10) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x10)) ));
            								}
HXDLIN( 616)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 616)								int color5;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color5 = c9;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c10 = color5;
HXDLIN( 616)									bool here16;
HXDLIN( 616)									if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 616)										here16 = img->transparent;
            									}
            									else {
HXLINE( 616)										here16 = false;
            									}
HXDLIN( 616)									if (here16) {
HXLINE( 616)										int location4;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            										}
HXDLIN( 616)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 616)										int this65;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this65 = this64;
            										}
HXDLIN( 616)										Float a15;
HXDLIN( 616)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 616)										if ((this66 == 0)) {
HXLINE( 616)											a15 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r14;
HXDLIN( 616)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 616)										if ((this67 == 0)) {
HXLINE( 616)											r14 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g14;
HXDLIN( 616)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 616)										if ((this68 == 0)) {
HXLINE( 616)											g14 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b15;
HXDLIN( 616)										int this69 = (this65 & 255);
HXDLIN( 616)										if ((this69 == 0)) {
HXLINE( 616)											b15 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a24;
HXDLIN( 616)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 616)										if ((this70 == 0)) {
HXLINE( 616)											a24 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r24;
HXDLIN( 616)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 616)										if ((this71 == 0)) {
HXLINE( 616)											r24 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g24;
HXDLIN( 616)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 616)										if ((this72 == 0)) {
HXLINE( 616)											g24 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b25;
HXDLIN( 616)										int this73 = (color5 & 255);
HXDLIN( 616)										if ((this73 == 0)) {
HXLINE( 616)											b25 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 616)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 616)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 616)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 616)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 616)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 616)										{
HXLINE( 616)											int here17;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here17 = blended4;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this74 = img->image;
HXDLIN( 616)										int index11;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x9) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x9)) ));
            										}
HXDLIN( 616)										int here18;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here18 = c10;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g44 = 0;
HXDLIN( 616)				int _g45 = 1;
HXDLIN( 616)				while((_g44 < _g45)){
HXLINE( 616)					_g44 = (_g44 + 1);
HXDLIN( 616)					int x11 = (_g44 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g46 = 0;
HXDLIN( 616)						int _g47 = 1;
HXDLIN( 616)						while((_g46 < _g47)){
HXLINE( 616)							_g46 = (_g46 + 1);
HXDLIN( 616)							int y10 = (_g46 - 1);
HXDLIN( 616)							{
HXLINE( 616)								::Dynamic this75 = this4->image;
HXDLIN( 616)								int index12;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 616)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 616)								int color6;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color6 = c11;
            								}
HXDLIN( 616)								int color7 = color6;
HXDLIN( 616)								{
HXLINE( 616)									int c12 = color7;
HXDLIN( 616)									bool here19;
HXDLIN( 616)									if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 616)										here19 = img->transparent;
            									}
            									else {
HXLINE( 616)										here19 = false;
            									}
HXDLIN( 616)									if (here19) {
HXLINE( 616)										int location5;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 616)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 616)										int this77;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this77 = this76;
            										}
HXDLIN( 616)										Float a16;
HXDLIN( 616)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 616)										if ((this78 == 0)) {
HXLINE( 616)											a16 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r15;
HXDLIN( 616)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 616)										if ((this79 == 0)) {
HXLINE( 616)											r15 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g15;
HXDLIN( 616)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 616)										if ((this80 == 0)) {
HXLINE( 616)											g15 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b16;
HXDLIN( 616)										int this81 = (this77 & 255);
HXDLIN( 616)										if ((this81 == 0)) {
HXLINE( 616)											b16 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a25;
HXDLIN( 616)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 616)										if ((this82 == 0)) {
HXLINE( 616)											a25 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r25;
HXDLIN( 616)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 616)										if ((this83 == 0)) {
HXLINE( 616)											r25 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g25;
HXDLIN( 616)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 616)										if ((this84 == 0)) {
HXLINE( 616)											g25 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b26;
HXDLIN( 616)										int this85 = (color7 & 255);
HXDLIN( 616)										if ((this85 == 0)) {
HXLINE( 616)											b26 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 616)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 616)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 616)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 616)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 616)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 616)										{
HXLINE( 616)											int here20;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here20 = blended5;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this86 = img->image;
HXDLIN( 616)										int index13;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 616)										int here21;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here21 = c12;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x12 = ((x11 + 1) + this4->width);
HXDLIN( 616)								int x13 = (this4->width - 1);
HXDLIN( 616)								::Dynamic this87 = this4->image;
HXDLIN( 616)								int index14;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x13) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x13)) ));
            								}
HXDLIN( 616)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 616)								int color8;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color8 = c13;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c14 = color8;
HXDLIN( 616)									bool here22;
HXDLIN( 616)									if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 616)										here22 = img->transparent;
            									}
            									else {
HXLINE( 616)										here22 = false;
            									}
HXDLIN( 616)									if (here22) {
HXLINE( 616)										int location6;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            										}
HXDLIN( 616)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 616)										int this89;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this89 = this88;
            										}
HXDLIN( 616)										Float a17;
HXDLIN( 616)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 616)										if ((this90 == 0)) {
HXLINE( 616)											a17 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r16;
HXDLIN( 616)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 616)										if ((this91 == 0)) {
HXLINE( 616)											r16 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g16;
HXDLIN( 616)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 616)										if ((this92 == 0)) {
HXLINE( 616)											g16 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b18;
HXDLIN( 616)										int this93 = (this89 & 255);
HXDLIN( 616)										if ((this93 == 0)) {
HXLINE( 616)											b18 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a26;
HXDLIN( 616)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 616)										if ((this94 == 0)) {
HXLINE( 616)											a26 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r26;
HXDLIN( 616)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 616)										if ((this95 == 0)) {
HXLINE( 616)											r26 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g26;
HXDLIN( 616)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 616)										if ((this96 == 0)) {
HXLINE( 616)											g26 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b27;
HXDLIN( 616)										int this97 = (color8 & 255);
HXDLIN( 616)										if ((this97 == 0)) {
HXLINE( 616)											b27 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 616)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 616)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 616)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 616)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 616)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 616)										{
HXLINE( 616)											int here23;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here23 = blended6;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this98 = img->image;
HXDLIN( 616)										int index15;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x12) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x12)) ));
            										}
HXDLIN( 616)										int here24;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here24 = c14;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x14 = ((x11 + 1) + this4->width);
HXDLIN( 616)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 616)								int x15 = (this4->width - 1);
HXDLIN( 616)								int y12 = (this4->height - 1);
HXDLIN( 616)								::Dynamic this99 = this4->image;
HXDLIN( 616)								int index16;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x15) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x15)) ));
            								}
HXDLIN( 616)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 616)								int color9;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color9 = c15;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c16 = color9;
HXDLIN( 616)									bool here25;
HXDLIN( 616)									if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 616)										here25 = img->transparent;
            									}
            									else {
HXLINE( 616)										here25 = false;
            									}
HXDLIN( 616)									if (here25) {
HXLINE( 616)										int location7;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x14) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x14)) ));
            										}
HXDLIN( 616)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 616)										int this101;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this101 = this100;
            										}
HXDLIN( 616)										Float a18;
HXDLIN( 616)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 616)										if ((this102 == 0)) {
HXLINE( 616)											a18 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r17;
HXDLIN( 616)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 616)										if ((this103 == 0)) {
HXLINE( 616)											r17 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g17;
HXDLIN( 616)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 616)										if ((this104 == 0)) {
HXLINE( 616)											g17 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b110;
HXDLIN( 616)										int this105 = (this101 & 255);
HXDLIN( 616)										if ((this105 == 0)) {
HXLINE( 616)											b110 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a27;
HXDLIN( 616)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 616)										if ((this106 == 0)) {
HXLINE( 616)											a27 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r27;
HXDLIN( 616)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 616)										if ((this107 == 0)) {
HXLINE( 616)											r27 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g27;
HXDLIN( 616)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 616)										if ((this108 == 0)) {
HXLINE( 616)											g27 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b28;
HXDLIN( 616)										int this109 = (color9 & 255);
HXDLIN( 616)										if ((this109 == 0)) {
HXLINE( 616)											b28 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 616)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 616)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 616)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 616)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 616)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 616)										{
HXLINE( 616)											int here26;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here26 = blended7;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this110 = img->image;
HXDLIN( 616)										int index17;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x14) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x14)) ));
            										}
HXDLIN( 616)										int here27;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here27 = c16;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 616)								int y14 = (this4->height - 1);
HXDLIN( 616)								::Dynamic this111 = this4->image;
HXDLIN( 616)								int index18;
HXDLIN( 616)								if (this4->useVirtualPos) {
HXLINE( 616)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXLINE( 616)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 616)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 616)								int color10;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color10 = c17;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c18 = color10;
HXDLIN( 616)									bool here28;
HXDLIN( 616)									if ((((c18 >> 24) & 255) < 254)) {
HXLINE( 616)										here28 = img->transparent;
            									}
            									else {
HXLINE( 616)										here28 = false;
            									}
HXDLIN( 616)									if (here28) {
HXLINE( 616)										int location8;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 616)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x11)) ));
            										}
HXDLIN( 616)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 616)										int this113;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this113 = this112;
            										}
HXDLIN( 616)										Float a110;
HXDLIN( 616)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 616)										if ((this114 == 0)) {
HXLINE( 616)											a110 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r18;
HXDLIN( 616)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 616)										if ((this115 == 0)) {
HXLINE( 616)											r18 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g18;
HXDLIN( 616)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 616)										if ((this116 == 0)) {
HXLINE( 616)											g18 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b111;
HXDLIN( 616)										int this117 = (this113 & 255);
HXDLIN( 616)										if ((this117 == 0)) {
HXLINE( 616)											b111 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a28;
HXDLIN( 616)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 616)										if ((this118 == 0)) {
HXLINE( 616)											a28 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r28;
HXDLIN( 616)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 616)										if ((this119 == 0)) {
HXLINE( 616)											r28 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g28;
HXDLIN( 616)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 616)										if ((this120 == 0)) {
HXLINE( 616)											g28 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b29;
HXDLIN( 616)										int this121 = (color10 & 255);
HXDLIN( 616)										if ((this121 == 0)) {
HXLINE( 616)											b29 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 616)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 616)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 616)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 616)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 616)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 616)										{
HXLINE( 616)											int here29;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here29 = blended8;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this122 = img->image;
HXDLIN( 616)										int index19;
HXDLIN( 616)										if (img->useVirtualPos) {
HXLINE( 616)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXLINE( 616)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x11)) ));
            										}
HXDLIN( 616)										int here30;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here30 = c18;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXLINE( 616)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 616)				int width2 = (this123->width + 2);
HXDLIN( 616)				int height2 = (this123->height + 2);
HXDLIN( 616)				 ::Dynamic imageType2 = null();
HXDLIN( 616)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 616)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 616)				::Dynamic here31;
HXDLIN( 616)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 616)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 616)						{
HXLINE( 616)							b31->width = width2;
HXDLIN( 616)							b31->height = height2;
HXDLIN( 616)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 616)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 616)							{
HXLINE( 616)								int len4 = b31->length;
HXDLIN( 616)								int w2 = 0;
HXDLIN( 616)								{
HXLINE( 616)									int _g48 = 0;
HXDLIN( 616)									int _g49 = b31->height;
HXDLIN( 616)									while((_g48 < _g49)){
HXLINE( 616)										_g48 = (_g48 + 1);
HXDLIN( 616)										int y15 = (_g48 - 1);
HXDLIN( 616)										{
HXLINE( 616)											int _g50 = 0;
HXDLIN( 616)											int _g51 = b31->width;
HXDLIN( 616)											while((_g50 < _g51)){
HXLINE( 616)												_g50 = (_g50 + 1);
HXDLIN( 616)												int x16 = (_g50 - 1);
HXDLIN( 616)												{
HXLINE( 616)													w2 = (w2 + 1);
HXDLIN( 616)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w2 = (w2 + 1);
HXDLIN( 616)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w2 = (w2 + 1);
HXDLIN( 616)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 616)												{
HXLINE( 616)													w2 = (w2 + 1);
HXDLIN( 616)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXLINE( 616)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 616)						{
HXLINE( 616)							a29->width = width2;
HXDLIN( 616)							a29->height = height2;
HXDLIN( 616)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 616)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 616)							{
HXLINE( 616)								int _g52 = 0;
HXDLIN( 616)								int _g53 = a29->length;
HXDLIN( 616)								while((_g52 < _g53)){
HXLINE( 616)									_g52 = (_g52 + 1);
HXDLIN( 616)									int i12 = (_g52 - 1);
HXDLIN( 616)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 616)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXLINE( 616)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 616)						{
HXLINE( 616)							b32->width = width2;
HXDLIN( 616)							b32->height = height2;
HXDLIN( 616)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 616)							int size2 = (b32->length * 4);
HXDLIN( 616)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 616)							{
HXLINE( 616)								int _g54 = 0;
HXDLIN( 616)								int _g55 = b32->length;
HXDLIN( 616)								while((_g54 < _g55)){
HXLINE( 616)									_g54 = (_g54 + 1);
HXDLIN( 616)									int i13 = (_g54 - 1);
HXDLIN( 616)									{
HXLINE( 616)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 616)										bool here32;
HXDLIN( 616)										if ((i13 >= 0)) {
HXLINE( 616)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXLINE( 616)											here32 = false;
            										}
HXDLIN( 616)										if (here32) {
HXLINE( 616)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 616)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 616)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 616)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 616)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 616)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXLINE( 616)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 616)						{
HXLINE( 616)							v3->width = width2;
HXDLIN( 616)							v3->height = height2;
HXDLIN( 616)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 616)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 616)							{
HXLINE( 616)								int _g56 = 0;
HXDLIN( 616)								int _g57 = v3->length;
HXDLIN( 616)								while((_g56 < _g57)){
HXLINE( 616)									_g56 = (_g56 + 1);
HXDLIN( 616)									int i14 = (_g56 - 1);
HXDLIN( 616)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 616)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 616)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 616)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 616)						{
HXLINE( 616)							b33->width = width2;
HXDLIN( 616)							b33->height = height2;
HXDLIN( 616)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 616)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 616)							{
HXLINE( 616)								int len5 = b33->length;
HXDLIN( 616)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 616)								if (::hx::IsNull( d2->head )) {
HXLINE( 616)									int _g58 = 0;
HXDLIN( 616)									int _g59 = len5;
HXDLIN( 616)									while((_g58 < _g59)){
HXLINE( 616)										_g58 = (_g58 + 1);
HXDLIN( 616)										int i15 = (_g58 - 1);
HXDLIN( 616)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 616)									int _g60 = 0;
HXDLIN( 616)									int _g61 = len5;
HXDLIN( 616)									while((_g60 < _g61)){
HXLINE( 616)										_g60 = (_g60 + 1);
HXDLIN( 616)										int i16 = (_g60 - 1);
HXDLIN( 616)										{
HXLINE( 616)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 616)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 616)											{
HXLINE( 616)												int _g62 = 0;
HXDLIN( 616)												int _g63 = i16;
HXDLIN( 616)												while((_g62 < _g63)){
HXLINE( 616)													_g62 = (_g62 + 1);
HXDLIN( 616)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 616)											if (::hx::IsNull( prev2 )) {
HXLINE( 616)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 616)												l2 = null();
            											}
            											else {
HXLINE( 616)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 616)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 616)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 616)				this124->image = here31;
HXDLIN( 616)				this124->width = width2;
HXDLIN( 616)				this124->height = height2;
HXDLIN( 616)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 616)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 616)				bool forceClear1 = false;
HXDLIN( 616)				int _g64 = 0;
HXDLIN( 616)				int _g65 = this123->height;
HXDLIN( 616)				while((_g64 < _g65)){
HXLINE( 616)					_g64 = (_g64 + 1);
HXDLIN( 616)					int dy1 = (_g64 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g66 = 0;
HXDLIN( 616)						int _g67 = this123->width;
HXDLIN( 616)						while((_g66 < _g67)){
HXLINE( 616)							_g66 = (_g66 + 1);
HXDLIN( 616)							int dx1 = (_g66 - 1);
HXDLIN( 616)							::Dynamic this126 = this123->image;
HXDLIN( 616)							int index20;
HXDLIN( 616)							if (this123->useVirtualPos) {
HXLINE( 616)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXLINE( 616)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 616)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 616)							int col1;
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								col1 = c19;
            							}
HXDLIN( 616)							bool here33;
HXDLIN( 616)							if (this123->useMask) {
HXLINE( 616)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXLINE( 616)								here33 = false;
            							}
HXDLIN( 616)							if (here33) {
HXLINE( 616)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 616)								::Dynamic this128 = this127->image;
HXDLIN( 616)								int index21;
HXDLIN( 616)								if (this127->useVirtualPos) {
HXLINE( 616)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXLINE( 616)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 616)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 616)								int v4;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									v4 = c20;
            								}
HXDLIN( 616)								int maskPixel1 = v4;
HXDLIN( 616)								int this129 = col1;
HXDLIN( 616)								if ((maskPixel1 == 0)) {
HXLINE( 616)									col1 = this129;
            								}
            								else {
HXLINE( 616)									Float m01;
HXDLIN( 616)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 616)									if ((this130 == 0)) {
HXLINE( 616)										m01 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m11;
HXDLIN( 616)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 616)									if ((this131 == 0)) {
HXLINE( 616)										m11 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m21;
HXDLIN( 616)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 616)									if ((this132 == 0)) {
HXLINE( 616)										m21 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float m31;
HXDLIN( 616)									int this133 = (maskPixel1 & 255);
HXDLIN( 616)									if ((this133 == 0)) {
HXLINE( 616)										m31 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 616)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 616)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 616)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 616)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 616)							if ((col1 != 0)) {
HXLINE( 616)								int x17 = (1 + dx1);
HXDLIN( 616)								int y16 = (1 + dy1);
HXDLIN( 616)								int c21 = col1;
HXDLIN( 616)								bool here34;
HXDLIN( 616)								if ((((c21 >> 24) & 255) < 254)) {
HXLINE( 616)									here34 = img1->transparent;
            								}
            								else {
HXLINE( 616)									here34 = false;
            								}
HXDLIN( 616)								if (here34) {
HXLINE( 616)									int location9;
HXDLIN( 616)									if (img1->useVirtualPos) {
HXLINE( 616)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXLINE( 616)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x17)) ));
            									}
HXDLIN( 616)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 616)									int this135;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										this135 = this134;
            									}
HXDLIN( 616)									Float a111;
HXDLIN( 616)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 616)									if ((this136 == 0)) {
HXLINE( 616)										a111 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r19;
HXDLIN( 616)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 616)									if ((this137 == 0)) {
HXLINE( 616)										r19 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g19;
HXDLIN( 616)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 616)									if ((this138 == 0)) {
HXLINE( 616)										g19 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b112;
HXDLIN( 616)									int this139 = (this135 & 255);
HXDLIN( 616)									if ((this139 == 0)) {
HXLINE( 616)										b112 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a210;
HXDLIN( 616)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 616)									if ((this140 == 0)) {
HXLINE( 616)										a210 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r29;
HXDLIN( 616)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 616)									if ((this141 == 0)) {
HXLINE( 616)										r29 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g29;
HXDLIN( 616)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 616)									if ((this142 == 0)) {
HXLINE( 616)										g29 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b210;
HXDLIN( 616)									int this143 = (col1 & 255);
HXDLIN( 616)									if ((this143 == 0)) {
HXLINE( 616)										b210 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 616)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 616)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 616)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 616)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 616)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 616)									{
HXLINE( 616)										int here35;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here35 = blended9;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXLINE( 616)									::Dynamic this144 = img1->image;
HXDLIN( 616)									int index22;
HXDLIN( 616)									if (img1->useVirtualPos) {
HXLINE( 616)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXLINE( 616)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x17)) ));
            									}
HXDLIN( 616)									int here36;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										here36 = c21;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXLINE( 616)								if (forceClear1) {
HXLINE( 616)									::Dynamic this145 = img1->image;
HXDLIN( 616)									int x18 = (1 + dx1);
HXDLIN( 616)									int y17 = (1 + dy1);
HXDLIN( 616)									int index23;
HXDLIN( 616)									if (img1->useVirtualPos) {
HXLINE( 616)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x18) - img1->virtualX));
            									}
            									else {
HXLINE( 616)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x18)) ));
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g68 = 0;
HXDLIN( 616)				int _g69 = this123->width;
HXDLIN( 616)				while((_g68 < _g69)){
HXLINE( 616)					_g68 = (_g68 + 1);
HXDLIN( 616)					int x19 = (_g68 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g70 = 0;
HXDLIN( 616)						int _g71 = 1;
HXDLIN( 616)						while((_g70 < _g71)){
HXLINE( 616)							_g70 = (_g70 + 1);
HXDLIN( 616)							int y18 = (_g70 - 1);
HXDLIN( 616)							{
HXLINE( 616)								int x20 = (x19 + 1);
HXDLIN( 616)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 616)								::Dynamic this146 = this123->image;
HXDLIN( 616)								int index24;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x19) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x19)) ));
            								}
HXDLIN( 616)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 616)								int color11;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color11 = c22;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c23 = color11;
HXDLIN( 616)									bool here37;
HXDLIN( 616)									if ((((c23 >> 24) & 255) < 254)) {
HXLINE( 616)										here37 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here37 = false;
            									}
HXDLIN( 616)									if (here37) {
HXLINE( 616)										int location10;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x20)) ));
            										}
HXDLIN( 616)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 616)										int this148;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this148 = this147;
            										}
HXDLIN( 616)										Float a112;
HXDLIN( 616)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 616)										if ((this149 == 0)) {
HXLINE( 616)											a112 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r110;
HXDLIN( 616)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 616)										if ((this150 == 0)) {
HXLINE( 616)											r110 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g110;
HXDLIN( 616)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 616)										if ((this151 == 0)) {
HXLINE( 616)											g110 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b113;
HXDLIN( 616)										int this152 = (this148 & 255);
HXDLIN( 616)										if ((this152 == 0)) {
HXLINE( 616)											b113 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a211;
HXDLIN( 616)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 616)										if ((this153 == 0)) {
HXLINE( 616)											a211 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r210;
HXDLIN( 616)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 616)										if ((this154 == 0)) {
HXLINE( 616)											r210 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g210;
HXDLIN( 616)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 616)										if ((this155 == 0)) {
HXLINE( 616)											g210 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b211;
HXDLIN( 616)										int this156 = (color11 & 255);
HXDLIN( 616)										if ((this156 == 0)) {
HXLINE( 616)											b211 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 616)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 616)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 616)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 616)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 616)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 616)										{
HXLINE( 616)											int here38;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here38 = blended10;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this157 = img1->image;
HXDLIN( 616)										int index25;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x20)) ));
            										}
HXDLIN( 616)										int here39;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here39 = c23;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x21 = (x19 + 1);
HXDLIN( 616)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 616)								int y21 = (1 - y18);
HXDLIN( 616)								::Dynamic this158 = this123->image;
HXDLIN( 616)								int index26;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x19) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x19)) ));
            								}
HXDLIN( 616)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 616)								int color12;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color12 = c24;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c25 = color12;
HXDLIN( 616)									bool here40;
HXDLIN( 616)									if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 616)										here40 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here40 = false;
            									}
HXDLIN( 616)									if (here40) {
HXLINE( 616)										int location11;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x21)) ));
            										}
HXDLIN( 616)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 616)										int this160;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this160 = this159;
            										}
HXDLIN( 616)										Float a113;
HXDLIN( 616)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 616)										if ((this161 == 0)) {
HXLINE( 616)											a113 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r111;
HXDLIN( 616)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 616)										if ((this162 == 0)) {
HXLINE( 616)											r111 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g111;
HXDLIN( 616)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 616)										if ((this163 == 0)) {
HXLINE( 616)											g111 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b114;
HXDLIN( 616)										int this164 = (this160 & 255);
HXDLIN( 616)										if ((this164 == 0)) {
HXLINE( 616)											b114 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a212;
HXDLIN( 616)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 616)										if ((this165 == 0)) {
HXLINE( 616)											a212 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r211;
HXDLIN( 616)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 616)										if ((this166 == 0)) {
HXLINE( 616)											r211 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g211;
HXDLIN( 616)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 616)										if ((this167 == 0)) {
HXLINE( 616)											g211 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b212;
HXDLIN( 616)										int this168 = (color12 & 255);
HXDLIN( 616)										if ((this168 == 0)) {
HXLINE( 616)											b212 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 616)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 616)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 616)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 616)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 616)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 616)										{
HXLINE( 616)											int here41;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here41 = blended11;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this169 = img1->image;
HXDLIN( 616)										int index27;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x21)) ));
            										}
HXDLIN( 616)										int here42;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here42 = c25;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g72 = 0;
HXDLIN( 616)				int _g73 = this123->height;
HXDLIN( 616)				while((_g72 < _g73)){
HXLINE( 616)					_g72 = (_g72 + 1);
HXDLIN( 616)					int y22 = (_g72 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g74 = 0;
HXDLIN( 616)						int _g75 = 1;
HXDLIN( 616)						while((_g74 < _g75)){
HXLINE( 616)							_g74 = (_g74 + 1);
HXDLIN( 616)							int x22 = (_g74 - 1);
HXDLIN( 616)							{
HXLINE( 616)								int y23 = (y22 + 1);
HXDLIN( 616)								int x23 = (((this123->width - 1) - 1) + x22);
HXDLIN( 616)								::Dynamic this170 = this123->image;
HXDLIN( 616)								int index28;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x23) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x23)) ));
            								}
HXDLIN( 616)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 616)								int color13;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color13 = c26;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c27 = color13;
HXDLIN( 616)									bool here43;
HXDLIN( 616)									if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 616)										here43 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here43 = false;
            									}
HXDLIN( 616)									if (here43) {
HXLINE( 616)										int location12;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x22) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x22)) ));
            										}
HXDLIN( 616)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 616)										int this172;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this172 = this171;
            										}
HXDLIN( 616)										Float a114;
HXDLIN( 616)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 616)										if ((this173 == 0)) {
HXLINE( 616)											a114 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r112;
HXDLIN( 616)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 616)										if ((this174 == 0)) {
HXLINE( 616)											r112 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g112;
HXDLIN( 616)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 616)										if ((this175 == 0)) {
HXLINE( 616)											g112 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b115;
HXDLIN( 616)										int this176 = (this172 & 255);
HXDLIN( 616)										if ((this176 == 0)) {
HXLINE( 616)											b115 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a213;
HXDLIN( 616)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 616)										if ((this177 == 0)) {
HXLINE( 616)											a213 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r212;
HXDLIN( 616)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 616)										if ((this178 == 0)) {
HXLINE( 616)											r212 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g212;
HXDLIN( 616)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 616)										if ((this179 == 0)) {
HXLINE( 616)											g212 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b213;
HXDLIN( 616)										int this180 = (color13 & 255);
HXDLIN( 616)										if ((this180 == 0)) {
HXLINE( 616)											b213 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 616)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 616)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 616)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 616)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 616)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 616)										{
HXLINE( 616)											int here44;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here44 = blended12;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this181 = img1->image;
HXDLIN( 616)										int index29;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x22) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x22)) ));
            										}
HXDLIN( 616)										int here45;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here45 = c27;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x24 = ((img1->width - x22) - 1);
HXDLIN( 616)								int y24 = (y22 + 1);
HXDLIN( 616)								int x25 = (1 - x22);
HXDLIN( 616)								::Dynamic this182 = this123->image;
HXDLIN( 616)								int index30;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x25)) ));
            								}
HXDLIN( 616)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 616)								int color14;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color14 = c28;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c29 = color14;
HXDLIN( 616)									bool here46;
HXDLIN( 616)									if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 616)										here46 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here46 = false;
            									}
HXDLIN( 616)									if (here46) {
HXLINE( 616)										int location13;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x24) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x24)) ));
            										}
HXDLIN( 616)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 616)										int this184;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this184 = this183;
            										}
HXDLIN( 616)										Float a115;
HXDLIN( 616)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 616)										if ((this185 == 0)) {
HXLINE( 616)											a115 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r113;
HXDLIN( 616)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 616)										if ((this186 == 0)) {
HXLINE( 616)											r113 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g113;
HXDLIN( 616)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 616)										if ((this187 == 0)) {
HXLINE( 616)											g113 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b116;
HXDLIN( 616)										int this188 = (this184 & 255);
HXDLIN( 616)										if ((this188 == 0)) {
HXLINE( 616)											b116 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a214;
HXDLIN( 616)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 616)										if ((this189 == 0)) {
HXLINE( 616)											a214 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r213;
HXDLIN( 616)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 616)										if ((this190 == 0)) {
HXLINE( 616)											r213 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g213;
HXDLIN( 616)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 616)										if ((this191 == 0)) {
HXLINE( 616)											g213 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b214;
HXDLIN( 616)										int this192 = (color14 & 255);
HXDLIN( 616)										if ((this192 == 0)) {
HXLINE( 616)											b214 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 616)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 616)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 616)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 616)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 616)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 616)										{
HXLINE( 616)											int here47;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here47 = blended13;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this193 = img1->image;
HXDLIN( 616)										int index31;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x24) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x24)) ));
            										}
HXDLIN( 616)										int here48;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here48 = c29;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				int _g76 = 0;
HXDLIN( 616)				int _g77 = 1;
HXDLIN( 616)				while((_g76 < _g77)){
HXLINE( 616)					_g76 = (_g76 + 1);
HXDLIN( 616)					int x26 = (_g76 - 1);
HXDLIN( 616)					{
HXLINE( 616)						int _g78 = 0;
HXDLIN( 616)						int _g79 = 1;
HXDLIN( 616)						while((_g78 < _g79)){
HXLINE( 616)							_g78 = (_g78 + 1);
HXDLIN( 616)							int y25 = (_g78 - 1);
HXDLIN( 616)							{
HXLINE( 616)								int x27 = (((this123->width - 1) - 1) + x26);
HXDLIN( 616)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 616)								::Dynamic this194 = this123->image;
HXDLIN( 616)								int index32;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x27) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x27)) ));
            								}
HXDLIN( 616)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 616)								int color15;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color15 = c30;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c31 = color15;
HXDLIN( 616)									bool here49;
HXDLIN( 616)									if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 616)										here49 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here49 = false;
            									}
HXDLIN( 616)									if (here49) {
HXLINE( 616)										int location14;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x26)) ));
            										}
HXDLIN( 616)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 616)										int this196;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this196 = this195;
            										}
HXDLIN( 616)										Float a116;
HXDLIN( 616)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 616)										if ((this197 == 0)) {
HXLINE( 616)											a116 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r114;
HXDLIN( 616)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 616)										if ((this198 == 0)) {
HXLINE( 616)											r114 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g114;
HXDLIN( 616)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 616)										if ((this199 == 0)) {
HXLINE( 616)											g114 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b117;
HXDLIN( 616)										int this200 = (this196 & 255);
HXDLIN( 616)										if ((this200 == 0)) {
HXLINE( 616)											b117 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a215;
HXDLIN( 616)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 616)										if ((this201 == 0)) {
HXLINE( 616)											a215 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r214;
HXDLIN( 616)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 616)										if ((this202 == 0)) {
HXLINE( 616)											r214 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g214;
HXDLIN( 616)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 616)										if ((this203 == 0)) {
HXLINE( 616)											g214 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b215;
HXDLIN( 616)										int this204 = (color15 & 255);
HXDLIN( 616)										if ((this204 == 0)) {
HXLINE( 616)											b215 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 616)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 616)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 616)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 616)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 616)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 616)										{
HXLINE( 616)											int here50;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here50 = blended14;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this205 = img1->image;
HXDLIN( 616)										int index33;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x26)) ));
            										}
HXDLIN( 616)										int here51;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here51 = c31;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x28 = ((x26 + 1) + this123->width);
HXDLIN( 616)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 616)								::Dynamic this206 = this123->image;
HXDLIN( 616)								int index34;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x26)) ));
            								}
HXDLIN( 616)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 616)								int color16;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color16 = c32;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c33 = color16;
HXDLIN( 616)									bool here52;
HXDLIN( 616)									if ((((c33 >> 24) & 255) < 254)) {
HXLINE( 616)										here52 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here52 = false;
            									}
HXDLIN( 616)									if (here52) {
HXLINE( 616)										int location15;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x28)) ));
            										}
HXDLIN( 616)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 616)										int this208;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this208 = this207;
            										}
HXDLIN( 616)										Float a117;
HXDLIN( 616)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 616)										if ((this209 == 0)) {
HXLINE( 616)											a117 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r115;
HXDLIN( 616)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 616)										if ((this210 == 0)) {
HXLINE( 616)											r115 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g115;
HXDLIN( 616)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 616)										if ((this211 == 0)) {
HXLINE( 616)											g115 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b118;
HXDLIN( 616)										int this212 = (this208 & 255);
HXDLIN( 616)										if ((this212 == 0)) {
HXLINE( 616)											b118 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a216;
HXDLIN( 616)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 616)										if ((this213 == 0)) {
HXLINE( 616)											a216 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r215;
HXDLIN( 616)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 616)										if ((this214 == 0)) {
HXLINE( 616)											r215 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g215;
HXDLIN( 616)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 616)										if ((this215 == 0)) {
HXLINE( 616)											g215 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b216;
HXDLIN( 616)										int this216 = (color16 & 255);
HXDLIN( 616)										if ((this216 == 0)) {
HXLINE( 616)											b216 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 616)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 616)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 616)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 616)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 616)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 616)										{
HXLINE( 616)											int here53;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here53 = blended15;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this217 = img1->image;
HXDLIN( 616)										int index35;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x28)) ));
            										}
HXDLIN( 616)										int here54;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here54 = c33;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int x29 = ((x26 + 1) + this123->width);
HXDLIN( 616)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 616)								::Dynamic this218 = this123->image;
HXDLIN( 616)								int index36;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x26)) ));
            								}
HXDLIN( 616)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 616)								int color17;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color17 = c34;
            								}
HXDLIN( 616)								int color18 = color17;
HXDLIN( 616)								{
HXLINE( 616)									int c35 = color18;
HXDLIN( 616)									bool here55;
HXDLIN( 616)									if ((((c35 >> 24) & 255) < 254)) {
HXLINE( 616)										here55 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here55 = false;
            									}
HXDLIN( 616)									if (here55) {
HXLINE( 616)										int location16;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x29) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x29)) ));
            										}
HXDLIN( 616)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 616)										int this220;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this220 = this219;
            										}
HXDLIN( 616)										Float a118;
HXDLIN( 616)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 616)										if ((this221 == 0)) {
HXLINE( 616)											a118 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r116;
HXDLIN( 616)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 616)										if ((this222 == 0)) {
HXLINE( 616)											r116 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g116;
HXDLIN( 616)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 616)										if ((this223 == 0)) {
HXLINE( 616)											g116 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b119;
HXDLIN( 616)										int this224 = (this220 & 255);
HXDLIN( 616)										if ((this224 == 0)) {
HXLINE( 616)											b119 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a217;
HXDLIN( 616)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 616)										if ((this225 == 0)) {
HXLINE( 616)											a217 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r216;
HXDLIN( 616)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 616)										if ((this226 == 0)) {
HXLINE( 616)											r216 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g216;
HXDLIN( 616)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 616)										if ((this227 == 0)) {
HXLINE( 616)											g216 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b217;
HXDLIN( 616)										int this228 = (color18 & 255);
HXDLIN( 616)										if ((this228 == 0)) {
HXLINE( 616)											b217 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 616)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 616)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 616)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 616)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 616)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 616)										{
HXLINE( 616)											int here56;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here56 = blended16;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this229 = img1->image;
HXDLIN( 616)										int index37;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x29) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x29)) ));
            										}
HXDLIN( 616)										int here57;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here57 = c35;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 616)							{
HXLINE( 616)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 616)								int x30 = (((this123->width - 1) - 1) + x26);
HXDLIN( 616)								::Dynamic this230 = this123->image;
HXDLIN( 616)								int index38;
HXDLIN( 616)								if (this123->useVirtualPos) {
HXLINE( 616)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x30) - this123->virtualX));
            								}
            								else {
HXLINE( 616)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x30)) ));
            								}
HXDLIN( 616)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 616)								int color19;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									color19 = c36;
            								}
HXDLIN( 616)								{
HXLINE( 616)									int c37 = color19;
HXDLIN( 616)									bool here58;
HXDLIN( 616)									if ((((c37 >> 24) & 255) < 254)) {
HXLINE( 616)										here58 = img1->transparent;
            									}
            									else {
HXLINE( 616)										here58 = false;
            									}
HXDLIN( 616)									if (here58) {
HXLINE( 616)										int location17;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x26)) ));
            										}
HXDLIN( 616)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 616)										int this232;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											this232 = this231;
            										}
HXDLIN( 616)										Float a119;
HXDLIN( 616)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 616)										if ((this233 == 0)) {
HXLINE( 616)											a119 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r117;
HXDLIN( 616)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 616)										if ((this234 == 0)) {
HXLINE( 616)											r117 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g117;
HXDLIN( 616)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 616)										if ((this235 == 0)) {
HXLINE( 616)											g117 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b120;
HXDLIN( 616)										int this236 = (this232 & 255);
HXDLIN( 616)										if ((this236 == 0)) {
HXLINE( 616)											b120 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a218;
HXDLIN( 616)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 616)										if ((this237 == 0)) {
HXLINE( 616)											a218 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float r217;
HXDLIN( 616)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 616)										if ((this238 == 0)) {
HXLINE( 616)											r217 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float g217;
HXDLIN( 616)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 616)										if ((this239 == 0)) {
HXLINE( 616)											g217 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float b218;
HXDLIN( 616)										int this240 = (color19 & 255);
HXDLIN( 616)										if ((this240 == 0)) {
HXLINE( 616)											b218 = ((Float)0.);
            										}
            										else {
HXLINE( 616)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 616)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 616)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 616)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 616)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 616)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 616)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 616)										{
HXLINE( 616)											int here59;
HXDLIN( 616)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXLINE( 616)												here59 = blended17;
            											}
HXDLIN( 616)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXLINE( 616)										::Dynamic this241 = img1->image;
HXDLIN( 616)										int index39;
HXDLIN( 616)										if (img1->useVirtualPos) {
HXLINE( 616)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x26) - img1->virtualX));
            										}
            										else {
HXLINE( 616)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x26)) ));
            										}
HXDLIN( 616)										int here60;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											here60 = c37;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 616)				here = img1;
            			}
            			break;
            		}
HXDLIN( 616)		{
HXLINE( 616)			int _g80 = 1;
HXDLIN( 616)			int _g81 = (this1->height - 2);
HXDLIN( 616)			while((_g80 < _g81)){
HXLINE( 616)				_g80 = (_g80 + 1);
HXDLIN( 616)				int y30 = (_g80 - 1);
HXDLIN( 616)				{
HXLINE( 616)					int _g82 = 1;
HXDLIN( 616)					int _g83 = (this1->width - 2);
HXDLIN( 616)					while((_g82 < _g83)){
HXLINE( 616)						_g82 = (_g82 + 1);
HXDLIN( 616)						int x31 = (_g82 - 1);
HXDLIN( 616)						if ((x31 == 1)) {
HXLINE( 616)							int x32 = (x31 - 1);
HXDLIN( 616)							int y31 = (y30 - 1);
HXDLIN( 616)							::Dynamic this242 = here->image;
HXDLIN( 616)							int index40;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x32)) ));
            							}
HXDLIN( 616)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								a0 = c38;
            							}
HXDLIN( 616)							int y32 = (y30 - 1);
HXDLIN( 616)							::Dynamic this243 = here->image;
HXDLIN( 616)							int index41;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x31)) ));
            							}
HXDLIN( 616)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								b0 = c39;
            							}
HXDLIN( 616)							int x33 = (x31 + 1);
HXDLIN( 616)							int y33 = (y30 - 1);
HXDLIN( 616)							::Dynamic this244 = here->image;
HXDLIN( 616)							int index42;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x33)) ));
            							}
HXDLIN( 616)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								c0 = c40;
            							}
HXDLIN( 616)							int x34 = (x31 - 1);
HXDLIN( 616)							::Dynamic this245 = here->image;
HXDLIN( 616)							int index43;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 616)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								d0 = c41;
            							}
HXDLIN( 616)							::Dynamic this246 = here->image;
HXDLIN( 616)							int index44;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x31)) ));
            							}
HXDLIN( 616)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 616)							int e01;
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 616)							int x35 = (x31 + 1);
HXDLIN( 616)							::Dynamic this247 = here->image;
HXDLIN( 616)							int index45;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x35)) ));
            							}
HXDLIN( 616)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								f0 = c43;
            							}
HXDLIN( 616)							int x36 = (x31 - 1);
HXDLIN( 616)							int y34 = (y30 + 1);
HXDLIN( 616)							::Dynamic this248 = here->image;
HXDLIN( 616)							int index46;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x36)) ));
            							}
HXDLIN( 616)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								g0 = c44;
            							}
HXDLIN( 616)							int y35 = (y30 + 1);
HXDLIN( 616)							::Dynamic this249 = here->image;
HXDLIN( 616)							int index47;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x31)) ));
            							}
HXDLIN( 616)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								h0 = c45;
            							}
HXDLIN( 616)							int x37 = (x31 + 1);
HXDLIN( 616)							int y36 = (y30 + 1);
HXDLIN( 616)							::Dynamic this250 = here->image;
HXDLIN( 616)							int index48;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x37)) ));
            							}
HXDLIN( 616)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 616)							int x38 = (x31 + 1);
HXDLIN( 616)							int y37 = (y30 - 1);
HXDLIN( 616)							::Dynamic this251 = here->image;
HXDLIN( 616)							int index49;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x38)) ));
            							}
HXDLIN( 616)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 616)							int x39 = (x31 + 1);
HXDLIN( 616)							::Dynamic this252 = here->image;
HXDLIN( 616)							int index50;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x39)) ));
            							}
HXDLIN( 616)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 616)							int x40 = (x31 + 1);
HXDLIN( 616)							int y38 = (y30 + 1);
HXDLIN( 616)							::Dynamic this253 = here->image;
HXDLIN( 616)							int index51;
HXDLIN( 616)							if (here->useVirtualPos) {
HXLINE( 616)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x40) - here->virtualX));
            							}
            							else {
HXLINE( 616)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x40)) ));
            							}
HXDLIN( 616)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 616)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXLINE( 616)								i0 = c49;
            							}
            						}
HXDLIN( 616)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 616)							bool _hx_tmp2;
HXDLIN( 616)							if ((m33_a != ((Float)0.))) {
HXLINE( 616)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp2 = false;
            							}
HXDLIN( 616)							if (_hx_tmp2) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 616)							bool _hx_tmp3;
HXDLIN( 616)							if ((m33_b != ((Float)0.))) {
HXLINE( 616)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp3 = false;
            							}
HXDLIN( 616)							if (_hx_tmp3) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 616)							bool _hx_tmp4;
HXDLIN( 616)							if ((m33_c != ((Float)0.))) {
HXLINE( 616)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp4 = false;
            							}
HXDLIN( 616)							if (_hx_tmp4) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 616)							bool _hx_tmp5;
HXDLIN( 616)							if ((m33_d != ((Float)0.))) {
HXLINE( 616)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp5 = false;
            							}
HXDLIN( 616)							if (_hx_tmp5) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 616)							bool _hx_tmp6;
HXDLIN( 616)							if ((m33_e != ((Float)0.))) {
HXLINE( 616)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp6 = false;
            							}
HXDLIN( 616)							if (_hx_tmp6) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 616)							bool _hx_tmp7;
HXDLIN( 616)							if ((m33_f != ((Float)0.))) {
HXLINE( 616)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp7 = false;
            							}
HXDLIN( 616)							if (_hx_tmp7) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 616)							bool _hx_tmp8;
HXDLIN( 616)							if ((m33_g != ((Float)0.))) {
HXLINE( 616)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp8 = false;
            							}
HXDLIN( 616)							if (_hx_tmp8) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 616)							bool _hx_tmp9;
HXDLIN( 616)							if ((m33_h != ((Float)0.))) {
HXLINE( 616)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp9 = false;
            							}
HXDLIN( 616)							if (_hx_tmp9) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 616)							bool _hx_tmp10;
HXDLIN( 616)							if ((m33_i != ((Float)0.))) {
HXLINE( 616)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp10 = false;
            							}
HXDLIN( 616)							if (_hx_tmp10) {
HXLINE( 616)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 616)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 616)							bool _hx_tmp11;
HXDLIN( 616)							if ((m33_a != ((Float)0.))) {
HXLINE( 616)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp11 = false;
            							}
HXDLIN( 616)							if (_hx_tmp11) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 616)							bool _hx_tmp12;
HXDLIN( 616)							if ((m33_b != ((Float)0.))) {
HXLINE( 616)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp12 = false;
            							}
HXDLIN( 616)							if (_hx_tmp12) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 616)							bool _hx_tmp13;
HXDLIN( 616)							if ((m33_c != ((Float)0.))) {
HXLINE( 616)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp13 = false;
            							}
HXDLIN( 616)							if (_hx_tmp13) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 616)							bool _hx_tmp14;
HXDLIN( 616)							if ((m33_d != ((Float)0.))) {
HXLINE( 616)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp14 = false;
            							}
HXDLIN( 616)							if (_hx_tmp14) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 616)							bool _hx_tmp15;
HXDLIN( 616)							if ((m33_e != ((Float)0.))) {
HXLINE( 616)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp15 = false;
            							}
HXDLIN( 616)							if (_hx_tmp15) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 616)							bool _hx_tmp16;
HXDLIN( 616)							if ((m33_f != ((Float)0.))) {
HXLINE( 616)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp16 = false;
            							}
HXDLIN( 616)							if (_hx_tmp16) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 616)							bool _hx_tmp17;
HXDLIN( 616)							if ((m33_g != ((Float)0.))) {
HXLINE( 616)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp17 = false;
            							}
HXDLIN( 616)							if (_hx_tmp17) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 616)							bool _hx_tmp18;
HXDLIN( 616)							if ((m33_h != ((Float)0.))) {
HXLINE( 616)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp18 = false;
            							}
HXDLIN( 616)							if (_hx_tmp18) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 616)							bool _hx_tmp19;
HXDLIN( 616)							if ((m33_i != ((Float)0.))) {
HXLINE( 616)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp19 = false;
            							}
HXDLIN( 616)							if (_hx_tmp19) {
HXLINE( 616)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 616)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 616)							bool _hx_tmp20;
HXDLIN( 616)							if ((m33_a != ((Float)0.))) {
HXLINE( 616)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp20 = false;
            							}
HXDLIN( 616)							if (_hx_tmp20) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 616)							bool _hx_tmp21;
HXDLIN( 616)							if ((m33_b != ((Float)0.))) {
HXLINE( 616)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp21 = false;
            							}
HXDLIN( 616)							if (_hx_tmp21) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 616)							bool _hx_tmp22;
HXDLIN( 616)							if ((m33_c != ((Float)0.))) {
HXLINE( 616)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp22 = false;
            							}
HXDLIN( 616)							if (_hx_tmp22) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 616)							bool _hx_tmp23;
HXDLIN( 616)							if ((m33_d != ((Float)0.))) {
HXLINE( 616)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp23 = false;
            							}
HXDLIN( 616)							if (_hx_tmp23) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 616)							bool _hx_tmp24;
HXDLIN( 616)							if ((m33_e != ((Float)0.))) {
HXLINE( 616)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp24 = false;
            							}
HXDLIN( 616)							if (_hx_tmp24) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 616)							bool _hx_tmp25;
HXDLIN( 616)							if ((m33_f != ((Float)0.))) {
HXLINE( 616)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp25 = false;
            							}
HXDLIN( 616)							if (_hx_tmp25) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 616)							bool _hx_tmp26;
HXDLIN( 616)							if ((m33_g != ((Float)0.))) {
HXLINE( 616)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp26 = false;
            							}
HXDLIN( 616)							if (_hx_tmp26) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 616)							bool _hx_tmp27;
HXDLIN( 616)							if ((m33_h != ((Float)0.))) {
HXLINE( 616)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp27 = false;
            							}
HXDLIN( 616)							if (_hx_tmp27) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 616)							bool _hx_tmp28;
HXDLIN( 616)							if ((m33_i != ((Float)0.))) {
HXLINE( 616)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp28 = false;
            							}
HXDLIN( 616)							if (_hx_tmp28) {
HXLINE( 616)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 616)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 616)							bool _hx_tmp29;
HXDLIN( 616)							if ((m33_a != ((Float)0.))) {
HXLINE( 616)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp29 = false;
            							}
HXDLIN( 616)							if (_hx_tmp29) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 616)							bool _hx_tmp30;
HXDLIN( 616)							if ((m33_b != ((Float)0.))) {
HXLINE( 616)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp30 = false;
            							}
HXDLIN( 616)							if (_hx_tmp30) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 616)							bool _hx_tmp31;
HXDLIN( 616)							if ((m33_c != ((Float)0.))) {
HXLINE( 616)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp31 = false;
            							}
HXDLIN( 616)							if (_hx_tmp31) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 616)							bool _hx_tmp32;
HXDLIN( 616)							if ((m33_d != ((Float)0.))) {
HXLINE( 616)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp32 = false;
            							}
HXDLIN( 616)							if (_hx_tmp32) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 616)							bool _hx_tmp33;
HXDLIN( 616)							if ((m33_e != ((Float)0.))) {
HXLINE( 616)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp33 = false;
            							}
HXDLIN( 616)							if (_hx_tmp33) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 616)							bool _hx_tmp34;
HXDLIN( 616)							if ((m33_f != ((Float)0.))) {
HXLINE( 616)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp34 = false;
            							}
HXDLIN( 616)							if (_hx_tmp34) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 616)							bool _hx_tmp35;
HXDLIN( 616)							if ((m33_g != ((Float)0.))) {
HXLINE( 616)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp35 = false;
            							}
HXDLIN( 616)							if (_hx_tmp35) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 616)							bool _hx_tmp36;
HXDLIN( 616)							if ((m33_h != ((Float)0.))) {
HXLINE( 616)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp36 = false;
            							}
HXDLIN( 616)							if (_hx_tmp36) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 616)							bool _hx_tmp37;
HXDLIN( 616)							if ((m33_i != ((Float)0.))) {
HXLINE( 616)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXLINE( 616)								_hx_tmp37 = false;
            							}
HXDLIN( 616)							if (_hx_tmp37) {
HXLINE( 616)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 616)						bool _hx_tmp38;
HXDLIN( 616)						if ((borderMode != 0)) {
HXLINE( 616)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXLINE( 616)							_hx_tmp38 = true;
            						}
HXDLIN( 616)						if (_hx_tmp38) {
HXLINE( 616)							int x41 = (x31 - 1);
HXDLIN( 616)							int y39 = (y30 - 1);
HXDLIN( 616)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 616)							{
HXLINE( 616)								int c50 = color20;
HXDLIN( 616)								bool _hx_tmp39;
HXDLIN( 616)								if ((((c50 >> 24) & 255) < 254)) {
HXLINE( 616)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXLINE( 616)									_hx_tmp39 = false;
            								}
HXDLIN( 616)								if (_hx_tmp39) {
HXLINE( 616)									int location18;
HXDLIN( 616)									if (out->useVirtualPos) {
HXLINE( 616)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            									}
            									else {
HXLINE( 616)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x41)) ));
            									}
HXDLIN( 616)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 616)									int this255;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										this255 = this254;
            									}
HXDLIN( 616)									Float a120;
HXDLIN( 616)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 616)									if ((this256 == 0)) {
HXLINE( 616)										a120 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r118;
HXDLIN( 616)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 616)									if ((this257 == 0)) {
HXLINE( 616)										r118 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g118;
HXDLIN( 616)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 616)									if ((this258 == 0)) {
HXLINE( 616)										g118 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b121;
HXDLIN( 616)									int this259 = (this255 & 255);
HXDLIN( 616)									if ((this259 == 0)) {
HXLINE( 616)										b121 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a219;
HXDLIN( 616)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 616)									if ((this260 == 0)) {
HXLINE( 616)										a219 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r218;
HXDLIN( 616)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 616)									if ((this261 == 0)) {
HXLINE( 616)										r218 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g218;
HXDLIN( 616)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 616)									if ((this262 == 0)) {
HXLINE( 616)										g218 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b219;
HXDLIN( 616)									int this263 = (color20 & 255);
HXDLIN( 616)									if ((this263 == 0)) {
HXLINE( 616)										b219 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 616)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 616)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 616)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 616)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 616)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 616)									{
HXLINE( 616)										int _hx_tmp40;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											_hx_tmp40 = blended18;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXLINE( 616)									::Dynamic this264 = out->image;
HXDLIN( 616)									int index52;
HXDLIN( 616)									if (out->useVirtualPos) {
HXLINE( 616)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            									}
            									else {
HXLINE( 616)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x41)) ));
            									}
HXDLIN( 616)									int _hx_tmp41;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp41 = c50;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXLINE( 616)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 616)							{
HXLINE( 616)								int c51 = color21;
HXDLIN( 616)								bool _hx_tmp42;
HXDLIN( 616)								if ((((c51 >> 24) & 255) < 254)) {
HXLINE( 616)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXLINE( 616)									_hx_tmp42 = false;
            								}
HXDLIN( 616)								if (_hx_tmp42) {
HXLINE( 616)									int location19;
HXDLIN( 616)									if (out->useVirtualPos) {
HXLINE( 616)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x31) - out->virtualX));
            									}
            									else {
HXLINE( 616)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x31)) ));
            									}
HXDLIN( 616)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 616)									int this266;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										this266 = this265;
            									}
HXDLIN( 616)									Float a121;
HXDLIN( 616)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 616)									if ((this267 == 0)) {
HXLINE( 616)										a121 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r119;
HXDLIN( 616)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 616)									if ((this268 == 0)) {
HXLINE( 616)										r119 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g119;
HXDLIN( 616)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 616)									if ((this269 == 0)) {
HXLINE( 616)										g119 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b122;
HXDLIN( 616)									int this270 = (this266 & 255);
HXDLIN( 616)									if ((this270 == 0)) {
HXLINE( 616)										b122 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a220;
HXDLIN( 616)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 616)									if ((this271 == 0)) {
HXLINE( 616)										a220 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float r219;
HXDLIN( 616)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 616)									if ((this272 == 0)) {
HXLINE( 616)										r219 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float g219;
HXDLIN( 616)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 616)									if ((this273 == 0)) {
HXLINE( 616)										g219 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float b220;
HXDLIN( 616)									int this274 = (color21 & 255);
HXDLIN( 616)									if ((this274 == 0)) {
HXLINE( 616)										b220 = ((Float)0.);
            									}
            									else {
HXLINE( 616)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 616)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 616)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 616)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 616)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 616)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 616)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 616)									{
HXLINE( 616)										int _hx_tmp43;
HXDLIN( 616)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXLINE( 616)											_hx_tmp43 = blended19;
            										}
HXDLIN( 616)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXLINE( 616)									::Dynamic this275 = out->image;
HXDLIN( 616)									int index53;
HXDLIN( 616)									if (out->useVirtualPos) {
HXLINE( 616)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x31) - out->virtualX));
            									}
            									else {
HXLINE( 616)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x31)) ));
            									}
HXDLIN( 616)									int _hx_tmp44;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp44 = c51;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 616)		if ((borderMode == 1)) {
HXLINE( 616)			{
HXLINE( 616)				int _g84 = 0;
HXDLIN( 616)				int _g85 = (this1->width - 1);
HXDLIN( 616)				while((_g84 < _g85)){
HXLINE( 616)					_g84 = (_g84 + 1);
HXDLIN( 616)					int x42 = (_g84 - 1);
HXDLIN( 616)					{
HXLINE( 616)						::Dynamic this276 = here->image;
HXDLIN( 616)						int index54;
HXDLIN( 616)						if (here->useVirtualPos) {
HXLINE( 616)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            						}
            						else {
HXLINE( 616)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x42)) ));
            						}
HXDLIN( 616)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 616)						int color22;
HXDLIN( 616)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXLINE( 616)							color22 = c52;
            						}
HXDLIN( 616)						int color23 = color22;
HXDLIN( 616)						{
HXLINE( 616)							int c53 = color23;
HXDLIN( 616)							bool _hx_tmp45;
HXDLIN( 616)							if ((((c53 >> 24) & 255) < 254)) {
HXLINE( 616)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXLINE( 616)								_hx_tmp45 = false;
            							}
HXDLIN( 616)							if (_hx_tmp45) {
HXLINE( 616)								int location20;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 616)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x42)) ));
            								}
HXDLIN( 616)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 616)								int this278;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									this278 = this277;
            								}
HXDLIN( 616)								Float a122;
HXDLIN( 616)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 616)								if ((this279 == 0)) {
HXLINE( 616)									a122 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r120;
HXDLIN( 616)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 616)								if ((this280 == 0)) {
HXLINE( 616)									r120 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g120;
HXDLIN( 616)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 616)								if ((this281 == 0)) {
HXLINE( 616)									g120 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b123;
HXDLIN( 616)								int this282 = (this278 & 255);
HXDLIN( 616)								if ((this282 == 0)) {
HXLINE( 616)									b123 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a221;
HXDLIN( 616)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 616)								if ((this283 == 0)) {
HXLINE( 616)									a221 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r220;
HXDLIN( 616)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 616)								if ((this284 == 0)) {
HXLINE( 616)									r220 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g220;
HXDLIN( 616)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 616)								if ((this285 == 0)) {
HXLINE( 616)									g220 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b221;
HXDLIN( 616)								int this286 = (color23 & 255);
HXDLIN( 616)								if ((this286 == 0)) {
HXLINE( 616)									b221 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 616)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 616)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 616)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 616)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 616)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 616)								{
HXLINE( 616)									int _hx_tmp46;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp46 = blended20;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXLINE( 616)								::Dynamic this287 = out->image;
HXDLIN( 616)								int index55;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 616)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x42)) ));
            								}
HXDLIN( 616)								int _hx_tmp47;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									_hx_tmp47 = c53;
            								}
HXDLIN( 616)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 616)					{
HXLINE( 616)						int y40 = (this1->height - 1);
HXDLIN( 616)						int y41 = (this1->height - 1);
HXDLIN( 616)						::Dynamic this288 = here->image;
HXDLIN( 616)						int index56;
HXDLIN( 616)						if (here->useVirtualPos) {
HXLINE( 616)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x42) - here->virtualX));
            						}
            						else {
HXLINE( 616)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x42)) ));
            						}
HXDLIN( 616)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 616)						int color24;
HXDLIN( 616)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXLINE( 616)							color24 = c54;
            						}
HXDLIN( 616)						{
HXLINE( 616)							int c55 = color24;
HXDLIN( 616)							bool _hx_tmp48;
HXDLIN( 616)							if ((((c55 >> 24) & 255) < 254)) {
HXLINE( 616)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXLINE( 616)								_hx_tmp48 = false;
            							}
HXDLIN( 616)							if (_hx_tmp48) {
HXLINE( 616)								int location21;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 616)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x42)) ));
            								}
HXDLIN( 616)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 616)								int this290;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									this290 = this289;
            								}
HXDLIN( 616)								Float a123;
HXDLIN( 616)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 616)								if ((this291 == 0)) {
HXLINE( 616)									a123 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r121;
HXDLIN( 616)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 616)								if ((this292 == 0)) {
HXLINE( 616)									r121 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g121;
HXDLIN( 616)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 616)								if ((this293 == 0)) {
HXLINE( 616)									g121 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b124;
HXDLIN( 616)								int this294 = (this290 & 255);
HXDLIN( 616)								if ((this294 == 0)) {
HXLINE( 616)									b124 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a222;
HXDLIN( 616)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 616)								if ((this295 == 0)) {
HXLINE( 616)									a222 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r221;
HXDLIN( 616)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 616)								if ((this296 == 0)) {
HXLINE( 616)									r221 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g221;
HXDLIN( 616)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 616)								if ((this297 == 0)) {
HXLINE( 616)									g221 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b222;
HXDLIN( 616)								int this298 = (color24 & 255);
HXDLIN( 616)								if ((this298 == 0)) {
HXLINE( 616)									b222 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 616)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 616)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 616)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 616)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 616)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 616)								{
HXLINE( 616)									int _hx_tmp49;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp49 = blended21;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXLINE( 616)								::Dynamic this299 = out->image;
HXDLIN( 616)								int index57;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXLINE( 616)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x42)) ));
            								}
HXDLIN( 616)								int _hx_tmp50;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									_hx_tmp50 = c55;
            								}
HXDLIN( 616)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 616)			{
HXLINE( 616)				int _g86 = 1;
HXDLIN( 616)				int _g87 = (this1->height - 2);
HXDLIN( 616)				while((_g86 < _g87)){
HXLINE( 616)					_g86 = (_g86 + 1);
HXDLIN( 616)					int y42 = (_g86 - 1);
HXDLIN( 616)					{
HXLINE( 616)						::Dynamic this300 = here->image;
HXDLIN( 616)						int index58;
HXDLIN( 616)						if (here->useVirtualPos) {
HXLINE( 616)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXLINE( 616)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 616)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 616)						int color25;
HXDLIN( 616)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXLINE( 616)							color25 = c56;
            						}
HXDLIN( 616)						int color26 = color25;
HXDLIN( 616)						{
HXLINE( 616)							int c57 = color26;
HXDLIN( 616)							bool _hx_tmp51;
HXDLIN( 616)							if ((((c57 >> 24) & 255) < 254)) {
HXLINE( 616)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXLINE( 616)								_hx_tmp51 = false;
            							}
HXDLIN( 616)							if (_hx_tmp51) {
HXLINE( 616)								int location22;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 616)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 616)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 616)								int this302;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									this302 = this301;
            								}
HXDLIN( 616)								Float a124;
HXDLIN( 616)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 616)								if ((this303 == 0)) {
HXLINE( 616)									a124 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r122;
HXDLIN( 616)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 616)								if ((this304 == 0)) {
HXLINE( 616)									r122 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g122;
HXDLIN( 616)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 616)								if ((this305 == 0)) {
HXLINE( 616)									g122 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b125;
HXDLIN( 616)								int this306 = (this302 & 255);
HXDLIN( 616)								if ((this306 == 0)) {
HXLINE( 616)									b125 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a223;
HXDLIN( 616)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 616)								if ((this307 == 0)) {
HXLINE( 616)									a223 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r222;
HXDLIN( 616)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 616)								if ((this308 == 0)) {
HXLINE( 616)									r222 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g222;
HXDLIN( 616)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 616)								if ((this309 == 0)) {
HXLINE( 616)									g222 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b223;
HXDLIN( 616)								int this310 = (color26 & 255);
HXDLIN( 616)								if ((this310 == 0)) {
HXLINE( 616)									b223 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 616)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 616)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 616)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 616)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 616)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 616)								{
HXLINE( 616)									int _hx_tmp52;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp52 = blended22;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXLINE( 616)								::Dynamic this311 = out->image;
HXDLIN( 616)								int index59;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXLINE( 616)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 616)								int _hx_tmp53;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									_hx_tmp53 = c57;
            								}
HXDLIN( 616)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 616)					{
HXLINE( 616)						int x43 = (this1->width - 1);
HXDLIN( 616)						int x44 = (this1->width - 1);
HXDLIN( 616)						::Dynamic this312 = here->image;
HXDLIN( 616)						int index60;
HXDLIN( 616)						if (here->useVirtualPos) {
HXLINE( 616)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x44) - here->virtualX));
            						}
            						else {
HXLINE( 616)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x44)) ));
            						}
HXDLIN( 616)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 616)						int color27;
HXDLIN( 616)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXLINE( 616)							color27 = c58;
            						}
HXDLIN( 616)						{
HXLINE( 616)							int c59 = color27;
HXDLIN( 616)							bool _hx_tmp54;
HXDLIN( 616)							if ((((c59 >> 24) & 255) < 254)) {
HXLINE( 616)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXLINE( 616)								_hx_tmp54 = false;
            							}
HXDLIN( 616)							if (_hx_tmp54) {
HXLINE( 616)								int location23;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x43) - out->virtualX));
            								}
            								else {
HXLINE( 616)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x43)) ));
            								}
HXDLIN( 616)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 616)								int this314;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									this314 = this313;
            								}
HXDLIN( 616)								Float a125;
HXDLIN( 616)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 616)								if ((this315 == 0)) {
HXLINE( 616)									a125 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r123;
HXDLIN( 616)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 616)								if ((this316 == 0)) {
HXLINE( 616)									r123 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g123;
HXDLIN( 616)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 616)								if ((this317 == 0)) {
HXLINE( 616)									g123 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b126;
HXDLIN( 616)								int this318 = (this314 & 255);
HXDLIN( 616)								if ((this318 == 0)) {
HXLINE( 616)									b126 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a224;
HXDLIN( 616)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 616)								if ((this319 == 0)) {
HXLINE( 616)									a224 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float r223;
HXDLIN( 616)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 616)								if ((this320 == 0)) {
HXLINE( 616)									r223 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float g223;
HXDLIN( 616)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 616)								if ((this321 == 0)) {
HXLINE( 616)									g223 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float b224;
HXDLIN( 616)								int this322 = (color27 & 255);
HXDLIN( 616)								if ((this322 == 0)) {
HXLINE( 616)									b224 = ((Float)0.);
            								}
            								else {
HXLINE( 616)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 616)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 616)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 616)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 616)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 616)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 616)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 616)								{
HXLINE( 616)									int _hx_tmp55;
HXDLIN( 616)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXLINE( 616)										_hx_tmp55 = blended23;
            									}
HXDLIN( 616)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXLINE( 616)								::Dynamic this323 = out->image;
HXDLIN( 616)								int index61;
HXDLIN( 616)								if (out->useVirtualPos) {
HXLINE( 616)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x43) - out->virtualX));
            								}
            								else {
HXLINE( 616)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x43)) ));
            								}
HXDLIN( 616)								int _hx_tmp56;
HXDLIN( 616)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 616)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXLINE( 616)									_hx_tmp56 = c59;
            								}
HXDLIN( 616)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 616)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Convolution_Impl__obj,edgeDetect0_3x3,return )

 ::pi_xy::ImageStruct Convolution_Impl__obj::emboss0_3x3( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_borderMode,::hx::Null< bool >  __o_adjustAlpha){
            		int borderMode = __o_borderMode.Default(0);
            		bool adjustAlpha = __o_adjustAlpha.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b1b62e405f06e9e2_623_emboss0_3x3)
HXDLIN( 623)		Float m33_a = ((Float)-0.66666666666666663);
HXDLIN( 623)		Float m33_b = ((Float)0.333333333333333315);
HXDLIN( 623)		Float m33_c = ((Float)0.);
HXDLIN( 623)		Float m33_d = ((Float)-0.333333333333333315);
HXDLIN( 623)		Float m33_e = ((Float)0.333333333333333315);
HXDLIN( 623)		Float m33_f = ((Float)0.333333333333333315);
HXDLIN( 623)		Float m33_g = ( (Float)(0) );
HXDLIN( 623)		Float m33_h = ((Float)0.333333333333333315);
HXDLIN( 623)		Float m33_i = ((Float)0.66666666666666663);
HXDLIN( 623)		bool adjustRed = true;
HXDLIN( 623)		bool adjustGreen = true;
HXDLIN( 623)		bool adjustBlue = true;
HXDLIN( 623)		int a0 = 0;
HXDLIN( 623)		int b0 = 0;
HXDLIN( 623)		int c0 = 0;
HXDLIN( 623)		int d0 = 0;
HXDLIN( 623)		int e0 = 0;
HXDLIN( 623)		int f0 = 0;
HXDLIN( 623)		int g0 = 0;
HXDLIN( 623)		int h0 = 0;
HXDLIN( 623)		int i0 = 0;
HXDLIN( 623)		Float r_ = ((Float)0.);
HXDLIN( 623)		Float g_ = ((Float)0.);
HXDLIN( 623)		Float b_ = ((Float)0.);
HXDLIN( 623)		Float a_ = ((Float)0.);
HXDLIN( 623)		int width = this1->width;
HXDLIN( 623)		int height = this1->height;
HXDLIN( 623)		 ::Dynamic imageType = null();
HXDLIN( 623)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 623)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 623)		::Dynamic _hx_tmp;
HXDLIN( 623)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 623)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 623)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 623)				{
HXDLIN( 623)					b->width = width;
HXDLIN( 623)					b->height = height;
HXDLIN( 623)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 623)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 623)					{
HXDLIN( 623)						int len = b->length;
HXDLIN( 623)						int w = 0;
HXDLIN( 623)						{
HXDLIN( 623)							int _g = 0;
HXDLIN( 623)							int _g1 = b->height;
HXDLIN( 623)							while((_g < _g1)){
HXDLIN( 623)								_g = (_g + 1);
HXDLIN( 623)								int y = (_g - 1);
HXDLIN( 623)								{
HXDLIN( 623)									int _g2 = 0;
HXDLIN( 623)									int _g3 = b->width;
HXDLIN( 623)									while((_g2 < _g3)){
HXDLIN( 623)										_g2 = (_g2 + 1);
HXDLIN( 623)										int x = (_g2 - 1);
HXDLIN( 623)										{
HXDLIN( 623)											w = (w + 1);
HXDLIN( 623)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 623)										{
HXDLIN( 623)											w = (w + 1);
HXDLIN( 623)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 623)										{
HXDLIN( 623)											w = (w + 1);
HXDLIN( 623)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 623)										{
HXDLIN( 623)											w = (w + 1);
HXDLIN( 623)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 623)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 623)				{
HXDLIN( 623)					a->width = width;
HXDLIN( 623)					a->height = height;
HXDLIN( 623)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 623)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 623)					{
HXDLIN( 623)						int _g4 = 0;
HXDLIN( 623)						int _g5 = a->length;
HXDLIN( 623)						while((_g4 < _g5)){
HXDLIN( 623)							_g4 = (_g4 + 1);
HXDLIN( 623)							int i = (_g4 - 1);
HXDLIN( 623)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 623)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 623)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 623)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 623)				{
HXDLIN( 623)					b1->width = width;
HXDLIN( 623)					b1->height = height;
HXDLIN( 623)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 623)					int size = (b1->length * 4);
HXDLIN( 623)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 623)					{
HXDLIN( 623)						int _g6 = 0;
HXDLIN( 623)						int _g7 = b1->length;
HXDLIN( 623)						while((_g6 < _g7)){
HXDLIN( 623)							_g6 = (_g6 + 1);
HXDLIN( 623)							int i1 = (_g6 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 623)								bool _hx_tmp1;
HXDLIN( 623)								if ((i1 >= 0)) {
HXDLIN( 623)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 623)									_hx_tmp1 = false;
            								}
HXDLIN( 623)								if (_hx_tmp1) {
HXDLIN( 623)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 623)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 623)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 623)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 623)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 623)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 623)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 623)				{
HXDLIN( 623)					v->width = width;
HXDLIN( 623)					v->height = height;
HXDLIN( 623)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 623)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 623)					{
HXDLIN( 623)						int _g8 = 0;
HXDLIN( 623)						int _g9 = v->length;
HXDLIN( 623)						while((_g8 < _g9)){
HXDLIN( 623)							_g8 = (_g8 + 1);
HXDLIN( 623)							int i2 = (_g8 - 1);
HXDLIN( 623)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 623)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 623)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 623)				{
HXDLIN( 623)					b2->width = width;
HXDLIN( 623)					b2->height = height;
HXDLIN( 623)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 623)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 623)					{
HXDLIN( 623)						int len1 = b2->length;
HXDLIN( 623)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 623)						if (::hx::IsNull( d->head )) {
HXDLIN( 623)							int _g10 = 0;
HXDLIN( 623)							int _g11 = len1;
HXDLIN( 623)							while((_g10 < _g11)){
HXDLIN( 623)								_g10 = (_g10 + 1);
HXDLIN( 623)								int i3 = (_g10 - 1);
HXDLIN( 623)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 623)							int _g12 = 0;
HXDLIN( 623)							int _g13 = len1;
HXDLIN( 623)							while((_g12 < _g13)){
HXDLIN( 623)								_g12 = (_g12 + 1);
HXDLIN( 623)								int i4 = (_g12 - 1);
HXDLIN( 623)								{
HXDLIN( 623)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 623)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 623)									{
HXDLIN( 623)										int _g14 = 0;
HXDLIN( 623)										int _g15 = i4;
HXDLIN( 623)										while((_g14 < _g15)){
HXDLIN( 623)											_g14 = (_g14 + 1);
HXDLIN( 623)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 623)									if (::hx::IsNull( prev )) {
HXDLIN( 623)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 623)										l = null();
            									}
            									else {
HXDLIN( 623)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 623)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 623)		this2->image = _hx_tmp;
HXDLIN( 623)		this2->width = width;
HXDLIN( 623)		this2->height = height;
HXDLIN( 623)		this2->imageType = ( (int)(imageType) );
HXDLIN( 623)		 ::pi_xy::ImageStruct out = this2;
HXDLIN( 623)		 ::pi_xy::ImageStruct here = this1;
HXDLIN( 623)		switch((int)(borderMode)){
            			case (int)0: {
HXDLIN( 623)				 ::pi_xy::ImageStruct this4 = this1;
HXDLIN( 623)				int width1 = (this4->width + 2);
HXDLIN( 623)				int height1 = (this4->height + 2);
HXDLIN( 623)				 ::Dynamic imageType1 = null();
HXDLIN( 623)				 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 623)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 623)				::Dynamic here1;
HXDLIN( 623)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 623)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 623)						{
HXDLIN( 623)							b3->width = width1;
HXDLIN( 623)							b3->height = height1;
HXDLIN( 623)							b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 623)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 623)							{
HXDLIN( 623)								int len2 = b3->length;
HXDLIN( 623)								int w1 = 0;
HXDLIN( 623)								{
HXDLIN( 623)									int _g16 = 0;
HXDLIN( 623)									int _g17 = b3->height;
HXDLIN( 623)									while((_g16 < _g17)){
HXDLIN( 623)										_g16 = (_g16 + 1);
HXDLIN( 623)										int y1 = (_g16 - 1);
HXDLIN( 623)										{
HXDLIN( 623)											int _g18 = 0;
HXDLIN( 623)											int _g19 = b3->width;
HXDLIN( 623)											while((_g18 < _g19)){
HXDLIN( 623)												_g18 = (_g18 + 1);
HXDLIN( 623)												int x1 = (_g18 - 1);
HXDLIN( 623)												{
HXDLIN( 623)													w1 = (w1 + 1);
HXDLIN( 623)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w1 = (w1 + 1);
HXDLIN( 623)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w1 = (w1 + 1);
HXDLIN( 623)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w1 = (w1 + 1);
HXDLIN( 623)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here1 = b3;
            					}
            					break;
            					case (int)1: {
HXDLIN( 623)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 623)						{
HXDLIN( 623)							a1->width = width1;
HXDLIN( 623)							a1->height = height1;
HXDLIN( 623)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 623)							a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 623)							{
HXDLIN( 623)								int _g20 = 0;
HXDLIN( 623)								int _g21 = a1->length;
HXDLIN( 623)								while((_g20 < _g21)){
HXDLIN( 623)									_g20 = (_g20 + 1);
HXDLIN( 623)									int i6 = (_g20 - 1);
HXDLIN( 623)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 623)						here1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 623)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 623)						{
HXDLIN( 623)							b4->width = width1;
HXDLIN( 623)							b4->height = height1;
HXDLIN( 623)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 623)							int size1 = (b4->length * 4);
HXDLIN( 623)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 623)							{
HXDLIN( 623)								int _g22 = 0;
HXDLIN( 623)								int _g23 = b4->length;
HXDLIN( 623)								while((_g22 < _g23)){
HXDLIN( 623)									_g22 = (_g22 + 1);
HXDLIN( 623)									int i7 = (_g22 - 1);
HXDLIN( 623)									{
HXDLIN( 623)										 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN( 623)										bool here2;
HXDLIN( 623)										if ((i7 >= 0)) {
HXDLIN( 623)											here2 = (i7 < (this6->byteLength >> 2));
            										}
            										else {
HXDLIN( 623)											here2 = false;
            										}
HXDLIN( 623)										if (here2) {
HXDLIN( 623)											 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN( 623)											int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN( 623)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 623)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 623)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 623)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here1 = b4;
            					}
            					break;
            					case (int)3: {
HXDLIN( 623)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 623)						{
HXDLIN( 623)							v1->width = width1;
HXDLIN( 623)							v1->height = height1;
HXDLIN( 623)							v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 623)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 623)							{
HXDLIN( 623)								int _g24 = 0;
HXDLIN( 623)								int _g25 = v1->length;
HXDLIN( 623)								while((_g24 < _g25)){
HXDLIN( 623)									_g24 = (_g24 + 1);
HXDLIN( 623)									int i8 = (_g24 - 1);
HXDLIN( 623)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 623)						here1 = v1;
            					}
            					break;
            					case (int)4: {
HXDLIN( 623)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 623)						{
HXDLIN( 623)							b5->width = width1;
HXDLIN( 623)							b5->height = height1;
HXDLIN( 623)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 623)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 623)							{
HXDLIN( 623)								int len3 = b5->length;
HXDLIN( 623)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 623)								if (::hx::IsNull( d1->head )) {
HXDLIN( 623)									int _g26 = 0;
HXDLIN( 623)									int _g27 = len3;
HXDLIN( 623)									while((_g26 < _g27)){
HXDLIN( 623)										_g26 = (_g26 + 1);
HXDLIN( 623)										int i9 = (_g26 - 1);
HXDLIN( 623)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 623)									int _g28 = 0;
HXDLIN( 623)									int _g29 = len3;
HXDLIN( 623)									while((_g28 < _g29)){
HXDLIN( 623)										_g28 = (_g28 + 1);
HXDLIN( 623)										int i10 = (_g28 - 1);
HXDLIN( 623)										{
HXDLIN( 623)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 623)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 623)											{
HXDLIN( 623)												int _g30 = 0;
HXDLIN( 623)												int _g31 = i10;
HXDLIN( 623)												while((_g30 < _g31)){
HXDLIN( 623)													_g30 = (_g30 + 1);
HXDLIN( 623)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 623)											if (::hx::IsNull( prev1 )) {
HXDLIN( 623)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 623)												l1 = null();
            											}
            											else {
HXDLIN( 623)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 623)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here1 = b5;
            					}
            					break;
            				}
HXDLIN( 623)				this5->image = here1;
HXDLIN( 623)				this5->width = width1;
HXDLIN( 623)				this5->height = height1;
HXDLIN( 623)				this5->imageType = ( (int)(imageType1) );
HXDLIN( 623)				 ::pi_xy::ImageStruct img = this5;
HXDLIN( 623)				bool forceClear = false;
HXDLIN( 623)				int _g32 = 0;
HXDLIN( 623)				int _g33 = this4->height;
HXDLIN( 623)				while((_g32 < _g33)){
HXDLIN( 623)					_g32 = (_g32 + 1);
HXDLIN( 623)					int dy = (_g32 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g34 = 0;
HXDLIN( 623)						int _g35 = this4->width;
HXDLIN( 623)						while((_g34 < _g35)){
HXDLIN( 623)							_g34 = (_g34 + 1);
HXDLIN( 623)							int dx = (_g34 - 1);
HXDLIN( 623)							::Dynamic this7 = this4->image;
HXDLIN( 623)							int index;
HXDLIN( 623)							if (this4->useVirtualPos) {
HXDLIN( 623)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            							}
            							else {
HXDLIN( 623)								index = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            							}
HXDLIN( 623)							int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN( 623)							int col;
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								col = c;
            							}
HXDLIN( 623)							bool here3;
HXDLIN( 623)							if (this4->useMask) {
HXDLIN( 623)								here3 = ::hx::IsNotNull( this4->mask );
            							}
            							else {
HXDLIN( 623)								here3 = false;
            							}
HXDLIN( 623)							if (here3) {
HXDLIN( 623)								 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN( 623)								::Dynamic this9 = this8->image;
HXDLIN( 623)								int index1;
HXDLIN( 623)								if (this8->useVirtualPos) {
HXDLIN( 623)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx) - this8->virtualX));
            								}
            								else {
HXDLIN( 623)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this8->width) + dx)) ));
            								}
HXDLIN( 623)								int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN( 623)								int v2;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									v2 = c1;
            								}
HXDLIN( 623)								int maskPixel = v2;
HXDLIN( 623)								int this10 = col;
HXDLIN( 623)								if ((maskPixel == 0)) {
HXDLIN( 623)									col = this10;
            								}
            								else {
HXDLIN( 623)									Float m0;
HXDLIN( 623)									int this11 = ((maskPixel >> 24) & 255);
HXDLIN( 623)									if ((this11 == 0)) {
HXDLIN( 623)										m0 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m1;
HXDLIN( 623)									int this12 = ((maskPixel >> 16) & 255);
HXDLIN( 623)									if ((this12 == 0)) {
HXDLIN( 623)										m1 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m2;
HXDLIN( 623)									int this13 = ((maskPixel >> 8) & 255);
HXDLIN( 623)									if ((this13 == 0)) {
HXDLIN( 623)										m2 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m3;
HXDLIN( 623)									int this14 = (maskPixel & 255);
HXDLIN( 623)									if ((this14 == 0)) {
HXDLIN( 623)										m3 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN( 623)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN( 623)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN( 623)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN( 623)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 623)							if ((col != 0)) {
HXDLIN( 623)								int x2 = (1 + dx);
HXDLIN( 623)								int y2 = (1 + dy);
HXDLIN( 623)								int c2 = col;
HXDLIN( 623)								bool here4;
HXDLIN( 623)								if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 623)									here4 = img->transparent;
            								}
            								else {
HXDLIN( 623)									here4 = false;
            								}
HXDLIN( 623)								if (here4) {
HXDLIN( 623)									int location;
HXDLIN( 623)									if (img->useVirtualPos) {
HXDLIN( 623)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 623)										location = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 623)									int this15 = ::iterMagic::Iimg_obj::get(img->image,location);
HXDLIN( 623)									int this16;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										this16 = this15;
            									}
HXDLIN( 623)									Float a11;
HXDLIN( 623)									int this17 = ((this16 >> 24) & 255);
HXDLIN( 623)									if ((this17 == 0)) {
HXDLIN( 623)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r1;
HXDLIN( 623)									int this18 = ((this16 >> 16) & 255);
HXDLIN( 623)									if ((this18 == 0)) {
HXDLIN( 623)										r1 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g1;
HXDLIN( 623)									int this19 = ((this16 >> 8) & 255);
HXDLIN( 623)									if ((this19 == 0)) {
HXDLIN( 623)										g1 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b11;
HXDLIN( 623)									int this20 = (this16 & 255);
HXDLIN( 623)									if ((this20 == 0)) {
HXDLIN( 623)										b11 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a2;
HXDLIN( 623)									int this21 = ((col >> 24) & 255);
HXDLIN( 623)									if ((this21 == 0)) {
HXDLIN( 623)										a2 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r2;
HXDLIN( 623)									int this22 = ((col >> 16) & 255);
HXDLIN( 623)									if ((this22 == 0)) {
HXDLIN( 623)										r2 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g2;
HXDLIN( 623)									int this23 = ((col >> 8) & 255);
HXDLIN( 623)									if ((this23 == 0)) {
HXDLIN( 623)										g2 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b21;
HXDLIN( 623)									int this24 = (col & 255);
HXDLIN( 623)									if ((this24 == 0)) {
HXDLIN( 623)										b21 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 623)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 623)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 623)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 623)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 623)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 623)									{
HXDLIN( 623)										int here5;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here5 = blended;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(img->image,location,here5);
            									}
            								}
            								else {
HXDLIN( 623)									::Dynamic this25 = img->image;
HXDLIN( 623)									int index2;
HXDLIN( 623)									if (img->useVirtualPos) {
HXDLIN( 623)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - img->virtualY) * ( (Float)(img->width) )) + x2) - img->virtualX));
            									}
            									else {
HXDLIN( 623)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * img->width) + x2)) ));
            									}
HXDLIN( 623)									int here6;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										here6 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										here6 = c2;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this25,index2,here6);
            								}
            							}
            							else {
HXDLIN( 623)								if (forceClear) {
HXDLIN( 623)									::Dynamic this26 = img->image;
HXDLIN( 623)									int x3 = (1 + dx);
HXDLIN( 623)									int y3 = (1 + dy);
HXDLIN( 623)									int index3;
HXDLIN( 623)									if (img->useVirtualPos) {
HXDLIN( 623)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - img->virtualY) * ( (Float)(img->width) )) + x3) - img->virtualX));
            									}
            									else {
HXDLIN( 623)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * img->width) + x3)) ));
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this26,index3,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g36 = 0;
HXDLIN( 623)				int _g37 = this4->width;
HXDLIN( 623)				while((_g36 < _g37)){
HXDLIN( 623)					_g36 = (_g36 + 1);
HXDLIN( 623)					int x4 = (_g36 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g38 = 0;
HXDLIN( 623)						int _g39 = 1;
HXDLIN( 623)						while((_g38 < _g39)){
HXDLIN( 623)							_g38 = (_g38 + 1);
HXDLIN( 623)							int y4 = (_g38 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								int x5 = (x4 + 1);
HXDLIN( 623)								::Dynamic this27 = this4->image;
HXDLIN( 623)								int index4;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index4 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index4 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x4)) ));
            								}
HXDLIN( 623)								int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN( 623)								int color;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color = c3;
            								}
HXDLIN( 623)								int color1 = color;
HXDLIN( 623)								{
HXDLIN( 623)									int c4 = color1;
HXDLIN( 623)									bool here7;
HXDLIN( 623)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 623)										here7 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here7 = false;
            									}
HXDLIN( 623)									if (here7) {
HXDLIN( 623)										int location1;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location1 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 623)										int this28 = ::iterMagic::Iimg_obj::get(img->image,location1);
HXDLIN( 623)										int this29;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this29 = this28;
            										}
HXDLIN( 623)										Float a12;
HXDLIN( 623)										int this30 = ((this29 >> 24) & 255);
HXDLIN( 623)										if ((this30 == 0)) {
HXDLIN( 623)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r11;
HXDLIN( 623)										int this31 = ((this29 >> 16) & 255);
HXDLIN( 623)										if ((this31 == 0)) {
HXDLIN( 623)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g11;
HXDLIN( 623)										int this32 = ((this29 >> 8) & 255);
HXDLIN( 623)										if ((this32 == 0)) {
HXDLIN( 623)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b12;
HXDLIN( 623)										int this33 = (this29 & 255);
HXDLIN( 623)										if ((this33 == 0)) {
HXDLIN( 623)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a21;
HXDLIN( 623)										int this34 = ((color1 >> 24) & 255);
HXDLIN( 623)										if ((this34 == 0)) {
HXDLIN( 623)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r21;
HXDLIN( 623)										int this35 = ((color1 >> 16) & 255);
HXDLIN( 623)										if ((this35 == 0)) {
HXDLIN( 623)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g21;
HXDLIN( 623)										int this36 = ((color1 >> 8) & 255);
HXDLIN( 623)										if ((this36 == 0)) {
HXDLIN( 623)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b22;
HXDLIN( 623)										int this37 = (color1 & 255);
HXDLIN( 623)										if ((this37 == 0)) {
HXDLIN( 623)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 623)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 623)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 623)										int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 623)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 623)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 623)										{
HXDLIN( 623)											int here8;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here8 = blended1;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location1,here8);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this38 = img->image;
HXDLIN( 623)										int index5;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - img->virtualY) * ( (Float)(img->width) )) + x5) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index5 = ::Std_obj::_hx_int(( (Float)(((y4 * img->width) + x5)) ));
            										}
HXDLIN( 623)										int here9;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here9 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here9 = c4;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this38,index5,here9);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x6 = (x4 + 1);
HXDLIN( 623)								int y5 = ((img->height - y4) - 1);
HXDLIN( 623)								int y6 = (this4->height - 1);
HXDLIN( 623)								::Dynamic this39 = this4->image;
HXDLIN( 623)								int index6;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this4->virtualY) * ( (Float)(this4->width) )) + x4) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this4->width) + x4)) ));
            								}
HXDLIN( 623)								int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 623)								int color2;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color2 = c5;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c6 = color2;
HXDLIN( 623)									bool here10;
HXDLIN( 623)									if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 623)										here10 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here10 = false;
            									}
HXDLIN( 623)									if (here10) {
HXDLIN( 623)										int location2;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 623)										int this40 = ::iterMagic::Iimg_obj::get(img->image,location2);
HXDLIN( 623)										int this41;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this41 = this40;
            										}
HXDLIN( 623)										Float a13;
HXDLIN( 623)										int this42 = ((this41 >> 24) & 255);
HXDLIN( 623)										if ((this42 == 0)) {
HXDLIN( 623)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r12;
HXDLIN( 623)										int this43 = ((this41 >> 16) & 255);
HXDLIN( 623)										if ((this43 == 0)) {
HXDLIN( 623)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g12;
HXDLIN( 623)										int this44 = ((this41 >> 8) & 255);
HXDLIN( 623)										if ((this44 == 0)) {
HXDLIN( 623)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b13;
HXDLIN( 623)										int this45 = (this41 & 255);
HXDLIN( 623)										if ((this45 == 0)) {
HXDLIN( 623)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a22;
HXDLIN( 623)										int this46 = ((color2 >> 24) & 255);
HXDLIN( 623)										if ((this46 == 0)) {
HXDLIN( 623)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r22;
HXDLIN( 623)										int this47 = ((color2 >> 16) & 255);
HXDLIN( 623)										if ((this47 == 0)) {
HXDLIN( 623)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g22;
HXDLIN( 623)										int this48 = ((color2 >> 8) & 255);
HXDLIN( 623)										if ((this48 == 0)) {
HXDLIN( 623)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b23;
HXDLIN( 623)										int this49 = (color2 & 255);
HXDLIN( 623)										if ((this49 == 0)) {
HXDLIN( 623)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 623)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 623)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 623)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 623)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 623)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 623)										{
HXDLIN( 623)											int here11;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here11 = blended2;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location2,here11);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this50 = img->image;
HXDLIN( 623)										int index7;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - img->virtualY) * ( (Float)(img->width) )) + x6) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * img->width) + x6)) ));
            										}
HXDLIN( 623)										int here12;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here12 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here12 = c6;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this50,index7,here12);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g40 = 0;
HXDLIN( 623)				int _g41 = this4->height;
HXDLIN( 623)				while((_g40 < _g41)){
HXDLIN( 623)					_g40 = (_g40 + 1);
HXDLIN( 623)					int y7 = (_g40 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g42 = 0;
HXDLIN( 623)						int _g43 = 1;
HXDLIN( 623)						while((_g42 < _g43)){
HXDLIN( 623)							_g42 = (_g42 + 1);
HXDLIN( 623)							int x7 = (_g42 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								int y8 = (y7 + 1);
HXDLIN( 623)								::Dynamic this51 = this4->image;
HXDLIN( 623)								int index8;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index8 = ::Std_obj::_hx_int((((( (Float)(y7) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index8 = ::Std_obj::_hx_int(( (Float)((y7 * this4->width)) ));
            								}
HXDLIN( 623)								int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN( 623)								int color3;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color3 = c7;
            								}
HXDLIN( 623)								int color4 = color3;
HXDLIN( 623)								{
HXDLIN( 623)									int c8 = color4;
HXDLIN( 623)									bool here13;
HXDLIN( 623)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 623)										here13 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here13 = false;
            									}
HXDLIN( 623)									if (here13) {
HXDLIN( 623)										int location3;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 623)										int this52 = ::iterMagic::Iimg_obj::get(img->image,location3);
HXDLIN( 623)										int this53;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this53 = ((((((this52 >> 24) & 255) << 24) | ((this52 & 255) << 16)) | (((this52 >> 8) & 255) << 8)) | ((this52 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this53 = this52;
            										}
HXDLIN( 623)										Float a14;
HXDLIN( 623)										int this54 = ((this53 >> 24) & 255);
HXDLIN( 623)										if ((this54 == 0)) {
HXDLIN( 623)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a14 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r13;
HXDLIN( 623)										int this55 = ((this53 >> 16) & 255);
HXDLIN( 623)										if ((this55 == 0)) {
HXDLIN( 623)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g13;
HXDLIN( 623)										int this56 = ((this53 >> 8) & 255);
HXDLIN( 623)										if ((this56 == 0)) {
HXDLIN( 623)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b14;
HXDLIN( 623)										int this57 = (this53 & 255);
HXDLIN( 623)										if ((this57 == 0)) {
HXDLIN( 623)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b14 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a23;
HXDLIN( 623)										int this58 = ((color4 >> 24) & 255);
HXDLIN( 623)										if ((this58 == 0)) {
HXDLIN( 623)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r23;
HXDLIN( 623)										int this59 = ((color4 >> 16) & 255);
HXDLIN( 623)										if ((this59 == 0)) {
HXDLIN( 623)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g23;
HXDLIN( 623)										int this60 = ((color4 >> 8) & 255);
HXDLIN( 623)										if ((this60 == 0)) {
HXDLIN( 623)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b24;
HXDLIN( 623)										int this61 = (color4 & 255);
HXDLIN( 623)										if ((this61 == 0)) {
HXDLIN( 623)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b24 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 623)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 623)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 623)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 623)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 623)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 623)										{
HXDLIN( 623)											int here14;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here14 = blended3;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location3,here14);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this62 = img->image;
HXDLIN( 623)										int index9;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - img->virtualY) * ( (Float)(img->width) )) + x7) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index9 = ::Std_obj::_hx_int(( (Float)(((y8 * img->width) + x7)) ));
            										}
HXDLIN( 623)										int here15;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here15 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here15 = c8;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this62,index9,here15);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x8 = ((img->width - x7) - 1);
HXDLIN( 623)								int y9 = (y7 + 1);
HXDLIN( 623)								int x9 = (this4->width - 1);
HXDLIN( 623)								::Dynamic this63 = this4->image;
HXDLIN( 623)								int index10;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index10 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x9) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index10 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x9)) ));
            								}
HXDLIN( 623)								int c9 = ::iterMagic::Iimg_obj::get(this63,index10);
HXDLIN( 623)								int color5;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color5 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color5 = c9;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c10 = color5;
HXDLIN( 623)									bool here16;
HXDLIN( 623)									if ((((c10 >> 24) & 255) < 254)) {
HXDLIN( 623)										here16 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here16 = false;
            									}
HXDLIN( 623)									if (here16) {
HXDLIN( 623)										int location4;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 623)										int this64 = ::iterMagic::Iimg_obj::get(img->image,location4);
HXDLIN( 623)										int this65;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this65 = ((((((this64 >> 24) & 255) << 24) | ((this64 & 255) << 16)) | (((this64 >> 8) & 255) << 8)) | ((this64 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this65 = this64;
            										}
HXDLIN( 623)										Float a15;
HXDLIN( 623)										int this66 = ((this65 >> 24) & 255);
HXDLIN( 623)										if ((this66 == 0)) {
HXDLIN( 623)											a15 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a15 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r14;
HXDLIN( 623)										int this67 = ((this65 >> 16) & 255);
HXDLIN( 623)										if ((this67 == 0)) {
HXDLIN( 623)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r14 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g14;
HXDLIN( 623)										int this68 = ((this65 >> 8) & 255);
HXDLIN( 623)										if ((this68 == 0)) {
HXDLIN( 623)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g14 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b15;
HXDLIN( 623)										int this69 = (this65 & 255);
HXDLIN( 623)										if ((this69 == 0)) {
HXDLIN( 623)											b15 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b15 = (( (Float)(this69) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a24;
HXDLIN( 623)										int this70 = ((color5 >> 24) & 255);
HXDLIN( 623)										if ((this70 == 0)) {
HXDLIN( 623)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a24 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r24;
HXDLIN( 623)										int this71 = ((color5 >> 16) & 255);
HXDLIN( 623)										if ((this71 == 0)) {
HXDLIN( 623)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r24 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g24;
HXDLIN( 623)										int this72 = ((color5 >> 8) & 255);
HXDLIN( 623)										if ((this72 == 0)) {
HXDLIN( 623)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g24 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b25;
HXDLIN( 623)										int this73 = (color5 & 255);
HXDLIN( 623)										if ((this73 == 0)) {
HXDLIN( 623)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b25 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 623)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 623)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 623)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN( 623)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 623)										int blended4 = ((((a8 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 623)										{
HXDLIN( 623)											int here17;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here17 = blended4;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location4,here17);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this74 = img->image;
HXDLIN( 623)										int index11;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - img->virtualY) * ( (Float)(img->width) )) + x8) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index11 = ::Std_obj::_hx_int(( (Float)(((y9 * img->width) + x8)) ));
            										}
HXDLIN( 623)										int here18;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here18 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here18 = c10;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this74,index11,here18);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g44 = 0;
HXDLIN( 623)				int _g45 = 1;
HXDLIN( 623)				while((_g44 < _g45)){
HXDLIN( 623)					_g44 = (_g44 + 1);
HXDLIN( 623)					int x10 = (_g44 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g46 = 0;
HXDLIN( 623)						int _g47 = 1;
HXDLIN( 623)						while((_g46 < _g47)){
HXDLIN( 623)							_g46 = (_g46 + 1);
HXDLIN( 623)							int y10 = (_g46 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								::Dynamic this75 = this4->image;
HXDLIN( 623)								int index12;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index12 = ::Std_obj::_hx_int((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index12 = ::Std_obj::_hx_int(( (Float)((0 * this4->width)) ));
            								}
HXDLIN( 623)								int c11 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 623)								int color6;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color6 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color6 = c11;
            								}
HXDLIN( 623)								int color7 = color6;
HXDLIN( 623)								{
HXDLIN( 623)									int c12 = color7;
HXDLIN( 623)									bool here19;
HXDLIN( 623)									if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 623)										here19 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here19 = false;
            									}
HXDLIN( 623)									if (here19) {
HXDLIN( 623)										int location5;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location5 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 623)										int this76 = ::iterMagic::Iimg_obj::get(img->image,location5);
HXDLIN( 623)										int this77;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this77 = this76;
            										}
HXDLIN( 623)										Float a16;
HXDLIN( 623)										int this78 = ((this77 >> 24) & 255);
HXDLIN( 623)										if ((this78 == 0)) {
HXDLIN( 623)											a16 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r15;
HXDLIN( 623)										int this79 = ((this77 >> 16) & 255);
HXDLIN( 623)										if ((this79 == 0)) {
HXDLIN( 623)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r15 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g15;
HXDLIN( 623)										int this80 = ((this77 >> 8) & 255);
HXDLIN( 623)										if ((this80 == 0)) {
HXDLIN( 623)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g15 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b16;
HXDLIN( 623)										int this81 = (this77 & 255);
HXDLIN( 623)										if ((this81 == 0)) {
HXDLIN( 623)											b16 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b16 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a25;
HXDLIN( 623)										int this82 = ((color7 >> 24) & 255);
HXDLIN( 623)										if ((this82 == 0)) {
HXDLIN( 623)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a25 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r25;
HXDLIN( 623)										int this83 = ((color7 >> 16) & 255);
HXDLIN( 623)										if ((this83 == 0)) {
HXDLIN( 623)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g25;
HXDLIN( 623)										int this84 = ((color7 >> 8) & 255);
HXDLIN( 623)										if ((this84 == 0)) {
HXDLIN( 623)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g25 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b26;
HXDLIN( 623)										int this85 = (color7 & 255);
HXDLIN( 623)										if ((this85 == 0)) {
HXDLIN( 623)											b26 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b26 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 623)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 623)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 623)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN( 623)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 623)										int blended5 = ((((a9 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 623)										{
HXDLIN( 623)											int here20;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here20 = blended5;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location5,here20);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this86 = img->image;
HXDLIN( 623)										int index13;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x10)) ));
            										}
HXDLIN( 623)										int here21;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here21 = c12;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this86,index13,here21);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x11 = ((x10 + 1) + this4->width);
HXDLIN( 623)								int x12 = (this4->width - 1);
HXDLIN( 623)								::Dynamic this87 = this4->image;
HXDLIN( 623)								int index14;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index14 = ::Std_obj::_hx_int(((((( (Float)(0) ) - this4->virtualY) * ( (Float)(this4->width) )) + x12) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index14 = ::Std_obj::_hx_int(( (Float)(((0 * this4->width) + x12)) ));
            								}
HXDLIN( 623)								int c13 = ::iterMagic::Iimg_obj::get(this87,index14);
HXDLIN( 623)								int color8;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color8 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color8 = c13;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c14 = color8;
HXDLIN( 623)									bool here22;
HXDLIN( 623)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 623)										here22 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here22 = false;
            									}
HXDLIN( 623)									if (here22) {
HXDLIN( 623)										int location6;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 623)										int this88 = ::iterMagic::Iimg_obj::get(img->image,location6);
HXDLIN( 623)										int this89;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this89 = this88;
            										}
HXDLIN( 623)										Float a17;
HXDLIN( 623)										int this90 = ((this89 >> 24) & 255);
HXDLIN( 623)										if ((this90 == 0)) {
HXDLIN( 623)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r16;
HXDLIN( 623)										int this91 = ((this89 >> 16) & 255);
HXDLIN( 623)										if ((this91 == 0)) {
HXDLIN( 623)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r16 = (( (Float)(this91) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g16;
HXDLIN( 623)										int this92 = ((this89 >> 8) & 255);
HXDLIN( 623)										if ((this92 == 0)) {
HXDLIN( 623)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g16 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b18;
HXDLIN( 623)										int this93 = (this89 & 255);
HXDLIN( 623)										if ((this93 == 0)) {
HXDLIN( 623)											b18 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b18 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a26;
HXDLIN( 623)										int this94 = ((color8 >> 24) & 255);
HXDLIN( 623)										if ((this94 == 0)) {
HXDLIN( 623)											a26 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a26 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r26;
HXDLIN( 623)										int this95 = ((color8 >> 16) & 255);
HXDLIN( 623)										if ((this95 == 0)) {
HXDLIN( 623)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r26 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g26;
HXDLIN( 623)										int this96 = ((color8 >> 8) & 255);
HXDLIN( 623)										if ((this96 == 0)) {
HXDLIN( 623)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g26 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b27;
HXDLIN( 623)										int this97 = (color8 & 255);
HXDLIN( 623)										if ((this97 == 0)) {
HXDLIN( 623)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b27 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN( 623)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 623)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 623)										int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a36) + (b27 * a26))));
HXDLIN( 623)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 623)										int blended6 = ((((a10 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN( 623)										{
HXDLIN( 623)											int here23;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here23 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here23 = blended6;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location6,here23);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this98 = img->image;
HXDLIN( 623)										int index15;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index15 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - img->virtualY) * ( (Float)(img->width) )) + x11) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index15 = ::Std_obj::_hx_int(( (Float)(((y10 * img->width) + x11)) ));
            										}
HXDLIN( 623)										int here24;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here24 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here24 = c14;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this98,index15,here24);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x13 = ((x10 + 1) + this4->width);
HXDLIN( 623)								int y11 = ((y10 + 1) + this4->height);
HXDLIN( 623)								int x14 = (this4->width - 1);
HXDLIN( 623)								int y12 = (this4->height - 1);
HXDLIN( 623)								::Dynamic this99 = this4->image;
HXDLIN( 623)								int index16;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this4->virtualY) * ( (Float)(this4->width) )) + x14) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index16 = ::Std_obj::_hx_int(( (Float)(((y12 * this4->width) + x14)) ));
            								}
HXDLIN( 623)								int c15 = ::iterMagic::Iimg_obj::get(this99,index16);
HXDLIN( 623)								int color9;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color9 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color9 = c15;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c16 = color9;
HXDLIN( 623)									bool here25;
HXDLIN( 623)									if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 623)										here25 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here25 = false;
            									}
HXDLIN( 623)									if (here25) {
HXDLIN( 623)										int location7;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location7 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 623)										int this100 = ::iterMagic::Iimg_obj::get(img->image,location7);
HXDLIN( 623)										int this101;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this101 = ((((((this100 >> 24) & 255) << 24) | ((this100 & 255) << 16)) | (((this100 >> 8) & 255) << 8)) | ((this100 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this101 = this100;
            										}
HXDLIN( 623)										Float a18;
HXDLIN( 623)										int this102 = ((this101 >> 24) & 255);
HXDLIN( 623)										if ((this102 == 0)) {
HXDLIN( 623)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a18 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r17;
HXDLIN( 623)										int this103 = ((this101 >> 16) & 255);
HXDLIN( 623)										if ((this103 == 0)) {
HXDLIN( 623)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r17 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g17;
HXDLIN( 623)										int this104 = ((this101 >> 8) & 255);
HXDLIN( 623)										if ((this104 == 0)) {
HXDLIN( 623)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g17 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b110;
HXDLIN( 623)										int this105 = (this101 & 255);
HXDLIN( 623)										if ((this105 == 0)) {
HXDLIN( 623)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b110 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a27;
HXDLIN( 623)										int this106 = ((color9 >> 24) & 255);
HXDLIN( 623)										if ((this106 == 0)) {
HXDLIN( 623)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a27 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r27;
HXDLIN( 623)										int this107 = ((color9 >> 16) & 255);
HXDLIN( 623)										if ((this107 == 0)) {
HXDLIN( 623)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r27 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g27;
HXDLIN( 623)										int this108 = ((color9 >> 8) & 255);
HXDLIN( 623)										if ((this108 == 0)) {
HXDLIN( 623)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b28;
HXDLIN( 623)										int this109 = (color9 & 255);
HXDLIN( 623)										if ((this109 == 0)) {
HXDLIN( 623)											b28 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b28 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a37 = (a18 * (( (Float)(1) ) - a27));
HXDLIN( 623)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 623)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 623)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b28 * a27))));
HXDLIN( 623)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 623)										int blended7 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN( 623)										{
HXDLIN( 623)											int here26;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here26 = blended7;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location7,here26);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this110 = img->image;
HXDLIN( 623)										int index17;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index17 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - img->virtualY) * ( (Float)(img->width) )) + x13) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index17 = ::Std_obj::_hx_int(( (Float)(((y11 * img->width) + x13)) ));
            										}
HXDLIN( 623)										int here27;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here27 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here27 = c16;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this110,index17,here27);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int y13 = ((y10 + 1) + this4->width);
HXDLIN( 623)								int y14 = (this4->height - 1);
HXDLIN( 623)								::Dynamic this111 = this4->image;
HXDLIN( 623)								int index18;
HXDLIN( 623)								if (this4->useVirtualPos) {
HXDLIN( 623)									index18 = ::Std_obj::_hx_int((((( (Float)(y14) ) - this4->virtualY) * ( (Float)(this4->width) )) - this4->virtualX));
            								}
            								else {
HXDLIN( 623)									index18 = ::Std_obj::_hx_int(( (Float)((y14 * this4->width)) ));
            								}
HXDLIN( 623)								int c17 = ::iterMagic::Iimg_obj::get(this111,index18);
HXDLIN( 623)								int color10;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color10 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color10 = c17;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c18 = color10;
HXDLIN( 623)									bool here28;
HXDLIN( 623)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 623)										here28 = img->transparent;
            									}
            									else {
HXDLIN( 623)										here28 = false;
            									}
HXDLIN( 623)									if (here28) {
HXDLIN( 623)										int location8;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											location8 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 623)										int this112 = ::iterMagic::Iimg_obj::get(img->image,location8);
HXDLIN( 623)										int this113;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this113 = this112;
            										}
HXDLIN( 623)										Float a110;
HXDLIN( 623)										int this114 = ((this113 >> 24) & 255);
HXDLIN( 623)										if ((this114 == 0)) {
HXDLIN( 623)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r18;
HXDLIN( 623)										int this115 = ((this113 >> 16) & 255);
HXDLIN( 623)										if ((this115 == 0)) {
HXDLIN( 623)											r18 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r18 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g18;
HXDLIN( 623)										int this116 = ((this113 >> 8) & 255);
HXDLIN( 623)										if ((this116 == 0)) {
HXDLIN( 623)											g18 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g18 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b111;
HXDLIN( 623)										int this117 = (this113 & 255);
HXDLIN( 623)										if ((this117 == 0)) {
HXDLIN( 623)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a28;
HXDLIN( 623)										int this118 = ((color10 >> 24) & 255);
HXDLIN( 623)										if ((this118 == 0)) {
HXDLIN( 623)											a28 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a28 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r28;
HXDLIN( 623)										int this119 = ((color10 >> 16) & 255);
HXDLIN( 623)										if ((this119 == 0)) {
HXDLIN( 623)											r28 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r28 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g28;
HXDLIN( 623)										int this120 = ((color10 >> 8) & 255);
HXDLIN( 623)										if ((this120 == 0)) {
HXDLIN( 623)											g28 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g28 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b29;
HXDLIN( 623)										int this121 = (color10 & 255);
HXDLIN( 623)										if ((this121 == 0)) {
HXDLIN( 623)											b29 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b29 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 623)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN( 623)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN( 623)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a28))));
HXDLIN( 623)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN( 623)										int blended8 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 623)										{
HXDLIN( 623)											int here29;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here29 = blended8;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img->image,location8,here29);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this122 = img->image;
HXDLIN( 623)										int index19;
HXDLIN( 623)										if (img->useVirtualPos) {
HXDLIN( 623)											index19 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - img->virtualY) * ( (Float)(img->width) )) + x10) - img->virtualX));
            										}
            										else {
HXDLIN( 623)											index19 = ::Std_obj::_hx_int(( (Float)(((y13 * img->width) + x10)) ));
            										}
HXDLIN( 623)										int here30;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here30 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here30 = c18;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this122,index19,here30);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				here = img;
            			}
            			break;
            			case (int)1: {
            			}
            			break;
            			case (int)2: {
HXDLIN( 623)				 ::pi_xy::ImageStruct this123 = this1;
HXDLIN( 623)				int width2 = (this123->width + 2);
HXDLIN( 623)				int height2 = (this123->height + 2);
HXDLIN( 623)				 ::Dynamic imageType2 = null();
HXDLIN( 623)				 ::pi_xy::ImageStruct this124 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 623)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 623)				::Dynamic here31;
HXDLIN( 623)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXDLIN( 623)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::BytesImg b31 = byt2;
HXDLIN( 623)						{
HXDLIN( 623)							b31->width = width2;
HXDLIN( 623)							b31->height = height2;
HXDLIN( 623)							b31->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 623)							b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 623)							{
HXDLIN( 623)								int len4 = b31->length;
HXDLIN( 623)								int w2 = 0;
HXDLIN( 623)								{
HXDLIN( 623)									int _g48 = 0;
HXDLIN( 623)									int _g49 = b31->height;
HXDLIN( 623)									while((_g48 < _g49)){
HXDLIN( 623)										_g48 = (_g48 + 1);
HXDLIN( 623)										int y15 = (_g48 - 1);
HXDLIN( 623)										{
HXDLIN( 623)											int _g50 = 0;
HXDLIN( 623)											int _g51 = b31->width;
HXDLIN( 623)											while((_g50 < _g51)){
HXDLIN( 623)												_g50 = (_g50 + 1);
HXDLIN( 623)												int x15 = (_g50 - 1);
HXDLIN( 623)												{
HXDLIN( 623)													w2 = (w2 + 1);
HXDLIN( 623)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w2 = (w2 + 1);
HXDLIN( 623)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w2 = (w2 + 1);
HXDLIN( 623)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 623)												{
HXDLIN( 623)													w2 = (w2 + 1);
HXDLIN( 623)													b31->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here31 = b31;
            					}
            					break;
            					case (int)1: {
HXDLIN( 623)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::ArrIntImg a29 = arrI2;
HXDLIN( 623)						{
HXDLIN( 623)							a29->width = width2;
HXDLIN( 623)							a29->height = height2;
HXDLIN( 623)							a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 623)							a29->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 623)							{
HXDLIN( 623)								int _g52 = 0;
HXDLIN( 623)								int _g53 = a29->length;
HXDLIN( 623)								while((_g52 < _g53)){
HXDLIN( 623)									_g52 = (_g52 + 1);
HXDLIN( 623)									int i12 = (_g52 - 1);
HXDLIN( 623)									a29->data[i12] = 0;
            								}
            							}
            						}
HXDLIN( 623)						here31 = a29;
            					}
            					break;
            					case (int)2: {
HXDLIN( 623)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::U32ArrImg b32 = u32a2;
HXDLIN( 623)						{
HXDLIN( 623)							b32->width = width2;
HXDLIN( 623)							b32->height = height2;
HXDLIN( 623)							b32->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 623)							int size2 = (b32->length * 4);
HXDLIN( 623)							b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 623)							{
HXDLIN( 623)								int _g54 = 0;
HXDLIN( 623)								int _g55 = b32->length;
HXDLIN( 623)								while((_g54 < _g55)){
HXDLIN( 623)									_g54 = (_g54 + 1);
HXDLIN( 623)									int i13 = (_g54 - 1);
HXDLIN( 623)									{
HXDLIN( 623)										 ::haxe::io::ArrayBufferViewImpl this125 = b32->data;
HXDLIN( 623)										bool here32;
HXDLIN( 623)										if ((i13 >= 0)) {
HXDLIN( 623)											here32 = (i13 < (this125->byteLength >> 2));
            										}
            										else {
HXDLIN( 623)											here32 = false;
            										}
HXDLIN( 623)										if (here32) {
HXDLIN( 623)											 ::haxe::io::Bytes _this2 = this125->bytes;
HXDLIN( 623)											int pos2 = ((i13 << 2) + this125->byteOffset);
HXDLIN( 623)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 623)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 623)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 623)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here31 = b32;
            					}
            					break;
            					case (int)3: {
HXDLIN( 623)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN( 623)						{
HXDLIN( 623)							v3->width = width2;
HXDLIN( 623)							v3->height = height2;
HXDLIN( 623)							v3->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 623)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 623)							{
HXDLIN( 623)								int _g56 = 0;
HXDLIN( 623)								int _g57 = v3->length;
HXDLIN( 623)								while((_g56 < _g57)){
HXDLIN( 623)									_g56 = (_g56 + 1);
HXDLIN( 623)									int i14 = (_g56 - 1);
HXDLIN( 623)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN( 623)						here31 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN( 623)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 623)						 ::iterMagic::StackIntImg b33 = sInt2;
HXDLIN( 623)						{
HXDLIN( 623)							b33->width = width2;
HXDLIN( 623)							b33->height = height2;
HXDLIN( 623)							b33->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 623)							b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 623)							{
HXDLIN( 623)								int len5 = b33->length;
HXDLIN( 623)								 ::haxe::ds::GenericStack_Int d2 = b33->data;
HXDLIN( 623)								if (::hx::IsNull( d2->head )) {
HXDLIN( 623)									int _g58 = 0;
HXDLIN( 623)									int _g59 = len5;
HXDLIN( 623)									while((_g58 < _g59)){
HXDLIN( 623)										_g58 = (_g58 + 1);
HXDLIN( 623)										int i15 = (_g58 - 1);
HXDLIN( 623)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXDLIN( 623)									int _g60 = 0;
HXDLIN( 623)									int _g61 = len5;
HXDLIN( 623)									while((_g60 < _g61)){
HXDLIN( 623)										_g60 = (_g60 + 1);
HXDLIN( 623)										int i16 = (_g60 - 1);
HXDLIN( 623)										{
HXDLIN( 623)											 ::haxe::ds::GenericCell_Int l2 = b33->data->head;
HXDLIN( 623)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 623)											{
HXDLIN( 623)												int _g62 = 0;
HXDLIN( 623)												int _g63 = i16;
HXDLIN( 623)												while((_g62 < _g63)){
HXDLIN( 623)													_g62 = (_g62 + 1);
HXDLIN( 623)													int i17 = (_g62 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 623)											if (::hx::IsNull( prev2 )) {
HXDLIN( 623)												b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 623)												l2 = null();
            											}
            											else {
HXDLIN( 623)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 623)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 623)						here31 = b33;
            					}
            					break;
            				}
HXDLIN( 623)				this124->image = here31;
HXDLIN( 623)				this124->width = width2;
HXDLIN( 623)				this124->height = height2;
HXDLIN( 623)				this124->imageType = ( (int)(imageType2) );
HXDLIN( 623)				 ::pi_xy::ImageStruct img1 = this124;
HXDLIN( 623)				bool forceClear1 = false;
HXDLIN( 623)				int _g64 = 0;
HXDLIN( 623)				int _g65 = this123->height;
HXDLIN( 623)				while((_g64 < _g65)){
HXDLIN( 623)					_g64 = (_g64 + 1);
HXDLIN( 623)					int dy1 = (_g64 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g66 = 0;
HXDLIN( 623)						int _g67 = this123->width;
HXDLIN( 623)						while((_g66 < _g67)){
HXDLIN( 623)							_g66 = (_g66 + 1);
HXDLIN( 623)							int dx1 = (_g66 - 1);
HXDLIN( 623)							::Dynamic this126 = this123->image;
HXDLIN( 623)							int index20;
HXDLIN( 623)							if (this123->useVirtualPos) {
HXDLIN( 623)								index20 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx1) - this123->virtualX));
            							}
            							else {
HXDLIN( 623)								index20 = ::Std_obj::_hx_int(( (Float)(((dy1 * this123->width) + dx1)) ));
            							}
HXDLIN( 623)							int c19 = ::iterMagic::Iimg_obj::get(this126,index20);
HXDLIN( 623)							int col1;
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								col1 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								col1 = c19;
            							}
HXDLIN( 623)							bool here33;
HXDLIN( 623)							if (this123->useMask) {
HXDLIN( 623)								here33 = ::hx::IsNotNull( this123->mask );
            							}
            							else {
HXDLIN( 623)								here33 = false;
            							}
HXDLIN( 623)							if (here33) {
HXDLIN( 623)								 ::pi_xy::ImageStruct this127 = this123->mask;
HXDLIN( 623)								::Dynamic this128 = this127->image;
HXDLIN( 623)								int index21;
HXDLIN( 623)								if (this127->useVirtualPos) {
HXDLIN( 623)									index21 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this127->virtualY) * ( (Float)(this127->width) )) + dx1) - this127->virtualX));
            								}
            								else {
HXDLIN( 623)									index21 = ::Std_obj::_hx_int(( (Float)(((dy1 * this127->width) + dx1)) ));
            								}
HXDLIN( 623)								int c20 = ::iterMagic::Iimg_obj::get(this128,index21);
HXDLIN( 623)								int v4;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									v4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									v4 = c20;
            								}
HXDLIN( 623)								int maskPixel1 = v4;
HXDLIN( 623)								int this129 = col1;
HXDLIN( 623)								if ((maskPixel1 == 0)) {
HXDLIN( 623)									col1 = this129;
            								}
            								else {
HXDLIN( 623)									Float m01;
HXDLIN( 623)									int this130 = ((maskPixel1 >> 24) & 255);
HXDLIN( 623)									if ((this130 == 0)) {
HXDLIN( 623)										m01 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m01 = (( (Float)(this130) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m11;
HXDLIN( 623)									int this131 = ((maskPixel1 >> 16) & 255);
HXDLIN( 623)									if ((this131 == 0)) {
HXDLIN( 623)										m11 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m11 = (( (Float)(this131) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m21;
HXDLIN( 623)									int this132 = ((maskPixel1 >> 8) & 255);
HXDLIN( 623)									if ((this132 == 0)) {
HXDLIN( 623)										m21 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m21 = (( (Float)(this132) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float m31;
HXDLIN( 623)									int this133 = (maskPixel1 & 255);
HXDLIN( 623)									if ((this133 == 0)) {
HXDLIN( 623)										m31 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										m31 = (( (Float)(this133) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this129 >> 24) & 255)) )));
HXDLIN( 623)									int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this129 >> 16) & 255)) )));
HXDLIN( 623)									int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this129 >> 8) & 255)) )));
HXDLIN( 623)									int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this129 & 255)) )));
HXDLIN( 623)									col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 623)							if ((col1 != 0)) {
HXDLIN( 623)								int x16 = (1 + dx1);
HXDLIN( 623)								int y16 = (1 + dy1);
HXDLIN( 623)								int c21 = col1;
HXDLIN( 623)								bool here34;
HXDLIN( 623)								if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 623)									here34 = img1->transparent;
            								}
            								else {
HXDLIN( 623)									here34 = false;
            								}
HXDLIN( 623)								if (here34) {
HXDLIN( 623)									int location9;
HXDLIN( 623)									if (img1->useVirtualPos) {
HXDLIN( 623)										location9 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 623)										location9 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 623)									int this134 = ::iterMagic::Iimg_obj::get(img1->image,location9);
HXDLIN( 623)									int this135;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										this135 = ((((((this134 >> 24) & 255) << 24) | ((this134 & 255) << 16)) | (((this134 >> 8) & 255) << 8)) | ((this134 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										this135 = this134;
            									}
HXDLIN( 623)									Float a111;
HXDLIN( 623)									int this136 = ((this135 >> 24) & 255);
HXDLIN( 623)									if ((this136 == 0)) {
HXDLIN( 623)										a111 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a111 = (( (Float)(this136) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r19;
HXDLIN( 623)									int this137 = ((this135 >> 16) & 255);
HXDLIN( 623)									if ((this137 == 0)) {
HXDLIN( 623)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r19 = (( (Float)(this137) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g19;
HXDLIN( 623)									int this138 = ((this135 >> 8) & 255);
HXDLIN( 623)									if ((this138 == 0)) {
HXDLIN( 623)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g19 = (( (Float)(this138) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b112;
HXDLIN( 623)									int this139 = (this135 & 255);
HXDLIN( 623)									if ((this139 == 0)) {
HXDLIN( 623)										b112 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b112 = (( (Float)(this139) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a210;
HXDLIN( 623)									int this140 = ((col1 >> 24) & 255);
HXDLIN( 623)									if ((this140 == 0)) {
HXDLIN( 623)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a210 = (( (Float)(this140) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r29;
HXDLIN( 623)									int this141 = ((col1 >> 16) & 255);
HXDLIN( 623)									if ((this141 == 0)) {
HXDLIN( 623)										r29 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r29 = (( (Float)(this141) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g29;
HXDLIN( 623)									int this142 = ((col1 >> 8) & 255);
HXDLIN( 623)									if ((this142 == 0)) {
HXDLIN( 623)										g29 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g29 = (( (Float)(this142) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b210;
HXDLIN( 623)									int this143 = (col1 & 255);
HXDLIN( 623)									if ((this143 == 0)) {
HXDLIN( 623)										b210 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b210 = (( (Float)(this143) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 623)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 623)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 623)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN( 623)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 623)									int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 623)									{
HXDLIN( 623)										int here35;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here35 = blended9;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(img1->image,location9,here35);
            									}
            								}
            								else {
HXDLIN( 623)									::Dynamic this144 = img1->image;
HXDLIN( 623)									int index22;
HXDLIN( 623)									if (img1->useVirtualPos) {
HXDLIN( 623)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - img1->virtualY) * ( (Float)(img1->width) )) + x16) - img1->virtualX));
            									}
            									else {
HXDLIN( 623)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * img1->width) + x16)) ));
            									}
HXDLIN( 623)									int here36;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										here36 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										here36 = c21;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this144,index22,here36);
            								}
            							}
            							else {
HXDLIN( 623)								if (forceClear1) {
HXDLIN( 623)									::Dynamic this145 = img1->image;
HXDLIN( 623)									int x17 = (1 + dx1);
HXDLIN( 623)									int y17 = (1 + dy1);
HXDLIN( 623)									int index23;
HXDLIN( 623)									if (img1->useVirtualPos) {
HXDLIN( 623)										index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - img1->virtualY) * ( (Float)(img1->width) )) + x17) - img1->virtualX));
            									}
            									else {
HXDLIN( 623)										index23 = ::Std_obj::_hx_int(( (Float)(((y17 * img1->width) + x17)) ));
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this145,index23,0);
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g68 = 0;
HXDLIN( 623)				int _g69 = this123->width;
HXDLIN( 623)				while((_g68 < _g69)){
HXDLIN( 623)					_g68 = (_g68 + 1);
HXDLIN( 623)					int x18 = (_g68 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g70 = 0;
HXDLIN( 623)						int _g71 = 1;
HXDLIN( 623)						while((_g70 < _g71)){
HXDLIN( 623)							_g70 = (_g70 + 1);
HXDLIN( 623)							int y18 = (_g70 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								int x19 = (x18 + 1);
HXDLIN( 623)								int y19 = (((this123->height - 1) - 1) + y18);
HXDLIN( 623)								::Dynamic this146 = this123->image;
HXDLIN( 623)								int index24;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this123->width) + x18)) ));
            								}
HXDLIN( 623)								int c22 = ::iterMagic::Iimg_obj::get(this146,index24);
HXDLIN( 623)								int color11;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color11 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color11 = c22;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c23 = color11;
HXDLIN( 623)									bool here37;
HXDLIN( 623)									if ((((c23 >> 24) & 255) < 254)) {
HXDLIN( 623)										here37 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here37 = false;
            									}
HXDLIN( 623)									if (here37) {
HXDLIN( 623)										int location10;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location10 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 623)										int this147 = ::iterMagic::Iimg_obj::get(img1->image,location10);
HXDLIN( 623)										int this148;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this148 = this147;
            										}
HXDLIN( 623)										Float a112;
HXDLIN( 623)										int this149 = ((this148 >> 24) & 255);
HXDLIN( 623)										if ((this149 == 0)) {
HXDLIN( 623)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a112 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r110;
HXDLIN( 623)										int this150 = ((this148 >> 16) & 255);
HXDLIN( 623)										if ((this150 == 0)) {
HXDLIN( 623)											r110 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r110 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g110;
HXDLIN( 623)										int this151 = ((this148 >> 8) & 255);
HXDLIN( 623)										if ((this151 == 0)) {
HXDLIN( 623)											g110 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g110 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b113;
HXDLIN( 623)										int this152 = (this148 & 255);
HXDLIN( 623)										if ((this152 == 0)) {
HXDLIN( 623)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b113 = (( (Float)(this152) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a211;
HXDLIN( 623)										int this153 = ((color11 >> 24) & 255);
HXDLIN( 623)										if ((this153 == 0)) {
HXDLIN( 623)											a211 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a211 = (( (Float)(this153) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r210;
HXDLIN( 623)										int this154 = ((color11 >> 16) & 255);
HXDLIN( 623)										if ((this154 == 0)) {
HXDLIN( 623)											r210 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g210;
HXDLIN( 623)										int this155 = ((color11 >> 8) & 255);
HXDLIN( 623)										if ((this155 == 0)) {
HXDLIN( 623)											g210 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b211;
HXDLIN( 623)										int this156 = (color11 & 255);
HXDLIN( 623)										if ((this156 == 0)) {
HXDLIN( 623)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b211 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 623)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 623)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 623)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN( 623)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 623)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b35);
HXDLIN( 623)										{
HXDLIN( 623)											int here38;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here38 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here38 = blended10;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location10,here38);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this157 = img1->image;
HXDLIN( 623)										int index25;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index25 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - img1->virtualY) * ( (Float)(img1->width) )) + x19) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index25 = ::Std_obj::_hx_int(( (Float)(((y18 * img1->width) + x19)) ));
            										}
HXDLIN( 623)										int here39;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here39 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here39 = c23;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this157,index25,here39);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x20 = (x18 + 1);
HXDLIN( 623)								int y20 = ((img1->height - y18) - 1);
HXDLIN( 623)								int y21 = (1 - y18);
HXDLIN( 623)								::Dynamic this158 = this123->image;
HXDLIN( 623)								int index26;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index26 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this123->virtualY) * ( (Float)(this123->width) )) + x18) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index26 = ::Std_obj::_hx_int(( (Float)(((y21 * this123->width) + x18)) ));
            								}
HXDLIN( 623)								int c24 = ::iterMagic::Iimg_obj::get(this158,index26);
HXDLIN( 623)								int color12;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color12 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color12 = c24;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c25 = color12;
HXDLIN( 623)									bool here40;
HXDLIN( 623)									if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 623)										here40 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here40 = false;
            									}
HXDLIN( 623)									if (here40) {
HXDLIN( 623)										int location11;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location11 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 623)										int this159 = ::iterMagic::Iimg_obj::get(img1->image,location11);
HXDLIN( 623)										int this160;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this160 = ((((((this159 >> 24) & 255) << 24) | ((this159 & 255) << 16)) | (((this159 >> 8) & 255) << 8)) | ((this159 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this160 = this159;
            										}
HXDLIN( 623)										Float a113;
HXDLIN( 623)										int this161 = ((this160 >> 24) & 255);
HXDLIN( 623)										if ((this161 == 0)) {
HXDLIN( 623)											a113 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r111;
HXDLIN( 623)										int this162 = ((this160 >> 16) & 255);
HXDLIN( 623)										if ((this162 == 0)) {
HXDLIN( 623)											r111 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r111 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g111;
HXDLIN( 623)										int this163 = ((this160 >> 8) & 255);
HXDLIN( 623)										if ((this163 == 0)) {
HXDLIN( 623)											g111 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g111 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b114;
HXDLIN( 623)										int this164 = (this160 & 255);
HXDLIN( 623)										if ((this164 == 0)) {
HXDLIN( 623)											b114 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b114 = (( (Float)(this164) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a212;
HXDLIN( 623)										int this165 = ((color12 >> 24) & 255);
HXDLIN( 623)										if ((this165 == 0)) {
HXDLIN( 623)											a212 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a212 = (( (Float)(this165) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r211;
HXDLIN( 623)										int this166 = ((color12 >> 16) & 255);
HXDLIN( 623)										if ((this166 == 0)) {
HXDLIN( 623)											r211 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r211 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g211;
HXDLIN( 623)										int this167 = ((color12 >> 8) & 255);
HXDLIN( 623)										if ((this167 == 0)) {
HXDLIN( 623)											g211 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g211 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b212;
HXDLIN( 623)										int this168 = (color12 & 255);
HXDLIN( 623)										if ((this168 == 0)) {
HXDLIN( 623)											b212 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b212 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 623)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 623)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 623)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN( 623)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 623)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b36);
HXDLIN( 623)										{
HXDLIN( 623)											int here41;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here41 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here41 = blended11;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location11,here41);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this169 = img1->image;
HXDLIN( 623)										int index27;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - img1->virtualY) * ( (Float)(img1->width) )) + x20) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * img1->width) + x20)) ));
            										}
HXDLIN( 623)										int here42;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here42 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here42 = c25;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this169,index27,here42);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g72 = 0;
HXDLIN( 623)				int _g73 = this123->height;
HXDLIN( 623)				while((_g72 < _g73)){
HXDLIN( 623)					_g72 = (_g72 + 1);
HXDLIN( 623)					int y22 = (_g72 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g74 = 0;
HXDLIN( 623)						int _g75 = 1;
HXDLIN( 623)						while((_g74 < _g75)){
HXDLIN( 623)							_g74 = (_g74 + 1);
HXDLIN( 623)							int x21 = (_g74 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								int y23 = (y22 + 1);
HXDLIN( 623)								int x22 = (((this123->width - 1) - 1) + x21);
HXDLIN( 623)								::Dynamic this170 = this123->image;
HXDLIN( 623)								int index28;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x22) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index28 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x22)) ));
            								}
HXDLIN( 623)								int c26 = ::iterMagic::Iimg_obj::get(this170,index28);
HXDLIN( 623)								int color13;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color13 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color13 = c26;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c27 = color13;
HXDLIN( 623)									bool here43;
HXDLIN( 623)									if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 623)										here43 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here43 = false;
            									}
HXDLIN( 623)									if (here43) {
HXDLIN( 623)										int location12;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location12 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location12 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 623)										int this171 = ::iterMagic::Iimg_obj::get(img1->image,location12);
HXDLIN( 623)										int this172;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this172 = ((((((this171 >> 24) & 255) << 24) | ((this171 & 255) << 16)) | (((this171 >> 8) & 255) << 8)) | ((this171 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this172 = this171;
            										}
HXDLIN( 623)										Float a114;
HXDLIN( 623)										int this173 = ((this172 >> 24) & 255);
HXDLIN( 623)										if ((this173 == 0)) {
HXDLIN( 623)											a114 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a114 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r112;
HXDLIN( 623)										int this174 = ((this172 >> 16) & 255);
HXDLIN( 623)										if ((this174 == 0)) {
HXDLIN( 623)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r112 = (( (Float)(this174) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g112;
HXDLIN( 623)										int this175 = ((this172 >> 8) & 255);
HXDLIN( 623)										if ((this175 == 0)) {
HXDLIN( 623)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g112 = (( (Float)(this175) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b115;
HXDLIN( 623)										int this176 = (this172 & 255);
HXDLIN( 623)										if ((this176 == 0)) {
HXDLIN( 623)											b115 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b115 = (( (Float)(this176) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a213;
HXDLIN( 623)										int this177 = ((color13 >> 24) & 255);
HXDLIN( 623)										if ((this177 == 0)) {
HXDLIN( 623)											a213 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a213 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r212;
HXDLIN( 623)										int this178 = ((color13 >> 16) & 255);
HXDLIN( 623)										if ((this178 == 0)) {
HXDLIN( 623)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r212 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g212;
HXDLIN( 623)										int this179 = ((color13 >> 8) & 255);
HXDLIN( 623)										if ((this179 == 0)) {
HXDLIN( 623)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g212 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b213;
HXDLIN( 623)										int this180 = (color13 & 255);
HXDLIN( 623)										if ((this180 == 0)) {
HXDLIN( 623)											b213 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b213 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 623)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 623)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 623)										int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN( 623)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 623)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN( 623)										{
HXDLIN( 623)											int here44;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here44 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here44 = blended12;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location12,here44);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this181 = img1->image;
HXDLIN( 623)										int index29;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - img1->virtualY) * ( (Float)(img1->width) )) + x21) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index29 = ::Std_obj::_hx_int(( (Float)(((y23 * img1->width) + x21)) ));
            										}
HXDLIN( 623)										int here45;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here45 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here45 = c27;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this181,index29,here45);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x23 = ((img1->width - x21) - 1);
HXDLIN( 623)								int y24 = (y22 + 1);
HXDLIN( 623)								int x24 = (1 - x21);
HXDLIN( 623)								::Dynamic this182 = this123->image;
HXDLIN( 623)								int index30;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index30 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this123->virtualY) * ( (Float)(this123->width) )) + x24) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index30 = ::Std_obj::_hx_int(( (Float)(((y22 * this123->width) + x24)) ));
            								}
HXDLIN( 623)								int c28 = ::iterMagic::Iimg_obj::get(this182,index30);
HXDLIN( 623)								int color14;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color14 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color14 = c28;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c29 = color14;
HXDLIN( 623)									bool here46;
HXDLIN( 623)									if ((((c29 >> 24) & 255) < 254)) {
HXDLIN( 623)										here46 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here46 = false;
            									}
HXDLIN( 623)									if (here46) {
HXDLIN( 623)										int location13;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location13 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location13 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 623)										int this183 = ::iterMagic::Iimg_obj::get(img1->image,location13);
HXDLIN( 623)										int this184;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this184 = ((((((this183 >> 24) & 255) << 24) | ((this183 & 255) << 16)) | (((this183 >> 8) & 255) << 8)) | ((this183 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this184 = this183;
            										}
HXDLIN( 623)										Float a115;
HXDLIN( 623)										int this185 = ((this184 >> 24) & 255);
HXDLIN( 623)										if ((this185 == 0)) {
HXDLIN( 623)											a115 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a115 = (( (Float)(this185) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r113;
HXDLIN( 623)										int this186 = ((this184 >> 16) & 255);
HXDLIN( 623)										if ((this186 == 0)) {
HXDLIN( 623)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r113 = (( (Float)(this186) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g113;
HXDLIN( 623)										int this187 = ((this184 >> 8) & 255);
HXDLIN( 623)										if ((this187 == 0)) {
HXDLIN( 623)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g113 = (( (Float)(this187) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b116;
HXDLIN( 623)										int this188 = (this184 & 255);
HXDLIN( 623)										if ((this188 == 0)) {
HXDLIN( 623)											b116 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b116 = (( (Float)(this188) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a214;
HXDLIN( 623)										int this189 = ((color14 >> 24) & 255);
HXDLIN( 623)										if ((this189 == 0)) {
HXDLIN( 623)											a214 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r213;
HXDLIN( 623)										int this190 = ((color14 >> 16) & 255);
HXDLIN( 623)										if ((this190 == 0)) {
HXDLIN( 623)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r213 = (( (Float)(this190) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g213;
HXDLIN( 623)										int this191 = ((color14 >> 8) & 255);
HXDLIN( 623)										if ((this191 == 0)) {
HXDLIN( 623)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g213 = (( (Float)(this191) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b214;
HXDLIN( 623)										int this192 = (color14 & 255);
HXDLIN( 623)										if ((this192 == 0)) {
HXDLIN( 623)											b214 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b214 = (( (Float)(this192) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 623)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 623)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 623)										int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN( 623)										int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 623)										int blended13 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN( 623)										{
HXDLIN( 623)											int here47;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here47 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here47 = blended13;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location13,here47);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this193 = img1->image;
HXDLIN( 623)										int index31;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index31 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - img1->virtualY) * ( (Float)(img1->width) )) + x23) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index31 = ::Std_obj::_hx_int(( (Float)(((y24 * img1->width) + x23)) ));
            										}
HXDLIN( 623)										int here48;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here48 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here48 = c29;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this193,index31,here48);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				int _g76 = 0;
HXDLIN( 623)				int _g77 = 1;
HXDLIN( 623)				while((_g76 < _g77)){
HXDLIN( 623)					_g76 = (_g76 + 1);
HXDLIN( 623)					int x25 = (_g76 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						int _g78 = 0;
HXDLIN( 623)						int _g79 = 1;
HXDLIN( 623)						while((_g78 < _g79)){
HXDLIN( 623)							_g78 = (_g78 + 1);
HXDLIN( 623)							int y25 = (_g78 - 1);
HXDLIN( 623)							{
HXDLIN( 623)								int x26 = (((this123->width - 1) - 1) + x25);
HXDLIN( 623)								int y26 = (((this123->height - 1) - 1) + y25);
HXDLIN( 623)								::Dynamic this194 = this123->image;
HXDLIN( 623)								int index32;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index32 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this123->virtualY) * ( (Float)(this123->width) )) + x26) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index32 = ::Std_obj::_hx_int(( (Float)(((y26 * this123->width) + x26)) ));
            								}
HXDLIN( 623)								int c30 = ::iterMagic::Iimg_obj::get(this194,index32);
HXDLIN( 623)								int color15;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color15 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color15 = c30;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c31 = color15;
HXDLIN( 623)									bool here49;
HXDLIN( 623)									if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 623)										here49 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here49 = false;
            									}
HXDLIN( 623)									if (here49) {
HXDLIN( 623)										int location14;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location14 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 623)										int this195 = ::iterMagic::Iimg_obj::get(img1->image,location14);
HXDLIN( 623)										int this196;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this196 = ((((((this195 >> 24) & 255) << 24) | ((this195 & 255) << 16)) | (((this195 >> 8) & 255) << 8)) | ((this195 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this196 = this195;
            										}
HXDLIN( 623)										Float a116;
HXDLIN( 623)										int this197 = ((this196 >> 24) & 255);
HXDLIN( 623)										if ((this197 == 0)) {
HXDLIN( 623)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a116 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r114;
HXDLIN( 623)										int this198 = ((this196 >> 16) & 255);
HXDLIN( 623)										if ((this198 == 0)) {
HXDLIN( 623)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r114 = (( (Float)(this198) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g114;
HXDLIN( 623)										int this199 = ((this196 >> 8) & 255);
HXDLIN( 623)										if ((this199 == 0)) {
HXDLIN( 623)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g114 = (( (Float)(this199) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b117;
HXDLIN( 623)										int this200 = (this196 & 255);
HXDLIN( 623)										if ((this200 == 0)) {
HXDLIN( 623)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b117 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a215;
HXDLIN( 623)										int this201 = ((color15 >> 24) & 255);
HXDLIN( 623)										if ((this201 == 0)) {
HXDLIN( 623)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a215 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r214;
HXDLIN( 623)										int this202 = ((color15 >> 16) & 255);
HXDLIN( 623)										if ((this202 == 0)) {
HXDLIN( 623)											r214 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r214 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g214;
HXDLIN( 623)										int this203 = ((color15 >> 8) & 255);
HXDLIN( 623)										if ((this203 == 0)) {
HXDLIN( 623)											g214 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g214 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b215;
HXDLIN( 623)										int this204 = (color15 & 255);
HXDLIN( 623)										if ((this204 == 0)) {
HXDLIN( 623)											b215 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 623)										int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 623)										int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 623)										int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN( 623)										int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 623)										int blended14 = ((((a44 << 24) | (r34 << 16)) | (g34 << 8)) | b39);
HXDLIN( 623)										{
HXDLIN( 623)											int here50;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here50 = blended14;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location14,here50);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this205 = img1->image;
HXDLIN( 623)										int index33;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index33 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x25)) ));
            										}
HXDLIN( 623)										int here51;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here51 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here51 = c31;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this205,index33,here51);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x27 = ((x25 + 1) + this123->width);
HXDLIN( 623)								int y27 = (((this123->height - 1) - 1) + y25);
HXDLIN( 623)								::Dynamic this206 = this123->image;
HXDLIN( 623)								int index34;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this123->width) + x25)) ));
            								}
HXDLIN( 623)								int c32 = ::iterMagic::Iimg_obj::get(this206,index34);
HXDLIN( 623)								int color16;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color16 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color16 = c32;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c33 = color16;
HXDLIN( 623)									bool here52;
HXDLIN( 623)									if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 623)										here52 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here52 = false;
            									}
HXDLIN( 623)									if (here52) {
HXDLIN( 623)										int location15;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location15 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location15 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 623)										int this207 = ::iterMagic::Iimg_obj::get(img1->image,location15);
HXDLIN( 623)										int this208;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this208 = ((((((this207 >> 24) & 255) << 24) | ((this207 & 255) << 16)) | (((this207 >> 8) & 255) << 8)) | ((this207 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this208 = this207;
            										}
HXDLIN( 623)										Float a117;
HXDLIN( 623)										int this209 = ((this208 >> 24) & 255);
HXDLIN( 623)										if ((this209 == 0)) {
HXDLIN( 623)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a117 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r115;
HXDLIN( 623)										int this210 = ((this208 >> 16) & 255);
HXDLIN( 623)										if ((this210 == 0)) {
HXDLIN( 623)											r115 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r115 = (( (Float)(this210) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g115;
HXDLIN( 623)										int this211 = ((this208 >> 8) & 255);
HXDLIN( 623)										if ((this211 == 0)) {
HXDLIN( 623)											g115 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g115 = (( (Float)(this211) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b118;
HXDLIN( 623)										int this212 = (this208 & 255);
HXDLIN( 623)										if ((this212 == 0)) {
HXDLIN( 623)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b118 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a216;
HXDLIN( 623)										int this213 = ((color16 >> 24) & 255);
HXDLIN( 623)										if ((this213 == 0)) {
HXDLIN( 623)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a216 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r215;
HXDLIN( 623)										int this214 = ((color16 >> 16) & 255);
HXDLIN( 623)										if ((this214 == 0)) {
HXDLIN( 623)											r215 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r215 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g215;
HXDLIN( 623)										int this215 = ((color16 >> 8) & 255);
HXDLIN( 623)										if ((this215 == 0)) {
HXDLIN( 623)											g215 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g215 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b216;
HXDLIN( 623)										int this216 = (color16 & 255);
HXDLIN( 623)										if ((this216 == 0)) {
HXDLIN( 623)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b216 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 623)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 623)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 623)										int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN( 623)										int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 623)										int blended15 = ((((a45 << 24) | (r35 << 16)) | (g35 << 8)) | b40);
HXDLIN( 623)										{
HXDLIN( 623)											int here53;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here53 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here53 = blended15;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location15,here53);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this217 = img1->image;
HXDLIN( 623)										int index35;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index35 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - img1->virtualY) * ( (Float)(img1->width) )) + x27) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index35 = ::Std_obj::_hx_int(( (Float)(((y25 * img1->width) + x27)) ));
            										}
HXDLIN( 623)										int here54;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here54 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here54 = c33;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this217,index35,here54);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int x28 = ((x25 + 1) + this123->width);
HXDLIN( 623)								int y28 = ((y25 + 1) + this123->height);
HXDLIN( 623)								::Dynamic this218 = this123->image;
HXDLIN( 623)								int index36;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index36 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x25) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index36 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x25)) ));
            								}
HXDLIN( 623)								int c34 = ::iterMagic::Iimg_obj::get(this218,index36);
HXDLIN( 623)								int color17;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color17 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color17 = c34;
            								}
HXDLIN( 623)								int color18 = color17;
HXDLIN( 623)								{
HXDLIN( 623)									int c35 = color18;
HXDLIN( 623)									bool here55;
HXDLIN( 623)									if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 623)										here55 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here55 = false;
            									}
HXDLIN( 623)									if (here55) {
HXDLIN( 623)										int location16;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location16 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location16 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 623)										int this219 = ::iterMagic::Iimg_obj::get(img1->image,location16);
HXDLIN( 623)										int this220;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this220 = ((((((this219 >> 24) & 255) << 24) | ((this219 & 255) << 16)) | (((this219 >> 8) & 255) << 8)) | ((this219 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this220 = this219;
            										}
HXDLIN( 623)										Float a118;
HXDLIN( 623)										int this221 = ((this220 >> 24) & 255);
HXDLIN( 623)										if ((this221 == 0)) {
HXDLIN( 623)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a118 = (( (Float)(this221) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r116;
HXDLIN( 623)										int this222 = ((this220 >> 16) & 255);
HXDLIN( 623)										if ((this222 == 0)) {
HXDLIN( 623)											r116 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r116 = (( (Float)(this222) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g116;
HXDLIN( 623)										int this223 = ((this220 >> 8) & 255);
HXDLIN( 623)										if ((this223 == 0)) {
HXDLIN( 623)											g116 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g116 = (( (Float)(this223) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b119;
HXDLIN( 623)										int this224 = (this220 & 255);
HXDLIN( 623)										if ((this224 == 0)) {
HXDLIN( 623)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b119 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a217;
HXDLIN( 623)										int this225 = ((color18 >> 24) & 255);
HXDLIN( 623)										if ((this225 == 0)) {
HXDLIN( 623)											a217 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a217 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r216;
HXDLIN( 623)										int this226 = ((color18 >> 16) & 255);
HXDLIN( 623)										if ((this226 == 0)) {
HXDLIN( 623)											r216 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r216 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g216;
HXDLIN( 623)										int this227 = ((color18 >> 8) & 255);
HXDLIN( 623)										if ((this227 == 0)) {
HXDLIN( 623)											g216 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g216 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b217;
HXDLIN( 623)										int this228 = (color18 & 255);
HXDLIN( 623)										if ((this228 == 0)) {
HXDLIN( 623)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b217 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a316 = (a118 * (( (Float)(1) ) - a217));
HXDLIN( 623)										int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 623)										int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 623)										int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a316) + (b217 * a217))));
HXDLIN( 623)										int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 623)										int blended16 = ((((a46 << 24) | (r36 << 16)) | (g36 << 8)) | b41);
HXDLIN( 623)										{
HXDLIN( 623)											int here56;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here56 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here56 = blended16;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location16,here56);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this229 = img1->image;
HXDLIN( 623)										int index37;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index37 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - img1->virtualY) * ( (Float)(img1->width) )) + x28) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index37 = ::Std_obj::_hx_int(( (Float)(((y28 * img1->width) + x28)) ));
            										}
HXDLIN( 623)										int here57;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here57 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here57 = c35;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this229,index37,here57);
            									}
            								}
            							}
HXDLIN( 623)							{
HXDLIN( 623)								int y29 = ((y25 + 1) + this123->width);
HXDLIN( 623)								int x29 = (((this123->width - 1) - 1) + x25);
HXDLIN( 623)								::Dynamic this230 = this123->image;
HXDLIN( 623)								int index38;
HXDLIN( 623)								if (this123->useVirtualPos) {
HXDLIN( 623)									index38 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this123->virtualY) * ( (Float)(this123->width) )) + x29) - this123->virtualX));
            								}
            								else {
HXDLIN( 623)									index38 = ::Std_obj::_hx_int(( (Float)(((y25 * this123->width) + x29)) ));
            								}
HXDLIN( 623)								int c36 = ::iterMagic::Iimg_obj::get(this230,index38);
HXDLIN( 623)								int color19;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									color19 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									color19 = c36;
            								}
HXDLIN( 623)								{
HXDLIN( 623)									int c37 = color19;
HXDLIN( 623)									bool here58;
HXDLIN( 623)									if ((((c37 >> 24) & 255) < 254)) {
HXDLIN( 623)										here58 = img1->transparent;
            									}
            									else {
HXDLIN( 623)										here58 = false;
            									}
HXDLIN( 623)									if (here58) {
HXDLIN( 623)										int location17;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											location17 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											location17 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 623)										int this231 = ::iterMagic::Iimg_obj::get(img1->image,location17);
HXDLIN( 623)										int this232;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											this232 = this231;
            										}
HXDLIN( 623)										Float a119;
HXDLIN( 623)										int this233 = ((this232 >> 24) & 255);
HXDLIN( 623)										if ((this233 == 0)) {
HXDLIN( 623)											a119 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a119 = (( (Float)(this233) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r117;
HXDLIN( 623)										int this234 = ((this232 >> 16) & 255);
HXDLIN( 623)										if ((this234 == 0)) {
HXDLIN( 623)											r117 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r117 = (( (Float)(this234) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g117;
HXDLIN( 623)										int this235 = ((this232 >> 8) & 255);
HXDLIN( 623)										if ((this235 == 0)) {
HXDLIN( 623)											g117 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g117 = (( (Float)(this235) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b120;
HXDLIN( 623)										int this236 = (this232 & 255);
HXDLIN( 623)										if ((this236 == 0)) {
HXDLIN( 623)											b120 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b120 = (( (Float)(this236) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a218;
HXDLIN( 623)										int this237 = ((color19 >> 24) & 255);
HXDLIN( 623)										if ((this237 == 0)) {
HXDLIN( 623)											a218 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											a218 = (( (Float)(this237) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float r217;
HXDLIN( 623)										int this238 = ((color19 >> 16) & 255);
HXDLIN( 623)										if ((this238 == 0)) {
HXDLIN( 623)											r217 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											r217 = (( (Float)(this238) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float g217;
HXDLIN( 623)										int this239 = ((color19 >> 8) & 255);
HXDLIN( 623)										if ((this239 == 0)) {
HXDLIN( 623)											g217 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											g217 = (( (Float)(this239) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float b218;
HXDLIN( 623)										int this240 = (color19 & 255);
HXDLIN( 623)										if ((this240 == 0)) {
HXDLIN( 623)											b218 = ((Float)0.);
            										}
            										else {
HXDLIN( 623)											b218 = (( (Float)(this240) ) / ( (Float)(255) ));
            										}
HXDLIN( 623)										Float a317 = (a119 * (( (Float)(1) ) - a218));
HXDLIN( 623)										int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 623)										int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 623)										int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a317) + (b218 * a218))));
HXDLIN( 623)										int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 623)										int blended17 = ((((a47 << 24) | (r37 << 16)) | (g37 << 8)) | b42);
HXDLIN( 623)										{
HXDLIN( 623)											int here59;
HXDLIN( 623)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)												here59 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            											}
            											else {
HXDLIN( 623)												here59 = blended17;
            											}
HXDLIN( 623)											::iterMagic::Iimg_obj::set(img1->image,location17,here59);
            										}
            									}
            									else {
HXDLIN( 623)										::Dynamic this241 = img1->image;
HXDLIN( 623)										int index39;
HXDLIN( 623)										if (img1->useVirtualPos) {
HXDLIN( 623)											index39 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - img1->virtualY) * ( (Float)(img1->width) )) + x25) - img1->virtualX));
            										}
            										else {
HXDLIN( 623)											index39 = ::Std_obj::_hx_int(( (Float)(((y29 * img1->width) + x25)) ));
            										}
HXDLIN( 623)										int here60;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											here60 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											here60 = c37;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(this241,index39,here60);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 623)				here = img1;
            			}
            			break;
            		}
HXDLIN( 623)		{
HXDLIN( 623)			int _g80 = 1;
HXDLIN( 623)			int _g81 = (this1->height - 2);
HXDLIN( 623)			while((_g80 < _g81)){
HXDLIN( 623)				_g80 = (_g80 + 1);
HXDLIN( 623)				int y30 = (_g80 - 1);
HXDLIN( 623)				{
HXDLIN( 623)					int _g82 = 1;
HXDLIN( 623)					int _g83 = (this1->width - 2);
HXDLIN( 623)					while((_g82 < _g83)){
HXDLIN( 623)						_g82 = (_g82 + 1);
HXDLIN( 623)						int x30 = (_g82 - 1);
HXDLIN( 623)						if ((x30 == 1)) {
HXDLIN( 623)							int x31 = (x30 - 1);
HXDLIN( 623)							int y31 = (y30 - 1);
HXDLIN( 623)							::Dynamic this242 = here->image;
HXDLIN( 623)							int index40;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index40 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - here->virtualY) * ( (Float)(here->width) )) + x31) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index40 = ::Std_obj::_hx_int(( (Float)(((y31 * here->width) + x31)) ));
            							}
HXDLIN( 623)							int c38 = ::iterMagic::Iimg_obj::get(this242,index40);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								a0 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								a0 = c38;
            							}
HXDLIN( 623)							int y32 = (y30 - 1);
HXDLIN( 623)							::Dynamic this243 = here->image;
HXDLIN( 623)							int index41;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index41 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index41 = ::Std_obj::_hx_int(( (Float)(((y32 * here->width) + x30)) ));
            							}
HXDLIN( 623)							int c39 = ::iterMagic::Iimg_obj::get(this243,index41);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								b0 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								b0 = c39;
            							}
HXDLIN( 623)							int x32 = (x30 + 1);
HXDLIN( 623)							int y33 = (y30 - 1);
HXDLIN( 623)							::Dynamic this244 = here->image;
HXDLIN( 623)							int index42;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index42 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - here->virtualY) * ( (Float)(here->width) )) + x32) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index42 = ::Std_obj::_hx_int(( (Float)(((y33 * here->width) + x32)) ));
            							}
HXDLIN( 623)							int c40 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								c0 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								c0 = c40;
            							}
HXDLIN( 623)							int x33 = (x30 - 1);
HXDLIN( 623)							::Dynamic this245 = here->image;
HXDLIN( 623)							int index43;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index43 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x33) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index43 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x33)) ));
            							}
HXDLIN( 623)							int c41 = ::iterMagic::Iimg_obj::get(this245,index43);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								d0 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								d0 = c41;
            							}
HXDLIN( 623)							::Dynamic this246 = here->image;
HXDLIN( 623)							int index44;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index44 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x30)) ));
            							}
HXDLIN( 623)							int c42 = ::iterMagic::Iimg_obj::get(this246,index44);
HXDLIN( 623)							int e01;
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								e01 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								e01 = c42;
            							}
HXLINE( 163)							e0 = e01;
HXLINE( 623)							int x34 = (x30 + 1);
HXDLIN( 623)							::Dynamic this247 = here->image;
HXDLIN( 623)							int index45;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index45 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x34) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index45 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x34)) ));
            							}
HXDLIN( 623)							int c43 = ::iterMagic::Iimg_obj::get(this247,index45);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								f0 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								f0 = c43;
            							}
HXDLIN( 623)							int x35 = (x30 - 1);
HXDLIN( 623)							int y34 = (y30 + 1);
HXDLIN( 623)							::Dynamic this248 = here->image;
HXDLIN( 623)							int index46;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index46 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - here->virtualY) * ( (Float)(here->width) )) + x35) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index46 = ::Std_obj::_hx_int(( (Float)(((y34 * here->width) + x35)) ));
            							}
HXDLIN( 623)							int c44 = ::iterMagic::Iimg_obj::get(this248,index46);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								g0 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								g0 = c44;
            							}
HXDLIN( 623)							int y35 = (y30 + 1);
HXDLIN( 623)							::Dynamic this249 = here->image;
HXDLIN( 623)							int index47;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index47 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - here->virtualY) * ( (Float)(here->width) )) + x30) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index47 = ::Std_obj::_hx_int(( (Float)(((y35 * here->width) + x30)) ));
            							}
HXDLIN( 623)							int c45 = ::iterMagic::Iimg_obj::get(this249,index47);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								h0 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								h0 = c45;
            							}
HXDLIN( 623)							int x36 = (x30 + 1);
HXDLIN( 623)							int y36 = (y30 + 1);
HXDLIN( 623)							::Dynamic this250 = here->image;
HXDLIN( 623)							int index48;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index48 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - here->virtualY) * ( (Float)(here->width) )) + x36) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index48 = ::Std_obj::_hx_int(( (Float)(((y36 * here->width) + x36)) ));
            							}
HXDLIN( 623)							int c46 = ::iterMagic::Iimg_obj::get(this250,index48);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								i0 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								i0 = c46;
            							}
            						}
            						else {
HXLINE( 171)							a0 = b0;
HXLINE( 172)							b0 = c0;
HXLINE( 623)							int x37 = (x30 + 1);
HXDLIN( 623)							int y37 = (y30 - 1);
HXDLIN( 623)							::Dynamic this251 = here->image;
HXDLIN( 623)							int index49;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index49 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - here->virtualY) * ( (Float)(here->width) )) + x37) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index49 = ::Std_obj::_hx_int(( (Float)(((y37 * here->width) + x37)) ));
            							}
HXDLIN( 623)							int c47 = ::iterMagic::Iimg_obj::get(this251,index49);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								c0 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								c0 = c47;
            							}
HXLINE( 174)							d0 = e0;
HXLINE( 175)							e0 = f0;
HXLINE( 623)							int x38 = (x30 + 1);
HXDLIN( 623)							::Dynamic this252 = here->image;
HXDLIN( 623)							int index50;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index50 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - here->virtualY) * ( (Float)(here->width) )) + x38) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index50 = ::Std_obj::_hx_int(( (Float)(((y30 * here->width) + x38)) ));
            							}
HXDLIN( 623)							int c48 = ::iterMagic::Iimg_obj::get(this252,index50);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								f0 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								f0 = c48;
            							}
HXLINE( 177)							g0 = h0;
HXLINE( 178)							h0 = i0;
HXLINE( 623)							int x39 = (x30 + 1);
HXDLIN( 623)							int y38 = (y30 + 1);
HXDLIN( 623)							::Dynamic this253 = here->image;
HXDLIN( 623)							int index51;
HXDLIN( 623)							if (here->useVirtualPos) {
HXDLIN( 623)								index51 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - here->virtualY) * ( (Float)(here->width) )) + x39) - here->virtualX));
            							}
            							else {
HXDLIN( 623)								index51 = ::Std_obj::_hx_int(( (Float)(((y38 * here->width) + x39)) ));
            							}
HXDLIN( 623)							int c49 = ::iterMagic::Iimg_obj::get(this253,index51);
HXDLIN( 623)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)								i0 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            							}
            							else {
HXDLIN( 623)								i0 = c49;
            							}
            						}
HXDLIN( 623)						if (adjustRed) {
HXLINE( 182)							r_ = ((Float)0.);
HXLINE( 623)							bool _hx_tmp2;
HXDLIN( 623)							if ((m33_a != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp2 = (a0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp2 = false;
            							}
HXDLIN( 623)							if (_hx_tmp2) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((a0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 623)							bool _hx_tmp3;
HXDLIN( 623)							if ((m33_b != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp3 = (b0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp3 = false;
            							}
HXDLIN( 623)							if (_hx_tmp3) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((b0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 623)							bool _hx_tmp4;
HXDLIN( 623)							if ((m33_c != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp4 = (c0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp4 = false;
            							}
HXDLIN( 623)							if (_hx_tmp4) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((c0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 623)							bool _hx_tmp5;
HXDLIN( 623)							if ((m33_d != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp5 = (d0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp5 = false;
            							}
HXDLIN( 623)							if (_hx_tmp5) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((d0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 623)							bool _hx_tmp6;
HXDLIN( 623)							if ((m33_e != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp6 = (e0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp6 = false;
            							}
HXDLIN( 623)							if (_hx_tmp6) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 623)							bool _hx_tmp7;
HXDLIN( 623)							if ((m33_f != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp7 = (f0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp7 = false;
            							}
HXDLIN( 623)							if (_hx_tmp7) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((f0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 623)							bool _hx_tmp8;
HXDLIN( 623)							if ((m33_g != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp8 = (g0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp8 = false;
            							}
HXDLIN( 623)							if (_hx_tmp8) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((g0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 623)							bool _hx_tmp9;
HXDLIN( 623)							if ((m33_h != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp9 = (h0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp9 = false;
            							}
HXDLIN( 623)							if (_hx_tmp9) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((h0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 623)							bool _hx_tmp10;
HXDLIN( 623)							if ((m33_i != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp10 = (i0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp10 = false;
            							}
HXDLIN( 623)							if (_hx_tmp10) {
HXDLIN( 623)								r_ = (r_ + ((( (Float)(((i0 >> 16) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 193)							r_ = (( (Float)(((e0 >> 16) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 623)						if (adjustGreen) {
HXLINE( 196)							g_ = ((Float)0.);
HXLINE( 623)							bool _hx_tmp11;
HXDLIN( 623)							if ((m33_a != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp11 = (a0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp11 = false;
            							}
HXDLIN( 623)							if (_hx_tmp11) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((a0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 623)							bool _hx_tmp12;
HXDLIN( 623)							if ((m33_b != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp12 = (b0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp12 = false;
            							}
HXDLIN( 623)							if (_hx_tmp12) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((b0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 623)							bool _hx_tmp13;
HXDLIN( 623)							if ((m33_c != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp13 = (c0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp13 = false;
            							}
HXDLIN( 623)							if (_hx_tmp13) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((c0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 623)							bool _hx_tmp14;
HXDLIN( 623)							if ((m33_d != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp14 = (d0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp14 = false;
            							}
HXDLIN( 623)							if (_hx_tmp14) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((d0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 623)							bool _hx_tmp15;
HXDLIN( 623)							if ((m33_e != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp15 = (e0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp15 = false;
            							}
HXDLIN( 623)							if (_hx_tmp15) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 623)							bool _hx_tmp16;
HXDLIN( 623)							if ((m33_f != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp16 = (f0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp16 = false;
            							}
HXDLIN( 623)							if (_hx_tmp16) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((f0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 623)							bool _hx_tmp17;
HXDLIN( 623)							if ((m33_g != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp17 = (g0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp17 = false;
            							}
HXDLIN( 623)							if (_hx_tmp17) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((g0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 623)							bool _hx_tmp18;
HXDLIN( 623)							if ((m33_h != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp18 = (h0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp18 = false;
            							}
HXDLIN( 623)							if (_hx_tmp18) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((h0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 623)							bool _hx_tmp19;
HXDLIN( 623)							if ((m33_i != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp19 = (i0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp19 = false;
            							}
HXDLIN( 623)							if (_hx_tmp19) {
HXDLIN( 623)								g_ = (g_ + ((( (Float)(((i0 >> 8) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 207)							g_ = (( (Float)(((e0 >> 8) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 623)						if (adjustBlue) {
HXLINE( 210)							b_ = ((Float)0.);
HXLINE( 623)							bool _hx_tmp20;
HXDLIN( 623)							if ((m33_a != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp20 = (a0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp20 = false;
            							}
HXDLIN( 623)							if (_hx_tmp20) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((a0 & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 623)							bool _hx_tmp21;
HXDLIN( 623)							if ((m33_b != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp21 = (b0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp21 = false;
            							}
HXDLIN( 623)							if (_hx_tmp21) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((b0 & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 623)							bool _hx_tmp22;
HXDLIN( 623)							if ((m33_c != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp22 = (c0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp22 = false;
            							}
HXDLIN( 623)							if (_hx_tmp22) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((c0 & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 623)							bool _hx_tmp23;
HXDLIN( 623)							if ((m33_d != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp23 = (d0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp23 = false;
            							}
HXDLIN( 623)							if (_hx_tmp23) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((d0 & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 623)							bool _hx_tmp24;
HXDLIN( 623)							if ((m33_e != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp24 = (e0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp24 = false;
            							}
HXDLIN( 623)							if (_hx_tmp24) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((e0 & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 623)							bool _hx_tmp25;
HXDLIN( 623)							if ((m33_f != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp25 = (f0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp25 = false;
            							}
HXDLIN( 623)							if (_hx_tmp25) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((f0 & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 623)							bool _hx_tmp26;
HXDLIN( 623)							if ((m33_g != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp26 = (g0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp26 = false;
            							}
HXDLIN( 623)							if (_hx_tmp26) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((g0 & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 623)							bool _hx_tmp27;
HXDLIN( 623)							if ((m33_h != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp27 = (h0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp27 = false;
            							}
HXDLIN( 623)							if (_hx_tmp27) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((h0 & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 623)							bool _hx_tmp28;
HXDLIN( 623)							if ((m33_i != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp28 = (i0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp28 = false;
            							}
HXDLIN( 623)							if (_hx_tmp28) {
HXDLIN( 623)								b_ = (b_ + ((( (Float)((i0 & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 221)							b_ = (( (Float)((e0 & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 623)						if (adjustAlpha) {
HXLINE( 224)							a_ = ((Float)0.);
HXLINE( 623)							bool _hx_tmp29;
HXDLIN( 623)							if ((m33_a != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp29 = (a0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp29 = false;
            							}
HXDLIN( 623)							if (_hx_tmp29) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((a0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_a));
            							}
HXDLIN( 623)							bool _hx_tmp30;
HXDLIN( 623)							if ((m33_b != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp30 = (b0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp30 = false;
            							}
HXDLIN( 623)							if (_hx_tmp30) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((b0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_b));
            							}
HXDLIN( 623)							bool _hx_tmp31;
HXDLIN( 623)							if ((m33_c != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp31 = (c0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp31 = false;
            							}
HXDLIN( 623)							if (_hx_tmp31) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((c0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_c));
            							}
HXDLIN( 623)							bool _hx_tmp32;
HXDLIN( 623)							if ((m33_d != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp32 = (d0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp32 = false;
            							}
HXDLIN( 623)							if (_hx_tmp32) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((d0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_d));
            							}
HXDLIN( 623)							bool _hx_tmp33;
HXDLIN( 623)							if ((m33_e != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp33 = (e0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp33 = false;
            							}
HXDLIN( 623)							if (_hx_tmp33) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_e));
            							}
HXDLIN( 623)							bool _hx_tmp34;
HXDLIN( 623)							if ((m33_f != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp34 = (f0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp34 = false;
            							}
HXDLIN( 623)							if (_hx_tmp34) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((f0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_f));
            							}
HXDLIN( 623)							bool _hx_tmp35;
HXDLIN( 623)							if ((m33_g != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp35 = (g0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp35 = false;
            							}
HXDLIN( 623)							if (_hx_tmp35) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((g0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_g));
            							}
HXDLIN( 623)							bool _hx_tmp36;
HXDLIN( 623)							if ((m33_h != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp36 = (h0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp36 = false;
            							}
HXDLIN( 623)							if (_hx_tmp36) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((h0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_h));
            							}
HXDLIN( 623)							bool _hx_tmp37;
HXDLIN( 623)							if ((m33_i != ((Float)0.))) {
HXDLIN( 623)								_hx_tmp37 = (i0 != 0);
            							}
            							else {
HXDLIN( 623)								_hx_tmp37 = false;
            							}
HXDLIN( 623)							if (_hx_tmp37) {
HXDLIN( 623)								a_ = (a_ + ((( (Float)(((i0 >> 24) & 255)) ) / ( (Float)(255) )) * m33_i));
            							}
            						}
            						else {
HXLINE( 235)							a_ = (( (Float)(((e0 >> 24) & 255)) ) / ( (Float)(255) ));
            						}
HXLINE( 623)						bool _hx_tmp38;
HXDLIN( 623)						if ((borderMode != 0)) {
HXDLIN( 623)							_hx_tmp38 = (borderMode == 2);
            						}
            						else {
HXDLIN( 623)							_hx_tmp38 = true;
            						}
HXDLIN( 623)						if (_hx_tmp38) {
HXDLIN( 623)							int x40 = (x30 - 1);
HXDLIN( 623)							int y39 = (y30 - 1);
HXDLIN( 623)							int color20 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 623)							{
HXDLIN( 623)								int c50 = color20;
HXDLIN( 623)								bool _hx_tmp39;
HXDLIN( 623)								if ((((c50 >> 24) & 255) < 254)) {
HXDLIN( 623)									_hx_tmp39 = out->transparent;
            								}
            								else {
HXDLIN( 623)									_hx_tmp39 = false;
            								}
HXDLIN( 623)								if (_hx_tmp39) {
HXDLIN( 623)									int location18;
HXDLIN( 623)									if (out->useVirtualPos) {
HXDLIN( 623)										location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 623)										location18 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 623)									int this254 = ::iterMagic::Iimg_obj::get(out->image,location18);
HXDLIN( 623)									int this255;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										this255 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										this255 = this254;
            									}
HXDLIN( 623)									Float a120;
HXDLIN( 623)									int this256 = ((this255 >> 24) & 255);
HXDLIN( 623)									if ((this256 == 0)) {
HXDLIN( 623)										a120 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a120 = (( (Float)(this256) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r118;
HXDLIN( 623)									int this257 = ((this255 >> 16) & 255);
HXDLIN( 623)									if ((this257 == 0)) {
HXDLIN( 623)										r118 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r118 = (( (Float)(this257) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g118;
HXDLIN( 623)									int this258 = ((this255 >> 8) & 255);
HXDLIN( 623)									if ((this258 == 0)) {
HXDLIN( 623)										g118 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g118 = (( (Float)(this258) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b121;
HXDLIN( 623)									int this259 = (this255 & 255);
HXDLIN( 623)									if ((this259 == 0)) {
HXDLIN( 623)										b121 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b121 = (( (Float)(this259) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a219;
HXDLIN( 623)									int this260 = ((color20 >> 24) & 255);
HXDLIN( 623)									if ((this260 == 0)) {
HXDLIN( 623)										a219 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a219 = (( (Float)(this260) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r218;
HXDLIN( 623)									int this261 = ((color20 >> 16) & 255);
HXDLIN( 623)									if ((this261 == 0)) {
HXDLIN( 623)										r218 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r218 = (( (Float)(this261) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g218;
HXDLIN( 623)									int this262 = ((color20 >> 8) & 255);
HXDLIN( 623)									if ((this262 == 0)) {
HXDLIN( 623)										g218 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g218 = (( (Float)(this262) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b219;
HXDLIN( 623)									int this263 = (color20 & 255);
HXDLIN( 623)									if ((this263 == 0)) {
HXDLIN( 623)										b219 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b219 = (( (Float)(this263) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a318 = (a120 * (( (Float)(1) ) - a219));
HXDLIN( 623)									int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 623)									int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 623)									int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a318) + (b219 * a219))));
HXDLIN( 623)									int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 623)									int blended18 = ((((a48 << 24) | (r38 << 16)) | (g38 << 8)) | b43);
HXDLIN( 623)									{
HXDLIN( 623)										int _hx_tmp40;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											_hx_tmp40 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											_hx_tmp40 = blended18;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(out->image,location18,_hx_tmp40);
            									}
            								}
            								else {
HXDLIN( 623)									::Dynamic this264 = out->image;
HXDLIN( 623)									int index52;
HXDLIN( 623)									if (out->useVirtualPos) {
HXDLIN( 623)										index52 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - out->virtualY) * ( (Float)(out->width) )) + x40) - out->virtualX));
            									}
            									else {
HXDLIN( 623)										index52 = ::Std_obj::_hx_int(( (Float)(((y39 * out->width) + x40)) ));
            									}
HXDLIN( 623)									int _hx_tmp41;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp41 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp41 = c50;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this264,index52,_hx_tmp41);
            								}
            							}
            						}
            						else {
HXDLIN( 623)							int color21 = ((((::Math_obj::round((a_ * ( (Float)(255) ))) << 24) | (::Math_obj::round((r_ * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g_ * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b_ * ( (Float)(255) ))));
HXDLIN( 623)							{
HXDLIN( 623)								int c51 = color21;
HXDLIN( 623)								bool _hx_tmp42;
HXDLIN( 623)								if ((((c51 >> 24) & 255) < 254)) {
HXDLIN( 623)									_hx_tmp42 = out->transparent;
            								}
            								else {
HXDLIN( 623)									_hx_tmp42 = false;
            								}
HXDLIN( 623)								if (_hx_tmp42) {
HXDLIN( 623)									int location19;
HXDLIN( 623)									if (out->useVirtualPos) {
HXDLIN( 623)										location19 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 623)										location19 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 623)									int this265 = ::iterMagic::Iimg_obj::get(out->image,location19);
HXDLIN( 623)									int this266;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										this266 = this265;
            									}
HXDLIN( 623)									Float a121;
HXDLIN( 623)									int this267 = ((this266 >> 24) & 255);
HXDLIN( 623)									if ((this267 == 0)) {
HXDLIN( 623)										a121 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a121 = (( (Float)(this267) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r119;
HXDLIN( 623)									int this268 = ((this266 >> 16) & 255);
HXDLIN( 623)									if ((this268 == 0)) {
HXDLIN( 623)										r119 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r119 = (( (Float)(this268) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g119;
HXDLIN( 623)									int this269 = ((this266 >> 8) & 255);
HXDLIN( 623)									if ((this269 == 0)) {
HXDLIN( 623)										g119 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g119 = (( (Float)(this269) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b122;
HXDLIN( 623)									int this270 = (this266 & 255);
HXDLIN( 623)									if ((this270 == 0)) {
HXDLIN( 623)										b122 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b122 = (( (Float)(this270) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a220;
HXDLIN( 623)									int this271 = ((color21 >> 24) & 255);
HXDLIN( 623)									if ((this271 == 0)) {
HXDLIN( 623)										a220 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										a220 = (( (Float)(this271) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float r219;
HXDLIN( 623)									int this272 = ((color21 >> 16) & 255);
HXDLIN( 623)									if ((this272 == 0)) {
HXDLIN( 623)										r219 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										r219 = (( (Float)(this272) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float g219;
HXDLIN( 623)									int this273 = ((color21 >> 8) & 255);
HXDLIN( 623)									if ((this273 == 0)) {
HXDLIN( 623)										g219 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										g219 = (( (Float)(this273) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float b220;
HXDLIN( 623)									int this274 = (color21 & 255);
HXDLIN( 623)									if ((this274 == 0)) {
HXDLIN( 623)										b220 = ((Float)0.);
            									}
            									else {
HXDLIN( 623)										b220 = (( (Float)(this274) ) / ( (Float)(255) ));
            									}
HXDLIN( 623)									Float a319 = (a121 * (( (Float)(1) ) - a220));
HXDLIN( 623)									int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 623)									int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 623)									int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a319) + (b220 * a220))));
HXDLIN( 623)									int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 623)									int blended19 = ((((a49 << 24) | (r39 << 16)) | (g39 << 8)) | b44);
HXDLIN( 623)									{
HXDLIN( 623)										int _hx_tmp43;
HXDLIN( 623)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)											_hx_tmp43 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            										}
            										else {
HXDLIN( 623)											_hx_tmp43 = blended19;
            										}
HXDLIN( 623)										::iterMagic::Iimg_obj::set(out->image,location19,_hx_tmp43);
            									}
            								}
            								else {
HXDLIN( 623)									::Dynamic this275 = out->image;
HXDLIN( 623)									int index53;
HXDLIN( 623)									if (out->useVirtualPos) {
HXDLIN( 623)										index53 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - out->virtualY) * ( (Float)(out->width) )) + x30) - out->virtualX));
            									}
            									else {
HXDLIN( 623)										index53 = ::Std_obj::_hx_int(( (Float)(((y30 * out->width) + x30)) ));
            									}
HXDLIN( 623)									int _hx_tmp44;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp44 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp44 = c51;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(this275,index53,_hx_tmp44);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 623)		if ((borderMode == 1)) {
HXDLIN( 623)			{
HXDLIN( 623)				int _g84 = 0;
HXDLIN( 623)				int _g85 = (this1->width - 1);
HXDLIN( 623)				while((_g84 < _g85)){
HXDLIN( 623)					_g84 = (_g84 + 1);
HXDLIN( 623)					int x41 = (_g84 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						::Dynamic this276 = here->image;
HXDLIN( 623)						int index54;
HXDLIN( 623)						if (here->useVirtualPos) {
HXDLIN( 623)							index54 = ::Std_obj::_hx_int(((((( (Float)(0) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 623)							index54 = ::Std_obj::_hx_int(( (Float)(((0 * here->width) + x41)) ));
            						}
HXDLIN( 623)						int c52 = ::iterMagic::Iimg_obj::get(this276,index54);
HXDLIN( 623)						int color22;
HXDLIN( 623)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)							color22 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            						}
            						else {
HXDLIN( 623)							color22 = c52;
            						}
HXDLIN( 623)						int color23 = color22;
HXDLIN( 623)						{
HXDLIN( 623)							int c53 = color23;
HXDLIN( 623)							bool _hx_tmp45;
HXDLIN( 623)							if ((((c53 >> 24) & 255) < 254)) {
HXDLIN( 623)								_hx_tmp45 = out->transparent;
            							}
            							else {
HXDLIN( 623)								_hx_tmp45 = false;
            							}
HXDLIN( 623)							if (_hx_tmp45) {
HXDLIN( 623)								int location20;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									location20 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									location20 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 623)								int this277 = ::iterMagic::Iimg_obj::get(out->image,location20);
HXDLIN( 623)								int this278;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									this278 = ((((((this277 >> 24) & 255) << 24) | ((this277 & 255) << 16)) | (((this277 >> 8) & 255) << 8)) | ((this277 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									this278 = this277;
            								}
HXDLIN( 623)								Float a122;
HXDLIN( 623)								int this279 = ((this278 >> 24) & 255);
HXDLIN( 623)								if ((this279 == 0)) {
HXDLIN( 623)									a122 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a122 = (( (Float)(this279) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r120;
HXDLIN( 623)								int this280 = ((this278 >> 16) & 255);
HXDLIN( 623)								if ((this280 == 0)) {
HXDLIN( 623)									r120 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r120 = (( (Float)(this280) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g120;
HXDLIN( 623)								int this281 = ((this278 >> 8) & 255);
HXDLIN( 623)								if ((this281 == 0)) {
HXDLIN( 623)									g120 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g120 = (( (Float)(this281) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b123;
HXDLIN( 623)								int this282 = (this278 & 255);
HXDLIN( 623)								if ((this282 == 0)) {
HXDLIN( 623)									b123 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b123 = (( (Float)(this282) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a221;
HXDLIN( 623)								int this283 = ((color23 >> 24) & 255);
HXDLIN( 623)								if ((this283 == 0)) {
HXDLIN( 623)									a221 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a221 = (( (Float)(this283) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r220;
HXDLIN( 623)								int this284 = ((color23 >> 16) & 255);
HXDLIN( 623)								if ((this284 == 0)) {
HXDLIN( 623)									r220 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r220 = (( (Float)(this284) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g220;
HXDLIN( 623)								int this285 = ((color23 >> 8) & 255);
HXDLIN( 623)								if ((this285 == 0)) {
HXDLIN( 623)									g220 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g220 = (( (Float)(this285) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b221;
HXDLIN( 623)								int this286 = (color23 & 255);
HXDLIN( 623)								if ((this286 == 0)) {
HXDLIN( 623)									b221 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b221 = (( (Float)(this286) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a320 = (a122 * (( (Float)(1) ) - a221));
HXDLIN( 623)								int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 623)								int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 623)								int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a320) + (b221 * a221))));
HXDLIN( 623)								int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 623)								int blended20 = ((((a50 << 24) | (r40 << 16)) | (g40 << 8)) | b45);
HXDLIN( 623)								{
HXDLIN( 623)									int _hx_tmp46;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp46 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp46 = blended20;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(out->image,location20,_hx_tmp46);
            								}
            							}
            							else {
HXDLIN( 623)								::Dynamic this287 = out->image;
HXDLIN( 623)								int index55;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									index55 = ::Std_obj::_hx_int(((((( (Float)(0) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									index55 = ::Std_obj::_hx_int(( (Float)(((0 * out->width) + x41)) ));
            								}
HXDLIN( 623)								int _hx_tmp47;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									_hx_tmp47 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									_hx_tmp47 = c53;
            								}
HXDLIN( 623)								::iterMagic::Iimg_obj::set(this287,index55,_hx_tmp47);
            							}
            						}
            					}
HXDLIN( 623)					{
HXDLIN( 623)						int y40 = (this1->height - 1);
HXDLIN( 623)						int y41 = (this1->height - 1);
HXDLIN( 623)						::Dynamic this288 = here->image;
HXDLIN( 623)						int index56;
HXDLIN( 623)						if (here->useVirtualPos) {
HXDLIN( 623)							index56 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - here->virtualY) * ( (Float)(here->width) )) + x41) - here->virtualX));
            						}
            						else {
HXDLIN( 623)							index56 = ::Std_obj::_hx_int(( (Float)(((y41 * here->width) + x41)) ));
            						}
HXDLIN( 623)						int c54 = ::iterMagic::Iimg_obj::get(this288,index56);
HXDLIN( 623)						int color24;
HXDLIN( 623)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)							color24 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            						}
            						else {
HXDLIN( 623)							color24 = c54;
            						}
HXDLIN( 623)						{
HXDLIN( 623)							int c55 = color24;
HXDLIN( 623)							bool _hx_tmp48;
HXDLIN( 623)							if ((((c55 >> 24) & 255) < 254)) {
HXDLIN( 623)								_hx_tmp48 = out->transparent;
            							}
            							else {
HXDLIN( 623)								_hx_tmp48 = false;
            							}
HXDLIN( 623)							if (_hx_tmp48) {
HXDLIN( 623)								int location21;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									location21 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 623)								int this289 = ::iterMagic::Iimg_obj::get(out->image,location21);
HXDLIN( 623)								int this290;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									this290 = ((((((this289 >> 24) & 255) << 24) | ((this289 & 255) << 16)) | (((this289 >> 8) & 255) << 8)) | ((this289 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									this290 = this289;
            								}
HXDLIN( 623)								Float a123;
HXDLIN( 623)								int this291 = ((this290 >> 24) & 255);
HXDLIN( 623)								if ((this291 == 0)) {
HXDLIN( 623)									a123 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a123 = (( (Float)(this291) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r121;
HXDLIN( 623)								int this292 = ((this290 >> 16) & 255);
HXDLIN( 623)								if ((this292 == 0)) {
HXDLIN( 623)									r121 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r121 = (( (Float)(this292) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g121;
HXDLIN( 623)								int this293 = ((this290 >> 8) & 255);
HXDLIN( 623)								if ((this293 == 0)) {
HXDLIN( 623)									g121 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g121 = (( (Float)(this293) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b124;
HXDLIN( 623)								int this294 = (this290 & 255);
HXDLIN( 623)								if ((this294 == 0)) {
HXDLIN( 623)									b124 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b124 = (( (Float)(this294) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a222;
HXDLIN( 623)								int this295 = ((color24 >> 24) & 255);
HXDLIN( 623)								if ((this295 == 0)) {
HXDLIN( 623)									a222 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a222 = (( (Float)(this295) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r221;
HXDLIN( 623)								int this296 = ((color24 >> 16) & 255);
HXDLIN( 623)								if ((this296 == 0)) {
HXDLIN( 623)									r221 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r221 = (( (Float)(this296) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g221;
HXDLIN( 623)								int this297 = ((color24 >> 8) & 255);
HXDLIN( 623)								if ((this297 == 0)) {
HXDLIN( 623)									g221 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g221 = (( (Float)(this297) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b222;
HXDLIN( 623)								int this298 = (color24 & 255);
HXDLIN( 623)								if ((this298 == 0)) {
HXDLIN( 623)									b222 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b222 = (( (Float)(this298) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a321 = (a123 * (( (Float)(1) ) - a222));
HXDLIN( 623)								int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 623)								int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 623)								int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a321) + (b222 * a222))));
HXDLIN( 623)								int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 623)								int blended21 = ((((a51 << 24) | (r41 << 16)) | (g41 << 8)) | b46);
HXDLIN( 623)								{
HXDLIN( 623)									int _hx_tmp49;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp49 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp49 = blended21;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(out->image,location21,_hx_tmp49);
            								}
            							}
            							else {
HXDLIN( 623)								::Dynamic this299 = out->image;
HXDLIN( 623)								int index57;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - out->virtualY) * ( (Float)(out->width) )) + x41) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									index57 = ::Std_obj::_hx_int(( (Float)(((y40 * out->width) + x41)) ));
            								}
HXDLIN( 623)								int _hx_tmp50;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									_hx_tmp50 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									_hx_tmp50 = c55;
            								}
HXDLIN( 623)								::iterMagic::Iimg_obj::set(this299,index57,_hx_tmp50);
            							}
            						}
            					}
            				}
            			}
HXDLIN( 623)			{
HXDLIN( 623)				int _g86 = 1;
HXDLIN( 623)				int _g87 = (this1->height - 2);
HXDLIN( 623)				while((_g86 < _g87)){
HXDLIN( 623)					_g86 = (_g86 + 1);
HXDLIN( 623)					int y42 = (_g86 - 1);
HXDLIN( 623)					{
HXDLIN( 623)						::Dynamic this300 = here->image;
HXDLIN( 623)						int index58;
HXDLIN( 623)						if (here->useVirtualPos) {
HXDLIN( 623)							index58 = ::Std_obj::_hx_int((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) - here->virtualX));
            						}
            						else {
HXDLIN( 623)							index58 = ::Std_obj::_hx_int(( (Float)((y42 * here->width)) ));
            						}
HXDLIN( 623)						int c56 = ::iterMagic::Iimg_obj::get(this300,index58);
HXDLIN( 623)						int color25;
HXDLIN( 623)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)							color25 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            						}
            						else {
HXDLIN( 623)							color25 = c56;
            						}
HXDLIN( 623)						int color26 = color25;
HXDLIN( 623)						{
HXDLIN( 623)							int c57 = color26;
HXDLIN( 623)							bool _hx_tmp51;
HXDLIN( 623)							if ((((c57 >> 24) & 255) < 254)) {
HXDLIN( 623)								_hx_tmp51 = out->transparent;
            							}
            							else {
HXDLIN( 623)								_hx_tmp51 = false;
            							}
HXDLIN( 623)							if (_hx_tmp51) {
HXDLIN( 623)								int location22;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									location22 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									location22 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 623)								int this301 = ::iterMagic::Iimg_obj::get(out->image,location22);
HXDLIN( 623)								int this302;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									this302 = ((((((this301 >> 24) & 255) << 24) | ((this301 & 255) << 16)) | (((this301 >> 8) & 255) << 8)) | ((this301 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									this302 = this301;
            								}
HXDLIN( 623)								Float a124;
HXDLIN( 623)								int this303 = ((this302 >> 24) & 255);
HXDLIN( 623)								if ((this303 == 0)) {
HXDLIN( 623)									a124 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a124 = (( (Float)(this303) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r122;
HXDLIN( 623)								int this304 = ((this302 >> 16) & 255);
HXDLIN( 623)								if ((this304 == 0)) {
HXDLIN( 623)									r122 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r122 = (( (Float)(this304) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g122;
HXDLIN( 623)								int this305 = ((this302 >> 8) & 255);
HXDLIN( 623)								if ((this305 == 0)) {
HXDLIN( 623)									g122 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g122 = (( (Float)(this305) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b125;
HXDLIN( 623)								int this306 = (this302 & 255);
HXDLIN( 623)								if ((this306 == 0)) {
HXDLIN( 623)									b125 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b125 = (( (Float)(this306) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a223;
HXDLIN( 623)								int this307 = ((color26 >> 24) & 255);
HXDLIN( 623)								if ((this307 == 0)) {
HXDLIN( 623)									a223 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a223 = (( (Float)(this307) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r222;
HXDLIN( 623)								int this308 = ((color26 >> 16) & 255);
HXDLIN( 623)								if ((this308 == 0)) {
HXDLIN( 623)									r222 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r222 = (( (Float)(this308) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g222;
HXDLIN( 623)								int this309 = ((color26 >> 8) & 255);
HXDLIN( 623)								if ((this309 == 0)) {
HXDLIN( 623)									g222 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g222 = (( (Float)(this309) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b223;
HXDLIN( 623)								int this310 = (color26 & 255);
HXDLIN( 623)								if ((this310 == 0)) {
HXDLIN( 623)									b223 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b223 = (( (Float)(this310) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a322 = (a124 * (( (Float)(1) ) - a223));
HXDLIN( 623)								int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 623)								int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 623)								int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a322) + (b223 * a223))));
HXDLIN( 623)								int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 623)								int blended22 = ((((a52 << 24) | (r42 << 16)) | (g42 << 8)) | b47);
HXDLIN( 623)								{
HXDLIN( 623)									int _hx_tmp52;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp52 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp52 = blended22;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(out->image,location22,_hx_tmp52);
            								}
            							}
            							else {
HXDLIN( 623)								::Dynamic this311 = out->image;
HXDLIN( 623)								int index59;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									index59 = ::Std_obj::_hx_int((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									index59 = ::Std_obj::_hx_int(( (Float)((y42 * out->width)) ));
            								}
HXDLIN( 623)								int _hx_tmp53;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									_hx_tmp53 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									_hx_tmp53 = c57;
            								}
HXDLIN( 623)								::iterMagic::Iimg_obj::set(this311,index59,_hx_tmp53);
            							}
            						}
            					}
HXDLIN( 623)					{
HXDLIN( 623)						int x42 = (this1->width - 1);
HXDLIN( 623)						int x43 = (this1->width - 1);
HXDLIN( 623)						::Dynamic this312 = here->image;
HXDLIN( 623)						int index60;
HXDLIN( 623)						if (here->useVirtualPos) {
HXDLIN( 623)							index60 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - here->virtualY) * ( (Float)(here->width) )) + x43) - here->virtualX));
            						}
            						else {
HXDLIN( 623)							index60 = ::Std_obj::_hx_int(( (Float)(((y42 * here->width) + x43)) ));
            						}
HXDLIN( 623)						int c58 = ::iterMagic::Iimg_obj::get(this312,index60);
HXDLIN( 623)						int color27;
HXDLIN( 623)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)							color27 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            						}
            						else {
HXDLIN( 623)							color27 = c58;
            						}
HXDLIN( 623)						{
HXDLIN( 623)							int c59 = color27;
HXDLIN( 623)							bool _hx_tmp54;
HXDLIN( 623)							if ((((c59 >> 24) & 255) < 254)) {
HXDLIN( 623)								_hx_tmp54 = out->transparent;
            							}
            							else {
HXDLIN( 623)								_hx_tmp54 = false;
            							}
HXDLIN( 623)							if (_hx_tmp54) {
HXDLIN( 623)								int location23;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									location23 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									location23 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 623)								int this313 = ::iterMagic::Iimg_obj::get(out->image,location23);
HXDLIN( 623)								int this314;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									this314 = ((((((this313 >> 24) & 255) << 24) | ((this313 & 255) << 16)) | (((this313 >> 8) & 255) << 8)) | ((this313 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									this314 = this313;
            								}
HXDLIN( 623)								Float a125;
HXDLIN( 623)								int this315 = ((this314 >> 24) & 255);
HXDLIN( 623)								if ((this315 == 0)) {
HXDLIN( 623)									a125 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a125 = (( (Float)(this315) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r123;
HXDLIN( 623)								int this316 = ((this314 >> 16) & 255);
HXDLIN( 623)								if ((this316 == 0)) {
HXDLIN( 623)									r123 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r123 = (( (Float)(this316) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g123;
HXDLIN( 623)								int this317 = ((this314 >> 8) & 255);
HXDLIN( 623)								if ((this317 == 0)) {
HXDLIN( 623)									g123 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g123 = (( (Float)(this317) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b126;
HXDLIN( 623)								int this318 = (this314 & 255);
HXDLIN( 623)								if ((this318 == 0)) {
HXDLIN( 623)									b126 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b126 = (( (Float)(this318) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a224;
HXDLIN( 623)								int this319 = ((color27 >> 24) & 255);
HXDLIN( 623)								if ((this319 == 0)) {
HXDLIN( 623)									a224 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									a224 = (( (Float)(this319) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float r223;
HXDLIN( 623)								int this320 = ((color27 >> 16) & 255);
HXDLIN( 623)								if ((this320 == 0)) {
HXDLIN( 623)									r223 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									r223 = (( (Float)(this320) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float g223;
HXDLIN( 623)								int this321 = ((color27 >> 8) & 255);
HXDLIN( 623)								if ((this321 == 0)) {
HXDLIN( 623)									g223 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									g223 = (( (Float)(this321) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float b224;
HXDLIN( 623)								int this322 = (color27 & 255);
HXDLIN( 623)								if ((this322 == 0)) {
HXDLIN( 623)									b224 = ((Float)0.);
            								}
            								else {
HXDLIN( 623)									b224 = (( (Float)(this322) ) / ( (Float)(255) ));
            								}
HXDLIN( 623)								Float a323 = (a125 * (( (Float)(1) ) - a224));
HXDLIN( 623)								int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 623)								int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 623)								int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a323) + (b224 * a224))));
HXDLIN( 623)								int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 623)								int blended23 = ((((a53 << 24) | (r43 << 16)) | (g43 << 8)) | b48);
HXDLIN( 623)								{
HXDLIN( 623)									int _hx_tmp55;
HXDLIN( 623)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)										_hx_tmp55 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            									}
            									else {
HXDLIN( 623)										_hx_tmp55 = blended23;
            									}
HXDLIN( 623)									::iterMagic::Iimg_obj::set(out->image,location23,_hx_tmp55);
            								}
            							}
            							else {
HXDLIN( 623)								::Dynamic this323 = out->image;
HXDLIN( 623)								int index61;
HXDLIN( 623)								if (out->useVirtualPos) {
HXDLIN( 623)									index61 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - out->virtualY) * ( (Float)(out->width) )) + x42) - out->virtualX));
            								}
            								else {
HXDLIN( 623)									index61 = ::Std_obj::_hx_int(( (Float)(((y42 * out->width) + x42)) ));
            								}
HXDLIN( 623)								int _hx_tmp56;
HXDLIN( 623)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 623)									_hx_tmp56 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            								}
            								else {
HXDLIN( 623)									_hx_tmp56 = c59;
            								}
HXDLIN( 623)								::iterMagic::Iimg_obj::set(this323,index61,_hx_tmp56);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 623)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Convolution_Impl__obj,emboss0_3x3,return )


Convolution_Impl__obj::Convolution_Impl__obj()
{
}

bool Convolution_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"emboss0_3x3") ) { outValue = emboss0_3x3_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"convolute3x3") ) { outValue = convolute3x3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"convolute5x5") ) { outValue = convolute5x5_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sharpen0_3x3") ) { outValue = sharpen0_3x3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"boxBlur0_3x3") ) { outValue = boxBlur0_3x3_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"gussianBlur_3x3") ) { outValue = gussianBlur_3x3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"gussianBlur_5x5") ) { outValue = gussianBlur_5x5_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"edgeDetect0_3x3") ) { outValue = edgeDetect0_3x3_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"edgeEnhance0_3x3") ) { outValue = edgeEnhance0_3x3_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"gussianBlur55data") ) { outValue = gussianBlur55data_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"unsharpenMask0_5x5") ) { outValue = unsharpenMask0_5x5_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"unsharpenMask055data") ) { outValue = unsharpenMask055data_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Convolution_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Convolution_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Convolution_Impl__obj::__mClass;

static ::String Convolution_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("convolute3x3",19,8d,d1,55),
	HX_("convolute5x5",9d,11,d3,55),
	HX_("sharpen0_3x3",2c,b0,8b,fa),
	HX_("boxBlur0_3x3",4d,81,52,2a),
	HX_("gussianBlur_3x3",fe,c6,88,18),
	HX_("gussianBlur55data",99,0c,42,30),
	HX_("gussianBlur_5x5",82,4b,8a,18),
	HX_("unsharpenMask055data",d4,64,19,3d),
	HX_("unsharpenMask0_5x5",fd,8e,6d,33),
	HX_("edgeEnhance0_3x3",ce,6d,90,b1),
	HX_("edgeDetect0_3x3",5f,ba,14,6b),
	HX_("emboss0_3x3",aa,18,1c,d0),
	::String(null())
};

void Convolution_Impl__obj::__register()
{
	Convolution_Impl__obj _hx_dummy;
	Convolution_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._Convolution.Convolution_Impl_",f4,43,0e,1f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Convolution_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Convolution_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Convolution_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Convolution_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Convolution_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _Convolution
