// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_RectangleWindow
#include <pi_xy/algo/RectangleWindow.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__TriPixel_TriPixel_Fields_
#include <pi_xy/algo/_TriPixel/TriPixel_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_18_fillTriangle,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriangle",0xbfa2b28f,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriangle","pi_xy/algo/TriPixel.hx",18,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_39_fillTriUnsafe,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriUnsafe",0x2a576e0a,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriUnsafe","pi_xy/algo/TriPixel.hx",39,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_98_fillTriangle2,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriangle2",0xeeb98ac3,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriangle2","pi_xy/algo/TriPixel.hx",98,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_119_fillTriUnsafe2,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriUnsafe2",0xe228dae8,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriUnsafe2","pi_xy/algo/TriPixel.hx",119,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_180_tileTriangle,"pi_xy.algo._TriPixel.TriPixel_Fields_","tileTriangle",0x9380d23a,"pi_xy.algo._TriPixel.TriPixel_Fields_.tileTriangle","pi_xy/algo/TriPixel.hx",180,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_201_tileTriUnsafe,"pi_xy.algo._TriPixel.TriPixel_Fields_","tileTriUnsafe",0xb8d503ff,"pi_xy.algo._TriPixel.TriPixel_Fields_.tileTriUnsafe","pi_xy/algo/TriPixel.hx",201,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_262_fillGradTriangle,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillGradTriangle",0xc49cabfd,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillGradTriangle","pi_xy/algo/TriPixel.hx",262,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_327_topRightImgTriFudge,"pi_xy.algo._TriPixel.TriPixel_Fields_","topRightImgTriFudge",0x6e048820,"pi_xy.algo._TriPixel.TriPixel_Fields_.topRightImgTriFudge","pi_xy/algo/TriPixel.hx",327,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_335_bottomLeftImgTriFudge,"pi_xy.algo._TriPixel.TriPixel_Fields_","bottomLeftImgTriFudge",0x2a45e975,"pi_xy.algo._TriPixel.TriPixel_Fields_.bottomLeftImgTriFudge","pi_xy/algo/TriPixel.hx",335,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_346_uvTriangleFudge,"pi_xy.algo._TriPixel.TriPixel_Fields_","uvTriangleFudge",0x2310fae6,"pi_xy.algo._TriPixel.TriPixel_Fields_.uvTriangleFudge","pi_xy/algo/TriPixel.hx",346,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_402_topLeftImgTri,"pi_xy.algo._TriPixel.TriPixel_Fields_","topLeftImgTri",0x34f4fca0,"pi_xy.algo._TriPixel.TriPixel_Fields_.topLeftImgTri","pi_xy/algo/TriPixel.hx",402,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_412_bottomRightImgTri,"pi_xy.algo._TriPixel.TriPixel_Fields_","bottomRightImgTri",0x7c2aa815,"pi_xy.algo._TriPixel.TriPixel_Fields_.bottomRightImgTri","pi_xy/algo/TriPixel.hx",412,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_419_uvTriangle,"pi_xy.algo._TriPixel.TriPixel_Fields_","uvTriangle",0xf112c76d,"pi_xy.algo._TriPixel.TriPixel_Fields_.uvTriangle","pi_xy/algo/TriPixel.hx",419,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_482_uvTriangleSoft3,"pi_xy.algo._TriPixel.TriPixel_Fields_","uvTriangleSoft3",0x9b50cd5c,"pi_xy.algo._TriPixel.TriPixel_Fields_.uvTriangleSoft3","pi_xy/algo/TriPixel.hx",482,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_568_fillTriTwoSoft,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriTwoSoft",0xfaf52a32,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriTwoSoft","pi_xy/algo/TriPixel.hx",568,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_591_fillTriSoftC,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriSoftC",0xb0af0eb5,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriSoftC","pi_xy/algo/TriPixel.hx",591,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_665_fillTriSoft3,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriSoft3",0xb0af0ea5,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriSoft3","pi_xy/algo/TriPixel.hx",665,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_782_fillQuarterSoft,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillQuarterSoft",0xc0d0c9cf,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillQuarterSoft","pi_xy/algo/TriPixel.hx",782,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_878_fillTriExtra0,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriExtra0",0x87598d84,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriExtra0","pi_xy/algo/TriPixel.hx",878,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_949_fillTriExtra1,"pi_xy.algo._TriPixel.TriPixel_Fields_","fillTriExtra1",0x87598d85,"pi_xy.algo._TriPixel.TriPixel_Fields_.fillTriExtra1","pi_xy/algo/TriPixel.hx",949,0x19d2e42f)
HX_LOCAL_STACK_FRAME(_hx_pos_4d6d42e233dea49a_1010_uvTriangleTexture3,"pi_xy.algo._TriPixel.TriPixel_Fields_","uvTriangleTexture3",0x0bfc2f85,"pi_xy.algo._TriPixel.TriPixel_Fields_.uvTriangleTexture3","pi_xy/algo/TriPixel.hx",1010,0x19d2e42f)
namespace pi_xy{
namespace algo{
namespace _TriPixel{

void TriPixel_Fields__obj::__construct() { }

Dynamic TriPixel_Fields__obj::__CreateEmpty() { return new TriPixel_Fields__obj; }

void *TriPixel_Fields__obj::_hx_vtable = 0;

Dynamic TriPixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriPixel_Fields__obj > _hx_result = new TriPixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TriPixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6be89ee2;
}

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriangle( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_18_fillTriangle)
HXLINE(  19)		bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXLINE(  20)		if (!(adjustWinding)) {
HXLINE(  23)			Float bx_ = bx;
HXLINE(  24)			Float by_ = by;
HXLINE(  25)			bx = cx;
HXLINE(  26)			by = cy;
HXLINE(  27)			cx = bx_;
HXLINE(  28)			cy = by_;
            		}
HXLINE(  30)		Float s0 = ((ay * cx) - (ax * cy));
HXDLIN(  30)		Float sx = (cy - ay);
HXDLIN(  30)		Float sy = (ax - cx);
HXDLIN(  30)		Float t0 = ((ax * by) - (ay * bx));
HXDLIN(  30)		Float tx = (ay - by);
HXDLIN(  30)		Float ty = (bx - ax);
HXDLIN(  30)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN(  30)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  30)		if ((ax > bx)) {
HXLINE(  30)			if ((ax > cx)) {
HXLINE(  30)				int min;
HXDLIN(  30)				if ((bx > cx)) {
HXLINE(  30)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  30)					min = ::Math_obj::floor(bx);
            				}
HXDLIN(  30)				int ii_min = min;
HXDLIN(  30)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  30)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE(  30)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  30)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  30)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE(  30)			if ((bx > cx)) {
HXLINE(  30)				int min1;
HXDLIN(  30)				if ((ax > cx)) {
HXLINE(  30)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  30)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  30)				int ii_min2 = min1;
HXDLIN(  30)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  30)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE(  30)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  30)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  30)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  30)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  30)		if ((ay > by)) {
HXLINE(  30)			if ((ay > cy)) {
HXLINE(  30)				int min2;
HXDLIN(  30)				if ((by > cy)) {
HXLINE(  30)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  30)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN(  30)				int ii_min4 = min2;
HXDLIN(  30)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  30)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE(  30)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  30)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  30)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE(  30)			if ((by > cy)) {
HXLINE(  30)				int min3;
HXDLIN(  30)				if ((ay > cy)) {
HXLINE(  30)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  30)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  30)				int ii_min6 = min3;
HXDLIN(  30)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  30)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE(  30)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  30)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  30)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  30)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  30)		if (hasUndo) {
HXLINE(  30)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  30)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  30)			 ::Dynamic imageType = null();
HXDLIN(  30)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  30)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  30)			::Dynamic undoImage1;
HXDLIN(  30)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  30)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  30)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  30)					{
HXLINE(  30)						b->width = width;
HXDLIN(  30)						b->height = height;
HXDLIN(  30)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  30)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  30)						{
HXLINE(  30)							int len = b->length;
HXDLIN(  30)							int w = 0;
HXDLIN(  30)							{
HXLINE(  30)								int _g = 0;
HXDLIN(  30)								int _g1 = b->height;
HXDLIN(  30)								while((_g < _g1)){
HXLINE(  30)									_g = (_g + 1);
HXDLIN(  30)									int y = (_g - 1);
HXDLIN(  30)									{
HXLINE(  30)										int _g2 = 0;
HXDLIN(  30)										int _g3 = b->width;
HXDLIN(  30)										while((_g2 < _g3)){
HXLINE(  30)											_g2 = (_g2 + 1);
HXDLIN(  30)											int x = (_g2 - 1);
HXDLIN(  30)											{
HXLINE(  30)												w = (w + 1);
HXDLIN(  30)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  30)											{
HXLINE(  30)												w = (w + 1);
HXDLIN(  30)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  30)											{
HXLINE(  30)												w = (w + 1);
HXDLIN(  30)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  30)											{
HXLINE(  30)												w = (w + 1);
HXDLIN(  30)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  30)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE(  30)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  30)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  30)					{
HXLINE(  30)						a->width = width;
HXDLIN(  30)						a->height = height;
HXDLIN(  30)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  30)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  30)						{
HXLINE(  30)							int _g4 = 0;
HXDLIN(  30)							int _g5 = a->length;
HXDLIN(  30)							while((_g4 < _g5)){
HXLINE(  30)								_g4 = (_g4 + 1);
HXDLIN(  30)								int i = (_g4 - 1);
HXDLIN(  30)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  30)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE(  30)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  30)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  30)					{
HXLINE(  30)						b1->width = width;
HXDLIN(  30)						b1->height = height;
HXDLIN(  30)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  30)						int size = (b1->length * 4);
HXDLIN(  30)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  30)						{
HXLINE(  30)							int _g6 = 0;
HXDLIN(  30)							int _g7 = b1->length;
HXDLIN(  30)							while((_g6 < _g7)){
HXLINE(  30)								_g6 = (_g6 + 1);
HXDLIN(  30)								int i1 = (_g6 - 1);
HXDLIN(  30)								{
HXLINE(  30)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  30)									bool undoImage2;
HXDLIN(  30)									if ((i1 >= 0)) {
HXLINE(  30)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  30)										undoImage2 = false;
            									}
HXDLIN(  30)									if (undoImage2) {
HXLINE(  30)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  30)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  30)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  30)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  30)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  30)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  30)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE(  30)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  30)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  30)					{
HXLINE(  30)						v->width = width;
HXDLIN(  30)						v->height = height;
HXDLIN(  30)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  30)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  30)						{
HXLINE(  30)							int _g8 = 0;
HXDLIN(  30)							int _g9 = v->length;
HXDLIN(  30)							while((_g8 < _g9)){
HXLINE(  30)								_g8 = (_g8 + 1);
HXDLIN(  30)								int i2 = (_g8 - 1);
HXDLIN(  30)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  30)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  30)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  30)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  30)					{
HXLINE(  30)						b2->width = width;
HXDLIN(  30)						b2->height = height;
HXDLIN(  30)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  30)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  30)						{
HXLINE(  30)							int len1 = b2->length;
HXDLIN(  30)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  30)							if (::hx::IsNull( d->head )) {
HXLINE(  30)								int _g10 = 0;
HXDLIN(  30)								int _g11 = len1;
HXDLIN(  30)								while((_g10 < _g11)){
HXLINE(  30)									_g10 = (_g10 + 1);
HXDLIN(  30)									int i3 = (_g10 - 1);
HXDLIN(  30)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  30)								int _g12 = 0;
HXDLIN(  30)								int _g13 = len1;
HXDLIN(  30)								while((_g12 < _g13)){
HXLINE(  30)									_g12 = (_g12 + 1);
HXDLIN(  30)									int i4 = (_g12 - 1);
HXDLIN(  30)									{
HXLINE(  30)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  30)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  30)										{
HXLINE(  30)											int _g14 = 0;
HXDLIN(  30)											int _g15 = i4;
HXDLIN(  30)											while((_g14 < _g15)){
HXLINE(  30)												_g14 = (_g14 + 1);
HXDLIN(  30)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  30)										if (::hx::IsNull( prev )) {
HXLINE(  30)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  30)											l = null();
            										}
            										else {
HXLINE(  30)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  30)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  30)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN(  30)			this1->image = undoImage1;
HXDLIN(  30)			this1->width = width;
HXDLIN(  30)			this1->height = height;
HXDLIN(  30)			this1->imageType = ( (int)(imageType) );
HXDLIN(  30)			undoImage = this1;
HXDLIN(  30)			{
HXLINE(  30)				int rectLeft = xIter3->start;
HXDLIN(  30)				int rectTop = yIter3->start;
HXDLIN(  30)				int rectRight = xIter3->max;
HXDLIN(  30)				bool forceClear = false;
HXDLIN(  30)				{
HXLINE(  30)					int _g16 = rectTop;
HXDLIN(  30)					int _g17 = yIter3->max;
HXDLIN(  30)					while((_g16 < _g17)){
HXLINE(  30)						_g16 = (_g16 + 1);
HXDLIN(  30)						int dy = (_g16 - 1);
HXDLIN(  30)						{
HXLINE(  30)							int _g18 = rectLeft;
HXDLIN(  30)							int _g19 = rectRight;
HXDLIN(  30)							while((_g18 < _g19)){
HXLINE(  30)								_g18 = (_g18 + 1);
HXDLIN(  30)								int dx = (_g18 - 1);
HXDLIN(  30)								::Dynamic this3 = pixelImage->image;
HXDLIN(  30)								int index;
HXDLIN(  30)								if (pixelImage->useVirtualPos) {
HXLINE(  30)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  30)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN(  30)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  30)								int col;
HXDLIN(  30)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  30)									col = c;
            								}
HXDLIN(  30)								bool _hx_tmp;
HXDLIN(  30)								if (pixelImage->useMask) {
HXLINE(  30)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(  30)									_hx_tmp = false;
            								}
HXDLIN(  30)								if (_hx_tmp) {
HXLINE(  30)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  30)									::Dynamic this5 = this4->image;
HXDLIN(  30)									int index1;
HXDLIN(  30)									if (this4->useVirtualPos) {
HXLINE(  30)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE(  30)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN(  30)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  30)									int v1;
HXDLIN(  30)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  30)										v1 = c1;
            									}
HXDLIN(  30)									int maskPixel = v1;
HXDLIN(  30)									int this6 = col;
HXDLIN(  30)									if ((maskPixel == 0)) {
HXLINE(  30)										col = this6;
            									}
            									else {
HXLINE(  30)										Float m0;
HXDLIN(  30)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  30)										if ((this7 == 0)) {
HXLINE(  30)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float m1;
HXDLIN(  30)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  30)										if ((this8 == 0)) {
HXLINE(  30)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float m2;
HXDLIN(  30)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  30)										if ((this9 == 0)) {
HXLINE(  30)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float m3;
HXDLIN(  30)										int this10 = (maskPixel & 255);
HXDLIN(  30)										if ((this10 == 0)) {
HXLINE(  30)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  30)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  30)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  30)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  30)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  30)								if ((col != 0)) {
HXLINE(  30)									int x1 = (dx - rectLeft);
HXDLIN(  30)									int y1 = (dy - rectTop);
HXDLIN(  30)									int c2 = col;
HXDLIN(  30)									bool _hx_tmp1;
HXDLIN(  30)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  30)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE(  30)										_hx_tmp1 = false;
            									}
HXDLIN(  30)									if (_hx_tmp1) {
HXLINE(  30)										int location;
HXDLIN(  30)										if (undoImage->useVirtualPos) {
HXLINE(  30)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  30)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  30)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  30)										int this12;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											this12 = this11;
            										}
HXDLIN(  30)										Float a1;
HXDLIN(  30)										int this13 = ((this12 >> 24) & 255);
HXDLIN(  30)										if ((this13 == 0)) {
HXLINE(  30)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r1;
HXDLIN(  30)										int this14 = ((this12 >> 16) & 255);
HXDLIN(  30)										if ((this14 == 0)) {
HXLINE(  30)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g1;
HXDLIN(  30)										int this15 = ((this12 >> 8) & 255);
HXDLIN(  30)										if ((this15 == 0)) {
HXLINE(  30)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b11;
HXDLIN(  30)										int this16 = (this12 & 255);
HXDLIN(  30)										if ((this16 == 0)) {
HXLINE(  30)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a2;
HXDLIN(  30)										int this17 = ((col >> 24) & 255);
HXDLIN(  30)										if ((this17 == 0)) {
HXLINE(  30)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r2;
HXDLIN(  30)										int this18 = ((col >> 16) & 255);
HXDLIN(  30)										if ((this18 == 0)) {
HXLINE(  30)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g2;
HXDLIN(  30)										int this19 = ((col >> 8) & 255);
HXDLIN(  30)										if ((this19 == 0)) {
HXLINE(  30)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b21;
HXDLIN(  30)										int this20 = (col & 255);
HXDLIN(  30)										if ((this20 == 0)) {
HXLINE(  30)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  30)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  30)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  30)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  30)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  30)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  30)										{
HXLINE(  30)											int _hx_tmp2;
HXDLIN(  30)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  30)												_hx_tmp2 = blended;
            											}
HXDLIN(  30)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE(  30)										::Dynamic this21 = undoImage->image;
HXDLIN(  30)										int index2;
HXDLIN(  30)										if (undoImage->useVirtualPos) {
HXLINE(  30)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  30)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  30)										int _hx_tmp3;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											_hx_tmp3 = c2;
            										}
HXDLIN(  30)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE(  30)									if (forceClear) {
HXLINE(  30)										::Dynamic this22 = undoImage->image;
HXDLIN(  30)										int x2 = (dx - rectLeft);
HXDLIN(  30)										int y2 = (dy - rectTop);
HXDLIN(  30)										int index3;
HXDLIN(  30)										if (undoImage->useVirtualPos) {
HXLINE(  30)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(  30)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  30)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  30)		bool found = false;
HXDLIN(  30)		Float s = ((Float)0.);
HXDLIN(  30)		Float t = ((Float)0.);
HXDLIN(  30)		Float sxx = ((Float)0.);
HXDLIN(  30)		Float txx = ((Float)0.);
HXDLIN(  30)		{
HXLINE(  30)			int _g_min = xIter3->start;
HXDLIN(  30)			int _g_max = xIter3->max;
HXDLIN(  30)			while((_g_min < _g_max)){
HXLINE(  30)				_g_min = (_g_min + 1);
HXDLIN(  30)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE(  30)				{
HXLINE(  30)					int _g_min1 = yIter3->start;
HXDLIN(  30)					int _g_max1 = yIter3->max;
HXDLIN(  30)					while((_g_min1 < _g_max1)){
HXLINE(  30)						_g_min1 = (_g_min1 + 1);
HXDLIN(  30)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  30)						bool _hx_tmp4;
HXDLIN(  30)						if (!((s <= 0))) {
HXLINE(  30)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE(  30)							_hx_tmp4 = true;
            						}
HXDLIN(  30)						if (_hx_tmp4) {
HXLINE(  30)							if (found) {
HXLINE(  30)								goto _hx_goto_11;
            							}
            						}
            						else {
HXLINE(  30)							if (((s + t) < A)) {
HXLINE(  30)								{
HXLINE(  30)									int c3 = color;
HXDLIN(  30)									bool _hx_tmp5;
HXDLIN(  30)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  30)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE(  30)										_hx_tmp5 = false;
            									}
HXDLIN(  30)									if (_hx_tmp5) {
HXLINE(  30)										int location1;
HXDLIN(  30)										if (pixelImage->useVirtualPos) {
HXLINE(  30)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  30)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN(  30)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  30)										int this24;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											this24 = this23;
            										}
HXDLIN(  30)										Float a11;
HXDLIN(  30)										int this25 = ((this24 >> 24) & 255);
HXDLIN(  30)										if ((this25 == 0)) {
HXLINE(  30)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r11;
HXDLIN(  30)										int this26 = ((this24 >> 16) & 255);
HXDLIN(  30)										if ((this26 == 0)) {
HXLINE(  30)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g11;
HXDLIN(  30)										int this27 = ((this24 >> 8) & 255);
HXDLIN(  30)										if ((this27 == 0)) {
HXLINE(  30)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b12;
HXDLIN(  30)										int this28 = (this24 & 255);
HXDLIN(  30)										if ((this28 == 0)) {
HXLINE(  30)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a21;
HXDLIN(  30)										int this29 = ((color >> 24) & 255);
HXDLIN(  30)										if ((this29 == 0)) {
HXLINE(  30)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r21;
HXDLIN(  30)										int this30 = ((color >> 16) & 255);
HXDLIN(  30)										if ((this30 == 0)) {
HXLINE(  30)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g21;
HXDLIN(  30)										int this31 = ((color >> 8) & 255);
HXDLIN(  30)										if ((this31 == 0)) {
HXLINE(  30)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b22;
HXDLIN(  30)										int this32 = (color & 255);
HXDLIN(  30)										if ((this32 == 0)) {
HXLINE(  30)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  30)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  30)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  30)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  30)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  30)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  30)										{
HXLINE(  30)											int _hx_tmp6;
HXDLIN(  30)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  30)												_hx_tmp6 = blended1;
            											}
HXDLIN(  30)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE(  30)										::Dynamic this33 = pixelImage->image;
HXDLIN(  30)										int index4;
HXDLIN(  30)										if (pixelImage->useVirtualPos) {
HXLINE(  30)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  30)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN(  30)										int _hx_tmp7;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											_hx_tmp7 = c3;
            										}
HXDLIN(  30)										::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXLINE(  30)								if (found) {
HXLINE(  30)									goto _hx_goto_11;
            								}
            							}
            						}
            					}
            					_hx_goto_11:;
            				}
            			}
            		}
HXDLIN(  30)		if ((hasHit == true)) {
HXLINE(  30)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  30)			if (hasUndo) {
HXLINE(  30)				v2->undoImage = undoImage;
HXDLIN(  30)				v2->undoX = xIter3->start;
HXDLIN(  30)				v2->undoY = yIter3->start;
            			}
HXDLIN(  30)			return v2;
            		}
            		else {
HXLINE(  30)			return null();
            		}
HXDLIN(  30)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriangle,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriUnsafe( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_39_fillTriUnsafe)
HXLINE(  40)		Float s0 = ((ay * cx) - (ax * cy));
HXLINE(  41)		Float sx = (cy - ay);
HXLINE(  42)		Float sy = (ax - cx);
HXLINE(  43)		Float t0 = ((ax * by) - (ay * bx));
HXLINE(  44)		Float tx = (ay - by);
HXLINE(  45)		Float ty = (bx - ax);
HXLINE(  46)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXLINE(  47)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  47)		if ((ax > bx)) {
HXLINE(  47)			if ((ax > cx)) {
HXLINE(  47)				int min;
HXDLIN(  47)				if ((bx > cx)) {
HXLINE(  47)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  47)					min = ::Math_obj::floor(bx);
            				}
HXDLIN(  47)				int ii_min = min;
HXDLIN(  47)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  47)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE(  47)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  47)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  47)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE(  47)			if ((bx > cx)) {
HXLINE(  47)				int min1;
HXDLIN(  47)				if ((ax > cx)) {
HXLINE(  47)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  47)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  47)				int ii_min2 = min1;
HXDLIN(  47)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  47)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE(  47)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  47)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  47)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE(  48)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  48)		if ((ay > by)) {
HXLINE(  48)			if ((ay > cy)) {
HXLINE(  48)				int min2;
HXDLIN(  48)				if ((by > cy)) {
HXLINE(  48)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  48)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN(  48)				int ii_min4 = min2;
HXDLIN(  48)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  48)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE(  48)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  48)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  48)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE(  48)			if ((by > cy)) {
HXLINE(  48)				int min3;
HXDLIN(  48)				if ((ay > cy)) {
HXLINE(  48)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  48)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  48)				int ii_min6 = min3;
HXDLIN(  48)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  48)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE(  48)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  48)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  48)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE(  49)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE(  50)		if (hasUndo) {
HXLINE(  51)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  51)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  51)			 ::Dynamic imageType = null();
HXDLIN(  51)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  51)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  51)			::Dynamic undoImage1;
HXDLIN(  51)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  51)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  51)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  51)					{
HXLINE(  51)						b->width = width;
HXDLIN(  51)						b->height = height;
HXDLIN(  51)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  51)						{
HXLINE(  51)							int len = b->length;
HXDLIN(  51)							int w = 0;
HXDLIN(  51)							{
HXLINE(  51)								int _g = 0;
HXDLIN(  51)								int _g1 = b->height;
HXDLIN(  51)								while((_g < _g1)){
HXLINE(  51)									_g = (_g + 1);
HXDLIN(  51)									int y = (_g - 1);
HXDLIN(  51)									{
HXLINE(  51)										int _g2 = 0;
HXDLIN(  51)										int _g3 = b->width;
HXDLIN(  51)										while((_g2 < _g3)){
HXLINE(  51)											_g2 = (_g2 + 1);
HXDLIN(  51)											int x = (_g2 - 1);
HXDLIN(  51)											{
HXLINE(  51)												w = (w + 1);
HXDLIN(  51)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  51)											{
HXLINE(  51)												w = (w + 1);
HXDLIN(  51)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  51)											{
HXLINE(  51)												w = (w + 1);
HXDLIN(  51)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  51)											{
HXLINE(  51)												w = (w + 1);
HXDLIN(  51)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE(  51)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  51)					{
HXLINE(  51)						a->width = width;
HXDLIN(  51)						a->height = height;
HXDLIN(  51)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  51)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)						{
HXLINE(  51)							int _g4 = 0;
HXDLIN(  51)							int _g5 = a->length;
HXDLIN(  51)							while((_g4 < _g5)){
HXLINE(  51)								_g4 = (_g4 + 1);
HXDLIN(  51)								int i = (_g4 - 1);
HXDLIN(  51)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  51)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE(  51)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  51)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  51)					{
HXLINE(  51)						b1->width = width;
HXDLIN(  51)						b1->height = height;
HXDLIN(  51)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)						int size = (b1->length * 4);
HXDLIN(  51)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  51)						{
HXLINE(  51)							int _g6 = 0;
HXDLIN(  51)							int _g7 = b1->length;
HXDLIN(  51)							while((_g6 < _g7)){
HXLINE(  51)								_g6 = (_g6 + 1);
HXDLIN(  51)								int i1 = (_g6 - 1);
HXDLIN(  51)								{
HXLINE(  51)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  51)									bool undoImage2;
HXDLIN(  51)									if ((i1 >= 0)) {
HXLINE(  51)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  51)										undoImage2 = false;
            									}
HXDLIN(  51)									if (undoImage2) {
HXLINE(  51)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  51)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  51)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  51)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  51)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  51)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE(  51)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  51)					{
HXLINE(  51)						v->width = width;
HXDLIN(  51)						v->height = height;
HXDLIN(  51)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  51)						{
HXLINE(  51)							int _g8 = 0;
HXDLIN(  51)							int _g9 = v->length;
HXDLIN(  51)							while((_g8 < _g9)){
HXLINE(  51)								_g8 = (_g8 + 1);
HXDLIN(  51)								int i2 = (_g8 - 1);
HXDLIN(  51)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  51)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  51)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  51)					{
HXLINE(  51)						b2->width = width;
HXDLIN(  51)						b2->height = height;
HXDLIN(  51)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  51)						{
HXLINE(  51)							int len1 = b2->length;
HXDLIN(  51)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  51)							if (::hx::IsNull( d->head )) {
HXLINE(  51)								int _g10 = 0;
HXDLIN(  51)								int _g11 = len1;
HXDLIN(  51)								while((_g10 < _g11)){
HXLINE(  51)									_g10 = (_g10 + 1);
HXDLIN(  51)									int i3 = (_g10 - 1);
HXDLIN(  51)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  51)								int _g12 = 0;
HXDLIN(  51)								int _g13 = len1;
HXDLIN(  51)								while((_g12 < _g13)){
HXLINE(  51)									_g12 = (_g12 + 1);
HXDLIN(  51)									int i4 = (_g12 - 1);
HXDLIN(  51)									{
HXLINE(  51)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  51)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  51)										{
HXLINE(  51)											int _g14 = 0;
HXDLIN(  51)											int _g15 = i4;
HXDLIN(  51)											while((_g14 < _g15)){
HXLINE(  51)												_g14 = (_g14 + 1);
HXDLIN(  51)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  51)										if (::hx::IsNull( prev )) {
HXLINE(  51)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  51)											l = null();
            										}
            										else {
HXLINE(  51)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  51)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN(  51)			this1->image = undoImage1;
HXDLIN(  51)			this1->width = width;
HXDLIN(  51)			this1->height = height;
HXDLIN(  51)			this1->imageType = ( (int)(imageType) );
HXDLIN(  51)			undoImage = this1;
HXLINE(  52)			{
HXLINE(  52)				int rectLeft = xIter3->start;
HXDLIN(  52)				int rectTop = yIter3->start;
HXDLIN(  52)				int rectRight = xIter3->max;
HXDLIN(  52)				bool forceClear = false;
HXDLIN(  52)				{
HXLINE(  52)					int _g16 = rectTop;
HXDLIN(  52)					int _g17 = yIter3->max;
HXDLIN(  52)					while((_g16 < _g17)){
HXLINE(  52)						_g16 = (_g16 + 1);
HXDLIN(  52)						int dy = (_g16 - 1);
HXDLIN(  52)						{
HXLINE(  52)							int _g18 = rectLeft;
HXDLIN(  52)							int _g19 = rectRight;
HXDLIN(  52)							while((_g18 < _g19)){
HXLINE(  52)								_g18 = (_g18 + 1);
HXDLIN(  52)								int dx = (_g18 - 1);
HXDLIN(  52)								::Dynamic this3 = pixelImage->image;
HXDLIN(  52)								int index;
HXDLIN(  52)								if (pixelImage->useVirtualPos) {
HXLINE(  52)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  52)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN(  52)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  52)								int col;
HXDLIN(  52)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  52)									col = c;
            								}
HXDLIN(  52)								bool _hx_tmp;
HXDLIN(  52)								if (pixelImage->useMask) {
HXLINE(  52)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(  52)									_hx_tmp = false;
            								}
HXDLIN(  52)								if (_hx_tmp) {
HXLINE(  52)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  52)									::Dynamic this5 = this4->image;
HXDLIN(  52)									int index1;
HXDLIN(  52)									if (this4->useVirtualPos) {
HXLINE(  52)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE(  52)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN(  52)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  52)									int v1;
HXDLIN(  52)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  52)										v1 = c1;
            									}
HXDLIN(  52)									int maskPixel = v1;
HXDLIN(  52)									int this6 = col;
HXDLIN(  52)									if ((maskPixel == 0)) {
HXLINE(  52)										col = this6;
            									}
            									else {
HXLINE(  52)										Float m0;
HXDLIN(  52)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  52)										if ((this7 == 0)) {
HXLINE(  52)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float m1;
HXDLIN(  52)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  52)										if ((this8 == 0)) {
HXLINE(  52)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float m2;
HXDLIN(  52)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  52)										if ((this9 == 0)) {
HXLINE(  52)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float m3;
HXDLIN(  52)										int this10 = (maskPixel & 255);
HXDLIN(  52)										if ((this10 == 0)) {
HXLINE(  52)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  52)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  52)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  52)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  52)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  52)								if ((col != 0)) {
HXLINE(  52)									int x1 = (dx - rectLeft);
HXDLIN(  52)									int y1 = (dy - rectTop);
HXDLIN(  52)									int c2 = col;
HXDLIN(  52)									bool _hx_tmp1;
HXDLIN(  52)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  52)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE(  52)										_hx_tmp1 = false;
            									}
HXDLIN(  52)									if (_hx_tmp1) {
HXLINE(  52)										int location;
HXDLIN(  52)										if (undoImage->useVirtualPos) {
HXLINE(  52)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  52)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  52)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  52)										int this12;
HXDLIN(  52)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE(  52)											this12 = this11;
            										}
HXDLIN(  52)										Float a1;
HXDLIN(  52)										int this13 = ((this12 >> 24) & 255);
HXDLIN(  52)										if ((this13 == 0)) {
HXLINE(  52)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float r1;
HXDLIN(  52)										int this14 = ((this12 >> 16) & 255);
HXDLIN(  52)										if ((this14 == 0)) {
HXLINE(  52)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float g1;
HXDLIN(  52)										int this15 = ((this12 >> 8) & 255);
HXDLIN(  52)										if ((this15 == 0)) {
HXLINE(  52)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float b11;
HXDLIN(  52)										int this16 = (this12 & 255);
HXDLIN(  52)										if ((this16 == 0)) {
HXLINE(  52)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float a2;
HXDLIN(  52)										int this17 = ((col >> 24) & 255);
HXDLIN(  52)										if ((this17 == 0)) {
HXLINE(  52)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float r2;
HXDLIN(  52)										int this18 = ((col >> 16) & 255);
HXDLIN(  52)										if ((this18 == 0)) {
HXLINE(  52)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float g2;
HXDLIN(  52)										int this19 = ((col >> 8) & 255);
HXDLIN(  52)										if ((this19 == 0)) {
HXLINE(  52)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float b21;
HXDLIN(  52)										int this20 = (col & 255);
HXDLIN(  52)										if ((this20 == 0)) {
HXLINE(  52)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  52)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  52)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  52)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  52)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  52)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  52)										{
HXLINE(  52)											int _hx_tmp2;
HXDLIN(  52)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  52)												_hx_tmp2 = blended;
            											}
HXDLIN(  52)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE(  52)										::Dynamic this21 = undoImage->image;
HXDLIN(  52)										int index2;
HXDLIN(  52)										if (undoImage->useVirtualPos) {
HXLINE(  52)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  52)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  52)										int _hx_tmp3;
HXDLIN(  52)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  52)											_hx_tmp3 = c2;
            										}
HXDLIN(  52)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE(  52)									if (forceClear) {
HXLINE(  52)										::Dynamic this22 = undoImage->image;
HXDLIN(  52)										int x2 = (dx - rectLeft);
HXDLIN(  52)										int y2 = (dy - rectTop);
HXDLIN(  52)										int index3;
HXDLIN(  52)										if (undoImage->useVirtualPos) {
HXLINE(  52)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(  52)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  52)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  54)		bool found = false;
HXLINE(  55)		Float s = ((Float)0.);
HXLINE(  56)		Float t = ((Float)0.);
HXLINE(  57)		Float sxx = ((Float)0.);
HXLINE(  58)		Float txx = ((Float)0.);
HXLINE(  59)		{
HXLINE(  59)			int _g_min = xIter3->start;
HXDLIN(  59)			int _g_max = xIter3->max;
HXDLIN(  59)			while((_g_min < _g_max)){
HXLINE(  59)				_g_min = (_g_min + 1);
HXDLIN(  59)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE(  63)				{
HXLINE(  63)					int _g_min1 = yIter3->start;
HXDLIN(  63)					int _g_max1 = yIter3->max;
HXDLIN(  63)					while((_g_min1 < _g_max1)){
HXLINE(  63)						_g_min1 = (_g_min1 + 1);
HXDLIN(  63)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  66)						bool _hx_tmp4;
HXDLIN(  66)						if (!((s <= 0))) {
HXLINE(  66)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE(  66)							_hx_tmp4 = true;
            						}
HXDLIN(  66)						if (_hx_tmp4) {
HXLINE(  68)							if (found) {
HXLINE(  68)								goto _hx_goto_24;
            							}
            						}
            						else {
HXLINE(  70)							if (((s + t) < A)) {
HXLINE(  72)								{
HXLINE(  72)									int c3 = color;
HXDLIN(  72)									bool _hx_tmp5;
HXDLIN(  72)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  72)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE(  72)										_hx_tmp5 = false;
            									}
HXDLIN(  72)									if (_hx_tmp5) {
HXLINE(  72)										int location1;
HXDLIN(  72)										if (pixelImage->useVirtualPos) {
HXLINE(  72)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  72)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN(  72)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  72)										int this24;
HXDLIN(  72)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)											this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE(  72)											this24 = this23;
            										}
HXDLIN(  72)										Float a11;
HXDLIN(  72)										int this25 = ((this24 >> 24) & 255);
HXDLIN(  72)										if ((this25 == 0)) {
HXLINE(  72)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float r11;
HXDLIN(  72)										int this26 = ((this24 >> 16) & 255);
HXDLIN(  72)										if ((this26 == 0)) {
HXLINE(  72)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float g11;
HXDLIN(  72)										int this27 = ((this24 >> 8) & 255);
HXDLIN(  72)										if ((this27 == 0)) {
HXLINE(  72)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float b12;
HXDLIN(  72)										int this28 = (this24 & 255);
HXDLIN(  72)										if ((this28 == 0)) {
HXLINE(  72)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float a21;
HXDLIN(  72)										int this29 = ((color >> 24) & 255);
HXDLIN(  72)										if ((this29 == 0)) {
HXLINE(  72)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float r21;
HXDLIN(  72)										int this30 = ((color >> 16) & 255);
HXDLIN(  72)										if ((this30 == 0)) {
HXLINE(  72)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float g21;
HXDLIN(  72)										int this31 = ((color >> 8) & 255);
HXDLIN(  72)										if ((this31 == 0)) {
HXLINE(  72)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float b22;
HXDLIN(  72)										int this32 = (color & 255);
HXDLIN(  72)										if ((this32 == 0)) {
HXLINE(  72)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  72)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  72)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  72)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  72)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  72)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  72)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  72)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  72)										{
HXLINE(  72)											int _hx_tmp6;
HXDLIN(  72)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  72)												_hx_tmp6 = blended1;
            											}
HXDLIN(  72)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE(  72)										::Dynamic this33 = pixelImage->image;
HXDLIN(  72)										int index4;
HXDLIN(  72)										if (pixelImage->useVirtualPos) {
HXLINE(  72)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  72)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN(  72)										int _hx_tmp7;
HXDLIN(  72)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE(  72)											_hx_tmp7 = c3;
            										}
HXDLIN(  72)										::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXLINE(  76)								if (found) {
HXLINE(  76)									goto _hx_goto_24;
            								}
            							}
            						}
            					}
            					_hx_goto_24:;
            				}
            			}
            		}
HXLINE(  81)		if ((hasHit == true)) {
HXLINE(  82)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE(  83)			if (hasUndo) {
HXLINE(  84)				v2->undoImage = undoImage;
HXLINE(  85)				v2->undoX = xIter3->start;
HXLINE(  86)				v2->undoY = yIter3->start;
            			}
HXLINE(  88)			return v2;
            		}
            		else {
HXLINE(  90)			return null();
            		}
HXLINE(  81)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriUnsafe,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriangle2( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_98_fillTriangle2)
HXLINE(  99)		bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXLINE( 100)		if (!(adjustWinding)) {
HXLINE( 103)			Float bx_ = bx;
HXLINE( 104)			Float by_ = by;
HXLINE( 105)			bx = cx;
HXLINE( 106)			by = cy;
HXLINE( 107)			cx = bx_;
HXLINE( 108)			cy = by_;
            		}
HXLINE( 110)		bool hasUndo = false;
HXDLIN( 110)		Float s0 = ((ay * cx) - (ax * cy));
HXDLIN( 110)		Float sx = (cy - ay);
HXDLIN( 110)		Float sy = (ax - cx);
HXDLIN( 110)		Float t0 = ((ax * by) - (ay * bx));
HXDLIN( 110)		Float tx = (ay - by);
HXDLIN( 110)		Float ty = (bx - ax);
HXDLIN( 110)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN( 110)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 110)		if ((ax > bx)) {
HXLINE( 110)			if ((ax > cx)) {
HXLINE( 110)				int min;
HXDLIN( 110)				if ((bx > cx)) {
HXLINE( 110)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 110)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 110)				int ii_min = min;
HXDLIN( 110)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 110)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 110)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 110)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 110)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 110)			if ((bx > cx)) {
HXLINE( 110)				int min1;
HXDLIN( 110)				if ((ax > cx)) {
HXLINE( 110)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 110)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 110)				int ii_min2 = min1;
HXDLIN( 110)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 110)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 110)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 110)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 110)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 110)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 110)		if ((ay > by)) {
HXLINE( 110)			if ((ay > cy)) {
HXLINE( 110)				int min2;
HXDLIN( 110)				if ((by > cy)) {
HXLINE( 110)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 110)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 110)				int ii_min4 = min2;
HXDLIN( 110)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 110)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 110)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 110)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 110)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 110)			if ((by > cy)) {
HXLINE( 110)				int min3;
HXDLIN( 110)				if ((ay > cy)) {
HXLINE( 110)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 110)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 110)				int ii_min6 = min3;
HXDLIN( 110)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 110)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 110)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 110)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 110)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 110)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 110)		if (hasUndo) {
HXLINE( 110)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 110)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 110)			 ::Dynamic imageType = null();
HXDLIN( 110)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 110)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 110)			::Dynamic undoImage1;
HXDLIN( 110)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 110)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 110)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 110)					{
HXLINE( 110)						b->width = width;
HXDLIN( 110)						b->height = height;
HXDLIN( 110)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 110)						{
HXLINE( 110)							int len = b->length;
HXDLIN( 110)							int w = 0;
HXDLIN( 110)							{
HXLINE( 110)								int _g = 0;
HXDLIN( 110)								int _g1 = b->height;
HXDLIN( 110)								while((_g < _g1)){
HXLINE( 110)									_g = (_g + 1);
HXDLIN( 110)									int y = (_g - 1);
HXDLIN( 110)									{
HXLINE( 110)										int _g2 = 0;
HXDLIN( 110)										int _g3 = b->width;
HXDLIN( 110)										while((_g2 < _g3)){
HXLINE( 110)											_g2 = (_g2 + 1);
HXDLIN( 110)											int x = (_g2 - 1);
HXDLIN( 110)											{
HXLINE( 110)												w = (w + 1);
HXDLIN( 110)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 110)											{
HXLINE( 110)												w = (w + 1);
HXDLIN( 110)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 110)											{
HXLINE( 110)												w = (w + 1);
HXDLIN( 110)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 110)											{
HXLINE( 110)												w = (w + 1);
HXDLIN( 110)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 110)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 110)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 110)					{
HXLINE( 110)						a->width = width;
HXDLIN( 110)						a->height = height;
HXDLIN( 110)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 110)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)						{
HXLINE( 110)							int _g4 = 0;
HXDLIN( 110)							int _g5 = a->length;
HXDLIN( 110)							while((_g4 < _g5)){
HXLINE( 110)								_g4 = (_g4 + 1);
HXDLIN( 110)								int i = (_g4 - 1);
HXDLIN( 110)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 110)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 110)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 110)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 110)					{
HXLINE( 110)						b1->width = width;
HXDLIN( 110)						b1->height = height;
HXDLIN( 110)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)						int size = (b1->length * 4);
HXDLIN( 110)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 110)						{
HXLINE( 110)							int _g6 = 0;
HXDLIN( 110)							int _g7 = b1->length;
HXDLIN( 110)							while((_g6 < _g7)){
HXLINE( 110)								_g6 = (_g6 + 1);
HXDLIN( 110)								int i1 = (_g6 - 1);
HXDLIN( 110)								{
HXLINE( 110)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 110)									bool undoImage2;
HXDLIN( 110)									if ((i1 >= 0)) {
HXLINE( 110)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 110)										undoImage2 = false;
            									}
HXDLIN( 110)									if (undoImage2) {
HXLINE( 110)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 110)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 110)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 110)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 110)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 110)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 110)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 110)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 110)					{
HXLINE( 110)						v->width = width;
HXDLIN( 110)						v->height = height;
HXDLIN( 110)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 110)						{
HXLINE( 110)							int _g8 = 0;
HXDLIN( 110)							int _g9 = v->length;
HXDLIN( 110)							while((_g8 < _g9)){
HXLINE( 110)								_g8 = (_g8 + 1);
HXDLIN( 110)								int i2 = (_g8 - 1);
HXDLIN( 110)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 110)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 110)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 110)					{
HXLINE( 110)						b2->width = width;
HXDLIN( 110)						b2->height = height;
HXDLIN( 110)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 110)						{
HXLINE( 110)							int len1 = b2->length;
HXDLIN( 110)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 110)							if (::hx::IsNull( d->head )) {
HXLINE( 110)								int _g10 = 0;
HXDLIN( 110)								int _g11 = len1;
HXDLIN( 110)								while((_g10 < _g11)){
HXLINE( 110)									_g10 = (_g10 + 1);
HXDLIN( 110)									int i3 = (_g10 - 1);
HXDLIN( 110)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 110)								int _g12 = 0;
HXDLIN( 110)								int _g13 = len1;
HXDLIN( 110)								while((_g12 < _g13)){
HXLINE( 110)									_g12 = (_g12 + 1);
HXDLIN( 110)									int i4 = (_g12 - 1);
HXDLIN( 110)									{
HXLINE( 110)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 110)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 110)										{
HXLINE( 110)											int _g14 = 0;
HXDLIN( 110)											int _g15 = i4;
HXDLIN( 110)											while((_g14 < _g15)){
HXLINE( 110)												_g14 = (_g14 + 1);
HXDLIN( 110)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 110)										if (::hx::IsNull( prev )) {
HXLINE( 110)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 110)											l = null();
            										}
            										else {
HXLINE( 110)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 110)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 110)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 110)			this1->image = undoImage1;
HXDLIN( 110)			this1->width = width;
HXDLIN( 110)			this1->height = height;
HXDLIN( 110)			this1->imageType = ( (int)(imageType) );
HXDLIN( 110)			undoImage = this1;
HXDLIN( 110)			{
HXLINE( 110)				int rectLeft = xIter3->start;
HXDLIN( 110)				int rectTop = yIter3->start;
HXDLIN( 110)				int rectRight = xIter3->max;
HXDLIN( 110)				bool forceClear = false;
HXDLIN( 110)				{
HXLINE( 110)					int _g16 = rectTop;
HXDLIN( 110)					int _g17 = yIter3->max;
HXDLIN( 110)					while((_g16 < _g17)){
HXLINE( 110)						_g16 = (_g16 + 1);
HXDLIN( 110)						int dy = (_g16 - 1);
HXDLIN( 110)						{
HXLINE( 110)							int _g18 = rectLeft;
HXDLIN( 110)							int _g19 = rectRight;
HXDLIN( 110)							while((_g18 < _g19)){
HXLINE( 110)								_g18 = (_g18 + 1);
HXDLIN( 110)								int dx = (_g18 - 1);
HXDLIN( 110)								::Dynamic this3 = pixelImage->image;
HXDLIN( 110)								int index;
HXDLIN( 110)								if (pixelImage->useVirtualPos) {
HXLINE( 110)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 110)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 110)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 110)								int col;
HXDLIN( 110)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 110)									col = c;
            								}
HXDLIN( 110)								bool _hx_tmp;
HXDLIN( 110)								if (pixelImage->useMask) {
HXLINE( 110)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 110)									_hx_tmp = false;
            								}
HXDLIN( 110)								if (_hx_tmp) {
HXLINE( 110)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 110)									::Dynamic this5 = this4->image;
HXDLIN( 110)									int index1;
HXDLIN( 110)									if (this4->useVirtualPos) {
HXLINE( 110)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 110)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 110)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 110)									int v1;
HXDLIN( 110)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 110)										v1 = c1;
            									}
HXDLIN( 110)									int maskPixel = v1;
HXDLIN( 110)									int this6 = col;
HXDLIN( 110)									if ((maskPixel == 0)) {
HXLINE( 110)										col = this6;
            									}
            									else {
HXLINE( 110)										Float m0;
HXDLIN( 110)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 110)										if ((this7 == 0)) {
HXLINE( 110)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float m1;
HXDLIN( 110)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 110)										if ((this8 == 0)) {
HXLINE( 110)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float m2;
HXDLIN( 110)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 110)										if ((this9 == 0)) {
HXLINE( 110)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float m3;
HXDLIN( 110)										int this10 = (maskPixel & 255);
HXDLIN( 110)										if ((this10 == 0)) {
HXLINE( 110)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 110)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 110)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 110)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 110)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 110)								if ((col != 0)) {
HXLINE( 110)									int x1 = (dx - rectLeft);
HXDLIN( 110)									int y1 = (dy - rectTop);
HXDLIN( 110)									int c2 = col;
HXDLIN( 110)									bool _hx_tmp1;
HXDLIN( 110)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 110)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 110)										_hx_tmp1 = false;
            									}
HXDLIN( 110)									if (_hx_tmp1) {
HXLINE( 110)										int location;
HXDLIN( 110)										if (undoImage->useVirtualPos) {
HXLINE( 110)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 110)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 110)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 110)										int this12;
HXDLIN( 110)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 110)											this12 = this11;
            										}
HXDLIN( 110)										Float a1;
HXDLIN( 110)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 110)										if ((this13 == 0)) {
HXLINE( 110)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float r1;
HXDLIN( 110)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 110)										if ((this14 == 0)) {
HXLINE( 110)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float g1;
HXDLIN( 110)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 110)										if ((this15 == 0)) {
HXLINE( 110)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float b11;
HXDLIN( 110)										int this16 = (this12 & 255);
HXDLIN( 110)										if ((this16 == 0)) {
HXLINE( 110)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float a2;
HXDLIN( 110)										int this17 = ((col >> 24) & 255);
HXDLIN( 110)										if ((this17 == 0)) {
HXLINE( 110)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float r2;
HXDLIN( 110)										int this18 = ((col >> 16) & 255);
HXDLIN( 110)										if ((this18 == 0)) {
HXLINE( 110)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float g2;
HXDLIN( 110)										int this19 = ((col >> 8) & 255);
HXDLIN( 110)										if ((this19 == 0)) {
HXLINE( 110)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float b21;
HXDLIN( 110)										int this20 = (col & 255);
HXDLIN( 110)										if ((this20 == 0)) {
HXLINE( 110)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 110)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 110)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 110)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 110)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 110)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 110)										{
HXLINE( 110)											int _hx_tmp2;
HXDLIN( 110)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 110)												_hx_tmp2 = blended;
            											}
HXDLIN( 110)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 110)										::Dynamic this21 = undoImage->image;
HXDLIN( 110)										int index2;
HXDLIN( 110)										if (undoImage->useVirtualPos) {
HXLINE( 110)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 110)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 110)										int _hx_tmp3;
HXDLIN( 110)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 110)											_hx_tmp3 = c2;
            										}
HXDLIN( 110)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 110)									if (forceClear) {
HXLINE( 110)										::Dynamic this22 = undoImage->image;
HXDLIN( 110)										int x2 = (dx - rectLeft);
HXDLIN( 110)										int y2 = (dy - rectTop);
HXDLIN( 110)										int index3;
HXDLIN( 110)										if (undoImage->useVirtualPos) {
HXLINE( 110)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 110)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 110)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 110)		bool found = false;
HXDLIN( 110)		Float s = ((Float)0.);
HXDLIN( 110)		Float t = ((Float)0.);
HXDLIN( 110)		Float syy = ((Float)0.);
HXDLIN( 110)		Float tyy = ((Float)0.);
HXDLIN( 110)		{
HXLINE( 110)			int _g_min = yIter3->start;
HXDLIN( 110)			int _g_max = yIter3->max;
HXDLIN( 110)			while((_g_min < _g_max)){
HXLINE( 110)				_g_min = (_g_min + 1);
HXDLIN( 110)				int y3 = (_g_min - 1);
HXLINE( 140)				syy = (sy * ( (Float)(y3) ));
HXLINE( 141)				tyy = (ty * ( (Float)(y3) ));
HXLINE( 142)				found = false;
HXLINE( 110)				{
HXLINE( 110)					int _g_min1 = xIter3->start;
HXDLIN( 110)					int _g_max1 = xIter3->max;
HXDLIN( 110)					while((_g_min1 < _g_max1)){
HXLINE( 110)						_g_min1 = (_g_min1 + 1);
HXDLIN( 110)						int x3 = (_g_min1 - 1);
HXLINE( 144)						s = ((s0 + (sx * ( (Float)(x3) ))) + syy);
HXLINE( 145)						t = ((t0 + (tx * ( (Float)(x3) ))) + tyy);
HXLINE( 110)						bool _hx_tmp4;
HXDLIN( 110)						if (!((s <= 0))) {
HXLINE( 110)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 110)							_hx_tmp4 = true;
            						}
HXDLIN( 110)						if (_hx_tmp4) {
HXLINE( 110)							if (found) {
HXLINE( 110)								goto _hx_goto_37;
            							}
            						}
            						else {
HXLINE( 110)							if (((s + t) < A)) {
HXLINE( 110)								{
HXLINE( 110)									int c3 = color;
HXDLIN( 110)									bool _hx_tmp5;
HXDLIN( 110)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 110)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE( 110)										_hx_tmp5 = false;
            									}
HXDLIN( 110)									if (_hx_tmp5) {
HXLINE( 110)										int location1;
HXDLIN( 110)										if (pixelImage->useVirtualPos) {
HXLINE( 110)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 110)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 110)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 110)										int this24;
HXDLIN( 110)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)											this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 110)											this24 = this23;
            										}
HXDLIN( 110)										Float a11;
HXDLIN( 110)										int this25 = ((this24 >> 24) & 255);
HXDLIN( 110)										if ((this25 == 0)) {
HXLINE( 110)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float r11;
HXDLIN( 110)										int this26 = ((this24 >> 16) & 255);
HXDLIN( 110)										if ((this26 == 0)) {
HXLINE( 110)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float g11;
HXDLIN( 110)										int this27 = ((this24 >> 8) & 255);
HXDLIN( 110)										if ((this27 == 0)) {
HXLINE( 110)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float b12;
HXDLIN( 110)										int this28 = (this24 & 255);
HXDLIN( 110)										if ((this28 == 0)) {
HXLINE( 110)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float a21;
HXDLIN( 110)										int this29 = ((color >> 24) & 255);
HXDLIN( 110)										if ((this29 == 0)) {
HXLINE( 110)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float r21;
HXDLIN( 110)										int this30 = ((color >> 16) & 255);
HXDLIN( 110)										if ((this30 == 0)) {
HXLINE( 110)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float g21;
HXDLIN( 110)										int this31 = ((color >> 8) & 255);
HXDLIN( 110)										if ((this31 == 0)) {
HXLINE( 110)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float b22;
HXDLIN( 110)										int this32 = (color & 255);
HXDLIN( 110)										if ((this32 == 0)) {
HXLINE( 110)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 110)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 110)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 110)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 110)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 110)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 110)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 110)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 110)										{
HXLINE( 110)											int _hx_tmp6;
HXDLIN( 110)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 110)												_hx_tmp6 = blended1;
            											}
HXDLIN( 110)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 110)										::Dynamic this33 = pixelImage->image;
HXDLIN( 110)										int index4;
HXDLIN( 110)										if (pixelImage->useVirtualPos) {
HXLINE( 110)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 110)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 110)										int _hx_tmp7;
HXDLIN( 110)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 110)											_hx_tmp7 = c3;
            										}
HXDLIN( 110)										::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            									}
            								}
HXLINE( 153)								found = true;
            							}
            							else {
HXLINE( 110)								if (found) {
HXLINE( 110)									goto _hx_goto_37;
            								}
            							}
            						}
            					}
            					_hx_goto_37:;
            				}
            			}
            		}
HXDLIN( 110)		if ((hasHit == true)) {
HXLINE( 110)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 110)			if (hasUndo) {
HXLINE( 110)				v2->undoImage = undoImage;
HXDLIN( 110)				v2->undoX = xIter3->start;
HXDLIN( 110)				v2->undoY = yIter3->start;
            			}
HXDLIN( 110)			return v2;
            		}
            		else {
HXLINE( 110)			return null();
            		}
HXDLIN( 110)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TriPixel_Fields__obj,fillTriangle2,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriUnsafe2( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_119_fillTriUnsafe2)
HXLINE( 120)		Float s0 = ((ay * cx) - (ax * cy));
HXLINE( 121)		Float sx = (cy - ay);
HXLINE( 122)		Float sy = (ax - cx);
HXLINE( 123)		Float t0 = ((ax * by) - (ay * bx));
HXLINE( 124)		Float tx = (ay - by);
HXLINE( 125)		Float ty = (bx - ax);
HXLINE( 126)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXLINE( 127)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 127)		if ((ax > bx)) {
HXLINE( 127)			if ((ax > cx)) {
HXLINE( 127)				int min;
HXDLIN( 127)				if ((bx > cx)) {
HXLINE( 127)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 127)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 127)				int ii_min = min;
HXDLIN( 127)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 127)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 127)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 127)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 127)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 127)			if ((bx > cx)) {
HXLINE( 127)				int min1;
HXDLIN( 127)				if ((ax > cx)) {
HXLINE( 127)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 127)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 127)				int ii_min2 = min1;
HXDLIN( 127)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 127)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 127)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 127)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 127)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 128)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 128)		if ((ay > by)) {
HXLINE( 128)			if ((ay > cy)) {
HXLINE( 128)				int min2;
HXDLIN( 128)				if ((by > cy)) {
HXLINE( 128)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 128)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 128)				int ii_min4 = min2;
HXDLIN( 128)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 128)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 128)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 128)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 128)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 128)			if ((by > cy)) {
HXLINE( 128)				int min3;
HXDLIN( 128)				if ((ay > cy)) {
HXLINE( 128)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 128)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 128)				int ii_min6 = min3;
HXDLIN( 128)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 128)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 128)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 128)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 128)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 129)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 130)		if (hasUndo) {
HXLINE( 131)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 131)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 131)			 ::Dynamic imageType = null();
HXDLIN( 131)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 131)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 131)			::Dynamic undoImage1;
HXDLIN( 131)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 131)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 131)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 131)					{
HXLINE( 131)						b->width = width;
HXDLIN( 131)						b->height = height;
HXDLIN( 131)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 131)						{
HXLINE( 131)							int len = b->length;
HXDLIN( 131)							int w = 0;
HXDLIN( 131)							{
HXLINE( 131)								int _g = 0;
HXDLIN( 131)								int _g1 = b->height;
HXDLIN( 131)								while((_g < _g1)){
HXLINE( 131)									_g = (_g + 1);
HXDLIN( 131)									int y = (_g - 1);
HXDLIN( 131)									{
HXLINE( 131)										int _g2 = 0;
HXDLIN( 131)										int _g3 = b->width;
HXDLIN( 131)										while((_g2 < _g3)){
HXLINE( 131)											_g2 = (_g2 + 1);
HXDLIN( 131)											int x = (_g2 - 1);
HXDLIN( 131)											{
HXLINE( 131)												w = (w + 1);
HXDLIN( 131)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 131)											{
HXLINE( 131)												w = (w + 1);
HXDLIN( 131)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 131)											{
HXLINE( 131)												w = (w + 1);
HXDLIN( 131)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 131)											{
HXLINE( 131)												w = (w + 1);
HXDLIN( 131)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 131)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 131)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 131)					{
HXLINE( 131)						a->width = width;
HXDLIN( 131)						a->height = height;
HXDLIN( 131)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 131)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)						{
HXLINE( 131)							int _g4 = 0;
HXDLIN( 131)							int _g5 = a->length;
HXDLIN( 131)							while((_g4 < _g5)){
HXLINE( 131)								_g4 = (_g4 + 1);
HXDLIN( 131)								int i = (_g4 - 1);
HXDLIN( 131)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 131)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 131)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 131)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 131)					{
HXLINE( 131)						b1->width = width;
HXDLIN( 131)						b1->height = height;
HXDLIN( 131)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)						int size = (b1->length * 4);
HXDLIN( 131)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 131)						{
HXLINE( 131)							int _g6 = 0;
HXDLIN( 131)							int _g7 = b1->length;
HXDLIN( 131)							while((_g6 < _g7)){
HXLINE( 131)								_g6 = (_g6 + 1);
HXDLIN( 131)								int i1 = (_g6 - 1);
HXDLIN( 131)								{
HXLINE( 131)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 131)									bool undoImage2;
HXDLIN( 131)									if ((i1 >= 0)) {
HXLINE( 131)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 131)										undoImage2 = false;
            									}
HXDLIN( 131)									if (undoImage2) {
HXLINE( 131)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 131)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 131)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 131)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 131)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 131)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 131)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 131)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 131)					{
HXLINE( 131)						v->width = width;
HXDLIN( 131)						v->height = height;
HXDLIN( 131)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 131)						{
HXLINE( 131)							int _g8 = 0;
HXDLIN( 131)							int _g9 = v->length;
HXDLIN( 131)							while((_g8 < _g9)){
HXLINE( 131)								_g8 = (_g8 + 1);
HXDLIN( 131)								int i2 = (_g8 - 1);
HXDLIN( 131)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 131)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 131)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 131)					{
HXLINE( 131)						b2->width = width;
HXDLIN( 131)						b2->height = height;
HXDLIN( 131)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 131)						{
HXLINE( 131)							int len1 = b2->length;
HXDLIN( 131)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 131)							if (::hx::IsNull( d->head )) {
HXLINE( 131)								int _g10 = 0;
HXDLIN( 131)								int _g11 = len1;
HXDLIN( 131)								while((_g10 < _g11)){
HXLINE( 131)									_g10 = (_g10 + 1);
HXDLIN( 131)									int i3 = (_g10 - 1);
HXDLIN( 131)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 131)								int _g12 = 0;
HXDLIN( 131)								int _g13 = len1;
HXDLIN( 131)								while((_g12 < _g13)){
HXLINE( 131)									_g12 = (_g12 + 1);
HXDLIN( 131)									int i4 = (_g12 - 1);
HXDLIN( 131)									{
HXLINE( 131)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 131)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 131)										{
HXLINE( 131)											int _g14 = 0;
HXDLIN( 131)											int _g15 = i4;
HXDLIN( 131)											while((_g14 < _g15)){
HXLINE( 131)												_g14 = (_g14 + 1);
HXDLIN( 131)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 131)										if (::hx::IsNull( prev )) {
HXLINE( 131)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 131)											l = null();
            										}
            										else {
HXLINE( 131)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 131)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 131)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 131)			this1->image = undoImage1;
HXDLIN( 131)			this1->width = width;
HXDLIN( 131)			this1->height = height;
HXDLIN( 131)			this1->imageType = ( (int)(imageType) );
HXDLIN( 131)			undoImage = this1;
HXLINE( 132)			{
HXLINE( 132)				int rectLeft = xIter3->start;
HXDLIN( 132)				int rectTop = yIter3->start;
HXDLIN( 132)				int rectRight = xIter3->max;
HXDLIN( 132)				bool forceClear = false;
HXDLIN( 132)				{
HXLINE( 132)					int _g16 = rectTop;
HXDLIN( 132)					int _g17 = yIter3->max;
HXDLIN( 132)					while((_g16 < _g17)){
HXLINE( 132)						_g16 = (_g16 + 1);
HXDLIN( 132)						int dy = (_g16 - 1);
HXDLIN( 132)						{
HXLINE( 132)							int _g18 = rectLeft;
HXDLIN( 132)							int _g19 = rectRight;
HXDLIN( 132)							while((_g18 < _g19)){
HXLINE( 132)								_g18 = (_g18 + 1);
HXDLIN( 132)								int dx = (_g18 - 1);
HXDLIN( 132)								::Dynamic this3 = pixelImage->image;
HXDLIN( 132)								int index;
HXDLIN( 132)								if (pixelImage->useVirtualPos) {
HXLINE( 132)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 132)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 132)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 132)								int col;
HXDLIN( 132)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 132)									col = c;
            								}
HXDLIN( 132)								bool _hx_tmp;
HXDLIN( 132)								if (pixelImage->useMask) {
HXLINE( 132)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 132)									_hx_tmp = false;
            								}
HXDLIN( 132)								if (_hx_tmp) {
HXLINE( 132)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 132)									::Dynamic this5 = this4->image;
HXDLIN( 132)									int index1;
HXDLIN( 132)									if (this4->useVirtualPos) {
HXLINE( 132)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 132)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 132)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 132)									int v1;
HXDLIN( 132)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 132)										v1 = c1;
            									}
HXDLIN( 132)									int maskPixel = v1;
HXDLIN( 132)									int this6 = col;
HXDLIN( 132)									if ((maskPixel == 0)) {
HXLINE( 132)										col = this6;
            									}
            									else {
HXLINE( 132)										Float m0;
HXDLIN( 132)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 132)										if ((this7 == 0)) {
HXLINE( 132)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float m1;
HXDLIN( 132)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 132)										if ((this8 == 0)) {
HXLINE( 132)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float m2;
HXDLIN( 132)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 132)										if ((this9 == 0)) {
HXLINE( 132)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float m3;
HXDLIN( 132)										int this10 = (maskPixel & 255);
HXDLIN( 132)										if ((this10 == 0)) {
HXLINE( 132)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 132)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 132)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 132)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 132)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 132)								if ((col != 0)) {
HXLINE( 132)									int x1 = (dx - rectLeft);
HXDLIN( 132)									int y1 = (dy - rectTop);
HXDLIN( 132)									int c2 = col;
HXDLIN( 132)									bool _hx_tmp1;
HXDLIN( 132)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 132)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 132)										_hx_tmp1 = false;
            									}
HXDLIN( 132)									if (_hx_tmp1) {
HXLINE( 132)										int location;
HXDLIN( 132)										if (undoImage->useVirtualPos) {
HXLINE( 132)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 132)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 132)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 132)										int this12;
HXDLIN( 132)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 132)											this12 = this11;
            										}
HXDLIN( 132)										Float a1;
HXDLIN( 132)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 132)										if ((this13 == 0)) {
HXLINE( 132)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float r1;
HXDLIN( 132)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 132)										if ((this14 == 0)) {
HXLINE( 132)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float g1;
HXDLIN( 132)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 132)										if ((this15 == 0)) {
HXLINE( 132)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float b11;
HXDLIN( 132)										int this16 = (this12 & 255);
HXDLIN( 132)										if ((this16 == 0)) {
HXLINE( 132)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float a2;
HXDLIN( 132)										int this17 = ((col >> 24) & 255);
HXDLIN( 132)										if ((this17 == 0)) {
HXLINE( 132)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float r2;
HXDLIN( 132)										int this18 = ((col >> 16) & 255);
HXDLIN( 132)										if ((this18 == 0)) {
HXLINE( 132)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float g2;
HXDLIN( 132)										int this19 = ((col >> 8) & 255);
HXDLIN( 132)										if ((this19 == 0)) {
HXLINE( 132)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float b21;
HXDLIN( 132)										int this20 = (col & 255);
HXDLIN( 132)										if ((this20 == 0)) {
HXLINE( 132)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 132)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 132)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 132)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 132)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 132)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 132)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 132)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 132)										{
HXLINE( 132)											int _hx_tmp2;
HXDLIN( 132)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 132)												_hx_tmp2 = blended;
            											}
HXDLIN( 132)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 132)										::Dynamic this21 = undoImage->image;
HXDLIN( 132)										int index2;
HXDLIN( 132)										if (undoImage->useVirtualPos) {
HXLINE( 132)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 132)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 132)										int _hx_tmp3;
HXDLIN( 132)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 132)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 132)											_hx_tmp3 = c2;
            										}
HXDLIN( 132)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 132)									if (forceClear) {
HXLINE( 132)										::Dynamic this22 = undoImage->image;
HXDLIN( 132)										int x2 = (dx - rectLeft);
HXDLIN( 132)										int y2 = (dy - rectTop);
HXDLIN( 132)										int index3;
HXDLIN( 132)										if (undoImage->useVirtualPos) {
HXLINE( 132)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 132)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 132)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 134)		bool found = false;
HXLINE( 135)		Float s = ((Float)0.);
HXLINE( 136)		Float t = ((Float)0.);
HXLINE( 137)		Float syy = ((Float)0.);
HXLINE( 138)		Float tyy = ((Float)0.);
HXLINE( 139)		{
HXLINE( 139)			int _g_min = yIter3->start;
HXDLIN( 139)			int _g_max = yIter3->max;
HXDLIN( 139)			while((_g_min < _g_max)){
HXLINE( 139)				_g_min = (_g_min + 1);
HXDLIN( 139)				int y3 = (_g_min - 1);
HXLINE( 140)				syy = (sy * ( (Float)(y3) ));
HXLINE( 141)				tyy = (ty * ( (Float)(y3) ));
HXLINE( 142)				found = false;
HXLINE( 143)				{
HXLINE( 143)					int _g_min1 = xIter3->start;
HXDLIN( 143)					int _g_max1 = xIter3->max;
HXDLIN( 143)					while((_g_min1 < _g_max1)){
HXLINE( 143)						_g_min1 = (_g_min1 + 1);
HXDLIN( 143)						int x3 = (_g_min1 - 1);
HXLINE( 144)						s = ((s0 + (sx * ( (Float)(x3) ))) + syy);
HXLINE( 145)						t = ((t0 + (tx * ( (Float)(x3) ))) + tyy);
HXLINE( 146)						bool _hx_tmp4;
HXDLIN( 146)						if (!((s <= 0))) {
HXLINE( 146)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 146)							_hx_tmp4 = true;
            						}
HXDLIN( 146)						if (_hx_tmp4) {
HXLINE( 148)							if (found) {
HXLINE( 148)								goto _hx_goto_50;
            							}
            						}
            						else {
HXLINE( 150)							if (((s + t) < A)) {
HXLINE( 152)								{
HXLINE( 152)									int c3 = color;
HXDLIN( 152)									bool _hx_tmp5;
HXDLIN( 152)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 152)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE( 152)										_hx_tmp5 = false;
            									}
HXDLIN( 152)									if (_hx_tmp5) {
HXLINE( 152)										int location1;
HXDLIN( 152)										if (pixelImage->useVirtualPos) {
HXLINE( 152)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 152)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 152)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 152)										int this24;
HXDLIN( 152)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)											this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 152)											this24 = this23;
            										}
HXDLIN( 152)										Float a11;
HXDLIN( 152)										int this25 = ((this24 >> 24) & 255);
HXDLIN( 152)										if ((this25 == 0)) {
HXLINE( 152)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float r11;
HXDLIN( 152)										int this26 = ((this24 >> 16) & 255);
HXDLIN( 152)										if ((this26 == 0)) {
HXLINE( 152)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float g11;
HXDLIN( 152)										int this27 = ((this24 >> 8) & 255);
HXDLIN( 152)										if ((this27 == 0)) {
HXLINE( 152)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float b12;
HXDLIN( 152)										int this28 = (this24 & 255);
HXDLIN( 152)										if ((this28 == 0)) {
HXLINE( 152)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float a21;
HXDLIN( 152)										int this29 = ((color >> 24) & 255);
HXDLIN( 152)										if ((this29 == 0)) {
HXLINE( 152)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float r21;
HXDLIN( 152)										int this30 = ((color >> 16) & 255);
HXDLIN( 152)										if ((this30 == 0)) {
HXLINE( 152)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float g21;
HXDLIN( 152)										int this31 = ((color >> 8) & 255);
HXDLIN( 152)										if ((this31 == 0)) {
HXLINE( 152)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float b22;
HXDLIN( 152)										int this32 = (color & 255);
HXDLIN( 152)										if ((this32 == 0)) {
HXLINE( 152)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 152)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 152)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 152)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 152)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 152)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 152)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 152)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 152)										{
HXLINE( 152)											int _hx_tmp6;
HXDLIN( 152)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 152)												_hx_tmp6 = blended1;
            											}
HXDLIN( 152)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 152)										::Dynamic this33 = pixelImage->image;
HXDLIN( 152)										int index4;
HXDLIN( 152)										if (pixelImage->useVirtualPos) {
HXLINE( 152)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 152)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 152)										int _hx_tmp7;
HXDLIN( 152)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 152)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 152)											_hx_tmp7 = c3;
            										}
HXDLIN( 152)										::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            									}
            								}
HXLINE( 153)								found = true;
            							}
            							else {
HXLINE( 156)								if (found) {
HXLINE( 156)									goto _hx_goto_50;
            								}
            							}
            						}
            					}
            					_hx_goto_50:;
            				}
            			}
            		}
HXLINE( 161)		if ((hasHit == true)) {
HXLINE( 162)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 163)			if (hasUndo) {
HXLINE( 164)				v2->undoImage = undoImage;
HXLINE( 165)				v2->undoX = xIter3->start;
HXLINE( 166)				v2->undoY = yIter3->start;
            			}
HXLINE( 168)			return v2;
            		}
            		else {
HXLINE( 170)			return null();
            		}
HXLINE( 161)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriUnsafe2,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::tileTriangle( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_180_tileTriangle)
HXLINE( 181)		bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXLINE( 182)		if (!(adjustWinding)) {
HXLINE( 185)			Float bx_ = bx;
HXLINE( 186)			Float by_ = by;
HXLINE( 187)			bx = cx;
HXLINE( 188)			by = cy;
HXLINE( 189)			cx = bx_;
HXLINE( 190)			cy = by_;
            		}
HXLINE( 192)		bool hasUndo = false;
HXDLIN( 192)		Float s0 = ((ay * cx) - (ax * cy));
HXDLIN( 192)		Float sx = (cy - ay);
HXDLIN( 192)		Float sy = (ax - cx);
HXDLIN( 192)		Float t0 = ((ax * by) - (ay * bx));
HXDLIN( 192)		Float tx = (ay - by);
HXDLIN( 192)		Float ty = (bx - ax);
HXDLIN( 192)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN( 192)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 192)		if ((ax > bx)) {
HXLINE( 192)			if ((ax > cx)) {
HXLINE( 192)				int min;
HXDLIN( 192)				if ((bx > cx)) {
HXLINE( 192)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 192)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 192)				int ii_min = min;
HXDLIN( 192)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 192)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 192)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 192)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 192)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 192)			if ((bx > cx)) {
HXLINE( 192)				int min1;
HXDLIN( 192)				if ((ax > cx)) {
HXLINE( 192)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 192)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 192)				int ii_min2 = min1;
HXDLIN( 192)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 192)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 192)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 192)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 192)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 192)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 192)		if ((ay > by)) {
HXLINE( 192)			if ((ay > cy)) {
HXLINE( 192)				int min2;
HXDLIN( 192)				if ((by > cy)) {
HXLINE( 192)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 192)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 192)				int ii_min4 = min2;
HXDLIN( 192)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 192)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 192)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 192)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 192)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 192)			if ((by > cy)) {
HXLINE( 192)				int min3;
HXDLIN( 192)				if ((ay > cy)) {
HXLINE( 192)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 192)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 192)				int ii_min6 = min3;
HXDLIN( 192)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 192)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 192)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 192)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 192)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 192)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 192)		if (hasUndo) {
HXLINE( 192)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 192)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 192)			 ::Dynamic imageType = null();
HXDLIN( 192)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 192)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 192)			::Dynamic undoImage1;
HXDLIN( 192)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 192)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 192)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 192)					{
HXLINE( 192)						b->width = width;
HXDLIN( 192)						b->height = height;
HXDLIN( 192)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 192)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 192)						{
HXLINE( 192)							int len = b->length;
HXDLIN( 192)							int w = 0;
HXDLIN( 192)							{
HXLINE( 192)								int _g = 0;
HXDLIN( 192)								int _g1 = b->height;
HXDLIN( 192)								while((_g < _g1)){
HXLINE( 192)									_g = (_g + 1);
HXDLIN( 192)									int y = (_g - 1);
HXDLIN( 192)									{
HXLINE( 192)										int _g2 = 0;
HXDLIN( 192)										int _g3 = b->width;
HXDLIN( 192)										while((_g2 < _g3)){
HXLINE( 192)											_g2 = (_g2 + 1);
HXDLIN( 192)											int x = (_g2 - 1);
HXDLIN( 192)											{
HXLINE( 192)												w = (w + 1);
HXDLIN( 192)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 192)											{
HXLINE( 192)												w = (w + 1);
HXDLIN( 192)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 192)											{
HXLINE( 192)												w = (w + 1);
HXDLIN( 192)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 192)											{
HXLINE( 192)												w = (w + 1);
HXDLIN( 192)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 192)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 192)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 192)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 192)					{
HXLINE( 192)						a->width = width;
HXDLIN( 192)						a->height = height;
HXDLIN( 192)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 192)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 192)						{
HXLINE( 192)							int _g4 = 0;
HXDLIN( 192)							int _g5 = a->length;
HXDLIN( 192)							while((_g4 < _g5)){
HXLINE( 192)								_g4 = (_g4 + 1);
HXDLIN( 192)								int i = (_g4 - 1);
HXDLIN( 192)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 192)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 192)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 192)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 192)					{
HXLINE( 192)						b1->width = width;
HXDLIN( 192)						b1->height = height;
HXDLIN( 192)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 192)						int size = (b1->length * 4);
HXDLIN( 192)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 192)						{
HXLINE( 192)							int _g6 = 0;
HXDLIN( 192)							int _g7 = b1->length;
HXDLIN( 192)							while((_g6 < _g7)){
HXLINE( 192)								_g6 = (_g6 + 1);
HXDLIN( 192)								int i1 = (_g6 - 1);
HXDLIN( 192)								{
HXLINE( 192)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 192)									bool undoImage2;
HXDLIN( 192)									if ((i1 >= 0)) {
HXLINE( 192)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 192)										undoImage2 = false;
            									}
HXDLIN( 192)									if (undoImage2) {
HXLINE( 192)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 192)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 192)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 192)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 192)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 192)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 192)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 192)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 192)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 192)					{
HXLINE( 192)						v->width = width;
HXDLIN( 192)						v->height = height;
HXDLIN( 192)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 192)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 192)						{
HXLINE( 192)							int _g8 = 0;
HXDLIN( 192)							int _g9 = v->length;
HXDLIN( 192)							while((_g8 < _g9)){
HXLINE( 192)								_g8 = (_g8 + 1);
HXDLIN( 192)								int i2 = (_g8 - 1);
HXDLIN( 192)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 192)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 192)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 192)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 192)					{
HXLINE( 192)						b2->width = width;
HXDLIN( 192)						b2->height = height;
HXDLIN( 192)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 192)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 192)						{
HXLINE( 192)							int len1 = b2->length;
HXDLIN( 192)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 192)							if (::hx::IsNull( d->head )) {
HXLINE( 192)								int _g10 = 0;
HXDLIN( 192)								int _g11 = len1;
HXDLIN( 192)								while((_g10 < _g11)){
HXLINE( 192)									_g10 = (_g10 + 1);
HXDLIN( 192)									int i3 = (_g10 - 1);
HXDLIN( 192)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 192)								int _g12 = 0;
HXDLIN( 192)								int _g13 = len1;
HXDLIN( 192)								while((_g12 < _g13)){
HXLINE( 192)									_g12 = (_g12 + 1);
HXDLIN( 192)									int i4 = (_g12 - 1);
HXDLIN( 192)									{
HXLINE( 192)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 192)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 192)										{
HXLINE( 192)											int _g14 = 0;
HXDLIN( 192)											int _g15 = i4;
HXDLIN( 192)											while((_g14 < _g15)){
HXLINE( 192)												_g14 = (_g14 + 1);
HXDLIN( 192)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 192)										if (::hx::IsNull( prev )) {
HXLINE( 192)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 192)											l = null();
            										}
            										else {
HXLINE( 192)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 192)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 192)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 192)			this1->image = undoImage1;
HXDLIN( 192)			this1->width = width;
HXDLIN( 192)			this1->height = height;
HXDLIN( 192)			this1->imageType = ( (int)(imageType) );
HXDLIN( 192)			undoImage = this1;
HXDLIN( 192)			{
HXLINE( 192)				int rectLeft = xIter3->start;
HXDLIN( 192)				int rectTop = yIter3->start;
HXDLIN( 192)				int rectRight = xIter3->max;
HXDLIN( 192)				bool forceClear = false;
HXDLIN( 192)				{
HXLINE( 192)					int _g16 = rectTop;
HXDLIN( 192)					int _g17 = yIter3->max;
HXDLIN( 192)					while((_g16 < _g17)){
HXLINE( 192)						_g16 = (_g16 + 1);
HXDLIN( 192)						int dy = (_g16 - 1);
HXDLIN( 192)						{
HXLINE( 192)							int _g18 = rectLeft;
HXDLIN( 192)							int _g19 = rectRight;
HXDLIN( 192)							while((_g18 < _g19)){
HXLINE( 192)								_g18 = (_g18 + 1);
HXDLIN( 192)								int dx = (_g18 - 1);
HXDLIN( 192)								::Dynamic this3 = pixelImage->image;
HXDLIN( 192)								int index;
HXDLIN( 192)								if (pixelImage->useVirtualPos) {
HXLINE( 192)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 192)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 192)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 192)								int col;
HXDLIN( 192)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 192)									col = c;
            								}
HXDLIN( 192)								bool _hx_tmp;
HXDLIN( 192)								if (pixelImage->useMask) {
HXLINE( 192)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 192)									_hx_tmp = false;
            								}
HXDLIN( 192)								if (_hx_tmp) {
HXLINE( 192)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 192)									::Dynamic this5 = this4->image;
HXDLIN( 192)									int index1;
HXDLIN( 192)									if (this4->useVirtualPos) {
HXLINE( 192)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 192)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 192)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 192)									int v1;
HXDLIN( 192)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 192)										v1 = c1;
            									}
HXDLIN( 192)									int maskPixel = v1;
HXDLIN( 192)									int this6 = col;
HXDLIN( 192)									if ((maskPixel == 0)) {
HXLINE( 192)										col = this6;
            									}
            									else {
HXLINE( 192)										Float m0;
HXDLIN( 192)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 192)										if ((this7 == 0)) {
HXLINE( 192)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float m1;
HXDLIN( 192)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 192)										if ((this8 == 0)) {
HXLINE( 192)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float m2;
HXDLIN( 192)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 192)										if ((this9 == 0)) {
HXLINE( 192)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float m3;
HXDLIN( 192)										int this10 = (maskPixel & 255);
HXDLIN( 192)										if ((this10 == 0)) {
HXLINE( 192)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 192)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 192)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 192)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 192)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 192)								if ((col != 0)) {
HXLINE( 192)									int x1 = (dx - rectLeft);
HXDLIN( 192)									int y1 = (dy - rectTop);
HXDLIN( 192)									int c2 = col;
HXDLIN( 192)									bool _hx_tmp1;
HXDLIN( 192)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 192)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 192)										_hx_tmp1 = false;
            									}
HXDLIN( 192)									if (_hx_tmp1) {
HXLINE( 192)										int location;
HXDLIN( 192)										if (undoImage->useVirtualPos) {
HXLINE( 192)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 192)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 192)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 192)										int this12;
HXDLIN( 192)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 192)											this12 = this11;
            										}
HXDLIN( 192)										Float a1;
HXDLIN( 192)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 192)										if ((this13 == 0)) {
HXLINE( 192)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float r1;
HXDLIN( 192)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 192)										if ((this14 == 0)) {
HXLINE( 192)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float g1;
HXDLIN( 192)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 192)										if ((this15 == 0)) {
HXLINE( 192)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float b11;
HXDLIN( 192)										int this16 = (this12 & 255);
HXDLIN( 192)										if ((this16 == 0)) {
HXLINE( 192)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float a2;
HXDLIN( 192)										int this17 = ((col >> 24) & 255);
HXDLIN( 192)										if ((this17 == 0)) {
HXLINE( 192)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float r2;
HXDLIN( 192)										int this18 = ((col >> 16) & 255);
HXDLIN( 192)										if ((this18 == 0)) {
HXLINE( 192)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float g2;
HXDLIN( 192)										int this19 = ((col >> 8) & 255);
HXDLIN( 192)										if ((this19 == 0)) {
HXLINE( 192)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float b21;
HXDLIN( 192)										int this20 = (col & 255);
HXDLIN( 192)										if ((this20 == 0)) {
HXLINE( 192)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 192)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 192)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 192)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 192)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 192)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 192)										{
HXLINE( 192)											int _hx_tmp2;
HXDLIN( 192)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 192)												_hx_tmp2 = blended;
            											}
HXDLIN( 192)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 192)										::Dynamic this21 = undoImage->image;
HXDLIN( 192)										int index2;
HXDLIN( 192)										if (undoImage->useVirtualPos) {
HXLINE( 192)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 192)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 192)										int _hx_tmp3;
HXDLIN( 192)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 192)											_hx_tmp3 = c2;
            										}
HXDLIN( 192)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 192)									if (forceClear) {
HXLINE( 192)										::Dynamic this22 = undoImage->image;
HXDLIN( 192)										int x2 = (dx - rectLeft);
HXDLIN( 192)										int y2 = (dy - rectTop);
HXDLIN( 192)										int index3;
HXDLIN( 192)										if (undoImage->useVirtualPos) {
HXLINE( 192)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 192)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 192)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 192)		bool foundY = false;
HXDLIN( 192)		Float s = ((Float)0.);
HXDLIN( 192)		Float t = ((Float)0.);
HXDLIN( 192)		Float sxx = ((Float)0.);
HXDLIN( 192)		Float txx = ((Float)0.);
HXDLIN( 192)		{
HXLINE( 192)			int _g_min = xIter3->start;
HXDLIN( 192)			int _g_max = xIter3->max;
HXDLIN( 192)			while((_g_min < _g_max)){
HXLINE( 192)				_g_min = (_g_min + 1);
HXDLIN( 192)				int x3 = (_g_min - 1);
HXLINE( 222)				sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)				txx = (tx * ( (Float)(x3) ));
HXLINE( 224)				foundY = false;
HXLINE( 192)				{
HXLINE( 192)					int _g_min1 = yIter3->start;
HXDLIN( 192)					int _g_max1 = yIter3->max;
HXDLIN( 192)					while((_g_min1 < _g_max1)){
HXLINE( 192)						_g_min1 = (_g_min1 + 1);
HXDLIN( 192)						int y3 = (_g_min1 - 1);
HXLINE( 226)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 192)						bool _hx_tmp4;
HXDLIN( 192)						if (!((s <= 0))) {
HXLINE( 192)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 192)							_hx_tmp4 = true;
            						}
HXDLIN( 192)						if (_hx_tmp4) {
HXLINE( 192)							if (foundY) {
HXLINE( 192)								goto _hx_goto_63;
            							}
            						}
            						else {
HXLINE( 192)							if (((s + t) < A)) {
HXLINE( 192)								int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 192)								int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 192)								::Dynamic this23 = tileImage->image;
HXDLIN( 192)								int index4;
HXDLIN( 192)								if (tileImage->useVirtualPos) {
HXLINE( 192)									index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            								}
            								else {
HXLINE( 192)									index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            								}
HXDLIN( 192)								int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 192)								int color;
HXDLIN( 192)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 192)									color = c3;
            								}
HXDLIN( 192)								{
HXLINE( 192)									int c4 = color;
HXDLIN( 192)									bool _hx_tmp5;
HXDLIN( 192)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 192)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE( 192)										_hx_tmp5 = false;
            									}
HXDLIN( 192)									if (_hx_tmp5) {
HXLINE( 192)										int location1;
HXDLIN( 192)										if (pixelImage->useVirtualPos) {
HXLINE( 192)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 192)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 192)										int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 192)										int this25;
HXDLIN( 192)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXLINE( 192)											this25 = this24;
            										}
HXDLIN( 192)										Float a11;
HXDLIN( 192)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 192)										if ((this26 == 0)) {
HXLINE( 192)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float r11;
HXDLIN( 192)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 192)										if ((this27 == 0)) {
HXLINE( 192)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float g11;
HXDLIN( 192)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 192)										if ((this28 == 0)) {
HXLINE( 192)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float b12;
HXDLIN( 192)										int this29 = (this25 & 255);
HXDLIN( 192)										if ((this29 == 0)) {
HXLINE( 192)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float a21;
HXDLIN( 192)										int this30 = ((color >> 24) & 255);
HXDLIN( 192)										if ((this30 == 0)) {
HXLINE( 192)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float r21;
HXDLIN( 192)										int this31 = ((color >> 16) & 255);
HXDLIN( 192)										if ((this31 == 0)) {
HXLINE( 192)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float g21;
HXDLIN( 192)										int this32 = ((color >> 8) & 255);
HXDLIN( 192)										if ((this32 == 0)) {
HXLINE( 192)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float b22;
HXDLIN( 192)										int this33 = (color & 255);
HXDLIN( 192)										if ((this33 == 0)) {
HXLINE( 192)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 192)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 192)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 192)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 192)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 192)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 192)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 192)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 192)										{
HXLINE( 192)											int _hx_tmp6;
HXDLIN( 192)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 192)												_hx_tmp6 = blended1;
            											}
HXDLIN( 192)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 192)										::Dynamic this34 = pixelImage->image;
HXDLIN( 192)										int index5;
HXDLIN( 192)										if (pixelImage->useVirtualPos) {
HXLINE( 192)											index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 192)											index5 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 192)										int _hx_tmp7;
HXDLIN( 192)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 192)											_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 192)											_hx_tmp7 = c4;
            										}
HXDLIN( 192)										::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp7);
            									}
            								}
HXLINE( 236)								foundY = true;
            							}
            							else {
HXLINE( 192)								if (foundY) {
HXLINE( 192)									goto _hx_goto_63;
            								}
            							}
            						}
            					}
            					_hx_goto_63:;
            				}
            			}
            		}
HXDLIN( 192)		if ((hasHit == false)) {
HXLINE( 192)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 192)			if (hasUndo) {
HXLINE( 192)				v2->undoImage = undoImage;
HXDLIN( 192)				v2->undoX = xIter3->start;
HXDLIN( 192)				v2->undoY = yIter3->start;
            			}
HXDLIN( 192)			return v2;
            		}
            		else {
HXLINE( 192)			return null();
            		}
HXDLIN( 192)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TriPixel_Fields__obj,tileTriangle,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::tileTriUnsafe( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_201_tileTriUnsafe)
HXLINE( 202)		Float s0 = ((ay * cx) - (ax * cy));
HXLINE( 203)		Float sx = (cy - ay);
HXLINE( 204)		Float sy = (ax - cx);
HXLINE( 205)		Float t0 = ((ax * by) - (ay * bx));
HXLINE( 206)		Float tx = (ay - by);
HXLINE( 207)		Float ty = (bx - ax);
HXLINE( 208)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXLINE( 209)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 209)		if ((ax > bx)) {
HXLINE( 209)			if ((ax > cx)) {
HXLINE( 209)				int min;
HXDLIN( 209)				if ((bx > cx)) {
HXLINE( 209)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 209)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 209)				int ii_min = min;
HXDLIN( 209)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 209)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 209)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 209)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 209)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 209)			if ((bx > cx)) {
HXLINE( 209)				int min1;
HXDLIN( 209)				if ((ax > cx)) {
HXLINE( 209)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 209)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 209)				int ii_min2 = min1;
HXDLIN( 209)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 209)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 209)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 209)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 209)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 210)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 210)		if ((ay > by)) {
HXLINE( 210)			if ((ay > cy)) {
HXLINE( 210)				int min2;
HXDLIN( 210)				if ((by > cy)) {
HXLINE( 210)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 210)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 210)				int ii_min4 = min2;
HXDLIN( 210)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 210)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 210)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 210)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 210)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 210)			if ((by > cy)) {
HXLINE( 210)				int min3;
HXDLIN( 210)				if ((ay > cy)) {
HXLINE( 210)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 210)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 210)				int ii_min6 = min3;
HXDLIN( 210)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 210)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 210)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 210)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 210)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 211)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 212)		if (hasUndo) {
HXLINE( 213)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 213)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 213)			 ::Dynamic imageType = null();
HXDLIN( 213)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 213)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 213)			::Dynamic undoImage1;
HXDLIN( 213)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 213)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 213)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 213)					{
HXLINE( 213)						b->width = width;
HXDLIN( 213)						b->height = height;
HXDLIN( 213)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 213)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 213)						{
HXLINE( 213)							int len = b->length;
HXDLIN( 213)							int w = 0;
HXDLIN( 213)							{
HXLINE( 213)								int _g = 0;
HXDLIN( 213)								int _g1 = b->height;
HXDLIN( 213)								while((_g < _g1)){
HXLINE( 213)									_g = (_g + 1);
HXDLIN( 213)									int y = (_g - 1);
HXDLIN( 213)									{
HXLINE( 213)										int _g2 = 0;
HXDLIN( 213)										int _g3 = b->width;
HXDLIN( 213)										while((_g2 < _g3)){
HXLINE( 213)											_g2 = (_g2 + 1);
HXDLIN( 213)											int x = (_g2 - 1);
HXDLIN( 213)											{
HXLINE( 213)												w = (w + 1);
HXDLIN( 213)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 213)											{
HXLINE( 213)												w = (w + 1);
HXDLIN( 213)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 213)											{
HXLINE( 213)												w = (w + 1);
HXDLIN( 213)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 213)											{
HXLINE( 213)												w = (w + 1);
HXDLIN( 213)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 213)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 213)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 213)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 213)					{
HXLINE( 213)						a->width = width;
HXDLIN( 213)						a->height = height;
HXDLIN( 213)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 213)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 213)						{
HXLINE( 213)							int _g4 = 0;
HXDLIN( 213)							int _g5 = a->length;
HXDLIN( 213)							while((_g4 < _g5)){
HXLINE( 213)								_g4 = (_g4 + 1);
HXDLIN( 213)								int i = (_g4 - 1);
HXDLIN( 213)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 213)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 213)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 213)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 213)					{
HXLINE( 213)						b1->width = width;
HXDLIN( 213)						b1->height = height;
HXDLIN( 213)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 213)						int size = (b1->length * 4);
HXDLIN( 213)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 213)						{
HXLINE( 213)							int _g6 = 0;
HXDLIN( 213)							int _g7 = b1->length;
HXDLIN( 213)							while((_g6 < _g7)){
HXLINE( 213)								_g6 = (_g6 + 1);
HXDLIN( 213)								int i1 = (_g6 - 1);
HXDLIN( 213)								{
HXLINE( 213)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 213)									bool undoImage2;
HXDLIN( 213)									if ((i1 >= 0)) {
HXLINE( 213)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 213)										undoImage2 = false;
            									}
HXDLIN( 213)									if (undoImage2) {
HXLINE( 213)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 213)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 213)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 213)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 213)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 213)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 213)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 213)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 213)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 213)					{
HXLINE( 213)						v->width = width;
HXDLIN( 213)						v->height = height;
HXDLIN( 213)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 213)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 213)						{
HXLINE( 213)							int _g8 = 0;
HXDLIN( 213)							int _g9 = v->length;
HXDLIN( 213)							while((_g8 < _g9)){
HXLINE( 213)								_g8 = (_g8 + 1);
HXDLIN( 213)								int i2 = (_g8 - 1);
HXDLIN( 213)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 213)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 213)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 213)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 213)					{
HXLINE( 213)						b2->width = width;
HXDLIN( 213)						b2->height = height;
HXDLIN( 213)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 213)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 213)						{
HXLINE( 213)							int len1 = b2->length;
HXDLIN( 213)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 213)							if (::hx::IsNull( d->head )) {
HXLINE( 213)								int _g10 = 0;
HXDLIN( 213)								int _g11 = len1;
HXDLIN( 213)								while((_g10 < _g11)){
HXLINE( 213)									_g10 = (_g10 + 1);
HXDLIN( 213)									int i3 = (_g10 - 1);
HXDLIN( 213)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 213)								int _g12 = 0;
HXDLIN( 213)								int _g13 = len1;
HXDLIN( 213)								while((_g12 < _g13)){
HXLINE( 213)									_g12 = (_g12 + 1);
HXDLIN( 213)									int i4 = (_g12 - 1);
HXDLIN( 213)									{
HXLINE( 213)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 213)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 213)										{
HXLINE( 213)											int _g14 = 0;
HXDLIN( 213)											int _g15 = i4;
HXDLIN( 213)											while((_g14 < _g15)){
HXLINE( 213)												_g14 = (_g14 + 1);
HXDLIN( 213)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 213)										if (::hx::IsNull( prev )) {
HXLINE( 213)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 213)											l = null();
            										}
            										else {
HXLINE( 213)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 213)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 213)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 213)			this1->image = undoImage1;
HXDLIN( 213)			this1->width = width;
HXDLIN( 213)			this1->height = height;
HXDLIN( 213)			this1->imageType = ( (int)(imageType) );
HXDLIN( 213)			undoImage = this1;
HXLINE( 214)			{
HXLINE( 214)				int rectLeft = xIter3->start;
HXDLIN( 214)				int rectTop = yIter3->start;
HXDLIN( 214)				int rectRight = xIter3->max;
HXDLIN( 214)				bool forceClear = false;
HXDLIN( 214)				{
HXLINE( 214)					int _g16 = rectTop;
HXDLIN( 214)					int _g17 = yIter3->max;
HXDLIN( 214)					while((_g16 < _g17)){
HXLINE( 214)						_g16 = (_g16 + 1);
HXDLIN( 214)						int dy = (_g16 - 1);
HXDLIN( 214)						{
HXLINE( 214)							int _g18 = rectLeft;
HXDLIN( 214)							int _g19 = rectRight;
HXDLIN( 214)							while((_g18 < _g19)){
HXLINE( 214)								_g18 = (_g18 + 1);
HXDLIN( 214)								int dx = (_g18 - 1);
HXDLIN( 214)								::Dynamic this3 = pixelImage->image;
HXDLIN( 214)								int index;
HXDLIN( 214)								if (pixelImage->useVirtualPos) {
HXLINE( 214)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 214)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 214)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 214)								int col;
HXDLIN( 214)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 214)									col = c;
            								}
HXDLIN( 214)								bool _hx_tmp;
HXDLIN( 214)								if (pixelImage->useMask) {
HXLINE( 214)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 214)									_hx_tmp = false;
            								}
HXDLIN( 214)								if (_hx_tmp) {
HXLINE( 214)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 214)									::Dynamic this5 = this4->image;
HXDLIN( 214)									int index1;
HXDLIN( 214)									if (this4->useVirtualPos) {
HXLINE( 214)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 214)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 214)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 214)									int v1;
HXDLIN( 214)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 214)										v1 = c1;
            									}
HXDLIN( 214)									int maskPixel = v1;
HXDLIN( 214)									int this6 = col;
HXDLIN( 214)									if ((maskPixel == 0)) {
HXLINE( 214)										col = this6;
            									}
            									else {
HXLINE( 214)										Float m0;
HXDLIN( 214)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 214)										if ((this7 == 0)) {
HXLINE( 214)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float m1;
HXDLIN( 214)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 214)										if ((this8 == 0)) {
HXLINE( 214)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float m2;
HXDLIN( 214)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 214)										if ((this9 == 0)) {
HXLINE( 214)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float m3;
HXDLIN( 214)										int this10 = (maskPixel & 255);
HXDLIN( 214)										if ((this10 == 0)) {
HXLINE( 214)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 214)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 214)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 214)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 214)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 214)								if ((col != 0)) {
HXLINE( 214)									int x1 = (dx - rectLeft);
HXDLIN( 214)									int y1 = (dy - rectTop);
HXDLIN( 214)									int c2 = col;
HXDLIN( 214)									bool _hx_tmp1;
HXDLIN( 214)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 214)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 214)										_hx_tmp1 = false;
            									}
HXDLIN( 214)									if (_hx_tmp1) {
HXLINE( 214)										int location;
HXDLIN( 214)										if (undoImage->useVirtualPos) {
HXLINE( 214)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 214)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 214)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 214)										int this12;
HXDLIN( 214)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 214)											this12 = this11;
            										}
HXDLIN( 214)										Float a1;
HXDLIN( 214)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 214)										if ((this13 == 0)) {
HXLINE( 214)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float r1;
HXDLIN( 214)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 214)										if ((this14 == 0)) {
HXLINE( 214)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float g1;
HXDLIN( 214)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 214)										if ((this15 == 0)) {
HXLINE( 214)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float b11;
HXDLIN( 214)										int this16 = (this12 & 255);
HXDLIN( 214)										if ((this16 == 0)) {
HXLINE( 214)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float a2;
HXDLIN( 214)										int this17 = ((col >> 24) & 255);
HXDLIN( 214)										if ((this17 == 0)) {
HXLINE( 214)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float r2;
HXDLIN( 214)										int this18 = ((col >> 16) & 255);
HXDLIN( 214)										if ((this18 == 0)) {
HXLINE( 214)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float g2;
HXDLIN( 214)										int this19 = ((col >> 8) & 255);
HXDLIN( 214)										if ((this19 == 0)) {
HXLINE( 214)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float b21;
HXDLIN( 214)										int this20 = (col & 255);
HXDLIN( 214)										if ((this20 == 0)) {
HXLINE( 214)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 214)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 214)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 214)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 214)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 214)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 214)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 214)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 214)										{
HXLINE( 214)											int _hx_tmp2;
HXDLIN( 214)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 214)												_hx_tmp2 = blended;
            											}
HXDLIN( 214)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 214)										::Dynamic this21 = undoImage->image;
HXDLIN( 214)										int index2;
HXDLIN( 214)										if (undoImage->useVirtualPos) {
HXLINE( 214)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 214)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 214)										int _hx_tmp3;
HXDLIN( 214)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 214)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 214)											_hx_tmp3 = c2;
            										}
HXDLIN( 214)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 214)									if (forceClear) {
HXLINE( 214)										::Dynamic this22 = undoImage->image;
HXDLIN( 214)										int x2 = (dx - rectLeft);
HXDLIN( 214)										int y2 = (dy - rectTop);
HXDLIN( 214)										int index3;
HXDLIN( 214)										if (undoImage->useVirtualPos) {
HXLINE( 214)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 214)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 214)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 216)		bool foundY = false;
HXLINE( 217)		Float s = ((Float)0.);
HXLINE( 218)		Float t = ((Float)0.);
HXLINE( 219)		Float sxx = ((Float)0.);
HXLINE( 220)		Float txx = ((Float)0.);
HXLINE( 221)		{
HXLINE( 221)			int _g_min = xIter3->start;
HXDLIN( 221)			int _g_max = xIter3->max;
HXDLIN( 221)			while((_g_min < _g_max)){
HXLINE( 221)				_g_min = (_g_min + 1);
HXDLIN( 221)				int x3 = (_g_min - 1);
HXLINE( 222)				sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)				txx = (tx * ( (Float)(x3) ));
HXLINE( 224)				foundY = false;
HXLINE( 225)				{
HXLINE( 225)					int _g_min1 = yIter3->start;
HXDLIN( 225)					int _g_max1 = yIter3->max;
HXDLIN( 225)					while((_g_min1 < _g_max1)){
HXLINE( 225)						_g_min1 = (_g_min1 + 1);
HXDLIN( 225)						int y3 = (_g_min1 - 1);
HXLINE( 226)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 228)						bool _hx_tmp4;
HXDLIN( 228)						if (!((s <= 0))) {
HXLINE( 228)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 228)							_hx_tmp4 = true;
            						}
HXDLIN( 228)						if (_hx_tmp4) {
HXLINE( 230)							if (foundY) {
HXLINE( 230)								goto _hx_goto_76;
            							}
            						}
            						else {
HXLINE( 232)							if (((s + t) < A)) {
HXLINE( 234)								int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 234)								int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 234)								::Dynamic this23 = tileImage->image;
HXDLIN( 234)								int index4;
HXDLIN( 234)								if (tileImage->useVirtualPos) {
HXLINE( 234)									index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            								}
            								else {
HXLINE( 234)									index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            								}
HXDLIN( 234)								int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 234)								int color;
HXDLIN( 234)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 234)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 234)									color = c3;
            								}
HXLINE( 235)								{
HXLINE( 235)									int c4 = color;
HXDLIN( 235)									bool _hx_tmp5;
HXDLIN( 235)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 235)										_hx_tmp5 = pixelImage->transparent;
            									}
            									else {
HXLINE( 235)										_hx_tmp5 = false;
            									}
HXDLIN( 235)									if (_hx_tmp5) {
HXLINE( 235)										int location1;
HXDLIN( 235)										if (pixelImage->useVirtualPos) {
HXLINE( 235)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 235)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 235)										int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 235)										int this25;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXLINE( 235)											this25 = this24;
            										}
HXDLIN( 235)										Float a11;
HXDLIN( 235)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 235)										if ((this26 == 0)) {
HXLINE( 235)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r11;
HXDLIN( 235)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 235)										if ((this27 == 0)) {
HXLINE( 235)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g11;
HXDLIN( 235)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 235)										if ((this28 == 0)) {
HXLINE( 235)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b12;
HXDLIN( 235)										int this29 = (this25 & 255);
HXDLIN( 235)										if ((this29 == 0)) {
HXLINE( 235)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a21;
HXDLIN( 235)										int this30 = ((color >> 24) & 255);
HXDLIN( 235)										if ((this30 == 0)) {
HXLINE( 235)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r21;
HXDLIN( 235)										int this31 = ((color >> 16) & 255);
HXDLIN( 235)										if ((this31 == 0)) {
HXLINE( 235)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g21;
HXDLIN( 235)										int this32 = ((color >> 8) & 255);
HXDLIN( 235)										if ((this32 == 0)) {
HXLINE( 235)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b22;
HXDLIN( 235)										int this33 = (color & 255);
HXDLIN( 235)										if ((this33 == 0)) {
HXLINE( 235)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 235)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 235)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 235)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 235)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 235)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 235)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 235)										{
HXLINE( 235)											int _hx_tmp6;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 235)												_hx_tmp6 = blended1;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 235)										::Dynamic this34 = pixelImage->image;
HXDLIN( 235)										int index5;
HXDLIN( 235)										if (pixelImage->useVirtualPos) {
HXLINE( 235)											index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 235)											index5 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            										}
HXDLIN( 235)										int _hx_tmp7;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 235)											_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 235)											_hx_tmp7 = c4;
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp7);
            									}
            								}
HXLINE( 236)								foundY = true;
            							}
            							else {
HXLINE( 239)								if (foundY) {
HXLINE( 239)									goto _hx_goto_76;
            								}
            							}
            						}
            					}
            					_hx_goto_76:;
            				}
            			}
            		}
HXLINE( 244)		if ((hasHit == false)) {
HXLINE( 245)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 246)			if (hasUndo) {
HXLINE( 247)				v2->undoImage = undoImage;
HXLINE( 248)				v2->undoX = xIter3->start;
HXLINE( 249)				v2->undoY = yIter3->start;
            			}
HXLINE( 251)			return v2;
            		}
            		else {
HXLINE( 253)			return null();
            		}
HXLINE( 244)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,tileTriUnsafe,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillGradTriangle( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,int colA,Float bx,Float by,int colB,Float cx,Float cy,int colC,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_262_fillGradTriangle)
HXLINE( 263)		int aA = ((colB >> 24) & 255);
HXLINE( 264)		int rA = ((colB >> 16) & 255);
HXLINE( 265)		int gA = ((colB >> 8) & 255);
HXLINE( 266)		int bA = (colB & 255);
HXLINE( 267)		int aB = ((colA >> 24) & 255);
HXLINE( 268)		int rB = ((colA >> 16) & 255);
HXLINE( 269)		int gB = ((colA >> 8) & 255);
HXLINE( 270)		int bB = (colA & 255);
HXLINE( 271)		int aC = ((colC >> 24) & 255);
HXLINE( 272)		int rC = ((colC >> 16) & 255);
HXLINE( 273)		int gC = ((colC >> 8) & 255);
HXLINE( 274)		int bC = (colC & 255);
HXLINE( 275)		Float bcx = (bx - cx);
HXLINE( 276)		Float bcy = (by - cy);
HXLINE( 277)		Float acx = (ax - cx);
HXLINE( 278)		Float acy = (ay - cy);
HXLINE( 280)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 281)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 282)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 283)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 284)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 284)		if ((ax > bx)) {
HXLINE( 284)			if ((ax > cx)) {
HXLINE( 284)				int min;
HXDLIN( 284)				if ((bx > cx)) {
HXLINE( 284)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 284)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 284)				int ii_min = min;
HXDLIN( 284)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 284)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 284)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 284)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 284)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 284)			if ((bx > cx)) {
HXLINE( 284)				int min1;
HXDLIN( 284)				if ((ax > cx)) {
HXLINE( 284)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 284)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 284)				int ii_min2 = min1;
HXDLIN( 284)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 284)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 284)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 284)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 284)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 285)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 285)		if ((ay > by)) {
HXLINE( 285)			if ((ay > cy)) {
HXLINE( 285)				int min2;
HXDLIN( 285)				if ((by > cy)) {
HXLINE( 285)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 285)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 285)				int ii_min4 = min2;
HXDLIN( 285)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 285)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 285)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 285)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 285)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 285)			if ((by > cy)) {
HXLINE( 285)				int min3;
HXDLIN( 285)				if ((ay > cy)) {
HXLINE( 285)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 285)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 285)				int ii_min6 = min3;
HXDLIN( 285)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 285)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 285)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 285)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 285)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 286)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 287)		if (hasUndo) {
HXLINE( 288)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 288)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 288)			 ::Dynamic imageType = null();
HXDLIN( 288)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 288)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 288)			::Dynamic undoImage1;
HXDLIN( 288)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 288)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 288)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 288)					{
HXLINE( 288)						b->width = width;
HXDLIN( 288)						b->height = height;
HXDLIN( 288)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 288)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 288)						{
HXLINE( 288)							int len = b->length;
HXDLIN( 288)							int w = 0;
HXDLIN( 288)							{
HXLINE( 288)								int _g = 0;
HXDLIN( 288)								int _g1 = b->height;
HXDLIN( 288)								while((_g < _g1)){
HXLINE( 288)									_g = (_g + 1);
HXDLIN( 288)									int y = (_g - 1);
HXDLIN( 288)									{
HXLINE( 288)										int _g2 = 0;
HXDLIN( 288)										int _g3 = b->width;
HXDLIN( 288)										while((_g2 < _g3)){
HXLINE( 288)											_g2 = (_g2 + 1);
HXDLIN( 288)											int x = (_g2 - 1);
HXDLIN( 288)											{
HXLINE( 288)												w = (w + 1);
HXDLIN( 288)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 288)											{
HXLINE( 288)												w = (w + 1);
HXDLIN( 288)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 288)											{
HXLINE( 288)												w = (w + 1);
HXDLIN( 288)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 288)											{
HXLINE( 288)												w = (w + 1);
HXDLIN( 288)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 288)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 288)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 288)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 288)					{
HXLINE( 288)						a->width = width;
HXDLIN( 288)						a->height = height;
HXDLIN( 288)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 288)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 288)						{
HXLINE( 288)							int _g4 = 0;
HXDLIN( 288)							int _g5 = a->length;
HXDLIN( 288)							while((_g4 < _g5)){
HXLINE( 288)								_g4 = (_g4 + 1);
HXDLIN( 288)								int i = (_g4 - 1);
HXDLIN( 288)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 288)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 288)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 288)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 288)					{
HXLINE( 288)						b1->width = width;
HXDLIN( 288)						b1->height = height;
HXDLIN( 288)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 288)						int size = (b1->length * 4);
HXDLIN( 288)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 288)						{
HXLINE( 288)							int _g6 = 0;
HXDLIN( 288)							int _g7 = b1->length;
HXDLIN( 288)							while((_g6 < _g7)){
HXLINE( 288)								_g6 = (_g6 + 1);
HXDLIN( 288)								int i1 = (_g6 - 1);
HXDLIN( 288)								{
HXLINE( 288)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 288)									bool undoImage2;
HXDLIN( 288)									if ((i1 >= 0)) {
HXLINE( 288)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 288)										undoImage2 = false;
            									}
HXDLIN( 288)									if (undoImage2) {
HXLINE( 288)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 288)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 288)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 288)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 288)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 288)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 288)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 288)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 288)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 288)					{
HXLINE( 288)						v->width = width;
HXDLIN( 288)						v->height = height;
HXDLIN( 288)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 288)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 288)						{
HXLINE( 288)							int _g8 = 0;
HXDLIN( 288)							int _g9 = v->length;
HXDLIN( 288)							while((_g8 < _g9)){
HXLINE( 288)								_g8 = (_g8 + 1);
HXDLIN( 288)								int i2 = (_g8 - 1);
HXDLIN( 288)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 288)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 288)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 288)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 288)					{
HXLINE( 288)						b2->width = width;
HXDLIN( 288)						b2->height = height;
HXDLIN( 288)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 288)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 288)						{
HXLINE( 288)							int len1 = b2->length;
HXDLIN( 288)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 288)							if (::hx::IsNull( d->head )) {
HXLINE( 288)								int _g10 = 0;
HXDLIN( 288)								int _g11 = len1;
HXDLIN( 288)								while((_g10 < _g11)){
HXLINE( 288)									_g10 = (_g10 + 1);
HXDLIN( 288)									int i3 = (_g10 - 1);
HXDLIN( 288)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 288)								int _g12 = 0;
HXDLIN( 288)								int _g13 = len1;
HXDLIN( 288)								while((_g12 < _g13)){
HXLINE( 288)									_g12 = (_g12 + 1);
HXDLIN( 288)									int i4 = (_g12 - 1);
HXDLIN( 288)									{
HXLINE( 288)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 288)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 288)										{
HXLINE( 288)											int _g14 = 0;
HXDLIN( 288)											int _g15 = i4;
HXDLIN( 288)											while((_g14 < _g15)){
HXLINE( 288)												_g14 = (_g14 + 1);
HXDLIN( 288)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 288)										if (::hx::IsNull( prev )) {
HXLINE( 288)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 288)											l = null();
            										}
            										else {
HXLINE( 288)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 288)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 288)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 288)			this1->image = undoImage1;
HXDLIN( 288)			this1->width = width;
HXDLIN( 288)			this1->height = height;
HXDLIN( 288)			this1->imageType = ( (int)(imageType) );
HXDLIN( 288)			undoImage = this1;
HXLINE( 289)			{
HXLINE( 289)				int rectLeft = xIter3->start;
HXDLIN( 289)				int rectTop = yIter3->start;
HXDLIN( 289)				int rectRight = xIter3->max;
HXDLIN( 289)				bool forceClear = false;
HXDLIN( 289)				{
HXLINE( 289)					int _g16 = rectTop;
HXDLIN( 289)					int _g17 = yIter3->max;
HXDLIN( 289)					while((_g16 < _g17)){
HXLINE( 289)						_g16 = (_g16 + 1);
HXDLIN( 289)						int dy = (_g16 - 1);
HXDLIN( 289)						{
HXLINE( 289)							int _g18 = rectLeft;
HXDLIN( 289)							int _g19 = rectRight;
HXDLIN( 289)							while((_g18 < _g19)){
HXLINE( 289)								_g18 = (_g18 + 1);
HXDLIN( 289)								int dx = (_g18 - 1);
HXDLIN( 289)								::Dynamic this3 = pixelImage->image;
HXDLIN( 289)								int index;
HXDLIN( 289)								if (pixelImage->useVirtualPos) {
HXLINE( 289)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 289)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 289)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 289)								int col;
HXDLIN( 289)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 289)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 289)									col = c;
            								}
HXDLIN( 289)								bool _hx_tmp;
HXDLIN( 289)								if (pixelImage->useMask) {
HXLINE( 289)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 289)									_hx_tmp = false;
            								}
HXDLIN( 289)								if (_hx_tmp) {
HXLINE( 289)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 289)									::Dynamic this5 = this4->image;
HXDLIN( 289)									int index1;
HXDLIN( 289)									if (this4->useVirtualPos) {
HXLINE( 289)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 289)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 289)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 289)									int v1;
HXDLIN( 289)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 289)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 289)										v1 = c1;
            									}
HXDLIN( 289)									int maskPixel = v1;
HXDLIN( 289)									int this6 = col;
HXDLIN( 289)									if ((maskPixel == 0)) {
HXLINE( 289)										col = this6;
            									}
            									else {
HXLINE( 289)										Float m0;
HXDLIN( 289)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 289)										if ((this7 == 0)) {
HXLINE( 289)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float m1;
HXDLIN( 289)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 289)										if ((this8 == 0)) {
HXLINE( 289)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float m2;
HXDLIN( 289)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 289)										if ((this9 == 0)) {
HXLINE( 289)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float m3;
HXDLIN( 289)										int this10 = (maskPixel & 255);
HXDLIN( 289)										if ((this10 == 0)) {
HXLINE( 289)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 289)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 289)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 289)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 289)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 289)								if ((col != 0)) {
HXLINE( 289)									int x1 = (dx - rectLeft);
HXDLIN( 289)									int y1 = (dy - rectTop);
HXDLIN( 289)									int c2 = col;
HXDLIN( 289)									bool _hx_tmp1;
HXDLIN( 289)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 289)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 289)										_hx_tmp1 = false;
            									}
HXDLIN( 289)									if (_hx_tmp1) {
HXLINE( 289)										int location;
HXDLIN( 289)										if (undoImage->useVirtualPos) {
HXLINE( 289)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 289)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 289)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 289)										int this12;
HXDLIN( 289)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 289)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 289)											this12 = this11;
            										}
HXDLIN( 289)										Float a1;
HXDLIN( 289)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 289)										if ((this13 == 0)) {
HXLINE( 289)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float r1;
HXDLIN( 289)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 289)										if ((this14 == 0)) {
HXLINE( 289)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float g1;
HXDLIN( 289)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 289)										if ((this15 == 0)) {
HXLINE( 289)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float b11;
HXDLIN( 289)										int this16 = (this12 & 255);
HXDLIN( 289)										if ((this16 == 0)) {
HXLINE( 289)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float a2;
HXDLIN( 289)										int this17 = ((col >> 24) & 255);
HXDLIN( 289)										if ((this17 == 0)) {
HXLINE( 289)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float r2;
HXDLIN( 289)										int this18 = ((col >> 16) & 255);
HXDLIN( 289)										if ((this18 == 0)) {
HXLINE( 289)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float g2;
HXDLIN( 289)										int this19 = ((col >> 8) & 255);
HXDLIN( 289)										if ((this19 == 0)) {
HXLINE( 289)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float b21;
HXDLIN( 289)										int this20 = (col & 255);
HXDLIN( 289)										if ((this20 == 0)) {
HXLINE( 289)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 289)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 289)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 289)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 289)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 289)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 289)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 289)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 289)										{
HXLINE( 289)											int _hx_tmp2;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 289)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 289)												_hx_tmp2 = blended;
            											}
HXDLIN( 289)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 289)										::Dynamic this21 = undoImage->image;
HXDLIN( 289)										int index2;
HXDLIN( 289)										if (undoImage->useVirtualPos) {
HXLINE( 289)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 289)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 289)										int _hx_tmp3;
HXDLIN( 289)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 289)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 289)											_hx_tmp3 = c2;
            										}
HXDLIN( 289)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 289)									if (forceClear) {
HXLINE( 289)										::Dynamic this22 = undoImage->image;
HXDLIN( 289)										int x2 = (dx - rectLeft);
HXDLIN( 289)										int y2 = (dy - rectTop);
HXDLIN( 289)										int index3;
HXDLIN( 289)										if (undoImage->useVirtualPos) {
HXLINE( 289)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 289)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 289)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 291)		{
HXLINE( 291)			int _g_min = xIter3->start;
HXDLIN( 291)			int _g_max = xIter3->max;
HXDLIN( 291)			while((_g_min < _g_max)){
HXLINE( 291)				_g_min = (_g_min + 1);
HXDLIN( 291)				int px = (_g_min - 1);
HXLINE( 292)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 293)				{
HXLINE( 293)					int _g_min1 = yIter3->start;
HXDLIN( 293)					int _g_max1 = yIter3->max;
HXDLIN( 293)					while((_g_min1 < _g_max1)){
HXLINE( 293)						_g_min1 = (_g_min1 + 1);
HXDLIN( 293)						int py = (_g_min1 - 1);
HXLINE( 294)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 295)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 296)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 297)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 298)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 299)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 300)						bool _hx_tmp4;
HXDLIN( 300)						bool _hx_tmp5;
HXDLIN( 300)						if ((ratioA >= 0)) {
HXLINE( 300)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 300)							_hx_tmp5 = false;
            						}
HXDLIN( 300)						if (_hx_tmp5) {
HXLINE( 300)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 300)							_hx_tmp4 = false;
            						}
HXDLIN( 300)						if (_hx_tmp4) {
HXLINE( 301)							int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 301)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 301)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 301)							int a5 = i6;
HXLINE( 302)							int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 302)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 302)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 302)							int r3 = i7;
HXLINE( 303)							int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 303)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 303)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 303)							int g3 = i8;
HXLINE( 304)							int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 304)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 304)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 304)							int b4 = i9;
HXLINE( 305)							{
HXLINE( 305)								int location1;
HXDLIN( 305)								if (pixelImage->useVirtualPos) {
HXLINE( 305)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 305)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 305)								bool _hx_tmp6;
HXDLIN( 305)								if (pixelImage->transparent) {
HXLINE( 305)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 305)									_hx_tmp6 = false;
            								}
HXDLIN( 305)								if (_hx_tmp6) {
HXLINE( 305)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 305)									int old;
HXDLIN( 305)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 305)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 305)										old = this23;
            									}
HXDLIN( 305)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 305)									Float a11;
HXDLIN( 305)									int this24 = ((old >> 24) & 255);
HXDLIN( 305)									if ((this24 == 0)) {
HXLINE( 305)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float r11;
HXDLIN( 305)									int this25 = ((old >> 16) & 255);
HXDLIN( 305)									if ((this25 == 0)) {
HXLINE( 305)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float g11;
HXDLIN( 305)									int this26 = ((old >> 8) & 255);
HXDLIN( 305)									if ((this26 == 0)) {
HXLINE( 305)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float b12;
HXDLIN( 305)									int this27 = (old & 255);
HXDLIN( 305)									if ((this27 == 0)) {
HXLINE( 305)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float a21;
HXDLIN( 305)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 305)									if ((this28 == 0)) {
HXLINE( 305)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float r21;
HXDLIN( 305)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 305)									if ((this29 == 0)) {
HXLINE( 305)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float g21;
HXDLIN( 305)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 305)									if ((this30 == 0)) {
HXLINE( 305)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float b22;
HXDLIN( 305)									int this31 = (rhs & 255);
HXDLIN( 305)									if ((this31 == 0)) {
HXLINE( 305)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 305)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 305)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 305)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 305)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 305)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 305)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 305)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 305)									{
HXLINE( 305)										int _hx_tmp7;
HXDLIN( 305)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 305)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 305)											_hx_tmp7 = blended1;
            										}
HXDLIN( 305)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 305)									int value;
HXDLIN( 305)									if (pixelImage->isLittle) {
HXLINE( 305)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 305)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 305)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 309)		if ((hasHit == false)) {
HXLINE( 310)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 311)			if (hasUndo) {
HXLINE( 312)				v2->undoImage = undoImage;
HXLINE( 313)				v2->undoX = xIter3->start;
HXLINE( 314)				v2->undoY = yIter3->start;
            			}
HXLINE( 316)			return v2;
            		}
            		else {
HXLINE( 318)			return null();
            		}
HXLINE( 309)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(TriPixel_Fields__obj,fillGradTriangle,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::topRightImgTriFudge( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_327_topRightImgTriFudge)
HXDLIN( 327)		Float au = ((Float)1.);
HXDLIN( 327)		Float av = ((Float)0.);
HXDLIN( 327)		Float bu = ((Float)0.);
HXDLIN( 327)		Float bv = ((Float)0.);
HXDLIN( 327)		Float temp = au;
HXLINE( 422)		au = bu;
HXLINE( 423)		bu = temp;
HXLINE( 424)		temp = av;
HXLINE( 425)		av = bv;
HXLINE( 426)		bv = temp;
HXLINE( 327)		Float bcx = (bx - cx);
HXDLIN( 327)		Float bcy = (by - cy);
HXDLIN( 327)		Float acx = (ax - cx);
HXDLIN( 327)		Float acy = (ay - cy);
HXDLIN( 327)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 327)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 327)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 327)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 327)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 327)		if ((ax > bx)) {
HXDLIN( 327)			if ((ax > cx)) {
HXDLIN( 327)				int min;
HXDLIN( 327)				if ((bx > cx)) {
HXDLIN( 327)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXDLIN( 327)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 327)				int ii_min = min;
HXDLIN( 327)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 327)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 327)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 327)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 327)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 327)			if ((bx > cx)) {
HXDLIN( 327)				int min1;
HXDLIN( 327)				if ((ax > cx)) {
HXDLIN( 327)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXDLIN( 327)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 327)				int ii_min2 = min1;
HXDLIN( 327)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 327)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 327)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 327)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 327)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 327)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 327)		if ((ay > by)) {
HXDLIN( 327)			if ((ay > cy)) {
HXDLIN( 327)				int min2;
HXDLIN( 327)				if ((by > cy)) {
HXDLIN( 327)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXDLIN( 327)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 327)				int ii_min4 = min2;
HXDLIN( 327)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 327)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 327)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 327)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 327)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 327)			if ((by > cy)) {
HXDLIN( 327)				int min3;
HXDLIN( 327)				if ((ay > cy)) {
HXDLIN( 327)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXDLIN( 327)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 327)				int ii_min6 = min3;
HXDLIN( 327)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 327)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 327)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 327)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 327)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 327)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 327)		if (hasUndo) {
HXDLIN( 327)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 327)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 327)			 ::Dynamic imageType = null();
HXDLIN( 327)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 327)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 327)			::Dynamic undoImage1;
HXDLIN( 327)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 327)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 327)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 327)					{
HXDLIN( 327)						b->width = width;
HXDLIN( 327)						b->height = height;
HXDLIN( 327)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 327)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 327)						{
HXDLIN( 327)							int len = b->length;
HXDLIN( 327)							int w = 0;
HXDLIN( 327)							{
HXDLIN( 327)								int _g = 0;
HXDLIN( 327)								int _g1 = b->height;
HXDLIN( 327)								while((_g < _g1)){
HXDLIN( 327)									_g = (_g + 1);
HXDLIN( 327)									int y = (_g - 1);
HXDLIN( 327)									{
HXDLIN( 327)										int _g2 = 0;
HXDLIN( 327)										int _g3 = b->width;
HXDLIN( 327)										while((_g2 < _g3)){
HXDLIN( 327)											_g2 = (_g2 + 1);
HXDLIN( 327)											int x = (_g2 - 1);
HXDLIN( 327)											{
HXDLIN( 327)												w = (w + 1);
HXDLIN( 327)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 327)											{
HXDLIN( 327)												w = (w + 1);
HXDLIN( 327)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 327)											{
HXDLIN( 327)												w = (w + 1);
HXDLIN( 327)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 327)											{
HXDLIN( 327)												w = (w + 1);
HXDLIN( 327)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 327)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 327)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 327)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 327)					{
HXDLIN( 327)						a->width = width;
HXDLIN( 327)						a->height = height;
HXDLIN( 327)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 327)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 327)						{
HXDLIN( 327)							int _g4 = 0;
HXDLIN( 327)							int _g5 = a->length;
HXDLIN( 327)							while((_g4 < _g5)){
HXDLIN( 327)								_g4 = (_g4 + 1);
HXDLIN( 327)								int i = (_g4 - 1);
HXDLIN( 327)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 327)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN( 327)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 327)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 327)					{
HXDLIN( 327)						b1->width = width;
HXDLIN( 327)						b1->height = height;
HXDLIN( 327)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 327)						int size = (b1->length * 4);
HXDLIN( 327)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 327)						{
HXDLIN( 327)							int _g6 = 0;
HXDLIN( 327)							int _g7 = b1->length;
HXDLIN( 327)							while((_g6 < _g7)){
HXDLIN( 327)								_g6 = (_g6 + 1);
HXDLIN( 327)								int i1 = (_g6 - 1);
HXDLIN( 327)								{
HXDLIN( 327)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 327)									bool undoImage2;
HXDLIN( 327)									if ((i1 >= 0)) {
HXDLIN( 327)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXDLIN( 327)										undoImage2 = false;
            									}
HXDLIN( 327)									if (undoImage2) {
HXDLIN( 327)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 327)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 327)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 327)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 327)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 327)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 327)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 327)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 327)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 327)					{
HXDLIN( 327)						v->width = width;
HXDLIN( 327)						v->height = height;
HXDLIN( 327)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 327)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 327)						{
HXDLIN( 327)							int _g8 = 0;
HXDLIN( 327)							int _g9 = v->length;
HXDLIN( 327)							while((_g8 < _g9)){
HXDLIN( 327)								_g8 = (_g8 + 1);
HXDLIN( 327)								int i2 = (_g8 - 1);
HXDLIN( 327)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 327)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 327)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 327)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 327)					{
HXDLIN( 327)						b2->width = width;
HXDLIN( 327)						b2->height = height;
HXDLIN( 327)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 327)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 327)						{
HXDLIN( 327)							int len1 = b2->length;
HXDLIN( 327)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 327)							if (::hx::IsNull( d->head )) {
HXDLIN( 327)								int _g10 = 0;
HXDLIN( 327)								int _g11 = len1;
HXDLIN( 327)								while((_g10 < _g11)){
HXDLIN( 327)									_g10 = (_g10 + 1);
HXDLIN( 327)									int i3 = (_g10 - 1);
HXDLIN( 327)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 327)								int _g12 = 0;
HXDLIN( 327)								int _g13 = len1;
HXDLIN( 327)								while((_g12 < _g13)){
HXDLIN( 327)									_g12 = (_g12 + 1);
HXDLIN( 327)									int i4 = (_g12 - 1);
HXDLIN( 327)									{
HXDLIN( 327)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 327)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 327)										{
HXDLIN( 327)											int _g14 = 0;
HXDLIN( 327)											int _g15 = i4;
HXDLIN( 327)											while((_g14 < _g15)){
HXDLIN( 327)												_g14 = (_g14 + 1);
HXDLIN( 327)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 327)										if (::hx::IsNull( prev )) {
HXDLIN( 327)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 327)											l = null();
            										}
            										else {
HXDLIN( 327)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 327)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 327)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 327)			this1->image = undoImage1;
HXDLIN( 327)			this1->width = width;
HXDLIN( 327)			this1->height = height;
HXDLIN( 327)			this1->imageType = ( (int)(imageType) );
HXDLIN( 327)			undoImage = this1;
HXDLIN( 327)			{
HXDLIN( 327)				int rectLeft = xIter3->start;
HXDLIN( 327)				int rectTop = yIter3->start;
HXDLIN( 327)				int rectRight = xIter3->max;
HXDLIN( 327)				bool forceClear = false;
HXDLIN( 327)				{
HXDLIN( 327)					int _g16 = rectTop;
HXDLIN( 327)					int _g17 = yIter3->max;
HXDLIN( 327)					while((_g16 < _g17)){
HXDLIN( 327)						_g16 = (_g16 + 1);
HXDLIN( 327)						int dy = (_g16 - 1);
HXDLIN( 327)						{
HXDLIN( 327)							int _g18 = rectLeft;
HXDLIN( 327)							int _g19 = rectRight;
HXDLIN( 327)							while((_g18 < _g19)){
HXDLIN( 327)								_g18 = (_g18 + 1);
HXDLIN( 327)								int dx = (_g18 - 1);
HXDLIN( 327)								::Dynamic this3 = pixelImage->image;
HXDLIN( 327)								int index;
HXDLIN( 327)								if (pixelImage->useVirtualPos) {
HXDLIN( 327)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXDLIN( 327)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 327)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 327)								int col;
HXDLIN( 327)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 327)									col = c;
            								}
HXDLIN( 327)								bool _hx_tmp;
HXDLIN( 327)								if (pixelImage->useMask) {
HXDLIN( 327)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXDLIN( 327)									_hx_tmp = false;
            								}
HXDLIN( 327)								if (_hx_tmp) {
HXDLIN( 327)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 327)									::Dynamic this5 = this4->image;
HXDLIN( 327)									int index1;
HXDLIN( 327)									if (this4->useVirtualPos) {
HXDLIN( 327)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXDLIN( 327)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 327)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 327)									int v1;
HXDLIN( 327)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 327)										v1 = c1;
            									}
HXDLIN( 327)									int maskPixel = v1;
HXDLIN( 327)									int this6 = col;
HXDLIN( 327)									if ((maskPixel == 0)) {
HXDLIN( 327)										col = this6;
            									}
            									else {
HXDLIN( 327)										Float m0;
HXDLIN( 327)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 327)										if ((this7 == 0)) {
HXDLIN( 327)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float m1;
HXDLIN( 327)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 327)										if ((this8 == 0)) {
HXDLIN( 327)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float m2;
HXDLIN( 327)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 327)										if ((this9 == 0)) {
HXDLIN( 327)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float m3;
HXDLIN( 327)										int this10 = (maskPixel & 255);
HXDLIN( 327)										if ((this10 == 0)) {
HXDLIN( 327)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 327)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 327)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 327)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 327)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 327)								if ((col != 0)) {
HXDLIN( 327)									int x1 = (dx - rectLeft);
HXDLIN( 327)									int y1 = (dy - rectTop);
HXDLIN( 327)									int c2 = col;
HXDLIN( 327)									bool _hx_tmp1;
HXDLIN( 327)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 327)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 327)										_hx_tmp1 = false;
            									}
HXDLIN( 327)									if (_hx_tmp1) {
HXDLIN( 327)										int location;
HXDLIN( 327)										if (undoImage->useVirtualPos) {
HXDLIN( 327)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 327)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 327)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 327)										int this12;
HXDLIN( 327)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXDLIN( 327)											this12 = this11;
            										}
HXDLIN( 327)										Float a1;
HXDLIN( 327)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 327)										if ((this13 == 0)) {
HXDLIN( 327)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float r1;
HXDLIN( 327)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 327)										if ((this14 == 0)) {
HXDLIN( 327)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float g1;
HXDLIN( 327)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 327)										if ((this15 == 0)) {
HXDLIN( 327)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float b11;
HXDLIN( 327)										int this16 = (this12 & 255);
HXDLIN( 327)										if ((this16 == 0)) {
HXDLIN( 327)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float a2;
HXDLIN( 327)										int this17 = ((col >> 24) & 255);
HXDLIN( 327)										if ((this17 == 0)) {
HXDLIN( 327)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float r2;
HXDLIN( 327)										int this18 = ((col >> 16) & 255);
HXDLIN( 327)										if ((this18 == 0)) {
HXDLIN( 327)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float g2;
HXDLIN( 327)										int this19 = ((col >> 8) & 255);
HXDLIN( 327)										if ((this19 == 0)) {
HXDLIN( 327)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float b21;
HXDLIN( 327)										int this20 = (col & 255);
HXDLIN( 327)										if ((this20 == 0)) {
HXDLIN( 327)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 327)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 327)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 327)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 327)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 327)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 327)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 327)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 327)										{
HXDLIN( 327)											int _hx_tmp2;
HXDLIN( 327)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 327)												_hx_tmp2 = blended;
            											}
HXDLIN( 327)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 327)										::Dynamic this21 = undoImage->image;
HXDLIN( 327)										int index2;
HXDLIN( 327)										if (undoImage->useVirtualPos) {
HXDLIN( 327)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 327)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 327)										int _hx_tmp3;
HXDLIN( 327)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 327)											_hx_tmp3 = c2;
            										}
HXDLIN( 327)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 327)									if (forceClear) {
HXDLIN( 327)										::Dynamic this22 = undoImage->image;
HXDLIN( 327)										int x2 = (dx - rectLeft);
HXDLIN( 327)										int y2 = (dy - rectTop);
HXDLIN( 327)										int index3;
HXDLIN( 327)										if (undoImage->useVirtualPos) {
HXDLIN( 327)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 327)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 327)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 327)		{
HXDLIN( 327)			int _g_min = xIter3->start;
HXDLIN( 327)			int _g_max = xIter3->max;
HXDLIN( 327)			while((_g_min < _g_max)){
HXDLIN( 327)				_g_min = (_g_min + 1);
HXDLIN( 327)				int px = (_g_min - 1);
HXDLIN( 327)				Float pcx = (( (Float)(px) ) - cx);
HXDLIN( 327)				{
HXDLIN( 327)					int _g_min1 = yIter3->start;
HXDLIN( 327)					int _g_max1 = yIter3->max;
HXDLIN( 327)					while((_g_min1 < _g_max1)){
HXDLIN( 327)						_g_min1 = (_g_min1 + 1);
HXDLIN( 327)						int py = (_g_min1 - 1);
HXDLIN( 327)						Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 327)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 327)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 327)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 327)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 327)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 327)						bool _hx_tmp4;
HXDLIN( 327)						bool _hx_tmp5;
HXDLIN( 327)						if ((ratioA >= 0)) {
HXDLIN( 327)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXDLIN( 327)							_hx_tmp5 = false;
            						}
HXDLIN( 327)						if (_hx_tmp5) {
HXDLIN( 327)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXDLIN( 327)							_hx_tmp4 = false;
            						}
HXDLIN( 327)						if (_hx_tmp4) {
HXDLIN( 327)							Float u = (((au * ratioA) + (bu * ratioB)) + ratioC);
HXDLIN( 327)							Float v2 = (((av * ratioA) + (bv * ratioB)) + ratioC);
HXDLIN( 327)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 327)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 327)							::Dynamic this23 = texture->image;
HXDLIN( 327)							int index4;
HXDLIN( 327)							if (texture->useVirtualPos) {
HXDLIN( 327)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXDLIN( 327)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 327)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 327)							int col1;
HXDLIN( 327)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 327)								col1 = c3;
            							}
HXDLIN( 327)							{
HXDLIN( 327)								int c4 = col1;
HXDLIN( 327)								bool _hx_tmp6;
HXDLIN( 327)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 327)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXDLIN( 327)									_hx_tmp6 = false;
            								}
HXDLIN( 327)								if (_hx_tmp6) {
HXDLIN( 327)									int location1;
HXDLIN( 327)									if (pixelImage->useVirtualPos) {
HXDLIN( 327)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 327)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 327)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 327)									int this25;
HXDLIN( 327)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN( 327)										this25 = this24;
            									}
HXDLIN( 327)									Float a11;
HXDLIN( 327)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 327)									if ((this26 == 0)) {
HXDLIN( 327)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float r11;
HXDLIN( 327)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 327)									if ((this27 == 0)) {
HXDLIN( 327)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float g11;
HXDLIN( 327)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 327)									if ((this28 == 0)) {
HXDLIN( 327)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float b12;
HXDLIN( 327)									int this29 = (this25 & 255);
HXDLIN( 327)									if ((this29 == 0)) {
HXDLIN( 327)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float a21;
HXDLIN( 327)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 327)									if ((this30 == 0)) {
HXDLIN( 327)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float r21;
HXDLIN( 327)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 327)									if ((this31 == 0)) {
HXDLIN( 327)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float g21;
HXDLIN( 327)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 327)									if ((this32 == 0)) {
HXDLIN( 327)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float b22;
HXDLIN( 327)									int this33 = (col1 & 255);
HXDLIN( 327)									if ((this33 == 0)) {
HXDLIN( 327)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 327)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 327)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 327)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 327)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 327)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 327)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 327)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 327)									{
HXDLIN( 327)										int _hx_tmp7;
HXDLIN( 327)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 327)											_hx_tmp7 = blended1;
            										}
HXDLIN( 327)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 327)									::Dynamic this34 = pixelImage->image;
HXDLIN( 327)									int index5;
HXDLIN( 327)									if (pixelImage->useVirtualPos) {
HXDLIN( 327)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 327)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 327)									int _hx_tmp8;
HXDLIN( 327)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 327)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 327)										_hx_tmp8 = c4;
            									}
HXDLIN( 327)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 327)		if ((hasHit == false)) {
HXDLIN( 327)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 327)			if (hasUndo) {
HXDLIN( 327)				v3->undoImage = undoImage;
HXDLIN( 327)				v3->undoX = xIter3->start;
HXDLIN( 327)				v3->undoY = yIter3->start;
            			}
HXDLIN( 327)			return v3;
            		}
            		else {
HXDLIN( 327)			return null();
            		}
HXDLIN( 327)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixel_Fields__obj,topRightImgTriFudge,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::bottomLeftImgTriFudge( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float dx,Float dy,Float cx,Float cy,Float ax,Float ay,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_335_bottomLeftImgTriFudge)
HXDLIN( 335)		Float au = ((Float)1.);
HXDLIN( 335)		Float av = ((Float)1.);
HXDLIN( 335)		Float bu = ((Float)0.);
HXDLIN( 335)		Float bv = ((Float)1.);
HXDLIN( 335)		Float temp = au;
HXLINE( 422)		au = bu;
HXLINE( 423)		bu = temp;
HXLINE( 424)		temp = av;
HXLINE( 425)		av = bv;
HXLINE( 426)		bv = temp;
HXLINE( 335)		Float bcx = (cx - ax);
HXDLIN( 335)		Float bcy = (cy - ay);
HXDLIN( 335)		Float acx = (dx - ax);
HXDLIN( 335)		Float acy = (dy - ay);
HXDLIN( 335)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 335)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 335)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 335)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 335)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 335)		if ((dx > cx)) {
HXDLIN( 335)			if ((dx > ax)) {
HXDLIN( 335)				int min;
HXDLIN( 335)				if ((cx > ax)) {
HXDLIN( 335)					min = ::Math_obj::floor(ax);
            				}
            				else {
HXDLIN( 335)					min = ::Math_obj::floor(cx);
            				}
HXDLIN( 335)				int ii_min = min;
HXDLIN( 335)				int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 335)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 335)				int ii_min1 = ::Math_obj::floor(cx);
HXDLIN( 335)				int ii_max1 = ::Math_obj::ceil(ax);
HXDLIN( 335)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 335)			if ((cx > ax)) {
HXDLIN( 335)				int min1;
HXDLIN( 335)				if ((dx > ax)) {
HXDLIN( 335)					min1 = ::Math_obj::floor(ax);
            				}
            				else {
HXDLIN( 335)					min1 = ::Math_obj::ceil(dx);
            				}
HXDLIN( 335)				int ii_min2 = min1;
HXDLIN( 335)				int ii_max2 = ::Math_obj::ceil(cx);
HXDLIN( 335)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 335)				int ii_min3 = ::Math_obj::floor(dx);
HXDLIN( 335)				int ii_max3 = ::Math_obj::ceil(ax);
HXDLIN( 335)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 335)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 335)		if ((dy > cy)) {
HXDLIN( 335)			if ((dy > ay)) {
HXDLIN( 335)				int min2;
HXDLIN( 335)				if ((cy > ay)) {
HXDLIN( 335)					min2 = ::Math_obj::floor(ay);
            				}
            				else {
HXDLIN( 335)					min2 = ::Math_obj::floor(cy);
            				}
HXDLIN( 335)				int ii_min4 = min2;
HXDLIN( 335)				int ii_max4 = ::Math_obj::ceil(dy);
HXDLIN( 335)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 335)				int ii_min5 = ::Math_obj::floor(cy);
HXDLIN( 335)				int ii_max5 = ::Math_obj::ceil(ay);
HXDLIN( 335)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 335)			if ((cy > ay)) {
HXDLIN( 335)				int min3;
HXDLIN( 335)				if ((dy > ay)) {
HXDLIN( 335)					min3 = ::Math_obj::floor(ay);
            				}
            				else {
HXDLIN( 335)					min3 = ::Math_obj::ceil(dy);
            				}
HXDLIN( 335)				int ii_min6 = min3;
HXDLIN( 335)				int ii_max6 = ::Math_obj::ceil(cy);
HXDLIN( 335)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 335)				int ii_min7 = ::Math_obj::floor(dy);
HXDLIN( 335)				int ii_max7 = ::Math_obj::ceil(ay);
HXDLIN( 335)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 335)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 335)		if (hasUndo) {
HXDLIN( 335)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 335)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 335)			 ::Dynamic imageType = null();
HXDLIN( 335)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 335)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 335)			::Dynamic undoImage1;
HXDLIN( 335)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 335)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 335)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 335)					{
HXDLIN( 335)						b->width = width;
HXDLIN( 335)						b->height = height;
HXDLIN( 335)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 335)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 335)						{
HXDLIN( 335)							int len = b->length;
HXDLIN( 335)							int w = 0;
HXDLIN( 335)							{
HXDLIN( 335)								int _g = 0;
HXDLIN( 335)								int _g1 = b->height;
HXDLIN( 335)								while((_g < _g1)){
HXDLIN( 335)									_g = (_g + 1);
HXDLIN( 335)									int y = (_g - 1);
HXDLIN( 335)									{
HXDLIN( 335)										int _g2 = 0;
HXDLIN( 335)										int _g3 = b->width;
HXDLIN( 335)										while((_g2 < _g3)){
HXDLIN( 335)											_g2 = (_g2 + 1);
HXDLIN( 335)											int x = (_g2 - 1);
HXDLIN( 335)											{
HXDLIN( 335)												w = (w + 1);
HXDLIN( 335)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 335)											{
HXDLIN( 335)												w = (w + 1);
HXDLIN( 335)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 335)											{
HXDLIN( 335)												w = (w + 1);
HXDLIN( 335)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 335)											{
HXDLIN( 335)												w = (w + 1);
HXDLIN( 335)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 335)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 335)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 335)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 335)					{
HXDLIN( 335)						a->width = width;
HXDLIN( 335)						a->height = height;
HXDLIN( 335)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 335)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 335)						{
HXDLIN( 335)							int _g4 = 0;
HXDLIN( 335)							int _g5 = a->length;
HXDLIN( 335)							while((_g4 < _g5)){
HXDLIN( 335)								_g4 = (_g4 + 1);
HXDLIN( 335)								int i = (_g4 - 1);
HXDLIN( 335)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 335)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN( 335)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 335)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 335)					{
HXDLIN( 335)						b1->width = width;
HXDLIN( 335)						b1->height = height;
HXDLIN( 335)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 335)						int size = (b1->length * 4);
HXDLIN( 335)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 335)						{
HXDLIN( 335)							int _g6 = 0;
HXDLIN( 335)							int _g7 = b1->length;
HXDLIN( 335)							while((_g6 < _g7)){
HXDLIN( 335)								_g6 = (_g6 + 1);
HXDLIN( 335)								int i1 = (_g6 - 1);
HXDLIN( 335)								{
HXDLIN( 335)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 335)									bool undoImage2;
HXDLIN( 335)									if ((i1 >= 0)) {
HXDLIN( 335)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXDLIN( 335)										undoImage2 = false;
            									}
HXDLIN( 335)									if (undoImage2) {
HXDLIN( 335)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 335)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 335)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 335)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 335)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 335)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 335)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 335)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 335)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 335)					{
HXDLIN( 335)						v->width = width;
HXDLIN( 335)						v->height = height;
HXDLIN( 335)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 335)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 335)						{
HXDLIN( 335)							int _g8 = 0;
HXDLIN( 335)							int _g9 = v->length;
HXDLIN( 335)							while((_g8 < _g9)){
HXDLIN( 335)								_g8 = (_g8 + 1);
HXDLIN( 335)								int i2 = (_g8 - 1);
HXDLIN( 335)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 335)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 335)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 335)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 335)					{
HXDLIN( 335)						b2->width = width;
HXDLIN( 335)						b2->height = height;
HXDLIN( 335)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 335)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 335)						{
HXDLIN( 335)							int len1 = b2->length;
HXDLIN( 335)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 335)							if (::hx::IsNull( d->head )) {
HXDLIN( 335)								int _g10 = 0;
HXDLIN( 335)								int _g11 = len1;
HXDLIN( 335)								while((_g10 < _g11)){
HXDLIN( 335)									_g10 = (_g10 + 1);
HXDLIN( 335)									int i3 = (_g10 - 1);
HXDLIN( 335)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 335)								int _g12 = 0;
HXDLIN( 335)								int _g13 = len1;
HXDLIN( 335)								while((_g12 < _g13)){
HXDLIN( 335)									_g12 = (_g12 + 1);
HXDLIN( 335)									int i4 = (_g12 - 1);
HXDLIN( 335)									{
HXDLIN( 335)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 335)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 335)										{
HXDLIN( 335)											int _g14 = 0;
HXDLIN( 335)											int _g15 = i4;
HXDLIN( 335)											while((_g14 < _g15)){
HXDLIN( 335)												_g14 = (_g14 + 1);
HXDLIN( 335)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 335)										if (::hx::IsNull( prev )) {
HXDLIN( 335)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 335)											l = null();
            										}
            										else {
HXDLIN( 335)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 335)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 335)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 335)			this1->image = undoImage1;
HXDLIN( 335)			this1->width = width;
HXDLIN( 335)			this1->height = height;
HXDLIN( 335)			this1->imageType = ( (int)(imageType) );
HXDLIN( 335)			undoImage = this1;
HXDLIN( 335)			{
HXDLIN( 335)				int rectLeft = xIter3->start;
HXDLIN( 335)				int rectTop = yIter3->start;
HXDLIN( 335)				int rectRight = xIter3->max;
HXDLIN( 335)				bool forceClear = false;
HXDLIN( 335)				{
HXDLIN( 335)					int _g16 = rectTop;
HXDLIN( 335)					int _g17 = yIter3->max;
HXDLIN( 335)					while((_g16 < _g17)){
HXDLIN( 335)						_g16 = (_g16 + 1);
HXDLIN( 335)						int dy1 = (_g16 - 1);
HXDLIN( 335)						{
HXDLIN( 335)							int _g18 = rectLeft;
HXDLIN( 335)							int _g19 = rectRight;
HXDLIN( 335)							while((_g18 < _g19)){
HXDLIN( 335)								_g18 = (_g18 + 1);
HXDLIN( 335)								int dx1 = (_g18 - 1);
HXDLIN( 335)								::Dynamic this3 = pixelImage->image;
HXDLIN( 335)								int index;
HXDLIN( 335)								if (pixelImage->useVirtualPos) {
HXDLIN( 335)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            								}
            								else {
HXDLIN( 335)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            								}
HXDLIN( 335)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 335)								int col;
HXDLIN( 335)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 335)									col = c;
            								}
HXDLIN( 335)								bool _hx_tmp;
HXDLIN( 335)								if (pixelImage->useMask) {
HXDLIN( 335)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXDLIN( 335)									_hx_tmp = false;
            								}
HXDLIN( 335)								if (_hx_tmp) {
HXDLIN( 335)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 335)									::Dynamic this5 = this4->image;
HXDLIN( 335)									int index1;
HXDLIN( 335)									if (this4->useVirtualPos) {
HXDLIN( 335)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            									}
            									else {
HXDLIN( 335)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            									}
HXDLIN( 335)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 335)									int v1;
HXDLIN( 335)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 335)										v1 = c1;
            									}
HXDLIN( 335)									int maskPixel = v1;
HXDLIN( 335)									int this6 = col;
HXDLIN( 335)									if ((maskPixel == 0)) {
HXDLIN( 335)										col = this6;
            									}
            									else {
HXDLIN( 335)										Float m0;
HXDLIN( 335)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 335)										if ((this7 == 0)) {
HXDLIN( 335)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float m1;
HXDLIN( 335)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 335)										if ((this8 == 0)) {
HXDLIN( 335)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float m2;
HXDLIN( 335)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 335)										if ((this9 == 0)) {
HXDLIN( 335)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float m3;
HXDLIN( 335)										int this10 = (maskPixel & 255);
HXDLIN( 335)										if ((this10 == 0)) {
HXDLIN( 335)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 335)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 335)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 335)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 335)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 335)								if ((col != 0)) {
HXDLIN( 335)									int x1 = (dx1 - rectLeft);
HXDLIN( 335)									int y1 = (dy1 - rectTop);
HXDLIN( 335)									int c2 = col;
HXDLIN( 335)									bool _hx_tmp1;
HXDLIN( 335)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 335)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 335)										_hx_tmp1 = false;
            									}
HXDLIN( 335)									if (_hx_tmp1) {
HXDLIN( 335)										int location;
HXDLIN( 335)										if (undoImage->useVirtualPos) {
HXDLIN( 335)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 335)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 335)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 335)										int this12;
HXDLIN( 335)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXDLIN( 335)											this12 = this11;
            										}
HXDLIN( 335)										Float a1;
HXDLIN( 335)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 335)										if ((this13 == 0)) {
HXDLIN( 335)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float r1;
HXDLIN( 335)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 335)										if ((this14 == 0)) {
HXDLIN( 335)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float g1;
HXDLIN( 335)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 335)										if ((this15 == 0)) {
HXDLIN( 335)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float b11;
HXDLIN( 335)										int this16 = (this12 & 255);
HXDLIN( 335)										if ((this16 == 0)) {
HXDLIN( 335)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float a2;
HXDLIN( 335)										int this17 = ((col >> 24) & 255);
HXDLIN( 335)										if ((this17 == 0)) {
HXDLIN( 335)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float r2;
HXDLIN( 335)										int this18 = ((col >> 16) & 255);
HXDLIN( 335)										if ((this18 == 0)) {
HXDLIN( 335)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float g2;
HXDLIN( 335)										int this19 = ((col >> 8) & 255);
HXDLIN( 335)										if ((this19 == 0)) {
HXDLIN( 335)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float b21;
HXDLIN( 335)										int this20 = (col & 255);
HXDLIN( 335)										if ((this20 == 0)) {
HXDLIN( 335)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 335)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 335)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 335)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 335)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 335)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 335)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 335)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 335)										{
HXDLIN( 335)											int _hx_tmp2;
HXDLIN( 335)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 335)												_hx_tmp2 = blended;
            											}
HXDLIN( 335)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 335)										::Dynamic this21 = undoImage->image;
HXDLIN( 335)										int index2;
HXDLIN( 335)										if (undoImage->useVirtualPos) {
HXDLIN( 335)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 335)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 335)										int _hx_tmp3;
HXDLIN( 335)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 335)											_hx_tmp3 = c2;
            										}
HXDLIN( 335)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 335)									if (forceClear) {
HXDLIN( 335)										::Dynamic this22 = undoImage->image;
HXDLIN( 335)										int x2 = (dx1 - rectLeft);
HXDLIN( 335)										int y2 = (dy1 - rectTop);
HXDLIN( 335)										int index3;
HXDLIN( 335)										if (undoImage->useVirtualPos) {
HXDLIN( 335)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 335)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 335)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 335)		{
HXDLIN( 335)			int _g_min = xIter3->start;
HXDLIN( 335)			int _g_max = xIter3->max;
HXDLIN( 335)			while((_g_min < _g_max)){
HXDLIN( 335)				_g_min = (_g_min + 1);
HXDLIN( 335)				int px = (_g_min - 1);
HXDLIN( 335)				Float pcx = (( (Float)(px) ) - ax);
HXDLIN( 335)				{
HXDLIN( 335)					int _g_min1 = yIter3->start;
HXDLIN( 335)					int _g_max1 = yIter3->max;
HXDLIN( 335)					while((_g_min1 < _g_max1)){
HXDLIN( 335)						_g_min1 = (_g_min1 + 1);
HXDLIN( 335)						int py = (_g_min1 - 1);
HXDLIN( 335)						Float pcy = (( (Float)(py) ) - ay);
HXDLIN( 335)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 335)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 335)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 335)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 335)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 335)						bool _hx_tmp4;
HXDLIN( 335)						bool _hx_tmp5;
HXDLIN( 335)						if ((ratioA >= 0)) {
HXDLIN( 335)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXDLIN( 335)							_hx_tmp5 = false;
            						}
HXDLIN( 335)						if (_hx_tmp5) {
HXDLIN( 335)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXDLIN( 335)							_hx_tmp4 = false;
            						}
HXDLIN( 335)						if (_hx_tmp4) {
HXDLIN( 335)							Float u = (((au * ratioA) + (bu * ratioB)) + (((Float)0.) * ratioC));
HXDLIN( 335)							Float v2 = (((av * ratioA) + (bv * ratioB)) + (((Float)0.) * ratioC));
HXDLIN( 335)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 335)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 335)							::Dynamic this23 = texture->image;
HXDLIN( 335)							int index4;
HXDLIN( 335)							if (texture->useVirtualPos) {
HXDLIN( 335)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXDLIN( 335)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 335)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 335)							int col1;
HXDLIN( 335)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 335)								col1 = c3;
            							}
HXDLIN( 335)							{
HXDLIN( 335)								int c4 = col1;
HXDLIN( 335)								bool _hx_tmp6;
HXDLIN( 335)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 335)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXDLIN( 335)									_hx_tmp6 = false;
            								}
HXDLIN( 335)								if (_hx_tmp6) {
HXDLIN( 335)									int location1;
HXDLIN( 335)									if (pixelImage->useVirtualPos) {
HXDLIN( 335)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 335)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 335)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 335)									int this25;
HXDLIN( 335)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN( 335)										this25 = this24;
            									}
HXDLIN( 335)									Float a11;
HXDLIN( 335)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 335)									if ((this26 == 0)) {
HXDLIN( 335)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float r11;
HXDLIN( 335)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 335)									if ((this27 == 0)) {
HXDLIN( 335)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float g11;
HXDLIN( 335)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 335)									if ((this28 == 0)) {
HXDLIN( 335)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float b12;
HXDLIN( 335)									int this29 = (this25 & 255);
HXDLIN( 335)									if ((this29 == 0)) {
HXDLIN( 335)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float a21;
HXDLIN( 335)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 335)									if ((this30 == 0)) {
HXDLIN( 335)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float r21;
HXDLIN( 335)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 335)									if ((this31 == 0)) {
HXDLIN( 335)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float g21;
HXDLIN( 335)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 335)									if ((this32 == 0)) {
HXDLIN( 335)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float b22;
HXDLIN( 335)									int this33 = (col1 & 255);
HXDLIN( 335)									if ((this33 == 0)) {
HXDLIN( 335)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 335)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 335)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 335)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 335)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 335)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 335)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 335)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 335)									{
HXDLIN( 335)										int _hx_tmp7;
HXDLIN( 335)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 335)											_hx_tmp7 = blended1;
            										}
HXDLIN( 335)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 335)									::Dynamic this34 = pixelImage->image;
HXDLIN( 335)									int index5;
HXDLIN( 335)									if (pixelImage->useVirtualPos) {
HXDLIN( 335)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 335)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 335)									int _hx_tmp8;
HXDLIN( 335)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 335)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 335)										_hx_tmp8 = c4;
            									}
HXDLIN( 335)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 335)		if ((hasHit == false)) {
HXDLIN( 335)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN( 335)			if (hasUndo) {
HXDLIN( 335)				v3->undoImage = undoImage;
HXDLIN( 335)				v3->undoX = xIter3->start;
HXDLIN( 335)				v3->undoY = yIter3->start;
            			}
HXDLIN( 335)			return v3;
            		}
            		else {
HXDLIN( 335)			return null();
            		}
HXDLIN( 335)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixel_Fields__obj,bottomLeftImgTriFudge,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::uvTriangleFudge( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float au,Float av,Float bx,Float by,Float bu,Float bv,Float cx,Float cy,Float cu,Float cv,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_346_uvTriangleFudge)
HXLINE( 347)		Float bcx = (bx - cx);
HXLINE( 348)		Float bcy = (by - cy);
HXLINE( 349)		Float acx = (ax - cx);
HXLINE( 350)		Float acy = (ay - cy);
HXLINE( 352)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 353)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 354)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 355)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 356)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 356)		if ((ax > bx)) {
HXLINE( 356)			if ((ax > cx)) {
HXLINE( 356)				int min;
HXDLIN( 356)				if ((bx > cx)) {
HXLINE( 356)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 356)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 356)				int ii_min = min;
HXDLIN( 356)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 356)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 356)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 356)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 356)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 356)			if ((bx > cx)) {
HXLINE( 356)				int min1;
HXDLIN( 356)				if ((ax > cx)) {
HXLINE( 356)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 356)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 356)				int ii_min2 = min1;
HXDLIN( 356)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 356)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 356)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 356)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 356)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 357)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 357)		if ((ay > by)) {
HXLINE( 357)			if ((ay > cy)) {
HXLINE( 357)				int min2;
HXDLIN( 357)				if ((by > cy)) {
HXLINE( 357)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 357)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 357)				int ii_min4 = min2;
HXDLIN( 357)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 357)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 357)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 357)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 357)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 357)			if ((by > cy)) {
HXLINE( 357)				int min3;
HXDLIN( 357)				if ((ay > cy)) {
HXLINE( 357)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 357)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 357)				int ii_min6 = min3;
HXDLIN( 357)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 357)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 357)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 357)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 357)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 358)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 359)		if (hasUndo) {
HXLINE( 360)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 360)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 360)			 ::Dynamic imageType = null();
HXDLIN( 360)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 360)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 360)			::Dynamic undoImage1;
HXDLIN( 360)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 360)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 360)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 360)					{
HXLINE( 360)						b->width = width;
HXDLIN( 360)						b->height = height;
HXDLIN( 360)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 360)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 360)						{
HXLINE( 360)							int len = b->length;
HXDLIN( 360)							int w = 0;
HXDLIN( 360)							{
HXLINE( 360)								int _g = 0;
HXDLIN( 360)								int _g1 = b->height;
HXDLIN( 360)								while((_g < _g1)){
HXLINE( 360)									_g = (_g + 1);
HXDLIN( 360)									int y = (_g - 1);
HXDLIN( 360)									{
HXLINE( 360)										int _g2 = 0;
HXDLIN( 360)										int _g3 = b->width;
HXDLIN( 360)										while((_g2 < _g3)){
HXLINE( 360)											_g2 = (_g2 + 1);
HXDLIN( 360)											int x = (_g2 - 1);
HXDLIN( 360)											{
HXLINE( 360)												w = (w + 1);
HXDLIN( 360)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 360)											{
HXLINE( 360)												w = (w + 1);
HXDLIN( 360)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 360)											{
HXLINE( 360)												w = (w + 1);
HXDLIN( 360)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 360)											{
HXLINE( 360)												w = (w + 1);
HXDLIN( 360)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 360)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 360)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 360)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 360)					{
HXLINE( 360)						a->width = width;
HXDLIN( 360)						a->height = height;
HXDLIN( 360)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 360)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 360)						{
HXLINE( 360)							int _g4 = 0;
HXDLIN( 360)							int _g5 = a->length;
HXDLIN( 360)							while((_g4 < _g5)){
HXLINE( 360)								_g4 = (_g4 + 1);
HXDLIN( 360)								int i = (_g4 - 1);
HXDLIN( 360)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 360)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 360)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 360)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 360)					{
HXLINE( 360)						b1->width = width;
HXDLIN( 360)						b1->height = height;
HXDLIN( 360)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 360)						int size = (b1->length * 4);
HXDLIN( 360)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 360)						{
HXLINE( 360)							int _g6 = 0;
HXDLIN( 360)							int _g7 = b1->length;
HXDLIN( 360)							while((_g6 < _g7)){
HXLINE( 360)								_g6 = (_g6 + 1);
HXDLIN( 360)								int i1 = (_g6 - 1);
HXDLIN( 360)								{
HXLINE( 360)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 360)									bool undoImage2;
HXDLIN( 360)									if ((i1 >= 0)) {
HXLINE( 360)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 360)										undoImage2 = false;
            									}
HXDLIN( 360)									if (undoImage2) {
HXLINE( 360)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 360)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 360)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 360)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 360)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 360)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 360)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 360)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 360)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 360)					{
HXLINE( 360)						v->width = width;
HXDLIN( 360)						v->height = height;
HXDLIN( 360)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 360)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 360)						{
HXLINE( 360)							int _g8 = 0;
HXDLIN( 360)							int _g9 = v->length;
HXDLIN( 360)							while((_g8 < _g9)){
HXLINE( 360)								_g8 = (_g8 + 1);
HXDLIN( 360)								int i2 = (_g8 - 1);
HXDLIN( 360)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 360)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 360)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 360)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 360)					{
HXLINE( 360)						b2->width = width;
HXDLIN( 360)						b2->height = height;
HXDLIN( 360)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 360)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 360)						{
HXLINE( 360)							int len1 = b2->length;
HXDLIN( 360)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 360)							if (::hx::IsNull( d->head )) {
HXLINE( 360)								int _g10 = 0;
HXDLIN( 360)								int _g11 = len1;
HXDLIN( 360)								while((_g10 < _g11)){
HXLINE( 360)									_g10 = (_g10 + 1);
HXDLIN( 360)									int i3 = (_g10 - 1);
HXDLIN( 360)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 360)								int _g12 = 0;
HXDLIN( 360)								int _g13 = len1;
HXDLIN( 360)								while((_g12 < _g13)){
HXLINE( 360)									_g12 = (_g12 + 1);
HXDLIN( 360)									int i4 = (_g12 - 1);
HXDLIN( 360)									{
HXLINE( 360)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 360)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 360)										{
HXLINE( 360)											int _g14 = 0;
HXDLIN( 360)											int _g15 = i4;
HXDLIN( 360)											while((_g14 < _g15)){
HXLINE( 360)												_g14 = (_g14 + 1);
HXDLIN( 360)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 360)										if (::hx::IsNull( prev )) {
HXLINE( 360)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 360)											l = null();
            										}
            										else {
HXLINE( 360)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 360)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 360)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 360)			this1->image = undoImage1;
HXDLIN( 360)			this1->width = width;
HXDLIN( 360)			this1->height = height;
HXDLIN( 360)			this1->imageType = ( (int)(imageType) );
HXDLIN( 360)			undoImage = this1;
HXLINE( 361)			{
HXLINE( 361)				int rectLeft = xIter3->start;
HXDLIN( 361)				int rectTop = yIter3->start;
HXDLIN( 361)				int rectRight = xIter3->max;
HXDLIN( 361)				bool forceClear = false;
HXDLIN( 361)				{
HXLINE( 361)					int _g16 = rectTop;
HXDLIN( 361)					int _g17 = yIter3->max;
HXDLIN( 361)					while((_g16 < _g17)){
HXLINE( 361)						_g16 = (_g16 + 1);
HXDLIN( 361)						int dy = (_g16 - 1);
HXDLIN( 361)						{
HXLINE( 361)							int _g18 = rectLeft;
HXDLIN( 361)							int _g19 = rectRight;
HXDLIN( 361)							while((_g18 < _g19)){
HXLINE( 361)								_g18 = (_g18 + 1);
HXDLIN( 361)								int dx = (_g18 - 1);
HXDLIN( 361)								::Dynamic this3 = pixelImage->image;
HXDLIN( 361)								int index;
HXDLIN( 361)								if (pixelImage->useVirtualPos) {
HXLINE( 361)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 361)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 361)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 361)								int col;
HXDLIN( 361)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 361)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 361)									col = c;
            								}
HXDLIN( 361)								bool _hx_tmp;
HXDLIN( 361)								if (pixelImage->useMask) {
HXLINE( 361)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 361)									_hx_tmp = false;
            								}
HXDLIN( 361)								if (_hx_tmp) {
HXLINE( 361)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 361)									::Dynamic this5 = this4->image;
HXDLIN( 361)									int index1;
HXDLIN( 361)									if (this4->useVirtualPos) {
HXLINE( 361)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 361)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 361)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 361)									int v1;
HXDLIN( 361)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 361)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 361)										v1 = c1;
            									}
HXDLIN( 361)									int maskPixel = v1;
HXDLIN( 361)									int this6 = col;
HXDLIN( 361)									if ((maskPixel == 0)) {
HXLINE( 361)										col = this6;
            									}
            									else {
HXLINE( 361)										Float m0;
HXDLIN( 361)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 361)										if ((this7 == 0)) {
HXLINE( 361)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float m1;
HXDLIN( 361)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 361)										if ((this8 == 0)) {
HXLINE( 361)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float m2;
HXDLIN( 361)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 361)										if ((this9 == 0)) {
HXLINE( 361)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float m3;
HXDLIN( 361)										int this10 = (maskPixel & 255);
HXDLIN( 361)										if ((this10 == 0)) {
HXLINE( 361)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 361)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 361)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 361)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 361)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 361)								if ((col != 0)) {
HXLINE( 361)									int x1 = (dx - rectLeft);
HXDLIN( 361)									int y1 = (dy - rectTop);
HXDLIN( 361)									int c2 = col;
HXDLIN( 361)									bool _hx_tmp1;
HXDLIN( 361)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 361)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 361)										_hx_tmp1 = false;
            									}
HXDLIN( 361)									if (_hx_tmp1) {
HXLINE( 361)										int location;
HXDLIN( 361)										if (undoImage->useVirtualPos) {
HXLINE( 361)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 361)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 361)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 361)										int this12;
HXDLIN( 361)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 361)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 361)											this12 = this11;
            										}
HXDLIN( 361)										Float a1;
HXDLIN( 361)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 361)										if ((this13 == 0)) {
HXLINE( 361)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float r1;
HXDLIN( 361)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 361)										if ((this14 == 0)) {
HXLINE( 361)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float g1;
HXDLIN( 361)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 361)										if ((this15 == 0)) {
HXLINE( 361)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float b11;
HXDLIN( 361)										int this16 = (this12 & 255);
HXDLIN( 361)										if ((this16 == 0)) {
HXLINE( 361)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float a2;
HXDLIN( 361)										int this17 = ((col >> 24) & 255);
HXDLIN( 361)										if ((this17 == 0)) {
HXLINE( 361)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float r2;
HXDLIN( 361)										int this18 = ((col >> 16) & 255);
HXDLIN( 361)										if ((this18 == 0)) {
HXLINE( 361)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float g2;
HXDLIN( 361)										int this19 = ((col >> 8) & 255);
HXDLIN( 361)										if ((this19 == 0)) {
HXLINE( 361)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float b21;
HXDLIN( 361)										int this20 = (col & 255);
HXDLIN( 361)										if ((this20 == 0)) {
HXLINE( 361)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 361)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 361)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 361)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 361)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 361)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 361)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 361)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 361)										{
HXLINE( 361)											int _hx_tmp2;
HXDLIN( 361)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 361)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 361)												_hx_tmp2 = blended;
            											}
HXDLIN( 361)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 361)										::Dynamic this21 = undoImage->image;
HXDLIN( 361)										int index2;
HXDLIN( 361)										if (undoImage->useVirtualPos) {
HXLINE( 361)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 361)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 361)										int _hx_tmp3;
HXDLIN( 361)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 361)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 361)											_hx_tmp3 = c2;
            										}
HXDLIN( 361)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 361)									if (forceClear) {
HXLINE( 361)										::Dynamic this22 = undoImage->image;
HXDLIN( 361)										int x2 = (dx - rectLeft);
HXDLIN( 361)										int y2 = (dy - rectTop);
HXDLIN( 361)										int index3;
HXDLIN( 361)										if (undoImage->useVirtualPos) {
HXLINE( 361)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 361)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 361)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 363)		{
HXLINE( 363)			int _g_min = xIter3->start;
HXDLIN( 363)			int _g_max = xIter3->max;
HXDLIN( 363)			while((_g_min < _g_max)){
HXLINE( 363)				_g_min = (_g_min + 1);
HXDLIN( 363)				int px = (_g_min - 1);
HXLINE( 364)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 365)				{
HXLINE( 365)					int _g_min1 = yIter3->start;
HXDLIN( 365)					int _g_max1 = yIter3->max;
HXDLIN( 365)					while((_g_min1 < _g_max1)){
HXLINE( 365)						_g_min1 = (_g_min1 + 1);
HXDLIN( 365)						int py = (_g_min1 - 1);
HXLINE( 366)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 367)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 368)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 369)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 370)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 371)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 372)						bool _hx_tmp4;
HXDLIN( 372)						bool _hx_tmp5;
HXDLIN( 372)						if ((ratioA >= 0)) {
HXLINE( 372)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 372)							_hx_tmp5 = false;
            						}
HXDLIN( 372)						if (_hx_tmp5) {
HXLINE( 372)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 372)							_hx_tmp4 = false;
            						}
HXDLIN( 372)						if (_hx_tmp4) {
HXLINE( 373)							Float u = (((au * ratioA) + (bu * ratioB)) + (cu * ratioC));
HXLINE( 374)							Float v2 = (((av * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXLINE( 375)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXLINE( 376)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXLINE( 377)							::Dynamic this23 = texture->image;
HXDLIN( 377)							int index4;
HXDLIN( 377)							if (texture->useVirtualPos) {
HXLINE( 377)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXLINE( 377)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 377)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 377)							int col1;
HXDLIN( 377)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 377)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 377)								col1 = c3;
            							}
HXLINE( 378)							{
HXLINE( 378)								int c4 = col1;
HXDLIN( 378)								bool _hx_tmp6;
HXDLIN( 378)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 378)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXLINE( 378)									_hx_tmp6 = false;
            								}
HXDLIN( 378)								if (_hx_tmp6) {
HXLINE( 378)									int location1;
HXDLIN( 378)									if (pixelImage->useVirtualPos) {
HXLINE( 378)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 378)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 378)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 378)									int this25;
HXDLIN( 378)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 378)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE( 378)										this25 = this24;
            									}
HXDLIN( 378)									Float a11;
HXDLIN( 378)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 378)									if ((this26 == 0)) {
HXLINE( 378)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float r11;
HXDLIN( 378)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 378)									if ((this27 == 0)) {
HXLINE( 378)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float g11;
HXDLIN( 378)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 378)									if ((this28 == 0)) {
HXLINE( 378)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float b12;
HXDLIN( 378)									int this29 = (this25 & 255);
HXDLIN( 378)									if ((this29 == 0)) {
HXLINE( 378)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float a21;
HXDLIN( 378)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 378)									if ((this30 == 0)) {
HXLINE( 378)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float r21;
HXDLIN( 378)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 378)									if ((this31 == 0)) {
HXLINE( 378)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float g21;
HXDLIN( 378)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 378)									if ((this32 == 0)) {
HXLINE( 378)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float b22;
HXDLIN( 378)									int this33 = (col1 & 255);
HXDLIN( 378)									if ((this33 == 0)) {
HXLINE( 378)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 378)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 378)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 378)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 378)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 378)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 378)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 378)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 378)									{
HXLINE( 378)										int _hx_tmp7;
HXDLIN( 378)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 378)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 378)											_hx_tmp7 = blended1;
            										}
HXDLIN( 378)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 378)									::Dynamic this34 = pixelImage->image;
HXDLIN( 378)									int index5;
HXDLIN( 378)									if (pixelImage->useVirtualPos) {
HXLINE( 378)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 378)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 378)									int _hx_tmp8;
HXDLIN( 378)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 378)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 378)										_hx_tmp8 = c4;
            									}
HXDLIN( 378)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 382)		if ((hasHit == false)) {
HXLINE( 383)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 384)			if (hasUndo) {
HXLINE( 385)				v3->undoImage = undoImage;
HXLINE( 386)				v3->undoX = xIter3->start;
HXLINE( 387)				v3->undoY = yIter3->start;
            			}
HXLINE( 389)			return v3;
            		}
            		else {
HXLINE( 391)			return null();
            		}
HXLINE( 382)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC17(TriPixel_Fields__obj,uvTriangleFudge,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::topLeftImgTri( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float bx,Float by,Float dx,Float dy,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_402_topLeftImgTri)
HXDLIN( 402)		Float au = ((Float)0.);
HXDLIN( 402)		Float av = ((Float)0.);
HXDLIN( 402)		Float bu = ( (Float)(1) );
HXDLIN( 402)		Float bv = ((Float)0.);
HXDLIN( 402)		Float temp = au;
HXLINE( 422)		au = bu;
HXLINE( 423)		bu = temp;
HXLINE( 424)		temp = av;
HXLINE( 425)		av = bv;
HXLINE( 426)		bv = temp;
HXLINE( 402)		Float bcx = (bx - dx);
HXDLIN( 402)		Float bcy = (by - dy);
HXDLIN( 402)		Float acx = (ax - dx);
HXDLIN( 402)		Float acy = (ay - dy);
HXDLIN( 402)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 402)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 402)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 402)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 402)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 402)		if ((ax > bx)) {
HXDLIN( 402)			if ((ax > dx)) {
HXDLIN( 402)				int min;
HXDLIN( 402)				if ((bx > dx)) {
HXDLIN( 402)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXDLIN( 402)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 402)				int ii_min = min;
HXDLIN( 402)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 402)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 402)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 402)				int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 402)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 402)			if ((bx > dx)) {
HXDLIN( 402)				int min1;
HXDLIN( 402)				if ((ax > dx)) {
HXDLIN( 402)					min1 = ::Math_obj::floor(dx);
            				}
            				else {
HXDLIN( 402)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 402)				int ii_min2 = min1;
HXDLIN( 402)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 402)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 402)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 402)				int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 402)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 402)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 402)		if ((ay > by)) {
HXDLIN( 402)			if ((ay > dy)) {
HXDLIN( 402)				int min2;
HXDLIN( 402)				if ((by > dy)) {
HXDLIN( 402)					min2 = ::Math_obj::floor(dy);
            				}
            				else {
HXDLIN( 402)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 402)				int ii_min4 = min2;
HXDLIN( 402)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 402)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 402)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 402)				int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 402)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 402)			if ((by > dy)) {
HXDLIN( 402)				int min3;
HXDLIN( 402)				if ((ay > dy)) {
HXDLIN( 402)					min3 = ::Math_obj::floor(dy);
            				}
            				else {
HXDLIN( 402)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 402)				int ii_min6 = min3;
HXDLIN( 402)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 402)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 402)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 402)				int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 402)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 402)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 402)		if (hasUndo) {
HXDLIN( 402)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 402)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 402)			 ::Dynamic imageType = null();
HXDLIN( 402)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 402)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 402)			::Dynamic undoImage1;
HXDLIN( 402)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 402)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 402)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 402)					{
HXDLIN( 402)						b->width = width;
HXDLIN( 402)						b->height = height;
HXDLIN( 402)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 402)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 402)						{
HXDLIN( 402)							int len = b->length;
HXDLIN( 402)							int w = 0;
HXDLIN( 402)							{
HXDLIN( 402)								int _g = 0;
HXDLIN( 402)								int _g1 = b->height;
HXDLIN( 402)								while((_g < _g1)){
HXDLIN( 402)									_g = (_g + 1);
HXDLIN( 402)									int y = (_g - 1);
HXDLIN( 402)									{
HXDLIN( 402)										int _g2 = 0;
HXDLIN( 402)										int _g3 = b->width;
HXDLIN( 402)										while((_g2 < _g3)){
HXDLIN( 402)											_g2 = (_g2 + 1);
HXDLIN( 402)											int x = (_g2 - 1);
HXDLIN( 402)											{
HXDLIN( 402)												w = (w + 1);
HXDLIN( 402)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 402)											{
HXDLIN( 402)												w = (w + 1);
HXDLIN( 402)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 402)											{
HXDLIN( 402)												w = (w + 1);
HXDLIN( 402)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 402)											{
HXDLIN( 402)												w = (w + 1);
HXDLIN( 402)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 402)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 402)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 402)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 402)					{
HXDLIN( 402)						a->width = width;
HXDLIN( 402)						a->height = height;
HXDLIN( 402)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 402)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 402)						{
HXDLIN( 402)							int _g4 = 0;
HXDLIN( 402)							int _g5 = a->length;
HXDLIN( 402)							while((_g4 < _g5)){
HXDLIN( 402)								_g4 = (_g4 + 1);
HXDLIN( 402)								int i = (_g4 - 1);
HXDLIN( 402)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 402)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN( 402)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 402)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 402)					{
HXDLIN( 402)						b1->width = width;
HXDLIN( 402)						b1->height = height;
HXDLIN( 402)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 402)						int size = (b1->length * 4);
HXDLIN( 402)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 402)						{
HXDLIN( 402)							int _g6 = 0;
HXDLIN( 402)							int _g7 = b1->length;
HXDLIN( 402)							while((_g6 < _g7)){
HXDLIN( 402)								_g6 = (_g6 + 1);
HXDLIN( 402)								int i1 = (_g6 - 1);
HXDLIN( 402)								{
HXDLIN( 402)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 402)									bool undoImage2;
HXDLIN( 402)									if ((i1 >= 0)) {
HXDLIN( 402)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXDLIN( 402)										undoImage2 = false;
            									}
HXDLIN( 402)									if (undoImage2) {
HXDLIN( 402)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 402)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 402)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 402)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 402)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 402)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 402)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 402)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 402)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 402)					{
HXDLIN( 402)						v->width = width;
HXDLIN( 402)						v->height = height;
HXDLIN( 402)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 402)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 402)						{
HXDLIN( 402)							int _g8 = 0;
HXDLIN( 402)							int _g9 = v->length;
HXDLIN( 402)							while((_g8 < _g9)){
HXDLIN( 402)								_g8 = (_g8 + 1);
HXDLIN( 402)								int i2 = (_g8 - 1);
HXDLIN( 402)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 402)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 402)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 402)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 402)					{
HXDLIN( 402)						b2->width = width;
HXDLIN( 402)						b2->height = height;
HXDLIN( 402)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 402)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 402)						{
HXDLIN( 402)							int len1 = b2->length;
HXDLIN( 402)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 402)							if (::hx::IsNull( d->head )) {
HXDLIN( 402)								int _g10 = 0;
HXDLIN( 402)								int _g11 = len1;
HXDLIN( 402)								while((_g10 < _g11)){
HXDLIN( 402)									_g10 = (_g10 + 1);
HXDLIN( 402)									int i3 = (_g10 - 1);
HXDLIN( 402)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 402)								int _g12 = 0;
HXDLIN( 402)								int _g13 = len1;
HXDLIN( 402)								while((_g12 < _g13)){
HXDLIN( 402)									_g12 = (_g12 + 1);
HXDLIN( 402)									int i4 = (_g12 - 1);
HXDLIN( 402)									{
HXDLIN( 402)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 402)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 402)										{
HXDLIN( 402)											int _g14 = 0;
HXDLIN( 402)											int _g15 = i4;
HXDLIN( 402)											while((_g14 < _g15)){
HXDLIN( 402)												_g14 = (_g14 + 1);
HXDLIN( 402)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 402)										if (::hx::IsNull( prev )) {
HXDLIN( 402)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 402)											l = null();
            										}
            										else {
HXDLIN( 402)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 402)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 402)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 402)			this1->image = undoImage1;
HXDLIN( 402)			this1->width = width;
HXDLIN( 402)			this1->height = height;
HXDLIN( 402)			this1->imageType = ( (int)(imageType) );
HXDLIN( 402)			undoImage = this1;
HXDLIN( 402)			{
HXDLIN( 402)				int rectLeft = xIter3->start;
HXDLIN( 402)				int rectTop = yIter3->start;
HXDLIN( 402)				int rectRight = xIter3->max;
HXDLIN( 402)				bool forceClear = false;
HXDLIN( 402)				{
HXDLIN( 402)					int _g16 = rectTop;
HXDLIN( 402)					int _g17 = yIter3->max;
HXDLIN( 402)					while((_g16 < _g17)){
HXDLIN( 402)						_g16 = (_g16 + 1);
HXDLIN( 402)						int dy1 = (_g16 - 1);
HXDLIN( 402)						{
HXDLIN( 402)							int _g18 = rectLeft;
HXDLIN( 402)							int _g19 = rectRight;
HXDLIN( 402)							while((_g18 < _g19)){
HXDLIN( 402)								_g18 = (_g18 + 1);
HXDLIN( 402)								int dx1 = (_g18 - 1);
HXDLIN( 402)								::Dynamic this3 = pixelImage->image;
HXDLIN( 402)								int index;
HXDLIN( 402)								if (pixelImage->useVirtualPos) {
HXDLIN( 402)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            								}
            								else {
HXDLIN( 402)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            								}
HXDLIN( 402)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 402)								int col;
HXDLIN( 402)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 402)									col = c;
            								}
HXDLIN( 402)								bool _hx_tmp;
HXDLIN( 402)								if (pixelImage->useMask) {
HXDLIN( 402)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXDLIN( 402)									_hx_tmp = false;
            								}
HXDLIN( 402)								if (_hx_tmp) {
HXDLIN( 402)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 402)									::Dynamic this5 = this4->image;
HXDLIN( 402)									int index1;
HXDLIN( 402)									if (this4->useVirtualPos) {
HXDLIN( 402)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            									}
            									else {
HXDLIN( 402)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            									}
HXDLIN( 402)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 402)									int v1;
HXDLIN( 402)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 402)										v1 = c1;
            									}
HXDLIN( 402)									int maskPixel = v1;
HXDLIN( 402)									int this6 = col;
HXDLIN( 402)									if ((maskPixel == 0)) {
HXDLIN( 402)										col = this6;
            									}
            									else {
HXDLIN( 402)										Float m0;
HXDLIN( 402)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 402)										if ((this7 == 0)) {
HXDLIN( 402)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float m1;
HXDLIN( 402)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 402)										if ((this8 == 0)) {
HXDLIN( 402)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float m2;
HXDLIN( 402)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 402)										if ((this9 == 0)) {
HXDLIN( 402)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float m3;
HXDLIN( 402)										int this10 = (maskPixel & 255);
HXDLIN( 402)										if ((this10 == 0)) {
HXDLIN( 402)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 402)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 402)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 402)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 402)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 402)								if ((col != 0)) {
HXDLIN( 402)									int x1 = (dx1 - rectLeft);
HXDLIN( 402)									int y1 = (dy1 - rectTop);
HXDLIN( 402)									int c2 = col;
HXDLIN( 402)									bool _hx_tmp1;
HXDLIN( 402)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 402)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 402)										_hx_tmp1 = false;
            									}
HXDLIN( 402)									if (_hx_tmp1) {
HXDLIN( 402)										int location;
HXDLIN( 402)										if (undoImage->useVirtualPos) {
HXDLIN( 402)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 402)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 402)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 402)										int this12;
HXDLIN( 402)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXDLIN( 402)											this12 = this11;
            										}
HXDLIN( 402)										Float a1;
HXDLIN( 402)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 402)										if ((this13 == 0)) {
HXDLIN( 402)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float r1;
HXDLIN( 402)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 402)										if ((this14 == 0)) {
HXDLIN( 402)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float g1;
HXDLIN( 402)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 402)										if ((this15 == 0)) {
HXDLIN( 402)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float b11;
HXDLIN( 402)										int this16 = (this12 & 255);
HXDLIN( 402)										if ((this16 == 0)) {
HXDLIN( 402)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float a2;
HXDLIN( 402)										int this17 = ((col >> 24) & 255);
HXDLIN( 402)										if ((this17 == 0)) {
HXDLIN( 402)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float r2;
HXDLIN( 402)										int this18 = ((col >> 16) & 255);
HXDLIN( 402)										if ((this18 == 0)) {
HXDLIN( 402)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float g2;
HXDLIN( 402)										int this19 = ((col >> 8) & 255);
HXDLIN( 402)										if ((this19 == 0)) {
HXDLIN( 402)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float b21;
HXDLIN( 402)										int this20 = (col & 255);
HXDLIN( 402)										if ((this20 == 0)) {
HXDLIN( 402)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 402)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 402)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 402)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 402)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 402)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 402)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 402)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 402)										{
HXDLIN( 402)											int _hx_tmp2;
HXDLIN( 402)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 402)												_hx_tmp2 = blended;
            											}
HXDLIN( 402)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 402)										::Dynamic this21 = undoImage->image;
HXDLIN( 402)										int index2;
HXDLIN( 402)										if (undoImage->useVirtualPos) {
HXDLIN( 402)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 402)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 402)										int _hx_tmp3;
HXDLIN( 402)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 402)											_hx_tmp3 = c2;
            										}
HXDLIN( 402)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 402)									if (forceClear) {
HXDLIN( 402)										::Dynamic this22 = undoImage->image;
HXDLIN( 402)										int x2 = (dx1 - rectLeft);
HXDLIN( 402)										int y2 = (dy1 - rectTop);
HXDLIN( 402)										int index3;
HXDLIN( 402)										if (undoImage->useVirtualPos) {
HXDLIN( 402)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 402)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 402)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 402)		{
HXDLIN( 402)			int _g_min = xIter3->start;
HXDLIN( 402)			int _g_max = xIter3->max;
HXDLIN( 402)			while((_g_min < _g_max)){
HXDLIN( 402)				_g_min = (_g_min + 1);
HXDLIN( 402)				int px = (_g_min - 1);
HXDLIN( 402)				Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 402)				{
HXDLIN( 402)					int _g_min1 = yIter3->start;
HXDLIN( 402)					int _g_max1 = yIter3->max;
HXDLIN( 402)					while((_g_min1 < _g_max1)){
HXDLIN( 402)						_g_min1 = (_g_min1 + 1);
HXDLIN( 402)						int py = (_g_min1 - 1);
HXDLIN( 402)						Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 402)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 402)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 402)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 402)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 402)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 402)						bool _hx_tmp4;
HXDLIN( 402)						bool _hx_tmp5;
HXDLIN( 402)						if ((ratioA >= 0)) {
HXDLIN( 402)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXDLIN( 402)							_hx_tmp5 = false;
            						}
HXDLIN( 402)						if (_hx_tmp5) {
HXDLIN( 402)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXDLIN( 402)							_hx_tmp4 = false;
            						}
HXDLIN( 402)						if (_hx_tmp4) {
HXDLIN( 402)							Float u = (((au * ratioA) + (bu * ratioB)) + (((Float)0.) * ratioC));
HXDLIN( 402)							Float v2 = (((av * ratioA) + (bv * ratioB)) + ratioC);
HXDLIN( 402)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 402)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 402)							::Dynamic this23 = texture->image;
HXDLIN( 402)							int index4;
HXDLIN( 402)							if (texture->useVirtualPos) {
HXDLIN( 402)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXDLIN( 402)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 402)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 402)							int col1;
HXDLIN( 402)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 402)								col1 = c3;
            							}
HXDLIN( 402)							{
HXDLIN( 402)								int c4 = col1;
HXDLIN( 402)								bool _hx_tmp6;
HXDLIN( 402)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 402)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXDLIN( 402)									_hx_tmp6 = false;
            								}
HXDLIN( 402)								if (_hx_tmp6) {
HXDLIN( 402)									int location1;
HXDLIN( 402)									if (pixelImage->useVirtualPos) {
HXDLIN( 402)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 402)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 402)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 402)									int this25;
HXDLIN( 402)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN( 402)										this25 = this24;
            									}
HXDLIN( 402)									Float a11;
HXDLIN( 402)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 402)									if ((this26 == 0)) {
HXDLIN( 402)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float r11;
HXDLIN( 402)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 402)									if ((this27 == 0)) {
HXDLIN( 402)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float g11;
HXDLIN( 402)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 402)									if ((this28 == 0)) {
HXDLIN( 402)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float b12;
HXDLIN( 402)									int this29 = (this25 & 255);
HXDLIN( 402)									if ((this29 == 0)) {
HXDLIN( 402)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float a21;
HXDLIN( 402)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 402)									if ((this30 == 0)) {
HXDLIN( 402)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float r21;
HXDLIN( 402)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 402)									if ((this31 == 0)) {
HXDLIN( 402)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float g21;
HXDLIN( 402)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 402)									if ((this32 == 0)) {
HXDLIN( 402)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float b22;
HXDLIN( 402)									int this33 = (col1 & 255);
HXDLIN( 402)									if ((this33 == 0)) {
HXDLIN( 402)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 402)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 402)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 402)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 402)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 402)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 402)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 402)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 402)									{
HXDLIN( 402)										int _hx_tmp7;
HXDLIN( 402)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 402)											_hx_tmp7 = blended1;
            										}
HXDLIN( 402)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 402)									::Dynamic this34 = pixelImage->image;
HXDLIN( 402)									int index5;
HXDLIN( 402)									if (pixelImage->useVirtualPos) {
HXDLIN( 402)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 402)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 402)									int _hx_tmp8;
HXDLIN( 402)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 402)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 402)										_hx_tmp8 = c4;
            									}
HXDLIN( 402)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 402)		if ((hasHit == false)) {
HXDLIN( 402)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 402)			if (hasUndo) {
HXDLIN( 402)				v3->undoImage = undoImage;
HXDLIN( 402)				v3->undoX = xIter3->start;
HXDLIN( 402)				v3->undoY = yIter3->start;
            			}
HXDLIN( 402)			return v3;
            		}
            		else {
HXDLIN( 402)			return null();
            		}
HXDLIN( 402)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixel_Fields__obj,topLeftImgTri,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::bottomRightImgTri( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_412_bottomRightImgTri)
HXDLIN( 412)		Float au = ((Float)1.);
HXDLIN( 412)		Float av = ((Float)0.);
HXDLIN( 412)		Float bu = ((Float)1.);
HXDLIN( 412)		Float bv = ((Float)1.);
HXDLIN( 412)		Float temp = au;
HXLINE( 422)		au = bu;
HXLINE( 423)		bu = temp;
HXLINE( 424)		temp = av;
HXLINE( 425)		av = bv;
HXLINE( 426)		bv = temp;
HXLINE( 412)		Float bcx = (cx - dx);
HXDLIN( 412)		Float bcy = (cy - dy);
HXDLIN( 412)		Float acx = (bx - dx);
HXDLIN( 412)		Float acy = (by - dy);
HXDLIN( 412)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 412)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 412)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 412)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 412)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 412)		if ((bx > cx)) {
HXDLIN( 412)			if ((bx > dx)) {
HXDLIN( 412)				int min;
HXDLIN( 412)				if ((cx > dx)) {
HXDLIN( 412)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXDLIN( 412)					min = ::Math_obj::floor(cx);
            				}
HXDLIN( 412)				int ii_min = min;
HXDLIN( 412)				int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 412)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 412)				int ii_min1 = ::Math_obj::floor(cx);
HXDLIN( 412)				int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 412)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 412)			if ((cx > dx)) {
HXDLIN( 412)				int min1;
HXDLIN( 412)				if ((bx > dx)) {
HXDLIN( 412)					min1 = ::Math_obj::floor(dx);
            				}
            				else {
HXDLIN( 412)					min1 = ::Math_obj::ceil(bx);
            				}
HXDLIN( 412)				int ii_min2 = min1;
HXDLIN( 412)				int ii_max2 = ::Math_obj::ceil(cx);
HXDLIN( 412)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 412)				int ii_min3 = ::Math_obj::floor(bx);
HXDLIN( 412)				int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 412)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 412)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 412)		if ((by > cy)) {
HXDLIN( 412)			if ((by > dy)) {
HXDLIN( 412)				int min2;
HXDLIN( 412)				if ((cy > dy)) {
HXDLIN( 412)					min2 = ::Math_obj::floor(dy);
            				}
            				else {
HXDLIN( 412)					min2 = ::Math_obj::floor(cy);
            				}
HXDLIN( 412)				int ii_min4 = min2;
HXDLIN( 412)				int ii_max4 = ::Math_obj::ceil(by);
HXDLIN( 412)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 412)				int ii_min5 = ::Math_obj::floor(cy);
HXDLIN( 412)				int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 412)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 412)			if ((cy > dy)) {
HXDLIN( 412)				int min3;
HXDLIN( 412)				if ((by > dy)) {
HXDLIN( 412)					min3 = ::Math_obj::floor(dy);
            				}
            				else {
HXDLIN( 412)					min3 = ::Math_obj::ceil(by);
            				}
HXDLIN( 412)				int ii_min6 = min3;
HXDLIN( 412)				int ii_max6 = ::Math_obj::ceil(cy);
HXDLIN( 412)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 412)				int ii_min7 = ::Math_obj::floor(by);
HXDLIN( 412)				int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 412)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 412)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 412)		if (hasUndo) {
HXDLIN( 412)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 412)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 412)			 ::Dynamic imageType = null();
HXDLIN( 412)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 412)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 412)			::Dynamic undoImage1;
HXDLIN( 412)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 412)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 412)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 412)					{
HXDLIN( 412)						b->width = width;
HXDLIN( 412)						b->height = height;
HXDLIN( 412)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 412)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 412)						{
HXDLIN( 412)							int len = b->length;
HXDLIN( 412)							int w = 0;
HXDLIN( 412)							{
HXDLIN( 412)								int _g = 0;
HXDLIN( 412)								int _g1 = b->height;
HXDLIN( 412)								while((_g < _g1)){
HXDLIN( 412)									_g = (_g + 1);
HXDLIN( 412)									int y = (_g - 1);
HXDLIN( 412)									{
HXDLIN( 412)										int _g2 = 0;
HXDLIN( 412)										int _g3 = b->width;
HXDLIN( 412)										while((_g2 < _g3)){
HXDLIN( 412)											_g2 = (_g2 + 1);
HXDLIN( 412)											int x = (_g2 - 1);
HXDLIN( 412)											{
HXDLIN( 412)												w = (w + 1);
HXDLIN( 412)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 412)											{
HXDLIN( 412)												w = (w + 1);
HXDLIN( 412)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 412)											{
HXDLIN( 412)												w = (w + 1);
HXDLIN( 412)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 412)											{
HXDLIN( 412)												w = (w + 1);
HXDLIN( 412)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 412)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 412)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 412)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 412)					{
HXDLIN( 412)						a->width = width;
HXDLIN( 412)						a->height = height;
HXDLIN( 412)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 412)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 412)						{
HXDLIN( 412)							int _g4 = 0;
HXDLIN( 412)							int _g5 = a->length;
HXDLIN( 412)							while((_g4 < _g5)){
HXDLIN( 412)								_g4 = (_g4 + 1);
HXDLIN( 412)								int i = (_g4 - 1);
HXDLIN( 412)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 412)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN( 412)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 412)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 412)					{
HXDLIN( 412)						b1->width = width;
HXDLIN( 412)						b1->height = height;
HXDLIN( 412)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 412)						int size = (b1->length * 4);
HXDLIN( 412)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 412)						{
HXDLIN( 412)							int _g6 = 0;
HXDLIN( 412)							int _g7 = b1->length;
HXDLIN( 412)							while((_g6 < _g7)){
HXDLIN( 412)								_g6 = (_g6 + 1);
HXDLIN( 412)								int i1 = (_g6 - 1);
HXDLIN( 412)								{
HXDLIN( 412)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 412)									bool undoImage2;
HXDLIN( 412)									if ((i1 >= 0)) {
HXDLIN( 412)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXDLIN( 412)										undoImage2 = false;
            									}
HXDLIN( 412)									if (undoImage2) {
HXDLIN( 412)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 412)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 412)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 412)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 412)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 412)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 412)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 412)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 412)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 412)					{
HXDLIN( 412)						v->width = width;
HXDLIN( 412)						v->height = height;
HXDLIN( 412)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 412)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 412)						{
HXDLIN( 412)							int _g8 = 0;
HXDLIN( 412)							int _g9 = v->length;
HXDLIN( 412)							while((_g8 < _g9)){
HXDLIN( 412)								_g8 = (_g8 + 1);
HXDLIN( 412)								int i2 = (_g8 - 1);
HXDLIN( 412)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 412)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 412)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 412)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 412)					{
HXDLIN( 412)						b2->width = width;
HXDLIN( 412)						b2->height = height;
HXDLIN( 412)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 412)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 412)						{
HXDLIN( 412)							int len1 = b2->length;
HXDLIN( 412)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 412)							if (::hx::IsNull( d->head )) {
HXDLIN( 412)								int _g10 = 0;
HXDLIN( 412)								int _g11 = len1;
HXDLIN( 412)								while((_g10 < _g11)){
HXDLIN( 412)									_g10 = (_g10 + 1);
HXDLIN( 412)									int i3 = (_g10 - 1);
HXDLIN( 412)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 412)								int _g12 = 0;
HXDLIN( 412)								int _g13 = len1;
HXDLIN( 412)								while((_g12 < _g13)){
HXDLIN( 412)									_g12 = (_g12 + 1);
HXDLIN( 412)									int i4 = (_g12 - 1);
HXDLIN( 412)									{
HXDLIN( 412)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 412)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 412)										{
HXDLIN( 412)											int _g14 = 0;
HXDLIN( 412)											int _g15 = i4;
HXDLIN( 412)											while((_g14 < _g15)){
HXDLIN( 412)												_g14 = (_g14 + 1);
HXDLIN( 412)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 412)										if (::hx::IsNull( prev )) {
HXDLIN( 412)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 412)											l = null();
            										}
            										else {
HXDLIN( 412)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 412)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 412)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 412)			this1->image = undoImage1;
HXDLIN( 412)			this1->width = width;
HXDLIN( 412)			this1->height = height;
HXDLIN( 412)			this1->imageType = ( (int)(imageType) );
HXDLIN( 412)			undoImage = this1;
HXDLIN( 412)			{
HXDLIN( 412)				int rectLeft = xIter3->start;
HXDLIN( 412)				int rectTop = yIter3->start;
HXDLIN( 412)				int rectRight = xIter3->max;
HXDLIN( 412)				bool forceClear = false;
HXDLIN( 412)				{
HXDLIN( 412)					int _g16 = rectTop;
HXDLIN( 412)					int _g17 = yIter3->max;
HXDLIN( 412)					while((_g16 < _g17)){
HXDLIN( 412)						_g16 = (_g16 + 1);
HXDLIN( 412)						int dy1 = (_g16 - 1);
HXDLIN( 412)						{
HXDLIN( 412)							int _g18 = rectLeft;
HXDLIN( 412)							int _g19 = rectRight;
HXDLIN( 412)							while((_g18 < _g19)){
HXDLIN( 412)								_g18 = (_g18 + 1);
HXDLIN( 412)								int dx1 = (_g18 - 1);
HXDLIN( 412)								::Dynamic this3 = pixelImage->image;
HXDLIN( 412)								int index;
HXDLIN( 412)								if (pixelImage->useVirtualPos) {
HXDLIN( 412)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            								}
            								else {
HXDLIN( 412)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            								}
HXDLIN( 412)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 412)								int col;
HXDLIN( 412)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 412)									col = c;
            								}
HXDLIN( 412)								bool _hx_tmp;
HXDLIN( 412)								if (pixelImage->useMask) {
HXDLIN( 412)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXDLIN( 412)									_hx_tmp = false;
            								}
HXDLIN( 412)								if (_hx_tmp) {
HXDLIN( 412)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 412)									::Dynamic this5 = this4->image;
HXDLIN( 412)									int index1;
HXDLIN( 412)									if (this4->useVirtualPos) {
HXDLIN( 412)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            									}
            									else {
HXDLIN( 412)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            									}
HXDLIN( 412)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 412)									int v1;
HXDLIN( 412)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 412)										v1 = c1;
            									}
HXDLIN( 412)									int maskPixel = v1;
HXDLIN( 412)									int this6 = col;
HXDLIN( 412)									if ((maskPixel == 0)) {
HXDLIN( 412)										col = this6;
            									}
            									else {
HXDLIN( 412)										Float m0;
HXDLIN( 412)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 412)										if ((this7 == 0)) {
HXDLIN( 412)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float m1;
HXDLIN( 412)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 412)										if ((this8 == 0)) {
HXDLIN( 412)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float m2;
HXDLIN( 412)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 412)										if ((this9 == 0)) {
HXDLIN( 412)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float m3;
HXDLIN( 412)										int this10 = (maskPixel & 255);
HXDLIN( 412)										if ((this10 == 0)) {
HXDLIN( 412)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 412)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 412)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 412)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 412)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 412)								if ((col != 0)) {
HXDLIN( 412)									int x1 = (dx1 - rectLeft);
HXDLIN( 412)									int y1 = (dy1 - rectTop);
HXDLIN( 412)									int c2 = col;
HXDLIN( 412)									bool _hx_tmp1;
HXDLIN( 412)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 412)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 412)										_hx_tmp1 = false;
            									}
HXDLIN( 412)									if (_hx_tmp1) {
HXDLIN( 412)										int location;
HXDLIN( 412)										if (undoImage->useVirtualPos) {
HXDLIN( 412)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 412)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 412)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 412)										int this12;
HXDLIN( 412)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXDLIN( 412)											this12 = this11;
            										}
HXDLIN( 412)										Float a1;
HXDLIN( 412)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 412)										if ((this13 == 0)) {
HXDLIN( 412)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float r1;
HXDLIN( 412)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 412)										if ((this14 == 0)) {
HXDLIN( 412)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float g1;
HXDLIN( 412)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 412)										if ((this15 == 0)) {
HXDLIN( 412)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float b11;
HXDLIN( 412)										int this16 = (this12 & 255);
HXDLIN( 412)										if ((this16 == 0)) {
HXDLIN( 412)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float a2;
HXDLIN( 412)										int this17 = ((col >> 24) & 255);
HXDLIN( 412)										if ((this17 == 0)) {
HXDLIN( 412)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float r2;
HXDLIN( 412)										int this18 = ((col >> 16) & 255);
HXDLIN( 412)										if ((this18 == 0)) {
HXDLIN( 412)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float g2;
HXDLIN( 412)										int this19 = ((col >> 8) & 255);
HXDLIN( 412)										if ((this19 == 0)) {
HXDLIN( 412)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float b21;
HXDLIN( 412)										int this20 = (col & 255);
HXDLIN( 412)										if ((this20 == 0)) {
HXDLIN( 412)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 412)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 412)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 412)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 412)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 412)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 412)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 412)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 412)										{
HXDLIN( 412)											int _hx_tmp2;
HXDLIN( 412)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 412)												_hx_tmp2 = blended;
            											}
HXDLIN( 412)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 412)										::Dynamic this21 = undoImage->image;
HXDLIN( 412)										int index2;
HXDLIN( 412)										if (undoImage->useVirtualPos) {
HXDLIN( 412)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 412)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 412)										int _hx_tmp3;
HXDLIN( 412)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 412)											_hx_tmp3 = c2;
            										}
HXDLIN( 412)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 412)									if (forceClear) {
HXDLIN( 412)										::Dynamic this22 = undoImage->image;
HXDLIN( 412)										int x2 = (dx1 - rectLeft);
HXDLIN( 412)										int y2 = (dy1 - rectTop);
HXDLIN( 412)										int index3;
HXDLIN( 412)										if (undoImage->useVirtualPos) {
HXDLIN( 412)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 412)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 412)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 412)		{
HXDLIN( 412)			int _g_min = xIter3->start;
HXDLIN( 412)			int _g_max = xIter3->max;
HXDLIN( 412)			while((_g_min < _g_max)){
HXDLIN( 412)				_g_min = (_g_min + 1);
HXDLIN( 412)				int px = (_g_min - 1);
HXDLIN( 412)				Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 412)				{
HXDLIN( 412)					int _g_min1 = yIter3->start;
HXDLIN( 412)					int _g_max1 = yIter3->max;
HXDLIN( 412)					while((_g_min1 < _g_max1)){
HXDLIN( 412)						_g_min1 = (_g_min1 + 1);
HXDLIN( 412)						int py = (_g_min1 - 1);
HXDLIN( 412)						Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 412)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 412)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 412)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 412)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 412)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 412)						bool _hx_tmp4;
HXDLIN( 412)						bool _hx_tmp5;
HXDLIN( 412)						if ((ratioA >= 0)) {
HXDLIN( 412)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXDLIN( 412)							_hx_tmp5 = false;
            						}
HXDLIN( 412)						if (_hx_tmp5) {
HXDLIN( 412)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXDLIN( 412)							_hx_tmp4 = false;
            						}
HXDLIN( 412)						if (_hx_tmp4) {
HXDLIN( 412)							Float u = (((au * ratioA) + (bu * ratioB)) + (((Float)0.) * ratioC));
HXDLIN( 412)							Float v2 = (((av * ratioA) + (bv * ratioB)) + ratioC);
HXDLIN( 412)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 412)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 412)							::Dynamic this23 = texture->image;
HXDLIN( 412)							int index4;
HXDLIN( 412)							if (texture->useVirtualPos) {
HXDLIN( 412)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXDLIN( 412)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 412)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 412)							int col1;
HXDLIN( 412)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN( 412)								col1 = c3;
            							}
HXDLIN( 412)							{
HXDLIN( 412)								int c4 = col1;
HXDLIN( 412)								bool _hx_tmp6;
HXDLIN( 412)								if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 412)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXDLIN( 412)									_hx_tmp6 = false;
            								}
HXDLIN( 412)								if (_hx_tmp6) {
HXDLIN( 412)									int location1;
HXDLIN( 412)									if (pixelImage->useVirtualPos) {
HXDLIN( 412)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 412)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 412)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 412)									int this25;
HXDLIN( 412)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN( 412)										this25 = this24;
            									}
HXDLIN( 412)									Float a11;
HXDLIN( 412)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 412)									if ((this26 == 0)) {
HXDLIN( 412)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float r11;
HXDLIN( 412)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 412)									if ((this27 == 0)) {
HXDLIN( 412)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float g11;
HXDLIN( 412)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 412)									if ((this28 == 0)) {
HXDLIN( 412)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float b12;
HXDLIN( 412)									int this29 = (this25 & 255);
HXDLIN( 412)									if ((this29 == 0)) {
HXDLIN( 412)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float a21;
HXDLIN( 412)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 412)									if ((this30 == 0)) {
HXDLIN( 412)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float r21;
HXDLIN( 412)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 412)									if ((this31 == 0)) {
HXDLIN( 412)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float g21;
HXDLIN( 412)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 412)									if ((this32 == 0)) {
HXDLIN( 412)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float b22;
HXDLIN( 412)									int this33 = (col1 & 255);
HXDLIN( 412)									if ((this33 == 0)) {
HXDLIN( 412)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN( 412)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 412)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 412)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 412)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 412)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 412)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 412)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 412)									{
HXDLIN( 412)										int _hx_tmp7;
HXDLIN( 412)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN( 412)											_hx_tmp7 = blended1;
            										}
HXDLIN( 412)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 412)									::Dynamic this34 = pixelImage->image;
HXDLIN( 412)									int index5;
HXDLIN( 412)									if (pixelImage->useVirtualPos) {
HXDLIN( 412)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXDLIN( 412)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 412)									int _hx_tmp8;
HXDLIN( 412)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 412)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXDLIN( 412)										_hx_tmp8 = c4;
            									}
HXDLIN( 412)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 412)		if ((hasHit == false)) {
HXDLIN( 412)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 412)			if (hasUndo) {
HXDLIN( 412)				v3->undoImage = undoImage;
HXDLIN( 412)				v3->undoX = xIter3->start;
HXDLIN( 412)				v3->undoY = yIter3->start;
            			}
HXDLIN( 412)			return v3;
            		}
            		else {
HXDLIN( 412)			return null();
            		}
HXDLIN( 412)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixel_Fields__obj,bottomRightImgTri,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::uvTriangle( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float au,Float av,Float bx,Float by,Float bu,Float bv,Float cx,Float cy,Float cu,Float cv,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_419_uvTriangle)
HXLINE( 421)		Float temp = au;
HXLINE( 422)		au = bu;
HXLINE( 423)		bu = temp;
HXLINE( 424)		temp = av;
HXLINE( 425)		av = bv;
HXLINE( 426)		bv = temp;
HXLINE( 428)		Float bcx = (bx - cx);
HXLINE( 429)		Float bcy = (by - cy);
HXLINE( 430)		Float acx = (ax - cx);
HXLINE( 431)		Float acy = (ay - cy);
HXLINE( 433)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 434)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 435)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 436)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 437)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 437)		if ((ax > bx)) {
HXLINE( 437)			if ((ax > cx)) {
HXLINE( 437)				int min;
HXDLIN( 437)				if ((bx > cx)) {
HXLINE( 437)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 437)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 437)				int ii_min = min;
HXDLIN( 437)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 437)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 437)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 437)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 437)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 437)			if ((bx > cx)) {
HXLINE( 437)				int min1;
HXDLIN( 437)				if ((ax > cx)) {
HXLINE( 437)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 437)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 437)				int ii_min2 = min1;
HXDLIN( 437)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 437)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 437)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 437)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 437)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 438)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 438)		if ((ay > by)) {
HXLINE( 438)			if ((ay > cy)) {
HXLINE( 438)				int min2;
HXDLIN( 438)				if ((by > cy)) {
HXLINE( 438)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 438)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 438)				int ii_min4 = min2;
HXDLIN( 438)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 438)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 438)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 438)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 438)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 438)			if ((by > cy)) {
HXLINE( 438)				int min3;
HXDLIN( 438)				if ((ay > cy)) {
HXLINE( 438)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 438)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 438)				int ii_min6 = min3;
HXDLIN( 438)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 438)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 438)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 438)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 438)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 439)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 440)		if (hasUndo) {
HXLINE( 441)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 441)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 441)			 ::Dynamic imageType = null();
HXDLIN( 441)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 441)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 441)			::Dynamic undoImage1;
HXDLIN( 441)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 441)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 441)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 441)					{
HXLINE( 441)						b->width = width;
HXDLIN( 441)						b->height = height;
HXDLIN( 441)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 441)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 441)						{
HXLINE( 441)							int len = b->length;
HXDLIN( 441)							int w = 0;
HXDLIN( 441)							{
HXLINE( 441)								int _g = 0;
HXDLIN( 441)								int _g1 = b->height;
HXDLIN( 441)								while((_g < _g1)){
HXLINE( 441)									_g = (_g + 1);
HXDLIN( 441)									int y = (_g - 1);
HXDLIN( 441)									{
HXLINE( 441)										int _g2 = 0;
HXDLIN( 441)										int _g3 = b->width;
HXDLIN( 441)										while((_g2 < _g3)){
HXLINE( 441)											_g2 = (_g2 + 1);
HXDLIN( 441)											int x = (_g2 - 1);
HXDLIN( 441)											{
HXLINE( 441)												w = (w + 1);
HXDLIN( 441)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 441)											{
HXLINE( 441)												w = (w + 1);
HXDLIN( 441)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 441)											{
HXLINE( 441)												w = (w + 1);
HXDLIN( 441)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 441)											{
HXLINE( 441)												w = (w + 1);
HXDLIN( 441)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 441)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 441)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 441)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 441)					{
HXLINE( 441)						a->width = width;
HXDLIN( 441)						a->height = height;
HXDLIN( 441)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 441)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 441)						{
HXLINE( 441)							int _g4 = 0;
HXDLIN( 441)							int _g5 = a->length;
HXDLIN( 441)							while((_g4 < _g5)){
HXLINE( 441)								_g4 = (_g4 + 1);
HXDLIN( 441)								int i = (_g4 - 1);
HXDLIN( 441)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 441)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 441)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 441)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 441)					{
HXLINE( 441)						b1->width = width;
HXDLIN( 441)						b1->height = height;
HXDLIN( 441)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 441)						int size = (b1->length * 4);
HXDLIN( 441)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 441)						{
HXLINE( 441)							int _g6 = 0;
HXDLIN( 441)							int _g7 = b1->length;
HXDLIN( 441)							while((_g6 < _g7)){
HXLINE( 441)								_g6 = (_g6 + 1);
HXDLIN( 441)								int i1 = (_g6 - 1);
HXDLIN( 441)								{
HXLINE( 441)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 441)									bool undoImage2;
HXDLIN( 441)									if ((i1 >= 0)) {
HXLINE( 441)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 441)										undoImage2 = false;
            									}
HXDLIN( 441)									if (undoImage2) {
HXLINE( 441)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 441)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 441)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 441)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 441)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 441)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 441)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 441)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 441)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 441)					{
HXLINE( 441)						v->width = width;
HXDLIN( 441)						v->height = height;
HXDLIN( 441)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 441)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 441)						{
HXLINE( 441)							int _g8 = 0;
HXDLIN( 441)							int _g9 = v->length;
HXDLIN( 441)							while((_g8 < _g9)){
HXLINE( 441)								_g8 = (_g8 + 1);
HXDLIN( 441)								int i2 = (_g8 - 1);
HXDLIN( 441)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 441)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 441)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 441)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 441)					{
HXLINE( 441)						b2->width = width;
HXDLIN( 441)						b2->height = height;
HXDLIN( 441)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 441)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 441)						{
HXLINE( 441)							int len1 = b2->length;
HXDLIN( 441)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 441)							if (::hx::IsNull( d->head )) {
HXLINE( 441)								int _g10 = 0;
HXDLIN( 441)								int _g11 = len1;
HXDLIN( 441)								while((_g10 < _g11)){
HXLINE( 441)									_g10 = (_g10 + 1);
HXDLIN( 441)									int i3 = (_g10 - 1);
HXDLIN( 441)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 441)								int _g12 = 0;
HXDLIN( 441)								int _g13 = len1;
HXDLIN( 441)								while((_g12 < _g13)){
HXLINE( 441)									_g12 = (_g12 + 1);
HXDLIN( 441)									int i4 = (_g12 - 1);
HXDLIN( 441)									{
HXLINE( 441)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 441)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 441)										{
HXLINE( 441)											int _g14 = 0;
HXDLIN( 441)											int _g15 = i4;
HXDLIN( 441)											while((_g14 < _g15)){
HXLINE( 441)												_g14 = (_g14 + 1);
HXDLIN( 441)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 441)										if (::hx::IsNull( prev )) {
HXLINE( 441)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 441)											l = null();
            										}
            										else {
HXLINE( 441)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 441)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 441)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 441)			this1->image = undoImage1;
HXDLIN( 441)			this1->width = width;
HXDLIN( 441)			this1->height = height;
HXDLIN( 441)			this1->imageType = ( (int)(imageType) );
HXDLIN( 441)			undoImage = this1;
HXLINE( 442)			{
HXLINE( 442)				int rectLeft = xIter3->start;
HXDLIN( 442)				int rectTop = yIter3->start;
HXDLIN( 442)				int rectRight = xIter3->max;
HXDLIN( 442)				bool forceClear = false;
HXDLIN( 442)				{
HXLINE( 442)					int _g16 = rectTop;
HXDLIN( 442)					int _g17 = yIter3->max;
HXDLIN( 442)					while((_g16 < _g17)){
HXLINE( 442)						_g16 = (_g16 + 1);
HXDLIN( 442)						int dy = (_g16 - 1);
HXDLIN( 442)						{
HXLINE( 442)							int _g18 = rectLeft;
HXDLIN( 442)							int _g19 = rectRight;
HXDLIN( 442)							while((_g18 < _g19)){
HXLINE( 442)								_g18 = (_g18 + 1);
HXDLIN( 442)								int dx = (_g18 - 1);
HXDLIN( 442)								::Dynamic this3 = pixelImage->image;
HXDLIN( 442)								int index;
HXDLIN( 442)								if (pixelImage->useVirtualPos) {
HXLINE( 442)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 442)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 442)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 442)								int col;
HXDLIN( 442)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 442)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 442)									col = c;
            								}
HXDLIN( 442)								bool _hx_tmp;
HXDLIN( 442)								if (pixelImage->useMask) {
HXLINE( 442)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 442)									_hx_tmp = false;
            								}
HXDLIN( 442)								if (_hx_tmp) {
HXLINE( 442)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 442)									::Dynamic this5 = this4->image;
HXDLIN( 442)									int index1;
HXDLIN( 442)									if (this4->useVirtualPos) {
HXLINE( 442)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 442)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 442)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 442)									int v1;
HXDLIN( 442)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 442)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 442)										v1 = c1;
            									}
HXDLIN( 442)									int maskPixel = v1;
HXDLIN( 442)									int this6 = col;
HXDLIN( 442)									if ((maskPixel == 0)) {
HXLINE( 442)										col = this6;
            									}
            									else {
HXLINE( 442)										Float m0;
HXDLIN( 442)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 442)										if ((this7 == 0)) {
HXLINE( 442)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float m1;
HXDLIN( 442)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 442)										if ((this8 == 0)) {
HXLINE( 442)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float m2;
HXDLIN( 442)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 442)										if ((this9 == 0)) {
HXLINE( 442)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float m3;
HXDLIN( 442)										int this10 = (maskPixel & 255);
HXDLIN( 442)										if ((this10 == 0)) {
HXLINE( 442)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 442)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 442)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 442)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 442)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 442)								if ((col != 0)) {
HXLINE( 442)									int x1 = (dx - rectLeft);
HXDLIN( 442)									int y1 = (dy - rectTop);
HXDLIN( 442)									int c2 = col;
HXDLIN( 442)									bool _hx_tmp1;
HXDLIN( 442)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 442)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 442)										_hx_tmp1 = false;
            									}
HXDLIN( 442)									if (_hx_tmp1) {
HXLINE( 442)										int location;
HXDLIN( 442)										if (undoImage->useVirtualPos) {
HXLINE( 442)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 442)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 442)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 442)										int this12;
HXDLIN( 442)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 442)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 442)											this12 = this11;
            										}
HXDLIN( 442)										Float a1;
HXDLIN( 442)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 442)										if ((this13 == 0)) {
HXLINE( 442)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float r1;
HXDLIN( 442)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 442)										if ((this14 == 0)) {
HXLINE( 442)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float g1;
HXDLIN( 442)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 442)										if ((this15 == 0)) {
HXLINE( 442)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float b11;
HXDLIN( 442)										int this16 = (this12 & 255);
HXDLIN( 442)										if ((this16 == 0)) {
HXLINE( 442)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float a2;
HXDLIN( 442)										int this17 = ((col >> 24) & 255);
HXDLIN( 442)										if ((this17 == 0)) {
HXLINE( 442)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float r2;
HXDLIN( 442)										int this18 = ((col >> 16) & 255);
HXDLIN( 442)										if ((this18 == 0)) {
HXLINE( 442)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float g2;
HXDLIN( 442)										int this19 = ((col >> 8) & 255);
HXDLIN( 442)										if ((this19 == 0)) {
HXLINE( 442)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float b21;
HXDLIN( 442)										int this20 = (col & 255);
HXDLIN( 442)										if ((this20 == 0)) {
HXLINE( 442)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 442)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 442)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 442)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 442)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 442)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 442)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 442)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 442)										{
HXLINE( 442)											int _hx_tmp2;
HXDLIN( 442)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 442)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 442)												_hx_tmp2 = blended;
            											}
HXDLIN( 442)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 442)										::Dynamic this21 = undoImage->image;
HXDLIN( 442)										int index2;
HXDLIN( 442)										if (undoImage->useVirtualPos) {
HXLINE( 442)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 442)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 442)										int _hx_tmp3;
HXDLIN( 442)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 442)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 442)											_hx_tmp3 = c2;
            										}
HXDLIN( 442)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 442)									if (forceClear) {
HXLINE( 442)										::Dynamic this22 = undoImage->image;
HXDLIN( 442)										int x2 = (dx - rectLeft);
HXDLIN( 442)										int y2 = (dy - rectTop);
HXDLIN( 442)										int index3;
HXDLIN( 442)										if (undoImage->useVirtualPos) {
HXLINE( 442)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 442)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 442)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 444)		{
HXLINE( 444)			int _g_min = xIter3->start;
HXDLIN( 444)			int _g_max = xIter3->max;
HXDLIN( 444)			while((_g_min < _g_max)){
HXLINE( 444)				_g_min = (_g_min + 1);
HXDLIN( 444)				int px = (_g_min - 1);
HXLINE( 445)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 446)				{
HXLINE( 446)					int _g_min1 = yIter3->start;
HXDLIN( 446)					int _g_max1 = yIter3->max;
HXDLIN( 446)					while((_g_min1 < _g_max1)){
HXLINE( 446)						_g_min1 = (_g_min1 + 1);
HXDLIN( 446)						int py = (_g_min1 - 1);
HXLINE( 447)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 448)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 449)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 450)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 451)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 452)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 453)						bool _hx_tmp4;
HXDLIN( 453)						bool _hx_tmp5;
HXDLIN( 453)						if ((ratioA >= 0)) {
HXLINE( 453)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 453)							_hx_tmp5 = false;
            						}
HXDLIN( 453)						if (_hx_tmp5) {
HXLINE( 453)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 453)							_hx_tmp4 = false;
            						}
HXDLIN( 453)						if (_hx_tmp4) {
HXLINE( 454)							Float u = (((au * ratioA) + (bu * ratioB)) + (cu * ratioC));
HXLINE( 455)							Float v2 = (((av * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXLINE( 456)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXLINE( 457)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXLINE( 458)							::Dynamic this23 = texture->image;
HXDLIN( 458)							int index4;
HXDLIN( 458)							if (texture->useVirtualPos) {
HXLINE( 458)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXLINE( 458)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 458)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 458)							int col1;
HXDLIN( 458)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 458)								col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 458)								col1 = c3;
            							}
HXLINE( 459)							{
HXLINE( 459)								int c4 = col1;
HXDLIN( 459)								bool _hx_tmp6;
HXDLIN( 459)								if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 459)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXLINE( 459)									_hx_tmp6 = false;
            								}
HXDLIN( 459)								if (_hx_tmp6) {
HXLINE( 459)									int location1;
HXDLIN( 459)									if (pixelImage->useVirtualPos) {
HXLINE( 459)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 459)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 459)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 459)									int this25;
HXDLIN( 459)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 459)										this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE( 459)										this25 = this24;
            									}
HXDLIN( 459)									Float a11;
HXDLIN( 459)									int this26 = ((this25 >> 24) & 255);
HXDLIN( 459)									if ((this26 == 0)) {
HXLINE( 459)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float r11;
HXDLIN( 459)									int this27 = ((this25 >> 16) & 255);
HXDLIN( 459)									if ((this27 == 0)) {
HXLINE( 459)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float g11;
HXDLIN( 459)									int this28 = ((this25 >> 8) & 255);
HXDLIN( 459)									if ((this28 == 0)) {
HXLINE( 459)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float b12;
HXDLIN( 459)									int this29 = (this25 & 255);
HXDLIN( 459)									if ((this29 == 0)) {
HXLINE( 459)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float a21;
HXDLIN( 459)									int this30 = ((col1 >> 24) & 255);
HXDLIN( 459)									if ((this30 == 0)) {
HXLINE( 459)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float r21;
HXDLIN( 459)									int this31 = ((col1 >> 16) & 255);
HXDLIN( 459)									if ((this31 == 0)) {
HXLINE( 459)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float g21;
HXDLIN( 459)									int this32 = ((col1 >> 8) & 255);
HXDLIN( 459)									if ((this32 == 0)) {
HXLINE( 459)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float b22;
HXDLIN( 459)									int this33 = (col1 & 255);
HXDLIN( 459)									if ((this33 == 0)) {
HXLINE( 459)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 459)										b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 459)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 459)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 459)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 459)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 459)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 459)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 459)									{
HXLINE( 459)										int _hx_tmp7;
HXDLIN( 459)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 459)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 459)											_hx_tmp7 = blended1;
            										}
HXDLIN( 459)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 459)									::Dynamic this34 = pixelImage->image;
HXDLIN( 459)									int index5;
HXDLIN( 459)									if (pixelImage->useVirtualPos) {
HXLINE( 459)										index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 459)										index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 459)									int _hx_tmp8;
HXDLIN( 459)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 459)										_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 459)										_hx_tmp8 = c4;
            									}
HXDLIN( 459)									::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 463)		if ((hasHit == false)) {
HXLINE( 464)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 465)			if (hasUndo) {
HXLINE( 466)				v3->undoImage = undoImage;
HXLINE( 467)				v3->undoX = xIter3->start;
HXLINE( 468)				v3->undoY = yIter3->start;
            			}
HXLINE( 470)			return v3;
            		}
            		else {
HXLINE( 472)			return null();
            		}
HXLINE( 463)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC17(TriPixel_Fields__obj,uvTriangle,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::uvTriangleSoft3( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float au,Float av,Float bx,Float by,Float bu,Float bv,Float cx,Float cy,Float cu,Float cv,Float soft3,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_482_uvTriangleSoft3)
HXLINE( 484)		Float temp = au;
HXLINE( 485)		au = bu;
HXLINE( 486)		bu = temp;
HXLINE( 487)		temp = av;
HXLINE( 488)		av = bv;
HXLINE( 489)		bv = temp;
HXLINE( 491)		Float bcx = (bx - cx);
HXLINE( 492)		Float bcy = (by - cy);
HXLINE( 493)		Float acx = (ax - cx);
HXLINE( 494)		Float acy = (ay - cy);
HXLINE( 496)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 497)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 498)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 499)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 500)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 500)		if ((ax > bx)) {
HXLINE( 500)			if ((ax > cx)) {
HXLINE( 500)				int min;
HXDLIN( 500)				if ((bx > cx)) {
HXLINE( 500)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 500)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 500)				int ii_min = min;
HXDLIN( 500)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 500)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 500)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 500)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 500)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 500)			if ((bx > cx)) {
HXLINE( 500)				int min1;
HXDLIN( 500)				if ((ax > cx)) {
HXLINE( 500)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 500)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 500)				int ii_min2 = min1;
HXDLIN( 500)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 500)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 500)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 500)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 500)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 501)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 501)		if ((ay > by)) {
HXLINE( 501)			if ((ay > cy)) {
HXLINE( 501)				int min2;
HXDLIN( 501)				if ((by > cy)) {
HXLINE( 501)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 501)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 501)				int ii_min4 = min2;
HXDLIN( 501)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 501)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 501)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 501)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 501)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 501)			if ((by > cy)) {
HXLINE( 501)				int min3;
HXDLIN( 501)				if ((ay > cy)) {
HXLINE( 501)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 501)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 501)				int ii_min6 = min3;
HXDLIN( 501)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 501)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 501)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 501)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 501)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 502)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 503)		if (hasUndo) {
HXLINE( 504)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 504)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 504)			 ::Dynamic imageType = null();
HXDLIN( 504)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 504)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 504)			::Dynamic undoImage1;
HXDLIN( 504)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 504)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 504)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 504)					{
HXLINE( 504)						b->width = width;
HXDLIN( 504)						b->height = height;
HXDLIN( 504)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 504)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 504)						{
HXLINE( 504)							int len = b->length;
HXDLIN( 504)							int w = 0;
HXDLIN( 504)							{
HXLINE( 504)								int _g = 0;
HXDLIN( 504)								int _g1 = b->height;
HXDLIN( 504)								while((_g < _g1)){
HXLINE( 504)									_g = (_g + 1);
HXDLIN( 504)									int y = (_g - 1);
HXDLIN( 504)									{
HXLINE( 504)										int _g2 = 0;
HXDLIN( 504)										int _g3 = b->width;
HXDLIN( 504)										while((_g2 < _g3)){
HXLINE( 504)											_g2 = (_g2 + 1);
HXDLIN( 504)											int x = (_g2 - 1);
HXDLIN( 504)											{
HXLINE( 504)												w = (w + 1);
HXDLIN( 504)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 504)											{
HXLINE( 504)												w = (w + 1);
HXDLIN( 504)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 504)											{
HXLINE( 504)												w = (w + 1);
HXDLIN( 504)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 504)											{
HXLINE( 504)												w = (w + 1);
HXDLIN( 504)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 504)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 504)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 504)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 504)					{
HXLINE( 504)						a->width = width;
HXDLIN( 504)						a->height = height;
HXDLIN( 504)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 504)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 504)						{
HXLINE( 504)							int _g4 = 0;
HXDLIN( 504)							int _g5 = a->length;
HXDLIN( 504)							while((_g4 < _g5)){
HXLINE( 504)								_g4 = (_g4 + 1);
HXDLIN( 504)								int i = (_g4 - 1);
HXDLIN( 504)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 504)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 504)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 504)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 504)					{
HXLINE( 504)						b1->width = width;
HXDLIN( 504)						b1->height = height;
HXDLIN( 504)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 504)						int size = (b1->length * 4);
HXDLIN( 504)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 504)						{
HXLINE( 504)							int _g6 = 0;
HXDLIN( 504)							int _g7 = b1->length;
HXDLIN( 504)							while((_g6 < _g7)){
HXLINE( 504)								_g6 = (_g6 + 1);
HXDLIN( 504)								int i1 = (_g6 - 1);
HXDLIN( 504)								{
HXLINE( 504)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 504)									bool undoImage2;
HXDLIN( 504)									if ((i1 >= 0)) {
HXLINE( 504)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 504)										undoImage2 = false;
            									}
HXDLIN( 504)									if (undoImage2) {
HXLINE( 504)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 504)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 504)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 504)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 504)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 504)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 504)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 504)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 504)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 504)					{
HXLINE( 504)						v->width = width;
HXDLIN( 504)						v->height = height;
HXDLIN( 504)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 504)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 504)						{
HXLINE( 504)							int _g8 = 0;
HXDLIN( 504)							int _g9 = v->length;
HXDLIN( 504)							while((_g8 < _g9)){
HXLINE( 504)								_g8 = (_g8 + 1);
HXDLIN( 504)								int i2 = (_g8 - 1);
HXDLIN( 504)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 504)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 504)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 504)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 504)					{
HXLINE( 504)						b2->width = width;
HXDLIN( 504)						b2->height = height;
HXDLIN( 504)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 504)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 504)						{
HXLINE( 504)							int len1 = b2->length;
HXDLIN( 504)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 504)							if (::hx::IsNull( d->head )) {
HXLINE( 504)								int _g10 = 0;
HXDLIN( 504)								int _g11 = len1;
HXDLIN( 504)								while((_g10 < _g11)){
HXLINE( 504)									_g10 = (_g10 + 1);
HXDLIN( 504)									int i3 = (_g10 - 1);
HXDLIN( 504)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 504)								int _g12 = 0;
HXDLIN( 504)								int _g13 = len1;
HXDLIN( 504)								while((_g12 < _g13)){
HXLINE( 504)									_g12 = (_g12 + 1);
HXDLIN( 504)									int i4 = (_g12 - 1);
HXDLIN( 504)									{
HXLINE( 504)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 504)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 504)										{
HXLINE( 504)											int _g14 = 0;
HXDLIN( 504)											int _g15 = i4;
HXDLIN( 504)											while((_g14 < _g15)){
HXLINE( 504)												_g14 = (_g14 + 1);
HXDLIN( 504)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 504)										if (::hx::IsNull( prev )) {
HXLINE( 504)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 504)											l = null();
            										}
            										else {
HXLINE( 504)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 504)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 504)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 504)			this1->image = undoImage1;
HXDLIN( 504)			this1->width = width;
HXDLIN( 504)			this1->height = height;
HXDLIN( 504)			this1->imageType = ( (int)(imageType) );
HXDLIN( 504)			undoImage = this1;
HXLINE( 505)			{
HXLINE( 505)				int rectLeft = xIter3->start;
HXDLIN( 505)				int rectTop = yIter3->start;
HXDLIN( 505)				int rectRight = xIter3->max;
HXDLIN( 505)				bool forceClear = false;
HXDLIN( 505)				{
HXLINE( 505)					int _g16 = rectTop;
HXDLIN( 505)					int _g17 = yIter3->max;
HXDLIN( 505)					while((_g16 < _g17)){
HXLINE( 505)						_g16 = (_g16 + 1);
HXDLIN( 505)						int dy = (_g16 - 1);
HXDLIN( 505)						{
HXLINE( 505)							int _g18 = rectLeft;
HXDLIN( 505)							int _g19 = rectRight;
HXDLIN( 505)							while((_g18 < _g19)){
HXLINE( 505)								_g18 = (_g18 + 1);
HXDLIN( 505)								int dx = (_g18 - 1);
HXDLIN( 505)								::Dynamic this3 = pixelImage->image;
HXDLIN( 505)								int index;
HXDLIN( 505)								if (pixelImage->useVirtualPos) {
HXLINE( 505)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 505)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 505)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 505)								int col;
HXDLIN( 505)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 505)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 505)									col = c;
            								}
HXDLIN( 505)								bool _hx_tmp;
HXDLIN( 505)								if (pixelImage->useMask) {
HXLINE( 505)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 505)									_hx_tmp = false;
            								}
HXDLIN( 505)								if (_hx_tmp) {
HXLINE( 505)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 505)									::Dynamic this5 = this4->image;
HXDLIN( 505)									int index1;
HXDLIN( 505)									if (this4->useVirtualPos) {
HXLINE( 505)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 505)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 505)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 505)									int v1;
HXDLIN( 505)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 505)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 505)										v1 = c1;
            									}
HXDLIN( 505)									int maskPixel = v1;
HXDLIN( 505)									int this6 = col;
HXDLIN( 505)									if ((maskPixel == 0)) {
HXLINE( 505)										col = this6;
            									}
            									else {
HXLINE( 505)										Float m0;
HXDLIN( 505)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 505)										if ((this7 == 0)) {
HXLINE( 505)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float m1;
HXDLIN( 505)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 505)										if ((this8 == 0)) {
HXLINE( 505)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float m2;
HXDLIN( 505)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 505)										if ((this9 == 0)) {
HXLINE( 505)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float m3;
HXDLIN( 505)										int this10 = (maskPixel & 255);
HXDLIN( 505)										if ((this10 == 0)) {
HXLINE( 505)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 505)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 505)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 505)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 505)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 505)								if ((col != 0)) {
HXLINE( 505)									int x1 = (dx - rectLeft);
HXDLIN( 505)									int y1 = (dy - rectTop);
HXDLIN( 505)									int c2 = col;
HXDLIN( 505)									bool _hx_tmp1;
HXDLIN( 505)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 505)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 505)										_hx_tmp1 = false;
            									}
HXDLIN( 505)									if (_hx_tmp1) {
HXLINE( 505)										int location;
HXDLIN( 505)										if (undoImage->useVirtualPos) {
HXLINE( 505)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 505)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 505)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 505)										int this12;
HXDLIN( 505)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 505)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 505)											this12 = this11;
            										}
HXDLIN( 505)										Float a1;
HXDLIN( 505)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 505)										if ((this13 == 0)) {
HXLINE( 505)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float r1;
HXDLIN( 505)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 505)										if ((this14 == 0)) {
HXLINE( 505)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float g1;
HXDLIN( 505)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 505)										if ((this15 == 0)) {
HXLINE( 505)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float b11;
HXDLIN( 505)										int this16 = (this12 & 255);
HXDLIN( 505)										if ((this16 == 0)) {
HXLINE( 505)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float a2;
HXDLIN( 505)										int this17 = ((col >> 24) & 255);
HXDLIN( 505)										if ((this17 == 0)) {
HXLINE( 505)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float r2;
HXDLIN( 505)										int this18 = ((col >> 16) & 255);
HXDLIN( 505)										if ((this18 == 0)) {
HXLINE( 505)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float g2;
HXDLIN( 505)										int this19 = ((col >> 8) & 255);
HXDLIN( 505)										if ((this19 == 0)) {
HXLINE( 505)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float b21;
HXDLIN( 505)										int this20 = (col & 255);
HXDLIN( 505)										if ((this20 == 0)) {
HXLINE( 505)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 505)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 505)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 505)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 505)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 505)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 505)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 505)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 505)										{
HXLINE( 505)											int _hx_tmp2;
HXDLIN( 505)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 505)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 505)												_hx_tmp2 = blended;
            											}
HXDLIN( 505)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 505)										::Dynamic this21 = undoImage->image;
HXDLIN( 505)										int index2;
HXDLIN( 505)										if (undoImage->useVirtualPos) {
HXLINE( 505)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 505)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 505)										int _hx_tmp3;
HXDLIN( 505)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 505)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 505)											_hx_tmp3 = c2;
            										}
HXDLIN( 505)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 505)									if (forceClear) {
HXLINE( 505)										::Dynamic this22 = undoImage->image;
HXDLIN( 505)										int x2 = (dx - rectLeft);
HXDLIN( 505)										int y2 = (dy - rectTop);
HXDLIN( 505)										int index3;
HXDLIN( 505)										if (undoImage->useVirtualPos) {
HXLINE( 505)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 505)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 505)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 507)		int a5 = 0;
HXLINE( 508)		int r3 = 0;
HXLINE( 509)		int g3 = 0;
HXLINE( 510)		int b4 = 0;
HXLINE( 511)		{
HXLINE( 511)			int _g_min = xIter3->start;
HXDLIN( 511)			int _g_max = xIter3->max;
HXDLIN( 511)			while((_g_min < _g_max)){
HXLINE( 511)				_g_min = (_g_min + 1);
HXDLIN( 511)				int px = (_g_min - 1);
HXLINE( 512)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 513)				{
HXLINE( 513)					int _g_min1 = yIter3->start;
HXDLIN( 513)					int _g_max1 = yIter3->max;
HXDLIN( 513)					while((_g_min1 < _g_max1)){
HXLINE( 513)						_g_min1 = (_g_min1 + 1);
HXDLIN( 513)						int py = (_g_min1 - 1);
HXLINE( 514)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 515)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 516)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 517)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 518)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 519)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 520)						bool _hx_tmp4;
HXDLIN( 520)						bool _hx_tmp5;
HXDLIN( 520)						if ((ratioA >= 0)) {
HXLINE( 520)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 520)							_hx_tmp5 = false;
            						}
HXDLIN( 520)						if (_hx_tmp5) {
HXLINE( 520)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 520)							_hx_tmp4 = false;
            						}
HXDLIN( 520)						if (_hx_tmp4) {
HXLINE( 521)							Float u = (((au * ratioA) + (bu * ratioB)) + (cu * ratioC));
HXLINE( 522)							Float v2 = (((av * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXLINE( 523)							int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXLINE( 524)							int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXLINE( 526)							::Dynamic this23 = texture->image;
HXDLIN( 526)							int index4;
HXDLIN( 526)							if (texture->useVirtualPos) {
HXLINE( 526)								index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            							}
            							else {
HXLINE( 526)								index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            							}
HXDLIN( 526)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 526)							int color;
HXDLIN( 526)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 526)								color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE( 526)								color = c3;
            							}
HXLINE( 527)							int aA = ((color >> 24) & 255);
HXLINE( 528)							int rA = ((color >> 16) & 255);
HXLINE( 529)							int gA = ((color >> 8) & 255);
HXLINE( 530)							int bA = (color & 255);
HXLINE( 532)							Float min4;
HXDLIN( 532)							if ((ratioA < ratioB)) {
HXLINE( 532)								min4 = ratioA;
            							}
            							else {
HXLINE( 532)								min4 = ratioB;
            							}
HXLINE( 533)							if (!((min4 < ratioC))) {
HXLINE( 533)								min4 = ratioC;
            							}
HXLINE( 534)							Float max;
HXDLIN( 534)							if ((ratioA > ratioB)) {
HXLINE( 534)								max = ratioA;
            							}
            							else {
HXLINE( 534)								max = ratioB;
            							}
HXLINE( 535)							if (!((max > ratioC))) {
HXLINE( 535)								max = ratioC;
            							}
HXLINE( 536)							max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 537)							Float min5;
HXDLIN( 537)							if ((min4 < max)) {
HXLINE( 537)								min5 = min4;
            							}
            							else {
HXLINE( 537)								min5 = ((max + min4) / ( (Float)(2) ));
            							}
HXLINE( 539)							int i6 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min5));
HXDLIN( 539)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 539)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 539)							a5 = i6;
HXLINE( 540)							int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 540)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 540)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 540)							r3 = i7;
HXLINE( 541)							int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 541)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 541)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 541)							g3 = i8;
HXLINE( 542)							int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 542)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 542)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 542)							b4 = i9;
HXLINE( 544)							{
HXLINE( 544)								int location1;
HXDLIN( 544)								if (pixelImage->useVirtualPos) {
HXLINE( 544)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 544)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 544)								bool _hx_tmp6;
HXDLIN( 544)								if (pixelImage->transparent) {
HXLINE( 544)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 544)									_hx_tmp6 = false;
            								}
HXDLIN( 544)								if (_hx_tmp6) {
HXLINE( 544)									int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 544)									int old;
HXDLIN( 544)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)										old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE( 544)										old = this24;
            									}
HXDLIN( 544)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 544)									Float a11;
HXDLIN( 544)									int this25 = ((old >> 24) & 255);
HXDLIN( 544)									if ((this25 == 0)) {
HXLINE( 544)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float r11;
HXDLIN( 544)									int this26 = ((old >> 16) & 255);
HXDLIN( 544)									if ((this26 == 0)) {
HXLINE( 544)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float g11;
HXDLIN( 544)									int this27 = ((old >> 8) & 255);
HXDLIN( 544)									if ((this27 == 0)) {
HXLINE( 544)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float b12;
HXDLIN( 544)									int this28 = (old & 255);
HXDLIN( 544)									if ((this28 == 0)) {
HXLINE( 544)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float a21;
HXDLIN( 544)									int this29 = ((rhs >> 24) & 255);
HXDLIN( 544)									if ((this29 == 0)) {
HXLINE( 544)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float r21;
HXDLIN( 544)									int this30 = ((rhs >> 16) & 255);
HXDLIN( 544)									if ((this30 == 0)) {
HXLINE( 544)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float g21;
HXDLIN( 544)									int this31 = ((rhs >> 8) & 255);
HXDLIN( 544)									if ((this31 == 0)) {
HXLINE( 544)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float b22;
HXDLIN( 544)									int this32 = (rhs & 255);
HXDLIN( 544)									if ((this32 == 0)) {
HXLINE( 544)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 544)										b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 544)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 544)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 544)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 544)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 544)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 544)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 544)									{
HXLINE( 544)										int _hx_tmp7;
HXDLIN( 544)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 544)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 544)											_hx_tmp7 = blended1;
            										}
HXDLIN( 544)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 544)									int value;
HXDLIN( 544)									if (pixelImage->isLittle) {
HXLINE( 544)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 544)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 544)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 548)		if ((hasHit == false)) {
HXLINE( 549)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 550)			if (hasUndo) {
HXLINE( 551)				v3->undoImage = undoImage;
HXLINE( 552)				v3->undoX = xIter3->start;
HXLINE( 553)				v3->undoY = yIter3->start;
            			}
HXLINE( 555)			return v3;
            		}
            		else {
HXLINE( 557)			return null();
            		}
HXLINE( 548)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC18(TriPixel_Fields__obj,uvTriangleSoft3,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriTwoSoft( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_hasHit){
            		Float softC = __o_softC.Default(10);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_568_fillTriTwoSoft)
HXLINE( 571)		Float ex = ((bx + cx) / ( (Float)(2) ));
HXLINE( 572)		Float ey = ((by + cy) / ( (Float)(2) ));
HXLINE( 574)		bool hasUndo = false;
HXDLIN( 574)		int aA = ((color >> 24) & 255);
HXDLIN( 574)		int rA = ((color >> 16) & 255);
HXDLIN( 574)		int gA = ((color >> 8) & 255);
HXDLIN( 574)		int bA = (color & 255);
HXDLIN( 574)		Float bcx = (ax - bx);
HXDLIN( 574)		Float bcy = (ay - by);
HXDLIN( 574)		Float acx = (ex - bx);
HXDLIN( 574)		Float acy = (ey - by);
HXDLIN( 574)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 574)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 574)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 574)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 574)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 574)		if ((ex > ax)) {
HXLINE( 574)			if ((ex > bx)) {
HXLINE( 574)				int min;
HXDLIN( 574)				if ((ax > bx)) {
HXLINE( 574)					min = ::Math_obj::floor(bx);
            				}
            				else {
HXLINE( 574)					min = ::Math_obj::floor(ax);
            				}
HXDLIN( 574)				int ii_min = min;
HXDLIN( 574)				int ii_max = ::Math_obj::ceil(ex);
HXDLIN( 574)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 574)				int ii_min1 = ::Math_obj::floor(ax);
HXDLIN( 574)				int ii_max1 = ::Math_obj::ceil(bx);
HXDLIN( 574)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 574)			if ((ax > bx)) {
HXLINE( 574)				int min1;
HXDLIN( 574)				if ((ex > bx)) {
HXLINE( 574)					min1 = ::Math_obj::floor(bx);
            				}
            				else {
HXLINE( 574)					min1 = ::Math_obj::ceil(ex);
            				}
HXDLIN( 574)				int ii_min2 = min1;
HXDLIN( 574)				int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN( 574)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 574)				int ii_min3 = ::Math_obj::floor(ex);
HXDLIN( 574)				int ii_max3 = ::Math_obj::ceil(bx);
HXDLIN( 574)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 574)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 574)		if ((ey > ay)) {
HXLINE( 574)			if ((ey > by)) {
HXLINE( 574)				int min2;
HXDLIN( 574)				if ((ay > by)) {
HXLINE( 574)					min2 = ::Math_obj::floor(by);
            				}
            				else {
HXLINE( 574)					min2 = ::Math_obj::floor(ay);
            				}
HXDLIN( 574)				int ii_min4 = min2;
HXDLIN( 574)				int ii_max4 = ::Math_obj::ceil(ey);
HXDLIN( 574)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 574)				int ii_min5 = ::Math_obj::floor(ay);
HXDLIN( 574)				int ii_max5 = ::Math_obj::ceil(by);
HXDLIN( 574)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 574)			if ((ay > by)) {
HXLINE( 574)				int min3;
HXDLIN( 574)				if ((ey > by)) {
HXLINE( 574)					min3 = ::Math_obj::floor(by);
            				}
            				else {
HXLINE( 574)					min3 = ::Math_obj::ceil(ey);
            				}
HXDLIN( 574)				int ii_min6 = min3;
HXDLIN( 574)				int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN( 574)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 574)				int ii_min7 = ::Math_obj::floor(ey);
HXDLIN( 574)				int ii_max7 = ::Math_obj::ceil(by);
HXDLIN( 574)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 574)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 574)		if (hasUndo) {
HXLINE( 574)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 574)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 574)			 ::Dynamic imageType = null();
HXDLIN( 574)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 574)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 574)			::Dynamic undoImage1;
HXDLIN( 574)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 574)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 574)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 574)					{
HXLINE( 574)						b->width = width;
HXDLIN( 574)						b->height = height;
HXDLIN( 574)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 574)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 574)						{
HXLINE( 574)							int len = b->length;
HXDLIN( 574)							int w = 0;
HXDLIN( 574)							{
HXLINE( 574)								int _g = 0;
HXDLIN( 574)								int _g1 = b->height;
HXDLIN( 574)								while((_g < _g1)){
HXLINE( 574)									_g = (_g + 1);
HXDLIN( 574)									int y = (_g - 1);
HXDLIN( 574)									{
HXLINE( 574)										int _g2 = 0;
HXDLIN( 574)										int _g3 = b->width;
HXDLIN( 574)										while((_g2 < _g3)){
HXLINE( 574)											_g2 = (_g2 + 1);
HXDLIN( 574)											int x = (_g2 - 1);
HXDLIN( 574)											{
HXLINE( 574)												w = (w + 1);
HXDLIN( 574)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 574)											{
HXLINE( 574)												w = (w + 1);
HXDLIN( 574)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 574)											{
HXLINE( 574)												w = (w + 1);
HXDLIN( 574)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 574)											{
HXLINE( 574)												w = (w + 1);
HXDLIN( 574)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 574)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 574)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 574)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 574)					{
HXLINE( 574)						a->width = width;
HXDLIN( 574)						a->height = height;
HXDLIN( 574)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 574)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 574)						{
HXLINE( 574)							int _g4 = 0;
HXDLIN( 574)							int _g5 = a->length;
HXDLIN( 574)							while((_g4 < _g5)){
HXLINE( 574)								_g4 = (_g4 + 1);
HXDLIN( 574)								int i = (_g4 - 1);
HXDLIN( 574)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 574)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 574)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 574)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 574)					{
HXLINE( 574)						b1->width = width;
HXDLIN( 574)						b1->height = height;
HXDLIN( 574)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 574)						int size = (b1->length * 4);
HXDLIN( 574)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 574)						{
HXLINE( 574)							int _g6 = 0;
HXDLIN( 574)							int _g7 = b1->length;
HXDLIN( 574)							while((_g6 < _g7)){
HXLINE( 574)								_g6 = (_g6 + 1);
HXDLIN( 574)								int i1 = (_g6 - 1);
HXDLIN( 574)								{
HXLINE( 574)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 574)									bool undoImage2;
HXDLIN( 574)									if ((i1 >= 0)) {
HXLINE( 574)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 574)										undoImage2 = false;
            									}
HXDLIN( 574)									if (undoImage2) {
HXLINE( 574)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 574)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 574)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 574)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 574)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 574)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 574)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 574)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 574)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 574)					{
HXLINE( 574)						v->width = width;
HXDLIN( 574)						v->height = height;
HXDLIN( 574)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 574)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 574)						{
HXLINE( 574)							int _g8 = 0;
HXDLIN( 574)							int _g9 = v->length;
HXDLIN( 574)							while((_g8 < _g9)){
HXLINE( 574)								_g8 = (_g8 + 1);
HXDLIN( 574)								int i2 = (_g8 - 1);
HXDLIN( 574)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 574)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 574)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 574)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 574)					{
HXLINE( 574)						b2->width = width;
HXDLIN( 574)						b2->height = height;
HXDLIN( 574)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 574)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 574)						{
HXLINE( 574)							int len1 = b2->length;
HXDLIN( 574)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 574)							if (::hx::IsNull( d->head )) {
HXLINE( 574)								int _g10 = 0;
HXDLIN( 574)								int _g11 = len1;
HXDLIN( 574)								while((_g10 < _g11)){
HXLINE( 574)									_g10 = (_g10 + 1);
HXDLIN( 574)									int i3 = (_g10 - 1);
HXDLIN( 574)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 574)								int _g12 = 0;
HXDLIN( 574)								int _g13 = len1;
HXDLIN( 574)								while((_g12 < _g13)){
HXLINE( 574)									_g12 = (_g12 + 1);
HXDLIN( 574)									int i4 = (_g12 - 1);
HXDLIN( 574)									{
HXLINE( 574)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 574)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 574)										{
HXLINE( 574)											int _g14 = 0;
HXDLIN( 574)											int _g15 = i4;
HXDLIN( 574)											while((_g14 < _g15)){
HXLINE( 574)												_g14 = (_g14 + 1);
HXDLIN( 574)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 574)										if (::hx::IsNull( prev )) {
HXLINE( 574)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 574)											l = null();
            										}
            										else {
HXLINE( 574)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 574)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 574)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 574)			this1->image = undoImage1;
HXDLIN( 574)			this1->width = width;
HXDLIN( 574)			this1->height = height;
HXDLIN( 574)			this1->imageType = ( (int)(imageType) );
HXDLIN( 574)			undoImage = this1;
HXDLIN( 574)			{
HXLINE( 574)				int rectLeft = xIter3->start;
HXDLIN( 574)				int rectTop = yIter3->start;
HXDLIN( 574)				int rectRight = xIter3->max;
HXDLIN( 574)				bool forceClear = false;
HXDLIN( 574)				{
HXLINE( 574)					int _g16 = rectTop;
HXDLIN( 574)					int _g17 = yIter3->max;
HXDLIN( 574)					while((_g16 < _g17)){
HXLINE( 574)						_g16 = (_g16 + 1);
HXDLIN( 574)						int dy = (_g16 - 1);
HXDLIN( 574)						{
HXLINE( 574)							int _g18 = rectLeft;
HXDLIN( 574)							int _g19 = rectRight;
HXDLIN( 574)							while((_g18 < _g19)){
HXLINE( 574)								_g18 = (_g18 + 1);
HXDLIN( 574)								int dx = (_g18 - 1);
HXDLIN( 574)								::Dynamic this3 = pixelImage->image;
HXDLIN( 574)								int index;
HXDLIN( 574)								if (pixelImage->useVirtualPos) {
HXLINE( 574)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 574)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 574)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 574)								int col;
HXDLIN( 574)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 574)									col = c;
            								}
HXDLIN( 574)								bool _hx_tmp;
HXDLIN( 574)								if (pixelImage->useMask) {
HXLINE( 574)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 574)									_hx_tmp = false;
            								}
HXDLIN( 574)								if (_hx_tmp) {
HXLINE( 574)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 574)									::Dynamic this5 = this4->image;
HXDLIN( 574)									int index1;
HXDLIN( 574)									if (this4->useVirtualPos) {
HXLINE( 574)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 574)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 574)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 574)									int v1;
HXDLIN( 574)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 574)										v1 = c1;
            									}
HXDLIN( 574)									int maskPixel = v1;
HXDLIN( 574)									int this6 = col;
HXDLIN( 574)									if ((maskPixel == 0)) {
HXLINE( 574)										col = this6;
            									}
            									else {
HXLINE( 574)										Float m0;
HXDLIN( 574)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 574)										if ((this7 == 0)) {
HXLINE( 574)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float m1;
HXDLIN( 574)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 574)										if ((this8 == 0)) {
HXLINE( 574)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float m2;
HXDLIN( 574)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 574)										if ((this9 == 0)) {
HXLINE( 574)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float m3;
HXDLIN( 574)										int this10 = (maskPixel & 255);
HXDLIN( 574)										if ((this10 == 0)) {
HXLINE( 574)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 574)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 574)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 574)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 574)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 574)								if ((col != 0)) {
HXLINE( 574)									int x1 = (dx - rectLeft);
HXDLIN( 574)									int y1 = (dy - rectTop);
HXDLIN( 574)									int c2 = col;
HXDLIN( 574)									bool _hx_tmp1;
HXDLIN( 574)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 574)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 574)										_hx_tmp1 = false;
            									}
HXDLIN( 574)									if (_hx_tmp1) {
HXLINE( 574)										int location;
HXDLIN( 574)										if (undoImage->useVirtualPos) {
HXLINE( 574)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 574)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 574)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 574)										int this12;
HXDLIN( 574)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 574)											this12 = this11;
            										}
HXDLIN( 574)										Float a1;
HXDLIN( 574)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 574)										if ((this13 == 0)) {
HXLINE( 574)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float r1;
HXDLIN( 574)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 574)										if ((this14 == 0)) {
HXLINE( 574)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float g1;
HXDLIN( 574)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 574)										if ((this15 == 0)) {
HXLINE( 574)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float b11;
HXDLIN( 574)										int this16 = (this12 & 255);
HXDLIN( 574)										if ((this16 == 0)) {
HXLINE( 574)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float a2;
HXDLIN( 574)										int this17 = ((col >> 24) & 255);
HXDLIN( 574)										if ((this17 == 0)) {
HXLINE( 574)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float r2;
HXDLIN( 574)										int this18 = ((col >> 16) & 255);
HXDLIN( 574)										if ((this18 == 0)) {
HXLINE( 574)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float g2;
HXDLIN( 574)										int this19 = ((col >> 8) & 255);
HXDLIN( 574)										if ((this19 == 0)) {
HXLINE( 574)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float b21;
HXDLIN( 574)										int this20 = (col & 255);
HXDLIN( 574)										if ((this20 == 0)) {
HXLINE( 574)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 574)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 574)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 574)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 574)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 574)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 574)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 574)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 574)										{
HXLINE( 574)											int _hx_tmp2;
HXDLIN( 574)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 574)												_hx_tmp2 = blended;
            											}
HXDLIN( 574)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 574)										::Dynamic this21 = undoImage->image;
HXDLIN( 574)										int index2;
HXDLIN( 574)										if (undoImage->useVirtualPos) {
HXLINE( 574)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 574)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 574)										int _hx_tmp3;
HXDLIN( 574)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 574)											_hx_tmp3 = c2;
            										}
HXDLIN( 574)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 574)									if (forceClear) {
HXLINE( 574)										::Dynamic this22 = undoImage->image;
HXDLIN( 574)										int x2 = (dx - rectLeft);
HXDLIN( 574)										int y2 = (dy - rectTop);
HXDLIN( 574)										int index3;
HXDLIN( 574)										if (undoImage->useVirtualPos) {
HXLINE( 574)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 574)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 574)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 574)		bool found = false;
HXDLIN( 574)		{
HXLINE( 574)			int _g_min = xIter3->start;
HXDLIN( 574)			int _g_max = xIter3->max;
HXDLIN( 574)			while((_g_min < _g_max)){
HXLINE( 574)				_g_min = (_g_min + 1);
HXDLIN( 574)				int px = (_g_min - 1);
HXDLIN( 574)				Float pcx = (( (Float)(px) ) - bx);
HXLINE( 619)				found = false;
HXLINE( 574)				{
HXLINE( 574)					int _g_min1 = yIter3->start;
HXDLIN( 574)					int _g_max1 = yIter3->max;
HXDLIN( 574)					while((_g_min1 < _g_max1)){
HXLINE( 574)						_g_min1 = (_g_min1 + 1);
HXDLIN( 574)						int py = (_g_min1 - 1);
HXDLIN( 574)						Float pcy = (( (Float)(py) ) - by);
HXDLIN( 574)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 574)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 574)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 574)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 574)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 574)						bool _hx_tmp4;
HXDLIN( 574)						bool _hx_tmp5;
HXDLIN( 574)						if ((ratioA >= 0)) {
HXLINE( 574)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 574)							_hx_tmp5 = false;
            						}
HXDLIN( 574)						if (_hx_tmp5) {
HXLINE( 574)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 574)							_hx_tmp4 = false;
            						}
HXDLIN( 574)						if (_hx_tmp4) {
HXLINE( 574)							int i6 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 574)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 574)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 574)							int a5 = i6;
HXDLIN( 574)							int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 574)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 574)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 574)							int r3 = i7;
HXDLIN( 574)							int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 574)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 574)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 574)							int g3 = i8;
HXDLIN( 574)							int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 574)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 574)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 574)							int b4 = i9;
HXDLIN( 574)							{
HXLINE( 574)								int location1;
HXDLIN( 574)								if (pixelImage->useVirtualPos) {
HXLINE( 574)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 574)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 574)								bool _hx_tmp6;
HXDLIN( 574)								if (pixelImage->transparent) {
HXLINE( 574)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 574)									_hx_tmp6 = false;
            								}
HXDLIN( 574)								if (_hx_tmp6) {
HXLINE( 574)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 574)									int old;
HXDLIN( 574)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 574)										old = this23;
            									}
HXDLIN( 574)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 574)									Float a11;
HXDLIN( 574)									int this24 = ((old >> 24) & 255);
HXDLIN( 574)									if ((this24 == 0)) {
HXLINE( 574)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float r11;
HXDLIN( 574)									int this25 = ((old >> 16) & 255);
HXDLIN( 574)									if ((this25 == 0)) {
HXLINE( 574)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float g11;
HXDLIN( 574)									int this26 = ((old >> 8) & 255);
HXDLIN( 574)									if ((this26 == 0)) {
HXLINE( 574)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float b12;
HXDLIN( 574)									int this27 = (old & 255);
HXDLIN( 574)									if ((this27 == 0)) {
HXLINE( 574)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float a21;
HXDLIN( 574)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 574)									if ((this28 == 0)) {
HXLINE( 574)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float r21;
HXDLIN( 574)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 574)									if ((this29 == 0)) {
HXLINE( 574)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float g21;
HXDLIN( 574)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 574)									if ((this30 == 0)) {
HXLINE( 574)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float b22;
HXDLIN( 574)									int this31 = (rhs & 255);
HXDLIN( 574)									if ((this31 == 0)) {
HXLINE( 574)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 574)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 574)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 574)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 574)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 574)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 574)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 574)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 574)									{
HXLINE( 574)										int _hx_tmp7;
HXDLIN( 574)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 574)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 574)											_hx_tmp7 = blended1;
            										}
HXDLIN( 574)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 574)									int value;
HXDLIN( 574)									if (pixelImage->isLittle) {
HXLINE( 574)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 574)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 574)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
HXLINE( 633)							found = true;
            						}
            						else {
HXLINE( 574)							if (found) {
HXLINE( 574)								goto _hx_goto_193;
            							}
            						}
            					}
            					_hx_goto_193:;
            				}
            			}
            		}
HXDLIN( 574)		 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 574)		 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 574)		int v_undoY;
HXDLIN( 574)		int v_undoX;
HXDLIN( 574)		Float v_ty;
HXDLIN( 574)		Float v_tx;
HXDLIN( 574)		Float v_t0;
HXDLIN( 574)		Float v_sy;
HXDLIN( 574)		Float v_sx;
HXDLIN( 574)		Float v_s0;
HXDLIN( 574)		Float v_A;
HXDLIN( 574)		Float ax1 = ex;
HXDLIN( 574)		Float ay1 = ey;
HXDLIN( 574)		 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 574)		Float bx1 = ax;
HXDLIN( 574)		Float by1 = ay;
HXDLIN( 574)		Float cx1 = bx;
HXDLIN( 574)		Float cy1 = by;
HXDLIN( 574)		bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN( 574)		if (!(adjustWinding)) {
HXLINE( 574)			Float bx_ = bx1;
HXDLIN( 574)			Float by_ = by1;
HXLINE(  24)			bx1 = cx1;
HXLINE(  25)			by1 = cy1;
HXLINE(  26)			cx1 = bx_;
HXLINE(  27)			cy1 = by_;
            		}
HXLINE( 574)		Float v_ax = ax1;
HXDLIN( 574)		Float v_ay = ay1;
HXDLIN( 574)		Float v_bx = bx1;
HXDLIN( 574)		Float v_by = by1;
HXDLIN( 574)		Float v_cx = cx1;
HXDLIN( 574)		Float v_cy = cy1;
HXDLIN( 574)		bool v_preCalculated = true;
HXDLIN( 574)		{
HXLINE( 574)			v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 574)			v_sx = (v_cy - v_ay);
HXDLIN( 574)			v_sy = (v_ax - v_cx);
HXDLIN( 574)			v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 574)			v_tx = (v_ay - v_by);
HXDLIN( 574)			v_ty = (v_bx - v_ax);
HXDLIN( 574)			v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 574)			Float a7 = v_ax;
HXDLIN( 574)			Float b6 = v_bx;
HXDLIN( 574)			Float c3 = v_cx;
HXDLIN( 574)			if ((a7 > b6)) {
HXLINE( 574)				if ((a7 > c3)) {
HXLINE( 574)					int min4;
HXDLIN( 574)					if ((b6 > c3)) {
HXLINE( 574)						min4 = ::Math_obj::floor(c3);
            					}
            					else {
HXLINE( 574)						min4 = ::Math_obj::floor(b6);
            					}
HXDLIN( 574)					int ii_min8 = min4;
HXDLIN( 574)					int ii_max8 = ::Math_obj::ceil(a7);
HXDLIN( 574)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 574)					int ii_min9 = ::Math_obj::floor(b6);
HXDLIN( 574)					int ii_max9 = ::Math_obj::ceil(c3);
HXDLIN( 574)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 574)				if ((b6 > c3)) {
HXLINE( 574)					int min5;
HXDLIN( 574)					if ((a7 > c3)) {
HXLINE( 574)						min5 = ::Math_obj::floor(c3);
            					}
            					else {
HXLINE( 574)						min5 = ::Math_obj::ceil(a7);
            					}
HXDLIN( 574)					int ii_min10 = min5;
HXDLIN( 574)					int ii_max10 = ::Math_obj::ceil(b6);
HXDLIN( 574)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 574)					int ii_min11 = ::Math_obj::floor(a7);
HXDLIN( 574)					int ii_max11 = ::Math_obj::ceil(c3);
HXDLIN( 574)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 574)			Float a8 = v_ay;
HXDLIN( 574)			Float b7 = v_by;
HXDLIN( 574)			Float c4 = v_cy;
HXDLIN( 574)			if ((a8 > b7)) {
HXLINE( 574)				if ((a8 > c4)) {
HXLINE( 574)					int min6;
HXDLIN( 574)					if ((b7 > c4)) {
HXLINE( 574)						min6 = ::Math_obj::floor(c4);
            					}
            					else {
HXLINE( 574)						min6 = ::Math_obj::floor(b7);
            					}
HXDLIN( 574)					int ii_min12 = min6;
HXDLIN( 574)					int ii_max12 = ::Math_obj::ceil(a8);
HXDLIN( 574)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 574)					int ii_min13 = ::Math_obj::floor(b7);
HXDLIN( 574)					int ii_max13 = ::Math_obj::ceil(c4);
HXDLIN( 574)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 574)				if ((b7 > c4)) {
HXLINE( 574)					int min7;
HXDLIN( 574)					if ((a8 > c4)) {
HXLINE( 574)						min7 = ::Math_obj::floor(c4);
            					}
            					else {
HXLINE( 574)						min7 = ::Math_obj::ceil(a8);
            					}
HXDLIN( 574)					int ii_min14 = min7;
HXDLIN( 574)					int ii_max14 = ::Math_obj::ceil(b7);
HXDLIN( 574)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 574)					int ii_min15 = ::Math_obj::floor(a8);
HXDLIN( 574)					int ii_max15 = ::Math_obj::ceil(c4);
HXDLIN( 574)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
            		}
HXDLIN( 574)		if (hasUndo) {
HXLINE( 574)			v_undoImage = undoImage;
HXDLIN( 574)			v_undoX = xIter3->start;
HXDLIN( 574)			v_undoY = yIter3->start;
            		}
HXLINE( 575)		bool hasUndo1 = false;
HXDLIN( 575)		int aA1 = ((color >> 24) & 255);
HXDLIN( 575)		int rA1 = ((color >> 16) & 255);
HXDLIN( 575)		int gA1 = ((color >> 8) & 255);
HXDLIN( 575)		int bA1 = (color & 255);
HXDLIN( 575)		Float bcx1 = (bx - cx);
HXDLIN( 575)		Float bcy1 = (by - cy);
HXDLIN( 575)		Float acx1 = (ex - cx);
HXDLIN( 575)		Float acy1 = (ey - cy);
HXDLIN( 575)		Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 575)		Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 575)		Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 575)		Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 575)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 575)		if ((ex > bx)) {
HXLINE( 575)			if ((ex > cx)) {
HXLINE( 575)				int min8;
HXDLIN( 575)				if ((bx > cx)) {
HXLINE( 575)					min8 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 575)					min8 = ::Math_obj::floor(bx);
            				}
HXDLIN( 575)				int ii_min16 = min8;
HXDLIN( 575)				int ii_max16 = ::Math_obj::ceil(ex);
HXDLIN( 575)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXLINE( 575)				int ii_min17 = ::Math_obj::floor(bx);
HXDLIN( 575)				int ii_max17 = ::Math_obj::ceil(cx);
HXDLIN( 575)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXLINE( 575)			if ((bx > cx)) {
HXLINE( 575)				int min9;
HXDLIN( 575)				if ((ex > cx)) {
HXLINE( 575)					min9 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 575)					min9 = ::Math_obj::ceil(ex);
            				}
HXDLIN( 575)				int ii_min18 = min9;
HXDLIN( 575)				int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN( 575)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXLINE( 575)				int ii_min19 = ::Math_obj::floor(ex);
HXDLIN( 575)				int ii_max19 = ::Math_obj::ceil(cx);
HXDLIN( 575)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN( 575)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 575)		if ((ey > by)) {
HXLINE( 575)			if ((ey > cy)) {
HXLINE( 575)				int min10;
HXDLIN( 575)				if ((by > cy)) {
HXLINE( 575)					min10 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 575)					min10 = ::Math_obj::floor(by);
            				}
HXDLIN( 575)				int ii_min20 = min10;
HXDLIN( 575)				int ii_max20 = ::Math_obj::ceil(ey);
HXDLIN( 575)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXLINE( 575)				int ii_min21 = ::Math_obj::floor(by);
HXDLIN( 575)				int ii_max21 = ::Math_obj::ceil(cy);
HXDLIN( 575)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXLINE( 575)			if ((by > cy)) {
HXLINE( 575)				int min11;
HXDLIN( 575)				if ((ey > cy)) {
HXLINE( 575)					min11 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 575)					min11 = ::Math_obj::ceil(ey);
            				}
HXDLIN( 575)				int ii_min22 = min11;
HXDLIN( 575)				int ii_max22 = ::Math_obj::ceil(by);
HXDLIN( 575)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXLINE( 575)				int ii_min23 = ::Math_obj::floor(ey);
HXDLIN( 575)				int ii_max23 = ::Math_obj::ceil(cy);
HXDLIN( 575)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN( 575)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 575)		if (hasUndo1) {
HXLINE( 575)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 575)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 575)			 ::Dynamic imageType1 = null();
HXDLIN( 575)			 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 575)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 575)			::Dynamic undoImage4;
HXDLIN( 575)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE( 575)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 575)					 ::iterMagic::BytesImg b8 = byt1;
HXDLIN( 575)					{
HXLINE( 575)						b8->width = width1;
HXDLIN( 575)						b8->height = height1;
HXDLIN( 575)						b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 575)						b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN( 575)						{
HXLINE( 575)							int len2 = b8->length;
HXDLIN( 575)							int w1 = 0;
HXDLIN( 575)							{
HXLINE( 575)								int _g20 = 0;
HXDLIN( 575)								int _g21 = b8->height;
HXDLIN( 575)								while((_g20 < _g21)){
HXLINE( 575)									_g20 = (_g20 + 1);
HXDLIN( 575)									int y3 = (_g20 - 1);
HXDLIN( 575)									{
HXLINE( 575)										int _g22 = 0;
HXDLIN( 575)										int _g23 = b8->width;
HXDLIN( 575)										while((_g22 < _g23)){
HXLINE( 575)											_g22 = (_g22 + 1);
HXDLIN( 575)											int x3 = (_g22 - 1);
HXDLIN( 575)											{
HXLINE( 575)												w1 = (w1 + 1);
HXDLIN( 575)												b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 575)											{
HXLINE( 575)												w1 = (w1 + 1);
HXDLIN( 575)												b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 575)											{
HXLINE( 575)												w1 = (w1 + 1);
HXDLIN( 575)												b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 575)											{
HXLINE( 575)												w1 = (w1 + 1);
HXDLIN( 575)												b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 575)					undoImage4 = b8;
            				}
            				break;
            				case (int)1: {
HXLINE( 575)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 575)					 ::iterMagic::ArrIntImg a9 = arrI1;
HXDLIN( 575)					{
HXLINE( 575)						a9->width = width1;
HXDLIN( 575)						a9->height = height1;
HXDLIN( 575)						a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 575)						a9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 575)						{
HXLINE( 575)							int _g24 = 0;
HXDLIN( 575)							int _g25 = a9->length;
HXDLIN( 575)							while((_g24 < _g25)){
HXLINE( 575)								_g24 = (_g24 + 1);
HXDLIN( 575)								int i10 = (_g24 - 1);
HXDLIN( 575)								a9->data[i10] = 0;
            							}
            						}
            					}
HXDLIN( 575)					undoImage4 = a9;
            				}
            				break;
            				case (int)2: {
HXLINE( 575)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 575)					 ::iterMagic::U32ArrImg b9 = u32a1;
HXDLIN( 575)					{
HXLINE( 575)						b9->width = width1;
HXDLIN( 575)						b9->height = height1;
HXDLIN( 575)						b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 575)						int size1 = (b9->length * 4);
HXDLIN( 575)						b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 575)						{
HXLINE( 575)							int _g26 = 0;
HXDLIN( 575)							int _g27 = b9->length;
HXDLIN( 575)							while((_g26 < _g27)){
HXLINE( 575)								_g26 = (_g26 + 1);
HXDLIN( 575)								int i11 = (_g26 - 1);
HXDLIN( 575)								{
HXLINE( 575)									 ::haxe::io::ArrayBufferViewImpl this33 = b9->data;
HXDLIN( 575)									bool undoImage5;
HXDLIN( 575)									if ((i11 >= 0)) {
HXLINE( 575)										undoImage5 = (i11 < (this33->byteLength >> 2));
            									}
            									else {
HXLINE( 575)										undoImage5 = false;
            									}
HXDLIN( 575)									if (undoImage5) {
HXLINE( 575)										 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 575)										int pos1 = ((i11 << 2) + this33->byteOffset);
HXDLIN( 575)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 575)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 575)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 575)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 575)					undoImage4 = b9;
            				}
            				break;
            				case (int)3: {
HXLINE( 575)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 575)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 575)					{
HXLINE( 575)						v2->width = width1;
HXDLIN( 575)						v2->height = height1;
HXDLIN( 575)						v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 575)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 575)						{
HXLINE( 575)							int _g28 = 0;
HXDLIN( 575)							int _g29 = v2->length;
HXDLIN( 575)							while((_g28 < _g29)){
HXLINE( 575)								_g28 = (_g28 + 1);
HXDLIN( 575)								int i12 = (_g28 - 1);
HXDLIN( 575)								v2->data->__unsafe_set(i12,0);
            							}
            						}
            					}
HXDLIN( 575)					undoImage4 = v2;
            				}
            				break;
            				case (int)4: {
HXLINE( 575)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 575)					 ::iterMagic::StackIntImg b10 = sInt1;
HXDLIN( 575)					{
HXLINE( 575)						b10->width = width1;
HXDLIN( 575)						b10->height = height1;
HXDLIN( 575)						b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 575)						b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 575)						{
HXLINE( 575)							int len3 = b10->length;
HXDLIN( 575)							 ::haxe::ds::GenericStack_Int d1 = b10->data;
HXDLIN( 575)							if (::hx::IsNull( d1->head )) {
HXLINE( 575)								int _g30 = 0;
HXDLIN( 575)								int _g31 = len3;
HXDLIN( 575)								while((_g30 < _g31)){
HXLINE( 575)									_g30 = (_g30 + 1);
HXDLIN( 575)									int i13 = (_g30 - 1);
HXDLIN( 575)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE( 575)								int _g32 = 0;
HXDLIN( 575)								int _g33 = len3;
HXDLIN( 575)								while((_g32 < _g33)){
HXLINE( 575)									_g32 = (_g32 + 1);
HXDLIN( 575)									int i14 = (_g32 - 1);
HXDLIN( 575)									{
HXLINE( 575)										 ::haxe::ds::GenericCell_Int l1 = b10->data->head;
HXDLIN( 575)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 575)										{
HXLINE( 575)											int _g34 = 0;
HXDLIN( 575)											int _g35 = i14;
HXDLIN( 575)											while((_g34 < _g35)){
HXLINE( 575)												_g34 = (_g34 + 1);
HXDLIN( 575)												int i15 = (_g34 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 575)										if (::hx::IsNull( prev1 )) {
HXLINE( 575)											b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 575)											l1 = null();
            										}
            										else {
HXLINE( 575)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 575)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 575)					undoImage4 = b10;
            				}
            				break;
            			}
HXDLIN( 575)			this32->image = undoImage4;
HXDLIN( 575)			this32->width = width1;
HXDLIN( 575)			this32->height = height1;
HXDLIN( 575)			this32->imageType = ( (int)(imageType1) );
HXDLIN( 575)			undoImage3 = this32;
HXDLIN( 575)			{
HXLINE( 575)				int rectLeft1 = xIter31->start;
HXDLIN( 575)				int rectTop1 = yIter31->start;
HXDLIN( 575)				int rectRight1 = xIter31->max;
HXDLIN( 575)				bool forceClear1 = false;
HXDLIN( 575)				{
HXLINE( 575)					int _g36 = rectTop1;
HXDLIN( 575)					int _g37 = yIter31->max;
HXDLIN( 575)					while((_g36 < _g37)){
HXLINE( 575)						_g36 = (_g36 + 1);
HXDLIN( 575)						int dy1 = (_g36 - 1);
HXDLIN( 575)						{
HXLINE( 575)							int _g38 = rectLeft1;
HXDLIN( 575)							int _g39 = rectRight1;
HXDLIN( 575)							while((_g38 < _g39)){
HXLINE( 575)								_g38 = (_g38 + 1);
HXDLIN( 575)								int dx1 = (_g38 - 1);
HXDLIN( 575)								::Dynamic this34 = pixelImage->image;
HXDLIN( 575)								int index4;
HXDLIN( 575)								if (pixelImage->useVirtualPos) {
HXLINE( 575)									index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 575)									index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            								}
HXDLIN( 575)								int c5 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 575)								int col1;
HXDLIN( 575)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)									col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 575)									col1 = c5;
            								}
HXDLIN( 575)								bool _hx_tmp8;
HXDLIN( 575)								if (pixelImage->useMask) {
HXLINE( 575)									_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 575)									_hx_tmp8 = false;
            								}
HXDLIN( 575)								if (_hx_tmp8) {
HXLINE( 575)									 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN( 575)									::Dynamic this36 = this35->image;
HXDLIN( 575)									int index5;
HXDLIN( 575)									if (this35->useVirtualPos) {
HXLINE( 575)										index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx1) - this35->virtualX));
            									}
            									else {
HXLINE( 575)										index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this35->width) + dx1)) ));
            									}
HXDLIN( 575)									int c6 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 575)									int v3;
HXDLIN( 575)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)										v3 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE( 575)										v3 = c6;
            									}
HXDLIN( 575)									int maskPixel1 = v3;
HXDLIN( 575)									int this37 = col1;
HXDLIN( 575)									if ((maskPixel1 == 0)) {
HXLINE( 575)										col1 = this37;
            									}
            									else {
HXLINE( 575)										Float m01;
HXDLIN( 575)										int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 575)										if ((this38 == 0)) {
HXLINE( 575)											m01 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float m11;
HXDLIN( 575)										int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 575)										if ((this39 == 0)) {
HXLINE( 575)											m11 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float m21;
HXDLIN( 575)										int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 575)										if ((this40 == 0)) {
HXLINE( 575)											m21 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float m31;
HXDLIN( 575)										int this41 = (maskPixel1 & 255);
HXDLIN( 575)										if ((this41 == 0)) {
HXLINE( 575)											m31 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 575)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 575)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 575)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 575)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 575)								if ((col1 != 0)) {
HXLINE( 575)									int x4 = (dx1 - rectLeft1);
HXDLIN( 575)									int y4 = (dy1 - rectTop1);
HXDLIN( 575)									int c7 = col1;
HXDLIN( 575)									bool _hx_tmp9;
HXDLIN( 575)									if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 575)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXLINE( 575)										_hx_tmp9 = false;
            									}
HXDLIN( 575)									if (_hx_tmp9) {
HXLINE( 575)										int location2;
HXDLIN( 575)										if (undoImage3->useVirtualPos) {
HXLINE( 575)											location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 575)											location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            										}
HXDLIN( 575)										int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 575)										int this43;
HXDLIN( 575)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)											this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            										}
            										else {
HXLINE( 575)											this43 = this42;
            										}
HXDLIN( 575)										Float a12;
HXDLIN( 575)										int this44 = ((this43 >> 24) & 255);
HXDLIN( 575)										if ((this44 == 0)) {
HXLINE( 575)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float r12;
HXDLIN( 575)										int this45 = ((this43 >> 16) & 255);
HXDLIN( 575)										if ((this45 == 0)) {
HXLINE( 575)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float g12;
HXDLIN( 575)										int this46 = ((this43 >> 8) & 255);
HXDLIN( 575)										if ((this46 == 0)) {
HXLINE( 575)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float b13;
HXDLIN( 575)										int this47 = (this43 & 255);
HXDLIN( 575)										if ((this47 == 0)) {
HXLINE( 575)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float a22;
HXDLIN( 575)										int this48 = ((col1 >> 24) & 255);
HXDLIN( 575)										if ((this48 == 0)) {
HXLINE( 575)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float r22;
HXDLIN( 575)										int this49 = ((col1 >> 16) & 255);
HXDLIN( 575)										if ((this49 == 0)) {
HXLINE( 575)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float g22;
HXDLIN( 575)										int this50 = ((col1 >> 8) & 255);
HXDLIN( 575)										if ((this50 == 0)) {
HXLINE( 575)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float b23;
HXDLIN( 575)										int this51 = (col1 & 255);
HXDLIN( 575)										if ((this51 == 0)) {
HXLINE( 575)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 575)											b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 575)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 575)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 575)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 575)										int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 575)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 575)										int blended2 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b14);
HXDLIN( 575)										{
HXLINE( 575)											int _hx_tmp10;
HXDLIN( 575)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 575)												_hx_tmp10 = blended2;
            											}
HXDLIN( 575)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXLINE( 575)										::Dynamic this52 = undoImage3->image;
HXDLIN( 575)										int index6;
HXDLIN( 575)										if (undoImage3->useVirtualPos) {
HXLINE( 575)											index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 575)											index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            										}
HXDLIN( 575)										int _hx_tmp11;
HXDLIN( 575)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)											_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 575)											_hx_tmp11 = c7;
            										}
HXDLIN( 575)										::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            									}
            								}
            								else {
HXLINE( 575)									if (forceClear1) {
HXLINE( 575)										::Dynamic this53 = undoImage3->image;
HXDLIN( 575)										int x5 = (dx1 - rectLeft1);
HXDLIN( 575)										int y5 = (dy1 - rectTop1);
HXDLIN( 575)										int index7;
HXDLIN( 575)										if (undoImage3->useVirtualPos) {
HXLINE( 575)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 575)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 575)										::iterMagic::Iimg_obj::set(this53,index7,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 575)		bool found1 = false;
HXDLIN( 575)		{
HXLINE( 575)			int _g_min2 = xIter31->start;
HXDLIN( 575)			int _g_max2 = xIter31->max;
HXDLIN( 575)			while((_g_min2 < _g_max2)){
HXLINE( 575)				_g_min2 = (_g_min2 + 1);
HXDLIN( 575)				int px1 = (_g_min2 - 1);
HXDLIN( 575)				Float pcx1 = (( (Float)(px1) ) - cx);
HXLINE( 619)				found1 = false;
HXLINE( 575)				{
HXLINE( 575)					int _g_min3 = yIter31->start;
HXDLIN( 575)					int _g_max3 = yIter31->max;
HXDLIN( 575)					while((_g_min3 < _g_max3)){
HXLINE( 575)						_g_min3 = (_g_min3 + 1);
HXDLIN( 575)						int py1 = (_g_min3 - 1);
HXDLIN( 575)						Float pcy1 = (( (Float)(py1) ) - cy);
HXDLIN( 575)						Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 575)						Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 575)						Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 575)						Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 575)						Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 575)						bool _hx_tmp12;
HXDLIN( 575)						bool _hx_tmp13;
HXDLIN( 575)						if ((ratioA1 >= 0)) {
HXLINE( 575)							_hx_tmp13 = (ratioB1 >= 0);
            						}
            						else {
HXLINE( 575)							_hx_tmp13 = false;
            						}
HXDLIN( 575)						if (_hx_tmp13) {
HXLINE( 575)							_hx_tmp12 = (ratioC1 >= 0);
            						}
            						else {
HXLINE( 575)							_hx_tmp12 = false;
            						}
HXDLIN( 575)						if (_hx_tmp12) {
HXLINE( 575)							int i16 = ::Std_obj::_hx_int((( (Float)(aA1) ) * (softC * ratioB1)));
HXDLIN( 575)							if ((i16 > 255)) {
HXLINE(  24)								i16 = 255;
            							}
HXLINE( 575)							if ((i16 < 0)) {
HXLINE(  25)								i16 = 0;
            							}
HXLINE( 575)							int a13 = i16;
HXDLIN( 575)							int i17 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 575)							if ((i17 > 255)) {
HXLINE(  24)								i17 = 255;
            							}
HXLINE( 575)							if ((i17 < 0)) {
HXLINE(  25)								i17 = 0;
            							}
HXLINE( 575)							int r6 = i17;
HXDLIN( 575)							int i18 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 575)							if ((i18 > 255)) {
HXLINE(  24)								i18 = 255;
            							}
HXLINE( 575)							if ((i18 < 0)) {
HXLINE(  25)								i18 = 0;
            							}
HXLINE( 575)							int g6 = i18;
HXDLIN( 575)							int i19 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 575)							if ((i19 > 255)) {
HXLINE(  24)								i19 = 255;
            							}
HXLINE( 575)							if ((i19 < 0)) {
HXLINE(  25)								i19 = 0;
            							}
HXLINE( 575)							int b15 = i19;
HXDLIN( 575)							{
HXLINE( 575)								int location3;
HXDLIN( 575)								if (pixelImage->useVirtualPos) {
HXLINE( 575)									location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 575)									location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            								}
HXDLIN( 575)								bool _hx_tmp14;
HXDLIN( 575)								if (pixelImage->transparent) {
HXLINE( 575)									_hx_tmp14 = (a13 < 254);
            								}
            								else {
HXLINE( 575)									_hx_tmp14 = false;
            								}
HXDLIN( 575)								if (_hx_tmp14) {
HXLINE( 575)									int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 575)									int old1;
HXDLIN( 575)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)										old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            									}
            									else {
HXLINE( 575)										old1 = this54;
            									}
HXDLIN( 575)									int rhs1 = ((((a13 << 24) | (r6 << 16)) | (g6 << 8)) | b15);
HXDLIN( 575)									Float a14;
HXDLIN( 575)									int this55 = ((old1 >> 24) & 255);
HXDLIN( 575)									if ((this55 == 0)) {
HXLINE( 575)										a14 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										a14 = (( (Float)(this55) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float r13;
HXDLIN( 575)									int this56 = ((old1 >> 16) & 255);
HXDLIN( 575)									if ((this56 == 0)) {
HXLINE( 575)										r13 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float g13;
HXDLIN( 575)									int this57 = ((old1 >> 8) & 255);
HXDLIN( 575)									if ((this57 == 0)) {
HXLINE( 575)										g13 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float b16;
HXDLIN( 575)									int this58 = (old1 & 255);
HXDLIN( 575)									if ((this58 == 0)) {
HXLINE( 575)										b16 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										b16 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float a23;
HXDLIN( 575)									int this59 = ((rhs1 >> 24) & 255);
HXDLIN( 575)									if ((this59 == 0)) {
HXLINE( 575)										a23 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float r23;
HXDLIN( 575)									int this60 = ((rhs1 >> 16) & 255);
HXDLIN( 575)									if ((this60 == 0)) {
HXLINE( 575)										r23 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float g23;
HXDLIN( 575)									int this61 = ((rhs1 >> 8) & 255);
HXDLIN( 575)									if ((this61 == 0)) {
HXLINE( 575)										g23 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float b24;
HXDLIN( 575)									int this62 = (rhs1 & 255);
HXDLIN( 575)									if ((this62 == 0)) {
HXLINE( 575)										b24 = ((Float)0.);
            									}
            									else {
HXLINE( 575)										b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            									}
HXDLIN( 575)									Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 575)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 575)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 575)									int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a33) + (b24 * a23))));
HXDLIN( 575)									int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 575)									int blended3 = ((((a15 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN( 575)									{
HXLINE( 575)										int _hx_tmp15;
HXDLIN( 575)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 575)											_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE( 575)											_hx_tmp15 = blended3;
            										}
HXDLIN( 575)										::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp15);
            									}
            								}
            								else {
HXLINE( 575)									int value1;
HXDLIN( 575)									if (pixelImage->isLittle) {
HXLINE( 575)										value1 = ((((a13 << 24) | (b15 << 16)) | (g6 << 8)) | r6);
            									}
            									else {
HXLINE( 575)										value1 = ((((a13 << 24) | (r6 << 16)) | (g6 << 8)) | b15);
            									}
HXDLIN( 575)									::iterMagic::Iimg_obj::set(pixelImage->image,location3,value1);
            								}
            							}
HXLINE( 633)							found1 = true;
            						}
            						else {
HXLINE( 575)							if (found1) {
HXLINE( 575)								goto _hx_goto_205;
            							}
            						}
            					}
            					_hx_goto_205:;
            				}
            			}
            		}
HXDLIN( 575)		 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 575)		 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 575)		int v_undoY1;
HXDLIN( 575)		int v_undoX1;
HXDLIN( 575)		Float v_ty1;
HXDLIN( 575)		Float v_tx1;
HXDLIN( 575)		Float v_t01;
HXDLIN( 575)		Float v_sy1;
HXDLIN( 575)		Float v_sx1;
HXDLIN( 575)		Float v_s01;
HXDLIN( 575)		Float v_A1;
HXDLIN( 575)		Float ax2 = ex;
HXDLIN( 575)		Float ay2 = ey;
HXDLIN( 575)		 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 575)		Float bx2 = bx;
HXDLIN( 575)		Float by2 = by;
HXDLIN( 575)		Float cx2 = cx;
HXDLIN( 575)		Float cy2 = cy;
HXDLIN( 575)		bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN( 575)		if (!(adjustWinding1)) {
HXLINE( 575)			Float bx_1 = bx2;
HXDLIN( 575)			Float by_1 = by2;
HXLINE(  24)			bx2 = cx2;
HXLINE(  25)			by2 = cy2;
HXLINE(  26)			cx2 = bx_1;
HXLINE(  27)			cy2 = by_1;
            		}
HXLINE( 575)		Float v_ax1 = ax2;
HXDLIN( 575)		Float v_ay1 = ay2;
HXDLIN( 575)		Float v_bx1 = bx2;
HXDLIN( 575)		Float v_by1 = by2;
HXDLIN( 575)		Float v_cx1 = cx2;
HXDLIN( 575)		Float v_cy1 = cy2;
HXDLIN( 575)		bool v_preCalculated1 = true;
HXDLIN( 575)		{
HXLINE( 575)			v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 575)			v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 575)			v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 575)			v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 575)			v_tx1 = (v_ay1 - v_by1);
HXDLIN( 575)			v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 575)			v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 575)			Float a16 = v_ax1;
HXDLIN( 575)			Float b18 = v_bx1;
HXDLIN( 575)			Float c8 = v_cx1;
HXDLIN( 575)			if ((a16 > b18)) {
HXLINE( 575)				if ((a16 > c8)) {
HXLINE( 575)					int min12;
HXDLIN( 575)					if ((b18 > c8)) {
HXLINE( 575)						min12 = ::Math_obj::floor(c8);
            					}
            					else {
HXLINE( 575)						min12 = ::Math_obj::floor(b18);
            					}
HXDLIN( 575)					int ii_min24 = min12;
HXDLIN( 575)					int ii_max24 = ::Math_obj::ceil(a16);
HXDLIN( 575)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE( 575)					int ii_min25 = ::Math_obj::floor(b18);
HXDLIN( 575)					int ii_max25 = ::Math_obj::ceil(c8);
HXDLIN( 575)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE( 575)				if ((b18 > c8)) {
HXLINE( 575)					int min13;
HXDLIN( 575)					if ((a16 > c8)) {
HXLINE( 575)						min13 = ::Math_obj::floor(c8);
            					}
            					else {
HXLINE( 575)						min13 = ::Math_obj::ceil(a16);
            					}
HXDLIN( 575)					int ii_min26 = min13;
HXDLIN( 575)					int ii_max26 = ::Math_obj::ceil(b18);
HXDLIN( 575)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE( 575)					int ii_min27 = ::Math_obj::floor(a16);
HXDLIN( 575)					int ii_max27 = ::Math_obj::ceil(c8);
HXDLIN( 575)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 575)			Float a17 = v_ay1;
HXDLIN( 575)			Float b19 = v_by1;
HXDLIN( 575)			Float c9 = v_cy1;
HXDLIN( 575)			if ((a17 > b19)) {
HXLINE( 575)				if ((a17 > c9)) {
HXLINE( 575)					int min14;
HXDLIN( 575)					if ((b19 > c9)) {
HXLINE( 575)						min14 = ::Math_obj::floor(c9);
            					}
            					else {
HXLINE( 575)						min14 = ::Math_obj::floor(b19);
            					}
HXDLIN( 575)					int ii_min28 = min14;
HXDLIN( 575)					int ii_max28 = ::Math_obj::ceil(a17);
HXDLIN( 575)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE( 575)					int ii_min29 = ::Math_obj::floor(b19);
HXDLIN( 575)					int ii_max29 = ::Math_obj::ceil(c9);
HXDLIN( 575)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE( 575)				if ((b19 > c9)) {
HXLINE( 575)					int min15;
HXDLIN( 575)					if ((a17 > c9)) {
HXLINE( 575)						min15 = ::Math_obj::floor(c9);
            					}
            					else {
HXLINE( 575)						min15 = ::Math_obj::ceil(a17);
            					}
HXDLIN( 575)					int ii_min30 = min15;
HXDLIN( 575)					int ii_max30 = ::Math_obj::ceil(b19);
HXDLIN( 575)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE( 575)					int ii_min31 = ::Math_obj::floor(a17);
HXDLIN( 575)					int ii_max31 = ::Math_obj::ceil(c9);
HXDLIN( 575)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
            		}
HXDLIN( 575)		if (hasUndo1) {
HXLINE( 575)			v_undoImage1 = undoImage3;
HXDLIN( 575)			v_undoX1 = xIter31->start;
HXDLIN( 575)			v_undoY1 = yIter31->start;
            		}
HXLINE( 576)		if ((hasHit == false)) {
HXLINE( 577)			 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 578)			return v4;
            		}
            		else {
HXLINE( 580)			return null();
            		}
HXLINE( 576)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriTwoSoft,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriSoftC( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< Float >  __o_softC,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		Float softC = __o_softC.Default(10);
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_591_fillTriSoftC)
HXLINE( 592)		int aA = ((color >> 24) & 255);
HXLINE( 593)		int rA = ((color >> 16) & 255);
HXLINE( 594)		int gA = ((color >> 8) & 255);
HXLINE( 595)		int bA = (color & 255);
HXLINE( 596)		Float bcx = (bx - cx);
HXLINE( 597)		Float bcy = (by - cy);
HXLINE( 598)		Float acx = (ax - cx);
HXLINE( 599)		Float acy = (ay - cy);
HXLINE( 601)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 602)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 603)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 604)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 605)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 605)		if ((ax > bx)) {
HXLINE( 605)			if ((ax > cx)) {
HXLINE( 605)				int min;
HXDLIN( 605)				if ((bx > cx)) {
HXLINE( 605)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 605)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 605)				int ii_min = min;
HXDLIN( 605)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 605)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 605)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 605)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 605)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 605)			if ((bx > cx)) {
HXLINE( 605)				int min1;
HXDLIN( 605)				if ((ax > cx)) {
HXLINE( 605)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 605)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 605)				int ii_min2 = min1;
HXDLIN( 605)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 605)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 605)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 605)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 605)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 606)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 606)		if ((ay > by)) {
HXLINE( 606)			if ((ay > cy)) {
HXLINE( 606)				int min2;
HXDLIN( 606)				if ((by > cy)) {
HXLINE( 606)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 606)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 606)				int ii_min4 = min2;
HXDLIN( 606)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 606)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 606)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 606)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 606)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 606)			if ((by > cy)) {
HXLINE( 606)				int min3;
HXDLIN( 606)				if ((ay > cy)) {
HXLINE( 606)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 606)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 606)				int ii_min6 = min3;
HXDLIN( 606)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 606)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 606)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 606)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 606)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 607)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 608)		if (hasUndo) {
HXLINE( 609)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 609)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 609)			 ::Dynamic imageType = null();
HXDLIN( 609)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 609)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 609)			::Dynamic undoImage1;
HXDLIN( 609)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 609)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 609)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 609)					{
HXLINE( 609)						b->width = width;
HXDLIN( 609)						b->height = height;
HXDLIN( 609)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 609)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 609)						{
HXLINE( 609)							int len = b->length;
HXDLIN( 609)							int w = 0;
HXDLIN( 609)							{
HXLINE( 609)								int _g = 0;
HXDLIN( 609)								int _g1 = b->height;
HXDLIN( 609)								while((_g < _g1)){
HXLINE( 609)									_g = (_g + 1);
HXDLIN( 609)									int y = (_g - 1);
HXDLIN( 609)									{
HXLINE( 609)										int _g2 = 0;
HXDLIN( 609)										int _g3 = b->width;
HXDLIN( 609)										while((_g2 < _g3)){
HXLINE( 609)											_g2 = (_g2 + 1);
HXDLIN( 609)											int x = (_g2 - 1);
HXDLIN( 609)											{
HXLINE( 609)												w = (w + 1);
HXDLIN( 609)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 609)											{
HXLINE( 609)												w = (w + 1);
HXDLIN( 609)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 609)											{
HXLINE( 609)												w = (w + 1);
HXDLIN( 609)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 609)											{
HXLINE( 609)												w = (w + 1);
HXDLIN( 609)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 609)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 609)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 609)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 609)					{
HXLINE( 609)						a->width = width;
HXDLIN( 609)						a->height = height;
HXDLIN( 609)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 609)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 609)						{
HXLINE( 609)							int _g4 = 0;
HXDLIN( 609)							int _g5 = a->length;
HXDLIN( 609)							while((_g4 < _g5)){
HXLINE( 609)								_g4 = (_g4 + 1);
HXDLIN( 609)								int i = (_g4 - 1);
HXDLIN( 609)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 609)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 609)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 609)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 609)					{
HXLINE( 609)						b1->width = width;
HXDLIN( 609)						b1->height = height;
HXDLIN( 609)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 609)						int size = (b1->length * 4);
HXDLIN( 609)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 609)						{
HXLINE( 609)							int _g6 = 0;
HXDLIN( 609)							int _g7 = b1->length;
HXDLIN( 609)							while((_g6 < _g7)){
HXLINE( 609)								_g6 = (_g6 + 1);
HXDLIN( 609)								int i1 = (_g6 - 1);
HXDLIN( 609)								{
HXLINE( 609)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 609)									bool undoImage2;
HXDLIN( 609)									if ((i1 >= 0)) {
HXLINE( 609)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 609)										undoImage2 = false;
            									}
HXDLIN( 609)									if (undoImage2) {
HXLINE( 609)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 609)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 609)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 609)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 609)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 609)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 609)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 609)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 609)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 609)					{
HXLINE( 609)						v->width = width;
HXDLIN( 609)						v->height = height;
HXDLIN( 609)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 609)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 609)						{
HXLINE( 609)							int _g8 = 0;
HXDLIN( 609)							int _g9 = v->length;
HXDLIN( 609)							while((_g8 < _g9)){
HXLINE( 609)								_g8 = (_g8 + 1);
HXDLIN( 609)								int i2 = (_g8 - 1);
HXDLIN( 609)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 609)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 609)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 609)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 609)					{
HXLINE( 609)						b2->width = width;
HXDLIN( 609)						b2->height = height;
HXDLIN( 609)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 609)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 609)						{
HXLINE( 609)							int len1 = b2->length;
HXDLIN( 609)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 609)							if (::hx::IsNull( d->head )) {
HXLINE( 609)								int _g10 = 0;
HXDLIN( 609)								int _g11 = len1;
HXDLIN( 609)								while((_g10 < _g11)){
HXLINE( 609)									_g10 = (_g10 + 1);
HXDLIN( 609)									int i3 = (_g10 - 1);
HXDLIN( 609)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 609)								int _g12 = 0;
HXDLIN( 609)								int _g13 = len1;
HXDLIN( 609)								while((_g12 < _g13)){
HXLINE( 609)									_g12 = (_g12 + 1);
HXDLIN( 609)									int i4 = (_g12 - 1);
HXDLIN( 609)									{
HXLINE( 609)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 609)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 609)										{
HXLINE( 609)											int _g14 = 0;
HXDLIN( 609)											int _g15 = i4;
HXDLIN( 609)											while((_g14 < _g15)){
HXLINE( 609)												_g14 = (_g14 + 1);
HXDLIN( 609)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 609)										if (::hx::IsNull( prev )) {
HXLINE( 609)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 609)											l = null();
            										}
            										else {
HXLINE( 609)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 609)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 609)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 609)			this1->image = undoImage1;
HXDLIN( 609)			this1->width = width;
HXDLIN( 609)			this1->height = height;
HXDLIN( 609)			this1->imageType = ( (int)(imageType) );
HXDLIN( 609)			undoImage = this1;
HXLINE( 610)			{
HXLINE( 610)				int rectLeft = xIter3->start;
HXDLIN( 610)				int rectTop = yIter3->start;
HXDLIN( 610)				int rectRight = xIter3->max;
HXDLIN( 610)				bool forceClear = false;
HXDLIN( 610)				{
HXLINE( 610)					int _g16 = rectTop;
HXDLIN( 610)					int _g17 = yIter3->max;
HXDLIN( 610)					while((_g16 < _g17)){
HXLINE( 610)						_g16 = (_g16 + 1);
HXDLIN( 610)						int dy = (_g16 - 1);
HXDLIN( 610)						{
HXLINE( 610)							int _g18 = rectLeft;
HXDLIN( 610)							int _g19 = rectRight;
HXDLIN( 610)							while((_g18 < _g19)){
HXLINE( 610)								_g18 = (_g18 + 1);
HXDLIN( 610)								int dx = (_g18 - 1);
HXDLIN( 610)								::Dynamic this3 = pixelImage->image;
HXDLIN( 610)								int index;
HXDLIN( 610)								if (pixelImage->useVirtualPos) {
HXLINE( 610)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 610)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 610)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 610)								int col;
HXDLIN( 610)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 610)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 610)									col = c;
            								}
HXDLIN( 610)								bool _hx_tmp;
HXDLIN( 610)								if (pixelImage->useMask) {
HXLINE( 610)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 610)									_hx_tmp = false;
            								}
HXDLIN( 610)								if (_hx_tmp) {
HXLINE( 610)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 610)									::Dynamic this5 = this4->image;
HXDLIN( 610)									int index1;
HXDLIN( 610)									if (this4->useVirtualPos) {
HXLINE( 610)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 610)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 610)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 610)									int v1;
HXDLIN( 610)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 610)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 610)										v1 = c1;
            									}
HXDLIN( 610)									int maskPixel = v1;
HXDLIN( 610)									int this6 = col;
HXDLIN( 610)									if ((maskPixel == 0)) {
HXLINE( 610)										col = this6;
            									}
            									else {
HXLINE( 610)										Float m0;
HXDLIN( 610)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 610)										if ((this7 == 0)) {
HXLINE( 610)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float m1;
HXDLIN( 610)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 610)										if ((this8 == 0)) {
HXLINE( 610)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float m2;
HXDLIN( 610)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 610)										if ((this9 == 0)) {
HXLINE( 610)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float m3;
HXDLIN( 610)										int this10 = (maskPixel & 255);
HXDLIN( 610)										if ((this10 == 0)) {
HXLINE( 610)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 610)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 610)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 610)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 610)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 610)								if ((col != 0)) {
HXLINE( 610)									int x1 = (dx - rectLeft);
HXDLIN( 610)									int y1 = (dy - rectTop);
HXDLIN( 610)									int c2 = col;
HXDLIN( 610)									bool _hx_tmp1;
HXDLIN( 610)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 610)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 610)										_hx_tmp1 = false;
            									}
HXDLIN( 610)									if (_hx_tmp1) {
HXLINE( 610)										int location;
HXDLIN( 610)										if (undoImage->useVirtualPos) {
HXLINE( 610)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 610)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 610)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 610)										int this12;
HXDLIN( 610)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 610)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 610)											this12 = this11;
            										}
HXDLIN( 610)										Float a1;
HXDLIN( 610)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 610)										if ((this13 == 0)) {
HXLINE( 610)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float r1;
HXDLIN( 610)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 610)										if ((this14 == 0)) {
HXLINE( 610)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float g1;
HXDLIN( 610)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 610)										if ((this15 == 0)) {
HXLINE( 610)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float b11;
HXDLIN( 610)										int this16 = (this12 & 255);
HXDLIN( 610)										if ((this16 == 0)) {
HXLINE( 610)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float a2;
HXDLIN( 610)										int this17 = ((col >> 24) & 255);
HXDLIN( 610)										if ((this17 == 0)) {
HXLINE( 610)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float r2;
HXDLIN( 610)										int this18 = ((col >> 16) & 255);
HXDLIN( 610)										if ((this18 == 0)) {
HXLINE( 610)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float g2;
HXDLIN( 610)										int this19 = ((col >> 8) & 255);
HXDLIN( 610)										if ((this19 == 0)) {
HXLINE( 610)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float b21;
HXDLIN( 610)										int this20 = (col & 255);
HXDLIN( 610)										if ((this20 == 0)) {
HXLINE( 610)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 610)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 610)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 610)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 610)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 610)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 610)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 610)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 610)										{
HXLINE( 610)											int _hx_tmp2;
HXDLIN( 610)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 610)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 610)												_hx_tmp2 = blended;
            											}
HXDLIN( 610)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 610)										::Dynamic this21 = undoImage->image;
HXDLIN( 610)										int index2;
HXDLIN( 610)										if (undoImage->useVirtualPos) {
HXLINE( 610)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 610)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 610)										int _hx_tmp3;
HXDLIN( 610)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 610)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 610)											_hx_tmp3 = c2;
            										}
HXDLIN( 610)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 610)									if (forceClear) {
HXLINE( 610)										::Dynamic this22 = undoImage->image;
HXDLIN( 610)										int x2 = (dx - rectLeft);
HXDLIN( 610)										int y2 = (dy - rectTop);
HXDLIN( 610)										int index3;
HXDLIN( 610)										if (undoImage->useVirtualPos) {
HXLINE( 610)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 610)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 610)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 612)		int a5 = 0;
HXLINE( 613)		int r3 = 0;
HXLINE( 614)		int g3 = 0;
HXLINE( 615)		int b4 = 0;
HXLINE( 616)		bool found = false;
HXLINE( 617)		{
HXLINE( 617)			int _g_min = xIter3->start;
HXDLIN( 617)			int _g_max = xIter3->max;
HXDLIN( 617)			while((_g_min < _g_max)){
HXLINE( 617)				_g_min = (_g_min + 1);
HXDLIN( 617)				int px = (_g_min - 1);
HXLINE( 618)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 619)				found = false;
HXLINE( 620)				{
HXLINE( 620)					int _g_min1 = yIter3->start;
HXDLIN( 620)					int _g_max1 = yIter3->max;
HXDLIN( 620)					while((_g_min1 < _g_max1)){
HXLINE( 620)						_g_min1 = (_g_min1 + 1);
HXDLIN( 620)						int py = (_g_min1 - 1);
HXLINE( 621)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 622)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 623)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 624)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 625)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 626)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 627)						bool _hx_tmp4;
HXDLIN( 627)						bool _hx_tmp5;
HXDLIN( 627)						if ((ratioA >= 0)) {
HXLINE( 627)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 627)							_hx_tmp5 = false;
            						}
HXDLIN( 627)						if (_hx_tmp5) {
HXLINE( 627)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 627)							_hx_tmp4 = false;
            						}
HXDLIN( 627)						if (_hx_tmp4) {
HXLINE( 628)							int i6 = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN( 628)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 628)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 628)							int a6 = i6;
HXLINE( 629)							int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 629)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 629)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 629)							int r4 = i7;
HXLINE( 630)							int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 630)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 630)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 630)							int g4 = i8;
HXLINE( 631)							int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 631)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 631)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 631)							int b5 = i9;
HXLINE( 632)							{
HXLINE( 632)								int location1;
HXDLIN( 632)								if (pixelImage->useVirtualPos) {
HXLINE( 632)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 632)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 632)								bool _hx_tmp6;
HXDLIN( 632)								if (pixelImage->transparent) {
HXLINE( 632)									_hx_tmp6 = (a6 < 254);
            								}
            								else {
HXLINE( 632)									_hx_tmp6 = false;
            								}
HXDLIN( 632)								if (_hx_tmp6) {
HXLINE( 632)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 632)									int old;
HXDLIN( 632)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 632)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 632)										old = this23;
            									}
HXDLIN( 632)									int rhs = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 632)									Float a11;
HXDLIN( 632)									int this24 = ((old >> 24) & 255);
HXDLIN( 632)									if ((this24 == 0)) {
HXLINE( 632)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float r11;
HXDLIN( 632)									int this25 = ((old >> 16) & 255);
HXDLIN( 632)									if ((this25 == 0)) {
HXLINE( 632)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float g11;
HXDLIN( 632)									int this26 = ((old >> 8) & 255);
HXDLIN( 632)									if ((this26 == 0)) {
HXLINE( 632)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float b12;
HXDLIN( 632)									int this27 = (old & 255);
HXDLIN( 632)									if ((this27 == 0)) {
HXLINE( 632)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float a21;
HXDLIN( 632)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 632)									if ((this28 == 0)) {
HXLINE( 632)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float r21;
HXDLIN( 632)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 632)									if ((this29 == 0)) {
HXLINE( 632)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float g21;
HXDLIN( 632)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 632)									if ((this30 == 0)) {
HXLINE( 632)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float b22;
HXDLIN( 632)									int this31 = (rhs & 255);
HXDLIN( 632)									if ((this31 == 0)) {
HXLINE( 632)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 632)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 632)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 632)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 632)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 632)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 632)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 632)									int blended1 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 632)									{
HXLINE( 632)										int _hx_tmp7;
HXDLIN( 632)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 632)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 632)											_hx_tmp7 = blended1;
            										}
HXDLIN( 632)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 632)									int value;
HXDLIN( 632)									if (pixelImage->isLittle) {
HXLINE( 632)										value = ((((a6 << 24) | (b5 << 16)) | (g4 << 8)) | r4);
            									}
            									else {
HXLINE( 632)										value = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
            									}
HXDLIN( 632)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
HXLINE( 633)							found = true;
            						}
            						else {
HXLINE( 634)							if (found) {
HXLINE( 636)								goto _hx_goto_218;
            							}
            						}
            					}
            					_hx_goto_218:;
            				}
            			}
            		}
HXLINE( 642)		if ((hasHit == false)) {
HXLINE( 643)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 644)			if (hasUndo) {
HXLINE( 645)				v2->undoImage = undoImage;
HXLINE( 646)				v2->undoX = xIter3->start;
HXLINE( 647)				v2->undoY = yIter3->start;
            			}
HXLINE( 649)			return v2;
            		}
            		else {
HXLINE( 651)			return null();
            		}
HXLINE( 642)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixel_Fields__obj,fillTriSoftC,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriSoft3( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< Float >  __o_soft3,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		Float soft3 = __o_soft3.Default(40);
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCA = __o_softCA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_665_fillTriSoft3)
HXLINE( 666)		int aA = ((color >> 24) & 255);
HXLINE( 667)		int rA = ((color >> 16) & 255);
HXLINE( 668)		int gA = ((color >> 8) & 255);
HXLINE( 669)		int bA = (color & 255);
HXLINE( 670)		Float bcx = (bx - cx);
HXLINE( 671)		Float bcy = (by - cy);
HXLINE( 672)		Float acx = (ax - cx);
HXLINE( 673)		Float acy = (ay - cy);
HXLINE( 675)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 676)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 677)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 678)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 679)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 679)		if ((ax > bx)) {
HXLINE( 679)			if ((ax > cx)) {
HXLINE( 679)				int min;
HXDLIN( 679)				if ((bx > cx)) {
HXLINE( 679)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 679)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 679)				int ii_min = min;
HXDLIN( 679)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 679)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 679)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 679)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 679)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 679)			if ((bx > cx)) {
HXLINE( 679)				int min1;
HXDLIN( 679)				if ((ax > cx)) {
HXLINE( 679)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 679)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 679)				int ii_min2 = min1;
HXDLIN( 679)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 679)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 679)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 679)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 679)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 680)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 680)		if ((ay > by)) {
HXLINE( 680)			if ((ay > cy)) {
HXLINE( 680)				int min2;
HXDLIN( 680)				if ((by > cy)) {
HXLINE( 680)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 680)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 680)				int ii_min4 = min2;
HXDLIN( 680)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 680)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 680)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 680)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 680)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 680)			if ((by > cy)) {
HXLINE( 680)				int min3;
HXDLIN( 680)				if ((ay > cy)) {
HXLINE( 680)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 680)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 680)				int ii_min6 = min3;
HXDLIN( 680)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 680)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 680)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 680)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 680)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 681)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 682)		if (hasUndo) {
HXLINE( 683)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 683)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 683)			 ::Dynamic imageType = null();
HXDLIN( 683)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 683)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 683)			::Dynamic undoImage1;
HXDLIN( 683)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 683)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 683)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 683)					{
HXLINE( 683)						b->width = width;
HXDLIN( 683)						b->height = height;
HXDLIN( 683)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 683)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 683)						{
HXLINE( 683)							int len = b->length;
HXDLIN( 683)							int w = 0;
HXDLIN( 683)							{
HXLINE( 683)								int _g = 0;
HXDLIN( 683)								int _g1 = b->height;
HXDLIN( 683)								while((_g < _g1)){
HXLINE( 683)									_g = (_g + 1);
HXDLIN( 683)									int y = (_g - 1);
HXDLIN( 683)									{
HXLINE( 683)										int _g2 = 0;
HXDLIN( 683)										int _g3 = b->width;
HXDLIN( 683)										while((_g2 < _g3)){
HXLINE( 683)											_g2 = (_g2 + 1);
HXDLIN( 683)											int x = (_g2 - 1);
HXDLIN( 683)											{
HXLINE( 683)												w = (w + 1);
HXDLIN( 683)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 683)											{
HXLINE( 683)												w = (w + 1);
HXDLIN( 683)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 683)											{
HXLINE( 683)												w = (w + 1);
HXDLIN( 683)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 683)											{
HXLINE( 683)												w = (w + 1);
HXDLIN( 683)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 683)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 683)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 683)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 683)					{
HXLINE( 683)						a->width = width;
HXDLIN( 683)						a->height = height;
HXDLIN( 683)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 683)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 683)						{
HXLINE( 683)							int _g4 = 0;
HXDLIN( 683)							int _g5 = a->length;
HXDLIN( 683)							while((_g4 < _g5)){
HXLINE( 683)								_g4 = (_g4 + 1);
HXDLIN( 683)								int i = (_g4 - 1);
HXDLIN( 683)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 683)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 683)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 683)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 683)					{
HXLINE( 683)						b1->width = width;
HXDLIN( 683)						b1->height = height;
HXDLIN( 683)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 683)						int size = (b1->length * 4);
HXDLIN( 683)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 683)						{
HXLINE( 683)							int _g6 = 0;
HXDLIN( 683)							int _g7 = b1->length;
HXDLIN( 683)							while((_g6 < _g7)){
HXLINE( 683)								_g6 = (_g6 + 1);
HXDLIN( 683)								int i1 = (_g6 - 1);
HXDLIN( 683)								{
HXLINE( 683)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 683)									bool undoImage2;
HXDLIN( 683)									if ((i1 >= 0)) {
HXLINE( 683)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 683)										undoImage2 = false;
            									}
HXDLIN( 683)									if (undoImage2) {
HXLINE( 683)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 683)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 683)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 683)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 683)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 683)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 683)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 683)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 683)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 683)					{
HXLINE( 683)						v->width = width;
HXDLIN( 683)						v->height = height;
HXDLIN( 683)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 683)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 683)						{
HXLINE( 683)							int _g8 = 0;
HXDLIN( 683)							int _g9 = v->length;
HXDLIN( 683)							while((_g8 < _g9)){
HXLINE( 683)								_g8 = (_g8 + 1);
HXDLIN( 683)								int i2 = (_g8 - 1);
HXDLIN( 683)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 683)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 683)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 683)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 683)					{
HXLINE( 683)						b2->width = width;
HXDLIN( 683)						b2->height = height;
HXDLIN( 683)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 683)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 683)						{
HXLINE( 683)							int len1 = b2->length;
HXDLIN( 683)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 683)							if (::hx::IsNull( d->head )) {
HXLINE( 683)								int _g10 = 0;
HXDLIN( 683)								int _g11 = len1;
HXDLIN( 683)								while((_g10 < _g11)){
HXLINE( 683)									_g10 = (_g10 + 1);
HXDLIN( 683)									int i3 = (_g10 - 1);
HXDLIN( 683)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 683)								int _g12 = 0;
HXDLIN( 683)								int _g13 = len1;
HXDLIN( 683)								while((_g12 < _g13)){
HXLINE( 683)									_g12 = (_g12 + 1);
HXDLIN( 683)									int i4 = (_g12 - 1);
HXDLIN( 683)									{
HXLINE( 683)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 683)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 683)										{
HXLINE( 683)											int _g14 = 0;
HXDLIN( 683)											int _g15 = i4;
HXDLIN( 683)											while((_g14 < _g15)){
HXLINE( 683)												_g14 = (_g14 + 1);
HXDLIN( 683)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 683)										if (::hx::IsNull( prev )) {
HXLINE( 683)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 683)											l = null();
            										}
            										else {
HXLINE( 683)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 683)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 683)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 683)			this1->image = undoImage1;
HXDLIN( 683)			this1->width = width;
HXDLIN( 683)			this1->height = height;
HXDLIN( 683)			this1->imageType = ( (int)(imageType) );
HXDLIN( 683)			undoImage = this1;
HXLINE( 684)			{
HXLINE( 684)				int rectLeft = xIter3->start;
HXDLIN( 684)				int rectTop = yIter3->start;
HXDLIN( 684)				int rectRight = xIter3->max;
HXDLIN( 684)				bool forceClear = false;
HXDLIN( 684)				{
HXLINE( 684)					int _g16 = rectTop;
HXDLIN( 684)					int _g17 = yIter3->max;
HXDLIN( 684)					while((_g16 < _g17)){
HXLINE( 684)						_g16 = (_g16 + 1);
HXDLIN( 684)						int dy = (_g16 - 1);
HXDLIN( 684)						{
HXLINE( 684)							int _g18 = rectLeft;
HXDLIN( 684)							int _g19 = rectRight;
HXDLIN( 684)							while((_g18 < _g19)){
HXLINE( 684)								_g18 = (_g18 + 1);
HXDLIN( 684)								int dx = (_g18 - 1);
HXDLIN( 684)								::Dynamic this3 = pixelImage->image;
HXDLIN( 684)								int index;
HXDLIN( 684)								if (pixelImage->useVirtualPos) {
HXLINE( 684)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 684)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 684)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 684)								int col;
HXDLIN( 684)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 684)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 684)									col = c;
            								}
HXDLIN( 684)								bool _hx_tmp;
HXDLIN( 684)								if (pixelImage->useMask) {
HXLINE( 684)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 684)									_hx_tmp = false;
            								}
HXDLIN( 684)								if (_hx_tmp) {
HXLINE( 684)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 684)									::Dynamic this5 = this4->image;
HXDLIN( 684)									int index1;
HXDLIN( 684)									if (this4->useVirtualPos) {
HXLINE( 684)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 684)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 684)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 684)									int v1;
HXDLIN( 684)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 684)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 684)										v1 = c1;
            									}
HXDLIN( 684)									int maskPixel = v1;
HXDLIN( 684)									int this6 = col;
HXDLIN( 684)									if ((maskPixel == 0)) {
HXLINE( 684)										col = this6;
            									}
            									else {
HXLINE( 684)										Float m0;
HXDLIN( 684)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 684)										if ((this7 == 0)) {
HXLINE( 684)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float m1;
HXDLIN( 684)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 684)										if ((this8 == 0)) {
HXLINE( 684)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float m2;
HXDLIN( 684)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 684)										if ((this9 == 0)) {
HXLINE( 684)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float m3;
HXDLIN( 684)										int this10 = (maskPixel & 255);
HXDLIN( 684)										if ((this10 == 0)) {
HXLINE( 684)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 684)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 684)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 684)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 684)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 684)								if ((col != 0)) {
HXLINE( 684)									int x1 = (dx - rectLeft);
HXDLIN( 684)									int y1 = (dy - rectTop);
HXDLIN( 684)									int c2 = col;
HXDLIN( 684)									bool _hx_tmp1;
HXDLIN( 684)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 684)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 684)										_hx_tmp1 = false;
            									}
HXDLIN( 684)									if (_hx_tmp1) {
HXLINE( 684)										int location;
HXDLIN( 684)										if (undoImage->useVirtualPos) {
HXLINE( 684)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 684)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 684)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 684)										int this12;
HXDLIN( 684)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 684)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 684)											this12 = this11;
            										}
HXDLIN( 684)										Float a1;
HXDLIN( 684)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 684)										if ((this13 == 0)) {
HXLINE( 684)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float r1;
HXDLIN( 684)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 684)										if ((this14 == 0)) {
HXLINE( 684)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float g1;
HXDLIN( 684)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 684)										if ((this15 == 0)) {
HXLINE( 684)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float b11;
HXDLIN( 684)										int this16 = (this12 & 255);
HXDLIN( 684)										if ((this16 == 0)) {
HXLINE( 684)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float a2;
HXDLIN( 684)										int this17 = ((col >> 24) & 255);
HXDLIN( 684)										if ((this17 == 0)) {
HXLINE( 684)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float r2;
HXDLIN( 684)										int this18 = ((col >> 16) & 255);
HXDLIN( 684)										if ((this18 == 0)) {
HXLINE( 684)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float g2;
HXDLIN( 684)										int this19 = ((col >> 8) & 255);
HXDLIN( 684)										if ((this19 == 0)) {
HXLINE( 684)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float b21;
HXDLIN( 684)										int this20 = (col & 255);
HXDLIN( 684)										if ((this20 == 0)) {
HXLINE( 684)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 684)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 684)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 684)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 684)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 684)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 684)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 684)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 684)										{
HXLINE( 684)											int _hx_tmp2;
HXDLIN( 684)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 684)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 684)												_hx_tmp2 = blended;
            											}
HXDLIN( 684)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 684)										::Dynamic this21 = undoImage->image;
HXDLIN( 684)										int index2;
HXDLIN( 684)										if (undoImage->useVirtualPos) {
HXLINE( 684)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 684)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 684)										int _hx_tmp3;
HXDLIN( 684)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 684)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 684)											_hx_tmp3 = c2;
            										}
HXDLIN( 684)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 684)									if (forceClear) {
HXLINE( 684)										::Dynamic this22 = undoImage->image;
HXDLIN( 684)										int x2 = (dx - rectLeft);
HXDLIN( 684)										int y2 = (dy - rectTop);
HXDLIN( 684)										int index3;
HXDLIN( 684)										if (undoImage->useVirtualPos) {
HXLINE( 684)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 684)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 684)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 686)		bool found = false;
HXLINE( 687)		Float min4 = ( (Float)(0) );
HXLINE( 688)		Float max = ( (Float)(0) );
HXLINE( 689)		int a5 = 0;
HXLINE( 690)		int r3 = 0;
HXLINE( 691)		int g3 = 0;
HXLINE( 692)		int b4 = 0;
HXLINE( 693)		{
HXLINE( 693)			int _g_min = xIter3->start;
HXDLIN( 693)			int _g_max = xIter3->max;
HXDLIN( 693)			while((_g_min < _g_max)){
HXLINE( 693)				_g_min = (_g_min + 1);
HXDLIN( 693)				int px = (_g_min - 1);
HXLINE( 694)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 695)				found = false;
HXLINE( 696)				{
HXLINE( 696)					int _g_min1 = yIter3->start;
HXDLIN( 696)					int _g_max1 = yIter3->max;
HXDLIN( 696)					while((_g_min1 < _g_max1)){
HXLINE( 696)						_g_min1 = (_g_min1 + 1);
HXDLIN( 696)						int py = (_g_min1 - 1);
HXLINE( 697)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 698)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 699)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 700)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 701)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 702)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 703)						bool _hx_tmp4;
HXDLIN( 703)						bool _hx_tmp5;
HXDLIN( 703)						if ((ratioA >= 0)) {
HXLINE( 703)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 703)							_hx_tmp5 = false;
            						}
HXDLIN( 703)						if (_hx_tmp5) {
HXLINE( 703)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 703)							_hx_tmp4 = false;
            						}
HXDLIN( 703)						if (_hx_tmp4) {
HXLINE( 705)							if (softAB) {
HXLINE( 705)								if (softBC) {
HXLINE( 705)									if (softCA) {
HXLINE( 739)										Float min5;
HXDLIN( 739)										if ((ratioA < ratioB)) {
HXLINE( 739)											min5 = ratioA;
            										}
            										else {
HXLINE( 739)											min5 = ratioB;
            										}
HXLINE( 740)										if (!((min5 < ratioC))) {
HXLINE( 740)											min5 = ratioC;
            										}
HXLINE( 741)										Float max1;
HXDLIN( 741)										if ((ratioA > ratioB)) {
HXLINE( 741)											max1 = ratioA;
            										}
            										else {
HXLINE( 741)											max1 = ratioB;
            										}
HXLINE( 742)										if (!((max1 > ratioC))) {
HXLINE( 742)											max1 = ratioC;
            										}
HXLINE( 743)										max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 744)										Float min6;
HXDLIN( 744)										if ((min5 < max1)) {
HXLINE( 744)											min6 = min5;
            										}
            										else {
HXLINE( 744)											min6 = ((max1 + min5) / ( (Float)(2) ));
            										}
HXLINE( 745)										int i6 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min6));
HXDLIN( 745)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE( 745)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE( 745)										a5 = i6;
            									}
            									else {
HXLINE( 732)										if ((ratioB < ratioC)) {
HXLINE( 732)											min4 = ratioB;
            										}
            										else {
HXLINE( 732)											min4 = ratioC;
            										}
HXLINE( 733)										if ((ratioA > ratioB)) {
HXLINE( 733)											max = ratioA;
            										}
            										else {
HXLINE( 733)											max = ratioB;
            										}
HXLINE( 734)										if (!((max > ratioC))) {
HXLINE( 734)											max = ratioC;
            										}
HXLINE( 735)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 736)										if (!((min4 < max))) {
HXLINE( 736)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXLINE( 737)										int i7 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 737)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE( 737)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE( 737)										a5 = i7;
            									}
            								}
            								else {
HXLINE( 705)									if (softCA) {
HXLINE( 725)										if ((ratioA < ratioC)) {
HXLINE( 725)											min4 = ratioA;
            										}
            										else {
HXLINE( 725)											min4 = ratioC;
            										}
HXLINE( 726)										if ((ratioA > ratioB)) {
HXLINE( 726)											max = ratioA;
            										}
            										else {
HXLINE( 726)											max = ratioB;
            										}
HXLINE( 727)										if (!((max > ratioC))) {
HXLINE( 727)											max = ratioC;
            										}
HXLINE( 728)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 729)										if (!((min4 < max))) {
HXLINE( 729)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXLINE( 730)										int i8 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 730)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE( 730)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE( 730)										a5 = i8;
            									}
            									else {
HXLINE( 722)										min4 = ratioC;
HXLINE( 723)										int i9 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 723)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE( 723)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE( 723)										a5 = i9;
            									}
            								}
            							}
            							else {
HXLINE( 705)								if (softBC) {
HXLINE( 705)									if (softCA) {
HXLINE( 715)										if ((ratioA < ratioB)) {
HXLINE( 715)											min4 = ratioA;
            										}
            										else {
HXLINE( 715)											min4 = ratioB;
            										}
HXLINE( 716)										if ((ratioA > ratioB)) {
HXLINE( 716)											max = ratioA;
            										}
            										else {
HXLINE( 716)											max = ratioB;
            										}
HXLINE( 717)										if (!((max > ratioC))) {
HXLINE( 717)											max = ratioC;
            										}
HXLINE( 718)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 719)										if (!((min4 < max))) {
HXLINE( 719)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXLINE( 720)										int i10 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 720)										if ((i10 > 255)) {
HXLINE(  24)											i10 = 255;
            										}
HXLINE( 720)										if ((i10 < 0)) {
HXLINE(  25)											i10 = 0;
            										}
HXLINE( 720)										a5 = i10;
            									}
            									else {
HXLINE( 712)										min4 = ratioB;
HXLINE( 713)										int i11 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 713)										if ((i11 > 255)) {
HXLINE(  24)											i11 = 255;
            										}
HXLINE( 713)										if ((i11 < 0)) {
HXLINE(  25)											i11 = 0;
            										}
HXLINE( 713)										a5 = i11;
            									}
            								}
            								else {
HXLINE( 705)									if (softCA) {
HXLINE( 709)										min4 = ratioA;
HXLINE( 710)										int i12 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 710)										if ((i12 > 255)) {
HXLINE(  24)											i12 = 255;
            										}
HXLINE( 710)										if ((i12 < 0)) {
HXLINE(  25)											i12 = 0;
            										}
HXLINE( 710)										a5 = i12;
            									}
            									else {
HXLINE( 707)										int i13 = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN( 707)										if ((i13 > 255)) {
HXLINE(  24)											i13 = 255;
            										}
HXLINE( 707)										if ((i13 < 0)) {
HXLINE(  25)											i13 = 0;
            										}
HXLINE( 707)										a5 = i13;
            									}
            								}
            							}
HXLINE( 747)							int i14 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 747)							if ((i14 > 255)) {
HXLINE(  24)								i14 = 255;
            							}
HXLINE( 747)							if ((i14 < 0)) {
HXLINE(  25)								i14 = 0;
            							}
HXLINE( 747)							r3 = i14;
HXLINE( 748)							int i15 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 748)							if ((i15 > 255)) {
HXLINE(  24)								i15 = 255;
            							}
HXLINE( 748)							if ((i15 < 0)) {
HXLINE(  25)								i15 = 0;
            							}
HXLINE( 748)							g3 = i15;
HXLINE( 749)							int i16 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 749)							if ((i16 > 255)) {
HXLINE(  24)								i16 = 255;
            							}
HXLINE( 749)							if ((i16 < 0)) {
HXLINE(  25)								i16 = 0;
            							}
HXLINE( 749)							b4 = i16;
HXLINE( 750)							{
HXLINE( 750)								int location1;
HXDLIN( 750)								if (pixelImage->useVirtualPos) {
HXLINE( 750)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 750)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 750)								bool _hx_tmp6;
HXDLIN( 750)								if (pixelImage->transparent) {
HXLINE( 750)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 750)									_hx_tmp6 = false;
            								}
HXDLIN( 750)								if (_hx_tmp6) {
HXLINE( 750)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 750)									int old;
HXDLIN( 750)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 750)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 750)										old = this23;
            									}
HXDLIN( 750)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 750)									Float a11;
HXDLIN( 750)									int this24 = ((old >> 24) & 255);
HXDLIN( 750)									if ((this24 == 0)) {
HXLINE( 750)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float r11;
HXDLIN( 750)									int this25 = ((old >> 16) & 255);
HXDLIN( 750)									if ((this25 == 0)) {
HXLINE( 750)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float g11;
HXDLIN( 750)									int this26 = ((old >> 8) & 255);
HXDLIN( 750)									if ((this26 == 0)) {
HXLINE( 750)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float b12;
HXDLIN( 750)									int this27 = (old & 255);
HXDLIN( 750)									if ((this27 == 0)) {
HXLINE( 750)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float a21;
HXDLIN( 750)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 750)									if ((this28 == 0)) {
HXLINE( 750)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float r21;
HXDLIN( 750)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 750)									if ((this29 == 0)) {
HXLINE( 750)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float g21;
HXDLIN( 750)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 750)									if ((this30 == 0)) {
HXLINE( 750)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float b22;
HXDLIN( 750)									int this31 = (rhs & 255);
HXDLIN( 750)									if ((this31 == 0)) {
HXLINE( 750)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 750)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 750)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 750)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 750)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 750)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 750)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 750)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 750)									{
HXLINE( 750)										int _hx_tmp7;
HXDLIN( 750)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 750)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 750)											_hx_tmp7 = blended1;
            										}
HXDLIN( 750)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 750)									int value;
HXDLIN( 750)									if (pixelImage->isLittle) {
HXLINE( 750)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 750)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 750)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
HXLINE( 751)							found = true;
            						}
            						else {
HXLINE( 752)							if (found) {
HXLINE( 754)								goto _hx_goto_231;
            							}
            						}
            					}
            					_hx_goto_231:;
            				}
            			}
            		}
HXLINE( 760)		if ((hasHit == false)) {
HXLINE( 761)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 762)			if (hasUndo) {
HXLINE( 763)				v2->undoImage = undoImage;
HXLINE( 764)				v2->undoX = xIter3->start;
HXLINE( 765)				v2->undoY = yIter3->start;
            			}
HXLINE( 767)			return v2;
            		}
            		else {
HXLINE( 769)			return null();
            		}
HXLINE( 760)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(TriPixel_Fields__obj,fillTriSoft3,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillQuarterSoft( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< Float >  __o_soft3,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		Float soft3 = __o_soft3.Default(40);
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCA = __o_softCA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_782_fillQuarterSoft)
HXLINE( 783)		int aA = ((color >> 24) & 255);
HXLINE( 784)		int rA = ((color >> 16) & 255);
HXLINE( 785)		int gA = ((color >> 8) & 255);
HXLINE( 786)		int bA = (color & 255);
HXLINE( 787)		Float bcx = (bx - cx);
HXLINE( 788)		Float bcy = (by - cy);
HXLINE( 789)		Float acx = (ax - cx);
HXLINE( 790)		Float acy = (ay - cy);
HXLINE( 792)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 793)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 794)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 795)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 796)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 796)		if ((ax > bx)) {
HXLINE( 796)			if ((ax > cx)) {
HXLINE( 796)				int min;
HXDLIN( 796)				if ((bx > cx)) {
HXLINE( 796)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 796)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 796)				int ii_min = min;
HXDLIN( 796)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 796)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 796)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 796)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 796)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 796)			if ((bx > cx)) {
HXLINE( 796)				int min1;
HXDLIN( 796)				if ((ax > cx)) {
HXLINE( 796)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 796)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 796)				int ii_min2 = min1;
HXDLIN( 796)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 796)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 796)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 796)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 796)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 797)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 797)		if ((ay > by)) {
HXLINE( 797)			if ((ay > cy)) {
HXLINE( 797)				int min2;
HXDLIN( 797)				if ((by > cy)) {
HXLINE( 797)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 797)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 797)				int ii_min4 = min2;
HXDLIN( 797)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 797)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 797)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 797)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 797)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 797)			if ((by > cy)) {
HXLINE( 797)				int min3;
HXDLIN( 797)				if ((ay > cy)) {
HXLINE( 797)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 797)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 797)				int ii_min6 = min3;
HXDLIN( 797)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 797)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 797)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 797)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 797)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 798)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 799)		if (hasUndo) {
HXLINE( 800)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 800)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 800)			 ::Dynamic imageType = null();
HXDLIN( 800)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 800)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 800)			::Dynamic undoImage1;
HXDLIN( 800)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 800)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 800)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 800)					{
HXLINE( 800)						b->width = width;
HXDLIN( 800)						b->height = height;
HXDLIN( 800)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 800)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 800)						{
HXLINE( 800)							int len = b->length;
HXDLIN( 800)							int w = 0;
HXDLIN( 800)							{
HXLINE( 800)								int _g = 0;
HXDLIN( 800)								int _g1 = b->height;
HXDLIN( 800)								while((_g < _g1)){
HXLINE( 800)									_g = (_g + 1);
HXDLIN( 800)									int y = (_g - 1);
HXDLIN( 800)									{
HXLINE( 800)										int _g2 = 0;
HXDLIN( 800)										int _g3 = b->width;
HXDLIN( 800)										while((_g2 < _g3)){
HXLINE( 800)											_g2 = (_g2 + 1);
HXDLIN( 800)											int x = (_g2 - 1);
HXDLIN( 800)											{
HXLINE( 800)												w = (w + 1);
HXDLIN( 800)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 800)											{
HXLINE( 800)												w = (w + 1);
HXDLIN( 800)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 800)											{
HXLINE( 800)												w = (w + 1);
HXDLIN( 800)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 800)											{
HXLINE( 800)												w = (w + 1);
HXDLIN( 800)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 800)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 800)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 800)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 800)					{
HXLINE( 800)						a->width = width;
HXDLIN( 800)						a->height = height;
HXDLIN( 800)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 800)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 800)						{
HXLINE( 800)							int _g4 = 0;
HXDLIN( 800)							int _g5 = a->length;
HXDLIN( 800)							while((_g4 < _g5)){
HXLINE( 800)								_g4 = (_g4 + 1);
HXDLIN( 800)								int i = (_g4 - 1);
HXDLIN( 800)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 800)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 800)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 800)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 800)					{
HXLINE( 800)						b1->width = width;
HXDLIN( 800)						b1->height = height;
HXDLIN( 800)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 800)						int size = (b1->length * 4);
HXDLIN( 800)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 800)						{
HXLINE( 800)							int _g6 = 0;
HXDLIN( 800)							int _g7 = b1->length;
HXDLIN( 800)							while((_g6 < _g7)){
HXLINE( 800)								_g6 = (_g6 + 1);
HXDLIN( 800)								int i1 = (_g6 - 1);
HXDLIN( 800)								{
HXLINE( 800)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 800)									bool undoImage2;
HXDLIN( 800)									if ((i1 >= 0)) {
HXLINE( 800)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 800)										undoImage2 = false;
            									}
HXDLIN( 800)									if (undoImage2) {
HXLINE( 800)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 800)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 800)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 800)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 800)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 800)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 800)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 800)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 800)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 800)					{
HXLINE( 800)						v->width = width;
HXDLIN( 800)						v->height = height;
HXDLIN( 800)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 800)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 800)						{
HXLINE( 800)							int _g8 = 0;
HXDLIN( 800)							int _g9 = v->length;
HXDLIN( 800)							while((_g8 < _g9)){
HXLINE( 800)								_g8 = (_g8 + 1);
HXDLIN( 800)								int i2 = (_g8 - 1);
HXDLIN( 800)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 800)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 800)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 800)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 800)					{
HXLINE( 800)						b2->width = width;
HXDLIN( 800)						b2->height = height;
HXDLIN( 800)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 800)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 800)						{
HXLINE( 800)							int len1 = b2->length;
HXDLIN( 800)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 800)							if (::hx::IsNull( d->head )) {
HXLINE( 800)								int _g10 = 0;
HXDLIN( 800)								int _g11 = len1;
HXDLIN( 800)								while((_g10 < _g11)){
HXLINE( 800)									_g10 = (_g10 + 1);
HXDLIN( 800)									int i3 = (_g10 - 1);
HXDLIN( 800)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 800)								int _g12 = 0;
HXDLIN( 800)								int _g13 = len1;
HXDLIN( 800)								while((_g12 < _g13)){
HXLINE( 800)									_g12 = (_g12 + 1);
HXDLIN( 800)									int i4 = (_g12 - 1);
HXDLIN( 800)									{
HXLINE( 800)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 800)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 800)										{
HXLINE( 800)											int _g14 = 0;
HXDLIN( 800)											int _g15 = i4;
HXDLIN( 800)											while((_g14 < _g15)){
HXLINE( 800)												_g14 = (_g14 + 1);
HXDLIN( 800)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 800)										if (::hx::IsNull( prev )) {
HXLINE( 800)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 800)											l = null();
            										}
            										else {
HXLINE( 800)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 800)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 800)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 800)			this1->image = undoImage1;
HXDLIN( 800)			this1->width = width;
HXDLIN( 800)			this1->height = height;
HXDLIN( 800)			this1->imageType = ( (int)(imageType) );
HXDLIN( 800)			undoImage = this1;
HXLINE( 801)			{
HXLINE( 801)				int rectLeft = xIter3->start;
HXDLIN( 801)				int rectTop = yIter3->start;
HXDLIN( 801)				int rectRight = xIter3->max;
HXDLIN( 801)				bool forceClear = false;
HXDLIN( 801)				{
HXLINE( 801)					int _g16 = rectTop;
HXDLIN( 801)					int _g17 = yIter3->max;
HXDLIN( 801)					while((_g16 < _g17)){
HXLINE( 801)						_g16 = (_g16 + 1);
HXDLIN( 801)						int dy = (_g16 - 1);
HXDLIN( 801)						{
HXLINE( 801)							int _g18 = rectLeft;
HXDLIN( 801)							int _g19 = rectRight;
HXDLIN( 801)							while((_g18 < _g19)){
HXLINE( 801)								_g18 = (_g18 + 1);
HXDLIN( 801)								int dx = (_g18 - 1);
HXDLIN( 801)								::Dynamic this3 = pixelImage->image;
HXDLIN( 801)								int index;
HXDLIN( 801)								if (pixelImage->useVirtualPos) {
HXLINE( 801)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 801)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 801)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 801)								int col;
HXDLIN( 801)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 801)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 801)									col = c;
            								}
HXDLIN( 801)								bool _hx_tmp;
HXDLIN( 801)								if (pixelImage->useMask) {
HXLINE( 801)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 801)									_hx_tmp = false;
            								}
HXDLIN( 801)								if (_hx_tmp) {
HXLINE( 801)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 801)									::Dynamic this5 = this4->image;
HXDLIN( 801)									int index1;
HXDLIN( 801)									if (this4->useVirtualPos) {
HXLINE( 801)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 801)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 801)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 801)									int v1;
HXDLIN( 801)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 801)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 801)										v1 = c1;
            									}
HXDLIN( 801)									int maskPixel = v1;
HXDLIN( 801)									int this6 = col;
HXDLIN( 801)									if ((maskPixel == 0)) {
HXLINE( 801)										col = this6;
            									}
            									else {
HXLINE( 801)										Float m0;
HXDLIN( 801)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 801)										if ((this7 == 0)) {
HXLINE( 801)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float m1;
HXDLIN( 801)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 801)										if ((this8 == 0)) {
HXLINE( 801)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float m2;
HXDLIN( 801)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 801)										if ((this9 == 0)) {
HXLINE( 801)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float m3;
HXDLIN( 801)										int this10 = (maskPixel & 255);
HXDLIN( 801)										if ((this10 == 0)) {
HXLINE( 801)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 801)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 801)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 801)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 801)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 801)								if ((col != 0)) {
HXLINE( 801)									int x1 = (dx - rectLeft);
HXDLIN( 801)									int y1 = (dy - rectTop);
HXDLIN( 801)									int c2 = col;
HXDLIN( 801)									bool _hx_tmp1;
HXDLIN( 801)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 801)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 801)										_hx_tmp1 = false;
            									}
HXDLIN( 801)									if (_hx_tmp1) {
HXLINE( 801)										int location;
HXDLIN( 801)										if (undoImage->useVirtualPos) {
HXLINE( 801)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 801)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 801)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 801)										int this12;
HXDLIN( 801)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 801)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 801)											this12 = this11;
            										}
HXDLIN( 801)										Float a1;
HXDLIN( 801)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 801)										if ((this13 == 0)) {
HXLINE( 801)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float r1;
HXDLIN( 801)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 801)										if ((this14 == 0)) {
HXLINE( 801)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float g1;
HXDLIN( 801)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 801)										if ((this15 == 0)) {
HXLINE( 801)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float b11;
HXDLIN( 801)										int this16 = (this12 & 255);
HXDLIN( 801)										if ((this16 == 0)) {
HXLINE( 801)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float a2;
HXDLIN( 801)										int this17 = ((col >> 24) & 255);
HXDLIN( 801)										if ((this17 == 0)) {
HXLINE( 801)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float r2;
HXDLIN( 801)										int this18 = ((col >> 16) & 255);
HXDLIN( 801)										if ((this18 == 0)) {
HXLINE( 801)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float g2;
HXDLIN( 801)										int this19 = ((col >> 8) & 255);
HXDLIN( 801)										if ((this19 == 0)) {
HXLINE( 801)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float b21;
HXDLIN( 801)										int this20 = (col & 255);
HXDLIN( 801)										if ((this20 == 0)) {
HXLINE( 801)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 801)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 801)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 801)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 801)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 801)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 801)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 801)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 801)										{
HXLINE( 801)											int _hx_tmp2;
HXDLIN( 801)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 801)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 801)												_hx_tmp2 = blended;
            											}
HXDLIN( 801)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 801)										::Dynamic this21 = undoImage->image;
HXDLIN( 801)										int index2;
HXDLIN( 801)										if (undoImage->useVirtualPos) {
HXLINE( 801)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 801)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 801)										int _hx_tmp3;
HXDLIN( 801)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 801)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 801)											_hx_tmp3 = c2;
            										}
HXDLIN( 801)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 801)									if (forceClear) {
HXLINE( 801)										::Dynamic this22 = undoImage->image;
HXDLIN( 801)										int x2 = (dx - rectLeft);
HXDLIN( 801)										int y2 = (dy - rectTop);
HXDLIN( 801)										int index3;
HXDLIN( 801)										if (undoImage->useVirtualPos) {
HXLINE( 801)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 801)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 801)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 803)		bool found = false;
HXLINE( 804)		Float min4 = ( (Float)(0) );
HXLINE( 805)		Float max = ( (Float)(0) );
HXLINE( 806)		int a5 = 0;
HXLINE( 807)		int r3 = 0;
HXLINE( 808)		int g3 = 0;
HXLINE( 809)		int b4 = 0;
HXLINE( 810)		{
HXLINE( 810)			int _g_min = xIter3->start;
HXDLIN( 810)			int _g_max = xIter3->max;
HXDLIN( 810)			while((_g_min < _g_max)){
HXLINE( 810)				_g_min = (_g_min + 1);
HXDLIN( 810)				int px = (_g_min - 1);
HXLINE( 811)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 812)				found = false;
HXLINE( 813)				{
HXLINE( 813)					int _g_min1 = yIter3->start;
HXDLIN( 813)					int _g_max1 = yIter3->max;
HXDLIN( 813)					while((_g_min1 < _g_max1)){
HXLINE( 813)						_g_min1 = (_g_min1 + 1);
HXDLIN( 813)						int py = (_g_min1 - 1);
HXLINE( 814)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 815)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 816)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 817)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 818)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 819)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 820)						bool _hx_tmp4;
HXDLIN( 820)						bool _hx_tmp5;
HXDLIN( 820)						if ((ratioA >= 0)) {
HXLINE( 820)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 820)							_hx_tmp5 = false;
            						}
HXDLIN( 820)						if (_hx_tmp5) {
HXLINE( 820)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 820)							_hx_tmp4 = false;
            						}
HXDLIN( 820)						if (_hx_tmp4) {
HXLINE( 821)							int i6 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 821)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 821)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 821)							r3 = i6;
HXLINE( 822)							int i7 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 822)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 822)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 822)							g3 = i7;
HXLINE( 823)							int i8 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 823)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 823)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 823)							b4 = i8;
HXLINE( 824)							bool _hx_tmp6;
HXDLIN( 824)							bool _hx_tmp7;
HXDLIN( 824)							if ((softAB == true)) {
HXLINE( 824)								_hx_tmp7 = (softBC == false);
            							}
            							else {
HXLINE( 824)								_hx_tmp7 = false;
            							}
HXDLIN( 824)							if (_hx_tmp7) {
HXLINE( 824)								_hx_tmp6 = (softCA == true);
            							}
            							else {
HXLINE( 824)								_hx_tmp6 = false;
            							}
HXDLIN( 824)							if (_hx_tmp6) {
HXLINE( 825)								if ((ratioA < ratioC)) {
HXLINE( 825)									min4 = ratioA;
            								}
            								else {
HXLINE( 825)									min4 = ratioC;
            								}
HXLINE( 827)								if ((ratioA > ratioB)) {
HXLINE( 827)									max = ratioA;
            								}
            								else {
HXLINE( 827)									max = ratioB;
            								}
HXLINE( 828)								if (!((max > ratioC))) {
HXLINE( 828)									max = ratioC;
            								}
HXLINE( 829)								max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 830)								if (!((min4 < max))) {
HXLINE( 830)									min4 = ((max + min4) / ( (Float)(2) ));
            								}
HXLINE( 832)								int i9 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 832)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 832)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 832)								a5 = i9;
HXLINE( 834)								{
HXLINE( 834)									int location1;
HXDLIN( 834)									if (pixelImage->useVirtualPos) {
HXLINE( 834)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 834)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 834)									bool _hx_tmp8;
HXDLIN( 834)									if (pixelImage->transparent) {
HXLINE( 834)										_hx_tmp8 = (a5 < 254);
            									}
            									else {
HXLINE( 834)										_hx_tmp8 = false;
            									}
HXDLIN( 834)									if (_hx_tmp8) {
HXLINE( 834)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 834)										int old;
HXDLIN( 834)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 834)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 834)											old = this23;
            										}
HXDLIN( 834)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 834)										Float a11;
HXDLIN( 834)										int this24 = ((old >> 24) & 255);
HXDLIN( 834)										if ((this24 == 0)) {
HXLINE( 834)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float r11;
HXDLIN( 834)										int this25 = ((old >> 16) & 255);
HXDLIN( 834)										if ((this25 == 0)) {
HXLINE( 834)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float g11;
HXDLIN( 834)										int this26 = ((old >> 8) & 255);
HXDLIN( 834)										if ((this26 == 0)) {
HXLINE( 834)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float b12;
HXDLIN( 834)										int this27 = (old & 255);
HXDLIN( 834)										if ((this27 == 0)) {
HXLINE( 834)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float a21;
HXDLIN( 834)										int this28 = ((rhs >> 24) & 255);
HXDLIN( 834)										if ((this28 == 0)) {
HXLINE( 834)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float r21;
HXDLIN( 834)										int this29 = ((rhs >> 16) & 255);
HXDLIN( 834)										if ((this29 == 0)) {
HXLINE( 834)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float g21;
HXDLIN( 834)										int this30 = ((rhs >> 8) & 255);
HXDLIN( 834)										if ((this30 == 0)) {
HXLINE( 834)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float b22;
HXDLIN( 834)										int this31 = (rhs & 255);
HXDLIN( 834)										if ((this31 == 0)) {
HXLINE( 834)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 834)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 834)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 834)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 834)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 834)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 834)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 834)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 834)										{
HXLINE( 834)											int _hx_tmp9;
HXDLIN( 834)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 834)												_hx_tmp9 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 834)												_hx_tmp9 = blended1;
            											}
HXDLIN( 834)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp9);
            										}
            									}
            									else {
HXLINE( 834)										int value;
HXDLIN( 834)										if (pixelImage->isLittle) {
HXLINE( 834)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 834)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 834)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
            							}
HXLINE( 837)							bool _hx_tmp10;
HXDLIN( 837)							bool _hx_tmp11;
HXDLIN( 837)							if ((softAB == true)) {
HXLINE( 837)								_hx_tmp11 = (softBC == true);
            							}
            							else {
HXLINE( 837)								_hx_tmp11 = false;
            							}
HXDLIN( 837)							if (_hx_tmp11) {
HXLINE( 837)								_hx_tmp10 = (softCA == false);
            							}
            							else {
HXLINE( 837)								_hx_tmp10 = false;
            							}
HXDLIN( 837)							if (_hx_tmp10) {
HXLINE( 838)								if ((ratioB < ratioC)) {
HXLINE( 838)									min4 = ratioB;
            								}
            								else {
HXLINE( 838)									min4 = ratioC;
            								}
HXLINE( 840)								if ((ratioA > ratioB)) {
HXLINE( 840)									max = ratioA;
            								}
            								else {
HXLINE( 840)									max = ratioB;
            								}
HXLINE( 841)								if (!((max > ratioC))) {
HXLINE( 841)									max = ratioC;
            								}
HXLINE( 842)								max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 843)								if (!((min4 < max))) {
HXLINE( 843)									min4 = ((max + min4) / ( (Float)(2) ));
            								}
HXLINE( 845)								int i10 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min4));
HXDLIN( 845)								if ((i10 > 255)) {
HXLINE(  24)									i10 = 255;
            								}
HXLINE( 845)								if ((i10 < 0)) {
HXLINE(  25)									i10 = 0;
            								}
HXLINE( 845)								a5 = i10;
HXLINE( 847)								{
HXLINE( 847)									int location2;
HXDLIN( 847)									if (pixelImage->useVirtualPos) {
HXLINE( 847)										location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 847)										location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 847)									bool _hx_tmp12;
HXDLIN( 847)									if (pixelImage->transparent) {
HXLINE( 847)										_hx_tmp12 = (a5 < 254);
            									}
            									else {
HXLINE( 847)										_hx_tmp12 = false;
            									}
HXDLIN( 847)									if (_hx_tmp12) {
HXLINE( 847)										int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN( 847)										int old1;
HXDLIN( 847)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 847)											old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            										}
            										else {
HXLINE( 847)											old1 = this32;
            										}
HXDLIN( 847)										int rhs1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 847)										Float a12;
HXDLIN( 847)										int this33 = ((old1 >> 24) & 255);
HXDLIN( 847)										if ((this33 == 0)) {
HXLINE( 847)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											a12 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float r12;
HXDLIN( 847)										int this34 = ((old1 >> 16) & 255);
HXDLIN( 847)										if ((this34 == 0)) {
HXLINE( 847)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float g12;
HXDLIN( 847)										int this35 = ((old1 >> 8) & 255);
HXDLIN( 847)										if ((this35 == 0)) {
HXLINE( 847)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float b13;
HXDLIN( 847)										int this36 = (old1 & 255);
HXDLIN( 847)										if ((this36 == 0)) {
HXLINE( 847)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float a22;
HXDLIN( 847)										int this37 = ((rhs1 >> 24) & 255);
HXDLIN( 847)										if ((this37 == 0)) {
HXLINE( 847)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float r22;
HXDLIN( 847)										int this38 = ((rhs1 >> 16) & 255);
HXDLIN( 847)										if ((this38 == 0)) {
HXLINE( 847)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float g22;
HXDLIN( 847)										int this39 = ((rhs1 >> 8) & 255);
HXDLIN( 847)										if ((this39 == 0)) {
HXLINE( 847)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float b23;
HXDLIN( 847)										int this40 = (rhs1 & 255);
HXDLIN( 847)										if ((this40 == 0)) {
HXLINE( 847)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 847)											b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            										}
HXDLIN( 847)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 847)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 847)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 847)										int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 847)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 847)										int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 847)										{
HXLINE( 847)											int _hx_tmp13;
HXDLIN( 847)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 847)												_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 847)												_hx_tmp13 = blended2;
            											}
HXDLIN( 847)											::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp13);
            										}
            									}
            									else {
HXLINE( 847)										int value1;
HXDLIN( 847)										if (pixelImage->isLittle) {
HXLINE( 847)											value1 = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 847)											value1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 847)										::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            									}
            								}
            							}
HXLINE( 850)							found = true;
            						}
            						else {
HXLINE( 851)							if (found) {
HXLINE( 853)								goto _hx_goto_244;
            							}
            						}
            					}
            					_hx_goto_244:;
            				}
            			}
            		}
HXLINE( 859)		if ((hasHit == false)) {
HXLINE( 860)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 861)			if (hasUndo) {
HXLINE( 862)				v2->undoImage = undoImage;
HXLINE( 863)				v2->undoX = xIter3->start;
HXLINE( 864)				v2->undoY = yIter3->start;
            			}
HXLINE( 866)			return v2;
            		}
            		else {
HXLINE( 868)			return null();
            		}
HXLINE( 859)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(TriPixel_Fields__obj,fillQuarterSoft,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriExtra0( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_878_fillTriExtra0)
HXLINE( 879)		int aA = ((color >> 24) & 255);
HXLINE( 880)		int rA = ((color >> 16) & 255);
HXLINE( 881)		int gA = ((color >> 8) & 255);
HXLINE( 882)		int bA = (color & 255);
HXLINE( 883)		Float bcx = (bx - cx);
HXLINE( 884)		Float bcy = (by - cy);
HXLINE( 885)		Float acx = (ax - cx);
HXLINE( 886)		Float acy = (ay - cy);
HXLINE( 888)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 889)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 890)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 891)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 892)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 892)		if ((ax > bx)) {
HXLINE( 892)			if ((ax > cx)) {
HXLINE( 892)				int min;
HXDLIN( 892)				if ((bx > cx)) {
HXLINE( 892)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 892)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 892)				int ii_min = min;
HXDLIN( 892)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 892)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 892)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 892)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 892)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 892)			if ((bx > cx)) {
HXLINE( 892)				int min1;
HXDLIN( 892)				if ((ax > cx)) {
HXLINE( 892)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 892)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 892)				int ii_min2 = min1;
HXDLIN( 892)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 892)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 892)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 892)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 892)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 893)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 893)		if ((ay > by)) {
HXLINE( 893)			if ((ay > cy)) {
HXLINE( 893)				int min2;
HXDLIN( 893)				if ((by > cy)) {
HXLINE( 893)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 893)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 893)				int ii_min4 = min2;
HXDLIN( 893)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 893)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 893)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 893)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 893)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 893)			if ((by > cy)) {
HXLINE( 893)				int min3;
HXDLIN( 893)				if ((ay > cy)) {
HXLINE( 893)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 893)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 893)				int ii_min6 = min3;
HXDLIN( 893)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 893)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 893)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 893)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 893)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 894)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 895)		if (hasUndo) {
HXLINE( 896)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 896)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 896)			 ::Dynamic imageType = null();
HXDLIN( 896)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 896)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 896)			::Dynamic undoImage1;
HXDLIN( 896)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 896)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 896)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 896)					{
HXLINE( 896)						b->width = width;
HXDLIN( 896)						b->height = height;
HXDLIN( 896)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 896)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 896)						{
HXLINE( 896)							int len = b->length;
HXDLIN( 896)							int w = 0;
HXDLIN( 896)							{
HXLINE( 896)								int _g = 0;
HXDLIN( 896)								int _g1 = b->height;
HXDLIN( 896)								while((_g < _g1)){
HXLINE( 896)									_g = (_g + 1);
HXDLIN( 896)									int y = (_g - 1);
HXDLIN( 896)									{
HXLINE( 896)										int _g2 = 0;
HXDLIN( 896)										int _g3 = b->width;
HXDLIN( 896)										while((_g2 < _g3)){
HXLINE( 896)											_g2 = (_g2 + 1);
HXDLIN( 896)											int x = (_g2 - 1);
HXDLIN( 896)											{
HXLINE( 896)												w = (w + 1);
HXDLIN( 896)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 896)											{
HXLINE( 896)												w = (w + 1);
HXDLIN( 896)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 896)											{
HXLINE( 896)												w = (w + 1);
HXDLIN( 896)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 896)											{
HXLINE( 896)												w = (w + 1);
HXDLIN( 896)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 896)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 896)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 896)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 896)					{
HXLINE( 896)						a->width = width;
HXDLIN( 896)						a->height = height;
HXDLIN( 896)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 896)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 896)						{
HXLINE( 896)							int _g4 = 0;
HXDLIN( 896)							int _g5 = a->length;
HXDLIN( 896)							while((_g4 < _g5)){
HXLINE( 896)								_g4 = (_g4 + 1);
HXDLIN( 896)								int i = (_g4 - 1);
HXDLIN( 896)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 896)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 896)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 896)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 896)					{
HXLINE( 896)						b1->width = width;
HXDLIN( 896)						b1->height = height;
HXDLIN( 896)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 896)						int size = (b1->length * 4);
HXDLIN( 896)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 896)						{
HXLINE( 896)							int _g6 = 0;
HXDLIN( 896)							int _g7 = b1->length;
HXDLIN( 896)							while((_g6 < _g7)){
HXLINE( 896)								_g6 = (_g6 + 1);
HXDLIN( 896)								int i1 = (_g6 - 1);
HXDLIN( 896)								{
HXLINE( 896)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 896)									bool undoImage2;
HXDLIN( 896)									if ((i1 >= 0)) {
HXLINE( 896)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 896)										undoImage2 = false;
            									}
HXDLIN( 896)									if (undoImage2) {
HXLINE( 896)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 896)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 896)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 896)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 896)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 896)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 896)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 896)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 896)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 896)					{
HXLINE( 896)						v->width = width;
HXDLIN( 896)						v->height = height;
HXDLIN( 896)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 896)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 896)						{
HXLINE( 896)							int _g8 = 0;
HXDLIN( 896)							int _g9 = v->length;
HXDLIN( 896)							while((_g8 < _g9)){
HXLINE( 896)								_g8 = (_g8 + 1);
HXDLIN( 896)								int i2 = (_g8 - 1);
HXDLIN( 896)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 896)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 896)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 896)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 896)					{
HXLINE( 896)						b2->width = width;
HXDLIN( 896)						b2->height = height;
HXDLIN( 896)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 896)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 896)						{
HXLINE( 896)							int len1 = b2->length;
HXDLIN( 896)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 896)							if (::hx::IsNull( d->head )) {
HXLINE( 896)								int _g10 = 0;
HXDLIN( 896)								int _g11 = len1;
HXDLIN( 896)								while((_g10 < _g11)){
HXLINE( 896)									_g10 = (_g10 + 1);
HXDLIN( 896)									int i3 = (_g10 - 1);
HXDLIN( 896)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 896)								int _g12 = 0;
HXDLIN( 896)								int _g13 = len1;
HXDLIN( 896)								while((_g12 < _g13)){
HXLINE( 896)									_g12 = (_g12 + 1);
HXDLIN( 896)									int i4 = (_g12 - 1);
HXDLIN( 896)									{
HXLINE( 896)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 896)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 896)										{
HXLINE( 896)											int _g14 = 0;
HXDLIN( 896)											int _g15 = i4;
HXDLIN( 896)											while((_g14 < _g15)){
HXLINE( 896)												_g14 = (_g14 + 1);
HXDLIN( 896)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 896)										if (::hx::IsNull( prev )) {
HXLINE( 896)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 896)											l = null();
            										}
            										else {
HXLINE( 896)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 896)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 896)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 896)			this1->image = undoImage1;
HXDLIN( 896)			this1->width = width;
HXDLIN( 896)			this1->height = height;
HXDLIN( 896)			this1->imageType = ( (int)(imageType) );
HXDLIN( 896)			undoImage = this1;
HXLINE( 897)			{
HXLINE( 897)				int rectLeft = xIter3->start;
HXDLIN( 897)				int rectTop = yIter3->start;
HXDLIN( 897)				int rectRight = xIter3->max;
HXDLIN( 897)				bool forceClear = false;
HXDLIN( 897)				{
HXLINE( 897)					int _g16 = rectTop;
HXDLIN( 897)					int _g17 = yIter3->max;
HXDLIN( 897)					while((_g16 < _g17)){
HXLINE( 897)						_g16 = (_g16 + 1);
HXDLIN( 897)						int dy = (_g16 - 1);
HXDLIN( 897)						{
HXLINE( 897)							int _g18 = rectLeft;
HXDLIN( 897)							int _g19 = rectRight;
HXDLIN( 897)							while((_g18 < _g19)){
HXLINE( 897)								_g18 = (_g18 + 1);
HXDLIN( 897)								int dx = (_g18 - 1);
HXDLIN( 897)								::Dynamic this3 = pixelImage->image;
HXDLIN( 897)								int index;
HXDLIN( 897)								if (pixelImage->useVirtualPos) {
HXLINE( 897)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 897)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 897)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 897)								int col;
HXDLIN( 897)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 897)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 897)									col = c;
            								}
HXDLIN( 897)								bool _hx_tmp;
HXDLIN( 897)								if (pixelImage->useMask) {
HXLINE( 897)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 897)									_hx_tmp = false;
            								}
HXDLIN( 897)								if (_hx_tmp) {
HXLINE( 897)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 897)									::Dynamic this5 = this4->image;
HXDLIN( 897)									int index1;
HXDLIN( 897)									if (this4->useVirtualPos) {
HXLINE( 897)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 897)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 897)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 897)									int v1;
HXDLIN( 897)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 897)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 897)										v1 = c1;
            									}
HXDLIN( 897)									int maskPixel = v1;
HXDLIN( 897)									int this6 = col;
HXDLIN( 897)									if ((maskPixel == 0)) {
HXLINE( 897)										col = this6;
            									}
            									else {
HXLINE( 897)										Float m0;
HXDLIN( 897)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 897)										if ((this7 == 0)) {
HXLINE( 897)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float m1;
HXDLIN( 897)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 897)										if ((this8 == 0)) {
HXLINE( 897)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float m2;
HXDLIN( 897)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 897)										if ((this9 == 0)) {
HXLINE( 897)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float m3;
HXDLIN( 897)										int this10 = (maskPixel & 255);
HXDLIN( 897)										if ((this10 == 0)) {
HXLINE( 897)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 897)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 897)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 897)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 897)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 897)								if ((col != 0)) {
HXLINE( 897)									int x1 = (dx - rectLeft);
HXDLIN( 897)									int y1 = (dy - rectTop);
HXDLIN( 897)									int c2 = col;
HXDLIN( 897)									bool _hx_tmp1;
HXDLIN( 897)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 897)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 897)										_hx_tmp1 = false;
            									}
HXDLIN( 897)									if (_hx_tmp1) {
HXLINE( 897)										int location;
HXDLIN( 897)										if (undoImage->useVirtualPos) {
HXLINE( 897)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 897)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 897)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 897)										int this12;
HXDLIN( 897)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 897)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 897)											this12 = this11;
            										}
HXDLIN( 897)										Float a1;
HXDLIN( 897)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 897)										if ((this13 == 0)) {
HXLINE( 897)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float r1;
HXDLIN( 897)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 897)										if ((this14 == 0)) {
HXLINE( 897)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float g1;
HXDLIN( 897)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 897)										if ((this15 == 0)) {
HXLINE( 897)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float b11;
HXDLIN( 897)										int this16 = (this12 & 255);
HXDLIN( 897)										if ((this16 == 0)) {
HXLINE( 897)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float a2;
HXDLIN( 897)										int this17 = ((col >> 24) & 255);
HXDLIN( 897)										if ((this17 == 0)) {
HXLINE( 897)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float r2;
HXDLIN( 897)										int this18 = ((col >> 16) & 255);
HXDLIN( 897)										if ((this18 == 0)) {
HXLINE( 897)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float g2;
HXDLIN( 897)										int this19 = ((col >> 8) & 255);
HXDLIN( 897)										if ((this19 == 0)) {
HXLINE( 897)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float b21;
HXDLIN( 897)										int this20 = (col & 255);
HXDLIN( 897)										if ((this20 == 0)) {
HXLINE( 897)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 897)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 897)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 897)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 897)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 897)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 897)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 897)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 897)										{
HXLINE( 897)											int _hx_tmp2;
HXDLIN( 897)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 897)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 897)												_hx_tmp2 = blended;
            											}
HXDLIN( 897)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 897)										::Dynamic this21 = undoImage->image;
HXDLIN( 897)										int index2;
HXDLIN( 897)										if (undoImage->useVirtualPos) {
HXLINE( 897)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 897)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 897)										int _hx_tmp3;
HXDLIN( 897)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 897)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 897)											_hx_tmp3 = c2;
            										}
HXDLIN( 897)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 897)									if (forceClear) {
HXLINE( 897)										::Dynamic this22 = undoImage->image;
HXDLIN( 897)										int x2 = (dx - rectLeft);
HXDLIN( 897)										int y2 = (dy - rectTop);
HXDLIN( 897)										int index3;
HXDLIN( 897)										if (undoImage->useVirtualPos) {
HXLINE( 897)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 897)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 897)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 899)		int a5 = 0;
HXLINE( 900)		int r3 = 0;
HXLINE( 901)		int g3 = 0;
HXLINE( 902)		int b4 = 0;
HXLINE( 903)		bool found = false;
HXLINE( 904)		{
HXLINE( 904)			int _g_min = xIter3->start;
HXDLIN( 904)			int _g_max = xIter3->max;
HXDLIN( 904)			while((_g_min < _g_max)){
HXLINE( 904)				_g_min = (_g_min + 1);
HXDLIN( 904)				int px = (_g_min - 1);
HXLINE( 905)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 906)				found = false;
HXLINE( 907)				{
HXLINE( 907)					int _g_min1 = yIter3->start;
HXDLIN( 907)					int _g_max1 = yIter3->max;
HXDLIN( 907)					while((_g_min1 < _g_max1)){
HXLINE( 907)						_g_min1 = (_g_min1 + 1);
HXDLIN( 907)						int py = (_g_min1 - 1);
HXLINE( 908)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 909)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 910)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 911)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 912)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 913)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 914)						bool _hx_tmp4;
HXDLIN( 914)						bool _hx_tmp5;
HXDLIN( 914)						if ((ratioA >= 0)) {
HXLINE( 914)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 914)							_hx_tmp5 = false;
            						}
HXDLIN( 914)						if (_hx_tmp5) {
HXLINE( 914)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 914)							_hx_tmp4 = false;
            						}
HXDLIN( 914)						if (_hx_tmp4) {
HXLINE( 915)							int i6 = ::Std_obj::_hx_int((( (Float)(aA) ) * (( (Float)(10) ) * ratioB)));
HXDLIN( 915)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 915)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 915)							a5 = i6;
HXLINE( 916)							int i7 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 916)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 916)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 916)							r3 = i7;
HXLINE( 917)							int i8 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 917)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 917)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 917)							g3 = i8;
HXLINE( 918)							int i9 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 918)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 918)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 918)							b4 = i9;
HXLINE( 919)							{
HXLINE( 919)								int location1;
HXDLIN( 919)								if (pixelImage->useVirtualPos) {
HXLINE( 919)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 919)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 919)								bool _hx_tmp6;
HXDLIN( 919)								if (pixelImage->transparent) {
HXLINE( 919)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 919)									_hx_tmp6 = false;
            								}
HXDLIN( 919)								if (_hx_tmp6) {
HXLINE( 919)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 919)									int old;
HXDLIN( 919)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 919)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 919)										old = this23;
            									}
HXDLIN( 919)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 919)									Float a11;
HXDLIN( 919)									int this24 = ((old >> 24) & 255);
HXDLIN( 919)									if ((this24 == 0)) {
HXLINE( 919)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float r11;
HXDLIN( 919)									int this25 = ((old >> 16) & 255);
HXDLIN( 919)									if ((this25 == 0)) {
HXLINE( 919)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float g11;
HXDLIN( 919)									int this26 = ((old >> 8) & 255);
HXDLIN( 919)									if ((this26 == 0)) {
HXLINE( 919)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float b12;
HXDLIN( 919)									int this27 = (old & 255);
HXDLIN( 919)									if ((this27 == 0)) {
HXLINE( 919)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float a21;
HXDLIN( 919)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 919)									if ((this28 == 0)) {
HXLINE( 919)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float r21;
HXDLIN( 919)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 919)									if ((this29 == 0)) {
HXLINE( 919)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float g21;
HXDLIN( 919)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 919)									if ((this30 == 0)) {
HXLINE( 919)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float b22;
HXDLIN( 919)									int this31 = (rhs & 255);
HXDLIN( 919)									if ((this31 == 0)) {
HXLINE( 919)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 919)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 919)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 919)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 919)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 919)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 919)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 919)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 919)									{
HXLINE( 919)										int _hx_tmp7;
HXDLIN( 919)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 919)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 919)											_hx_tmp7 = blended1;
            										}
HXDLIN( 919)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 919)									int value;
HXDLIN( 919)									if (pixelImage->isLittle) {
HXLINE( 919)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 919)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 919)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
HXLINE( 921)							found = true;
            						}
            						else {
HXLINE( 922)							if (found) {
HXLINE( 924)								goto _hx_goto_257;
            							}
            						}
            					}
            					_hx_goto_257:;
            				}
            			}
            		}
HXLINE( 930)		if ((hasHit == false)) {
HXLINE( 931)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 932)			if (hasUndo) {
HXLINE( 933)				v2->undoImage = undoImage;
HXLINE( 934)				v2->undoX = xIter3->start;
HXLINE( 935)				v2->undoY = yIter3->start;
            			}
HXLINE( 937)			return v2;
            		}
            		else {
HXLINE( 939)			return null();
            		}
HXLINE( 930)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriExtra0,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::fillTriExtra1( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_949_fillTriExtra1)
HXLINE( 950)		Float bcx = (bx - cx);
HXLINE( 951)		Float bcy = (by - cy);
HXLINE( 952)		Float acx = (ax - cx);
HXLINE( 953)		Float acy = (ay - cy);
HXLINE( 955)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 956)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 957)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 958)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 959)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 959)		if ((ax > bx)) {
HXLINE( 959)			if ((ax > cx)) {
HXLINE( 959)				int min;
HXDLIN( 959)				if ((bx > cx)) {
HXLINE( 959)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 959)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 959)				int ii_min = min;
HXDLIN( 959)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 959)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 959)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 959)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 959)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 959)			if ((bx > cx)) {
HXLINE( 959)				int min1;
HXDLIN( 959)				if ((ax > cx)) {
HXLINE( 959)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 959)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 959)				int ii_min2 = min1;
HXDLIN( 959)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 959)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 959)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 959)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 959)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 960)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 960)		if ((ay > by)) {
HXLINE( 960)			if ((ay > cy)) {
HXLINE( 960)				int min2;
HXDLIN( 960)				if ((by > cy)) {
HXLINE( 960)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 960)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 960)				int ii_min4 = min2;
HXDLIN( 960)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 960)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 960)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 960)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 960)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 960)			if ((by > cy)) {
HXLINE( 960)				int min3;
HXDLIN( 960)				if ((ay > cy)) {
HXLINE( 960)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 960)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 960)				int ii_min6 = min3;
HXDLIN( 960)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 960)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 960)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 960)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 960)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 961)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 962)		if (hasUndo) {
HXLINE( 963)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 963)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 963)			 ::Dynamic imageType = null();
HXDLIN( 963)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 963)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 963)			::Dynamic undoImage1;
HXDLIN( 963)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 963)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 963)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 963)					{
HXLINE( 963)						b->width = width;
HXDLIN( 963)						b->height = height;
HXDLIN( 963)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 963)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 963)						{
HXLINE( 963)							int len = b->length;
HXDLIN( 963)							int w = 0;
HXDLIN( 963)							{
HXLINE( 963)								int _g = 0;
HXDLIN( 963)								int _g1 = b->height;
HXDLIN( 963)								while((_g < _g1)){
HXLINE( 963)									_g = (_g + 1);
HXDLIN( 963)									int y = (_g - 1);
HXDLIN( 963)									{
HXLINE( 963)										int _g2 = 0;
HXDLIN( 963)										int _g3 = b->width;
HXDLIN( 963)										while((_g2 < _g3)){
HXLINE( 963)											_g2 = (_g2 + 1);
HXDLIN( 963)											int x = (_g2 - 1);
HXDLIN( 963)											{
HXLINE( 963)												w = (w + 1);
HXDLIN( 963)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 963)											{
HXLINE( 963)												w = (w + 1);
HXDLIN( 963)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 963)											{
HXLINE( 963)												w = (w + 1);
HXDLIN( 963)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 963)											{
HXLINE( 963)												w = (w + 1);
HXDLIN( 963)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 963)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 963)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 963)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 963)					{
HXLINE( 963)						a->width = width;
HXDLIN( 963)						a->height = height;
HXDLIN( 963)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 963)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 963)						{
HXLINE( 963)							int _g4 = 0;
HXDLIN( 963)							int _g5 = a->length;
HXDLIN( 963)							while((_g4 < _g5)){
HXLINE( 963)								_g4 = (_g4 + 1);
HXDLIN( 963)								int i = (_g4 - 1);
HXDLIN( 963)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 963)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 963)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 963)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 963)					{
HXLINE( 963)						b1->width = width;
HXDLIN( 963)						b1->height = height;
HXDLIN( 963)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 963)						int size = (b1->length * 4);
HXDLIN( 963)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 963)						{
HXLINE( 963)							int _g6 = 0;
HXDLIN( 963)							int _g7 = b1->length;
HXDLIN( 963)							while((_g6 < _g7)){
HXLINE( 963)								_g6 = (_g6 + 1);
HXDLIN( 963)								int i1 = (_g6 - 1);
HXDLIN( 963)								{
HXLINE( 963)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 963)									bool undoImage2;
HXDLIN( 963)									if ((i1 >= 0)) {
HXLINE( 963)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 963)										undoImage2 = false;
            									}
HXDLIN( 963)									if (undoImage2) {
HXLINE( 963)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 963)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 963)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 963)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 963)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 963)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 963)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 963)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 963)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 963)					{
HXLINE( 963)						v->width = width;
HXDLIN( 963)						v->height = height;
HXDLIN( 963)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 963)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 963)						{
HXLINE( 963)							int _g8 = 0;
HXDLIN( 963)							int _g9 = v->length;
HXDLIN( 963)							while((_g8 < _g9)){
HXLINE( 963)								_g8 = (_g8 + 1);
HXDLIN( 963)								int i2 = (_g8 - 1);
HXDLIN( 963)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 963)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 963)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 963)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 963)					{
HXLINE( 963)						b2->width = width;
HXDLIN( 963)						b2->height = height;
HXDLIN( 963)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 963)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 963)						{
HXLINE( 963)							int len1 = b2->length;
HXDLIN( 963)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 963)							if (::hx::IsNull( d->head )) {
HXLINE( 963)								int _g10 = 0;
HXDLIN( 963)								int _g11 = len1;
HXDLIN( 963)								while((_g10 < _g11)){
HXLINE( 963)									_g10 = (_g10 + 1);
HXDLIN( 963)									int i3 = (_g10 - 1);
HXDLIN( 963)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 963)								int _g12 = 0;
HXDLIN( 963)								int _g13 = len1;
HXDLIN( 963)								while((_g12 < _g13)){
HXLINE( 963)									_g12 = (_g12 + 1);
HXDLIN( 963)									int i4 = (_g12 - 1);
HXDLIN( 963)									{
HXLINE( 963)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 963)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 963)										{
HXLINE( 963)											int _g14 = 0;
HXDLIN( 963)											int _g15 = i4;
HXDLIN( 963)											while((_g14 < _g15)){
HXLINE( 963)												_g14 = (_g14 + 1);
HXDLIN( 963)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 963)										if (::hx::IsNull( prev )) {
HXLINE( 963)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 963)											l = null();
            										}
            										else {
HXLINE( 963)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 963)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 963)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 963)			this1->image = undoImage1;
HXDLIN( 963)			this1->width = width;
HXDLIN( 963)			this1->height = height;
HXDLIN( 963)			this1->imageType = ( (int)(imageType) );
HXDLIN( 963)			undoImage = this1;
HXLINE( 964)			{
HXLINE( 964)				int rectLeft = xIter3->start;
HXDLIN( 964)				int rectTop = yIter3->start;
HXDLIN( 964)				int rectRight = xIter3->max;
HXDLIN( 964)				bool forceClear = false;
HXDLIN( 964)				{
HXLINE( 964)					int _g16 = rectTop;
HXDLIN( 964)					int _g17 = yIter3->max;
HXDLIN( 964)					while((_g16 < _g17)){
HXLINE( 964)						_g16 = (_g16 + 1);
HXDLIN( 964)						int dy = (_g16 - 1);
HXDLIN( 964)						{
HXLINE( 964)							int _g18 = rectLeft;
HXDLIN( 964)							int _g19 = rectRight;
HXDLIN( 964)							while((_g18 < _g19)){
HXLINE( 964)								_g18 = (_g18 + 1);
HXDLIN( 964)								int dx = (_g18 - 1);
HXDLIN( 964)								::Dynamic this3 = pixelImage->image;
HXDLIN( 964)								int index;
HXDLIN( 964)								if (pixelImage->useVirtualPos) {
HXLINE( 964)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 964)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 964)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 964)								int col;
HXDLIN( 964)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 964)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 964)									col = c;
            								}
HXDLIN( 964)								bool _hx_tmp;
HXDLIN( 964)								if (pixelImage->useMask) {
HXLINE( 964)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 964)									_hx_tmp = false;
            								}
HXDLIN( 964)								if (_hx_tmp) {
HXLINE( 964)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 964)									::Dynamic this5 = this4->image;
HXDLIN( 964)									int index1;
HXDLIN( 964)									if (this4->useVirtualPos) {
HXLINE( 964)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 964)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 964)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 964)									int v1;
HXDLIN( 964)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 964)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 964)										v1 = c1;
            									}
HXDLIN( 964)									int maskPixel = v1;
HXDLIN( 964)									int this6 = col;
HXDLIN( 964)									if ((maskPixel == 0)) {
HXLINE( 964)										col = this6;
            									}
            									else {
HXLINE( 964)										Float m0;
HXDLIN( 964)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 964)										if ((this7 == 0)) {
HXLINE( 964)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float m1;
HXDLIN( 964)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 964)										if ((this8 == 0)) {
HXLINE( 964)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float m2;
HXDLIN( 964)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 964)										if ((this9 == 0)) {
HXLINE( 964)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float m3;
HXDLIN( 964)										int this10 = (maskPixel & 255);
HXDLIN( 964)										if ((this10 == 0)) {
HXLINE( 964)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 964)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 964)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 964)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 964)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 964)								if ((col != 0)) {
HXLINE( 964)									int x1 = (dx - rectLeft);
HXDLIN( 964)									int y1 = (dy - rectTop);
HXDLIN( 964)									int c2 = col;
HXDLIN( 964)									bool _hx_tmp1;
HXDLIN( 964)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 964)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 964)										_hx_tmp1 = false;
            									}
HXDLIN( 964)									if (_hx_tmp1) {
HXLINE( 964)										int location;
HXDLIN( 964)										if (undoImage->useVirtualPos) {
HXLINE( 964)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 964)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 964)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 964)										int this12;
HXDLIN( 964)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 964)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 964)											this12 = this11;
            										}
HXDLIN( 964)										Float a1;
HXDLIN( 964)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 964)										if ((this13 == 0)) {
HXLINE( 964)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float r1;
HXDLIN( 964)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 964)										if ((this14 == 0)) {
HXLINE( 964)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float g1;
HXDLIN( 964)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 964)										if ((this15 == 0)) {
HXLINE( 964)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float b11;
HXDLIN( 964)										int this16 = (this12 & 255);
HXDLIN( 964)										if ((this16 == 0)) {
HXLINE( 964)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float a2;
HXDLIN( 964)										int this17 = ((col >> 24) & 255);
HXDLIN( 964)										if ((this17 == 0)) {
HXLINE( 964)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float r2;
HXDLIN( 964)										int this18 = ((col >> 16) & 255);
HXDLIN( 964)										if ((this18 == 0)) {
HXLINE( 964)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float g2;
HXDLIN( 964)										int this19 = ((col >> 8) & 255);
HXDLIN( 964)										if ((this19 == 0)) {
HXLINE( 964)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float b21;
HXDLIN( 964)										int this20 = (col & 255);
HXDLIN( 964)										if ((this20 == 0)) {
HXLINE( 964)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 964)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 964)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 964)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 964)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 964)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 964)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 964)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 964)										{
HXLINE( 964)											int _hx_tmp2;
HXDLIN( 964)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 964)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 964)												_hx_tmp2 = blended;
            											}
HXDLIN( 964)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 964)										::Dynamic this21 = undoImage->image;
HXDLIN( 964)										int index2;
HXDLIN( 964)										if (undoImage->useVirtualPos) {
HXLINE( 964)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 964)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 964)										int _hx_tmp3;
HXDLIN( 964)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 964)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 964)											_hx_tmp3 = c2;
            										}
HXDLIN( 964)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 964)									if (forceClear) {
HXLINE( 964)										::Dynamic this22 = undoImage->image;
HXDLIN( 964)										int x2 = (dx - rectLeft);
HXDLIN( 964)										int y2 = (dy - rectTop);
HXDLIN( 964)										int index3;
HXDLIN( 964)										if (undoImage->useVirtualPos) {
HXLINE( 964)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 964)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 964)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 966)		bool found = false;
HXLINE( 967)		{
HXLINE( 967)			int _g_min = yIter3->start;
HXDLIN( 967)			int _g_max = yIter3->max;
HXDLIN( 967)			while((_g_min < _g_max)){
HXLINE( 967)				_g_min = (_g_min + 1);
HXDLIN( 967)				int py = (_g_min - 1);
HXLINE( 968)				Float pcy = (( (Float)(py) ) - cy);
HXLINE( 969)				found = false;
HXLINE( 970)				{
HXLINE( 970)					int _g_min1 = xIter3->start;
HXDLIN( 970)					int _g_max1 = xIter3->max;
HXDLIN( 970)					while((_g_min1 < _g_max1)){
HXLINE( 970)						_g_min1 = (_g_min1 + 1);
HXDLIN( 970)						int px = (_g_min1 - 1);
HXLINE( 971)						Float pcx = (( (Float)(px) ) - cx);
HXLINE( 972)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 973)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 974)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 975)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 976)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 977)						bool _hx_tmp4;
HXDLIN( 977)						bool _hx_tmp5;
HXDLIN( 977)						if ((ratioA >= 0)) {
HXLINE( 977)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 977)							_hx_tmp5 = false;
            						}
HXDLIN( 977)						if (_hx_tmp5) {
HXLINE( 977)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 977)							_hx_tmp4 = false;
            						}
HXDLIN( 977)						if (_hx_tmp4) {
HXLINE( 978)							{
HXLINE( 978)								int c3 = color;
HXDLIN( 978)								bool _hx_tmp6;
HXDLIN( 978)								if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 978)									_hx_tmp6 = pixelImage->transparent;
            								}
            								else {
HXLINE( 978)									_hx_tmp6 = false;
            								}
HXDLIN( 978)								if (_hx_tmp6) {
HXLINE( 978)									int location1;
HXDLIN( 978)									if (pixelImage->useVirtualPos) {
HXLINE( 978)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 978)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 978)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 978)									int this24;
HXDLIN( 978)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 978)										this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 978)										this24 = this23;
            									}
HXDLIN( 978)									Float a11;
HXDLIN( 978)									int this25 = ((this24 >> 24) & 255);
HXDLIN( 978)									if ((this25 == 0)) {
HXLINE( 978)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float r11;
HXDLIN( 978)									int this26 = ((this24 >> 16) & 255);
HXDLIN( 978)									if ((this26 == 0)) {
HXLINE( 978)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float g11;
HXDLIN( 978)									int this27 = ((this24 >> 8) & 255);
HXDLIN( 978)									if ((this27 == 0)) {
HXLINE( 978)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float b12;
HXDLIN( 978)									int this28 = (this24 & 255);
HXDLIN( 978)									if ((this28 == 0)) {
HXLINE( 978)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float a21;
HXDLIN( 978)									int this29 = ((color >> 24) & 255);
HXDLIN( 978)									if ((this29 == 0)) {
HXLINE( 978)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float r21;
HXDLIN( 978)									int this30 = ((color >> 16) & 255);
HXDLIN( 978)									if ((this30 == 0)) {
HXLINE( 978)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float g21;
HXDLIN( 978)									int this31 = ((color >> 8) & 255);
HXDLIN( 978)									if ((this31 == 0)) {
HXLINE( 978)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float b22;
HXDLIN( 978)									int this32 = (color & 255);
HXDLIN( 978)									if ((this32 == 0)) {
HXLINE( 978)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 978)										b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 978)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 978)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 978)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 978)									int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 978)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 978)									int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 978)									{
HXLINE( 978)										int _hx_tmp7;
HXDLIN( 978)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 978)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 978)											_hx_tmp7 = blended1;
            										}
HXDLIN( 978)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 978)									::Dynamic this33 = pixelImage->image;
HXDLIN( 978)									int index4;
HXDLIN( 978)									if (pixelImage->useVirtualPos) {
HXLINE( 978)										index4 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 978)										index4 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 978)									int _hx_tmp8;
HXDLIN( 978)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 978)										_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 978)										_hx_tmp8 = c3;
            									}
HXDLIN( 978)									::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp8);
            								}
            							}
HXLINE( 979)							found = true;
            						}
            						else {
HXLINE( 980)							if (found) {
HXLINE( 982)								goto _hx_goto_270;
            							}
            						}
            					}
            					_hx_goto_270:;
            				}
            			}
            		}
HXLINE( 988)		if ((hasHit == false)) {
HXLINE( 989)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 990)			if (hasUndo) {
HXLINE( 991)				v2->undoImage = undoImage;
HXLINE( 992)				v2->undoX = xIter3->start;
HXLINE( 993)				v2->undoY = yIter3->start;
            			}
HXLINE( 995)			return v2;
            		}
            		else {
HXLINE( 997)			return null();
            		}
HXLINE( 988)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixel_Fields__obj,fillTriExtra1,return )

 ::pi_xy::algo::HitTri TriPixel_Fields__obj::uvTriangleTexture3( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct textureA, ::pi_xy::algo::RectangleWindow winA, ::pi_xy::ImageStruct textureB, ::pi_xy::algo::RectangleWindow winB, ::pi_xy::ImageStruct textureC, ::pi_xy::algo::RectangleWindow winC,Float ax,Float ay,Float au,Float av,Float bx,Float by,Float bu,Float bv,Float cx,Float cy,Float cu,Float cv,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4d6d42e233dea49a_1010_uvTriangleTexture3)
HXLINE(1012)		Float temp = au;
HXLINE(1013)		au = bu;
HXLINE(1014)		bu = temp;
HXLINE(1015)		temp = av;
HXLINE(1016)		av = bv;
HXLINE(1017)		bv = temp;
HXLINE(1019)		Float bcx = (bx - cx);
HXLINE(1020)		Float bcy = (by - cy);
HXLINE(1021)		Float acx = (ax - cx);
HXLINE(1022)		Float acy = (ay - cy);
HXLINE(1024)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE(1025)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE(1026)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE(1027)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE(1028)		int colA = 0;
HXLINE(1029)		int colB = 0;
HXLINE(1030)		int colC = 0;
HXLINE(1031)		Float u = ((Float)0.);
HXLINE(1032)		Float v = ((Float)0.);
HXLINE(1033)		int x = 0;
HXLINE(1034)		int y = 0;
HXLINE(1036)		int a = 0;
HXLINE(1037)		int r = 0;
HXLINE(1038)		int g = 0;
HXLINE(1039)		int b = 0;
HXLINE(1040)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(1040)		if ((ax > bx)) {
HXLINE(1040)			if ((ax > cx)) {
HXLINE(1040)				int min;
HXDLIN(1040)				if ((bx > cx)) {
HXLINE(1040)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(1040)					min = ::Math_obj::floor(bx);
            				}
HXDLIN(1040)				int ii_min = min;
HXDLIN(1040)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(1040)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE(1040)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(1040)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(1040)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE(1040)			if ((bx > cx)) {
HXLINE(1040)				int min1;
HXDLIN(1040)				if ((ax > cx)) {
HXLINE(1040)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(1040)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(1040)				int ii_min2 = min1;
HXDLIN(1040)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(1040)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE(1040)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(1040)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(1040)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE(1041)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(1041)		if ((ay > by)) {
HXLINE(1041)			if ((ay > cy)) {
HXLINE(1041)				int min2;
HXDLIN(1041)				if ((by > cy)) {
HXLINE(1041)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(1041)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN(1041)				int ii_min4 = min2;
HXDLIN(1041)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(1041)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE(1041)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN(1041)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(1041)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE(1041)			if ((by > cy)) {
HXLINE(1041)				int min3;
HXDLIN(1041)				if ((ay > cy)) {
HXLINE(1041)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(1041)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(1041)				int ii_min6 = min3;
HXDLIN(1041)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(1041)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE(1041)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(1041)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(1041)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE(1042)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE(1043)		if (hasUndo) {
HXLINE(1044)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(1044)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(1044)			 ::Dynamic imageType = null();
HXDLIN(1044)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(1044)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(1044)			::Dynamic undoImage1;
HXDLIN(1044)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(1044)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(1044)					 ::iterMagic::BytesImg b1 = byt;
HXDLIN(1044)					{
HXLINE(1044)						b1->width = width;
HXDLIN(1044)						b1->height = height;
HXDLIN(1044)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(1044)						b1->data = ::haxe::io::Bytes_obj::alloc((b1->length * 4));
HXDLIN(1044)						{
HXLINE(1044)							int len = b1->length;
HXDLIN(1044)							int w = 0;
HXDLIN(1044)							{
HXLINE(1044)								int _g = 0;
HXDLIN(1044)								int _g1 = b1->height;
HXDLIN(1044)								while((_g < _g1)){
HXLINE(1044)									_g = (_g + 1);
HXDLIN(1044)									int y1 = (_g - 1);
HXDLIN(1044)									{
HXLINE(1044)										int _g2 = 0;
HXDLIN(1044)										int _g3 = b1->width;
HXDLIN(1044)										while((_g2 < _g3)){
HXLINE(1044)											_g2 = (_g2 + 1);
HXDLIN(1044)											int x1 = (_g2 - 1);
HXDLIN(1044)											{
HXLINE(1044)												w = (w + 1);
HXDLIN(1044)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(1044)											{
HXLINE(1044)												w = (w + 1);
HXDLIN(1044)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(1044)											{
HXLINE(1044)												w = (w + 1);
HXDLIN(1044)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(1044)											{
HXLINE(1044)												w = (w + 1);
HXDLIN(1044)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(1044)					undoImage1 = b1;
            				}
            				break;
            				case (int)1: {
HXLINE(1044)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(1044)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN(1044)					{
HXLINE(1044)						a1->width = width;
HXDLIN(1044)						a1->height = height;
HXDLIN(1044)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN(1044)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(1044)						{
HXLINE(1044)							int _g4 = 0;
HXDLIN(1044)							int _g5 = a1->length;
HXDLIN(1044)							while((_g4 < _g5)){
HXLINE(1044)								_g4 = (_g4 + 1);
HXDLIN(1044)								int i = (_g4 - 1);
HXDLIN(1044)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN(1044)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXLINE(1044)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(1044)					 ::iterMagic::U32ArrImg b2 = u32a;
HXDLIN(1044)					{
HXLINE(1044)						b2->width = width;
HXDLIN(1044)						b2->height = height;
HXDLIN(1044)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(1044)						int size = (b2->length * 4);
HXDLIN(1044)						b2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(1044)						{
HXLINE(1044)							int _g6 = 0;
HXDLIN(1044)							int _g7 = b2->length;
HXDLIN(1044)							while((_g6 < _g7)){
HXLINE(1044)								_g6 = (_g6 + 1);
HXDLIN(1044)								int i1 = (_g6 - 1);
HXDLIN(1044)								{
HXLINE(1044)									 ::haxe::io::ArrayBufferViewImpl this2 = b2->data;
HXDLIN(1044)									bool undoImage2;
HXDLIN(1044)									if ((i1 >= 0)) {
HXLINE(1044)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(1044)										undoImage2 = false;
            									}
HXDLIN(1044)									if (undoImage2) {
HXLINE(1044)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(1044)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(1044)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(1044)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(1044)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(1044)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(1044)					undoImage1 = b2;
            				}
            				break;
            				case (int)3: {
HXLINE(1044)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(1044)					 ::iterMagic::VecIntImg v1 = vec;
HXDLIN(1044)					{
HXLINE(1044)						v1->width = width;
HXDLIN(1044)						v1->height = height;
HXDLIN(1044)						v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(1044)						v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(1044)						{
HXLINE(1044)							int _g8 = 0;
HXDLIN(1044)							int _g9 = v1->length;
HXDLIN(1044)							while((_g8 < _g9)){
HXLINE(1044)								_g8 = (_g8 + 1);
HXDLIN(1044)								int i2 = (_g8 - 1);
HXDLIN(1044)								v1->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(1044)					undoImage1 = v1;
            				}
            				break;
            				case (int)4: {
HXLINE(1044)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(1044)					 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN(1044)					{
HXLINE(1044)						b3->width = width;
HXDLIN(1044)						b3->height = height;
HXDLIN(1044)						b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(1044)						b3->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(1044)						{
HXLINE(1044)							int len1 = b3->length;
HXDLIN(1044)							 ::haxe::ds::GenericStack_Int d = b3->data;
HXDLIN(1044)							if (::hx::IsNull( d->head )) {
HXLINE(1044)								int _g10 = 0;
HXDLIN(1044)								int _g11 = len1;
HXDLIN(1044)								while((_g10 < _g11)){
HXLINE(1044)									_g10 = (_g10 + 1);
HXDLIN(1044)									int i3 = (_g10 - 1);
HXDLIN(1044)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(1044)								int _g12 = 0;
HXDLIN(1044)								int _g13 = len1;
HXDLIN(1044)								while((_g12 < _g13)){
HXLINE(1044)									_g12 = (_g12 + 1);
HXDLIN(1044)									int i4 = (_g12 - 1);
HXDLIN(1044)									{
HXLINE(1044)										 ::haxe::ds::GenericCell_Int l = b3->data->head;
HXDLIN(1044)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(1044)										{
HXLINE(1044)											int _g14 = 0;
HXDLIN(1044)											int _g15 = i4;
HXDLIN(1044)											while((_g14 < _g15)){
HXLINE(1044)												_g14 = (_g14 + 1);
HXDLIN(1044)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(1044)										if (::hx::IsNull( prev )) {
HXLINE(1044)											b3->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(1044)											l = null();
            										}
            										else {
HXLINE(1044)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(1044)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(1044)					undoImage1 = b3;
            				}
            				break;
            			}
HXDLIN(1044)			this1->image = undoImage1;
HXDLIN(1044)			this1->width = width;
HXDLIN(1044)			this1->height = height;
HXDLIN(1044)			this1->imageType = ( (int)(imageType) );
HXDLIN(1044)			undoImage = this1;
HXLINE(1045)			{
HXLINE(1045)				int rectLeft = xIter3->start;
HXDLIN(1045)				int rectTop = yIter3->start;
HXDLIN(1045)				int rectRight = xIter3->max;
HXDLIN(1045)				bool forceClear = false;
HXDLIN(1045)				{
HXLINE(1045)					int _g16 = rectTop;
HXDLIN(1045)					int _g17 = yIter3->max;
HXDLIN(1045)					while((_g16 < _g17)){
HXLINE(1045)						_g16 = (_g16 + 1);
HXDLIN(1045)						int dy = (_g16 - 1);
HXDLIN(1045)						{
HXLINE(1045)							int _g18 = rectLeft;
HXDLIN(1045)							int _g19 = rectRight;
HXDLIN(1045)							while((_g18 < _g19)){
HXLINE(1045)								_g18 = (_g18 + 1);
HXDLIN(1045)								int dx = (_g18 - 1);
HXDLIN(1045)								::Dynamic this3 = pixelImage->image;
HXDLIN(1045)								int index;
HXDLIN(1045)								if (pixelImage->useVirtualPos) {
HXLINE(1045)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE(1045)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN(1045)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(1045)								int col;
HXDLIN(1045)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1045)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(1045)									col = c;
            								}
HXDLIN(1045)								bool _hx_tmp;
HXDLIN(1045)								if (pixelImage->useMask) {
HXLINE(1045)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(1045)									_hx_tmp = false;
            								}
HXDLIN(1045)								if (_hx_tmp) {
HXLINE(1045)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(1045)									::Dynamic this5 = this4->image;
HXDLIN(1045)									int index1;
HXDLIN(1045)									if (this4->useVirtualPos) {
HXLINE(1045)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE(1045)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN(1045)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(1045)									int v2;
HXDLIN(1045)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1045)										v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(1045)										v2 = c1;
            									}
HXDLIN(1045)									int maskPixel = v2;
HXDLIN(1045)									int this6 = col;
HXDLIN(1045)									if ((maskPixel == 0)) {
HXLINE(1045)										col = this6;
            									}
            									else {
HXLINE(1045)										Float m0;
HXDLIN(1045)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN(1045)										if ((this7 == 0)) {
HXLINE(1045)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float m1;
HXDLIN(1045)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN(1045)										if ((this8 == 0)) {
HXLINE(1045)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float m2;
HXDLIN(1045)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN(1045)										if ((this9 == 0)) {
HXLINE(1045)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float m3;
HXDLIN(1045)										int this10 = (maskPixel & 255);
HXDLIN(1045)										if ((this10 == 0)) {
HXLINE(1045)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(1045)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(1045)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(1045)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(1045)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(1045)								if ((col != 0)) {
HXLINE(1045)									int x2 = (dx - rectLeft);
HXDLIN(1045)									int y2 = (dy - rectTop);
HXDLIN(1045)									int c2 = col;
HXDLIN(1045)									bool _hx_tmp1;
HXDLIN(1045)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(1045)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE(1045)										_hx_tmp1 = false;
            									}
HXDLIN(1045)									if (_hx_tmp1) {
HXLINE(1045)										int location;
HXDLIN(1045)										if (undoImage->useVirtualPos) {
HXLINE(1045)											location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(1045)											location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(1045)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(1045)										int this12;
HXDLIN(1045)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1045)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE(1045)											this12 = this11;
            										}
HXDLIN(1045)										Float a11;
HXDLIN(1045)										int this13 = ((this12 >> 24) & 255);
HXDLIN(1045)										if ((this13 == 0)) {
HXLINE(1045)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											a11 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float r1;
HXDLIN(1045)										int this14 = ((this12 >> 16) & 255);
HXDLIN(1045)										if ((this14 == 0)) {
HXLINE(1045)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float g1;
HXDLIN(1045)										int this15 = ((this12 >> 8) & 255);
HXDLIN(1045)										if ((this15 == 0)) {
HXLINE(1045)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float b11;
HXDLIN(1045)										int this16 = (this12 & 255);
HXDLIN(1045)										if ((this16 == 0)) {
HXLINE(1045)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float a2;
HXDLIN(1045)										int this17 = ((col >> 24) & 255);
HXDLIN(1045)										if ((this17 == 0)) {
HXLINE(1045)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float r2;
HXDLIN(1045)										int this18 = ((col >> 16) & 255);
HXDLIN(1045)										if ((this18 == 0)) {
HXLINE(1045)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float g2;
HXDLIN(1045)										int this19 = ((col >> 8) & 255);
HXDLIN(1045)										if ((this19 == 0)) {
HXLINE(1045)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float b21;
HXDLIN(1045)										int this20 = (col & 255);
HXDLIN(1045)										if ((this20 == 0)) {
HXLINE(1045)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(1045)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(1045)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(1045)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(1045)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(1045)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(1045)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(1045)										int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(1045)										{
HXLINE(1045)											int _hx_tmp2;
HXDLIN(1045)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1045)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(1045)												_hx_tmp2 = blended;
            											}
HXDLIN(1045)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE(1045)										::Dynamic this21 = undoImage->image;
HXDLIN(1045)										int index2;
HXDLIN(1045)										if (undoImage->useVirtualPos) {
HXLINE(1045)											index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(1045)											index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(1045)										int _hx_tmp3;
HXDLIN(1045)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1045)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(1045)											_hx_tmp3 = c2;
            										}
HXDLIN(1045)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE(1045)									if (forceClear) {
HXLINE(1045)										::Dynamic this22 = undoImage->image;
HXDLIN(1045)										int x3 = (dx - rectLeft);
HXDLIN(1045)										int y3 = (dy - rectTop);
HXDLIN(1045)										int index3;
HXDLIN(1045)										if (undoImage->useVirtualPos) {
HXLINE(1045)											index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            										}
            										else {
HXLINE(1045)											index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            										}
HXDLIN(1045)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(1047)		{
HXLINE(1047)			int _g_min = xIter3->start;
HXDLIN(1047)			int _g_max = xIter3->max;
HXDLIN(1047)			while((_g_min < _g_max)){
HXLINE(1047)				_g_min = (_g_min + 1);
HXDLIN(1047)				int px = (_g_min - 1);
HXLINE(1048)				Float pcx = (( (Float)(px) ) - cx);
HXLINE(1049)				{
HXLINE(1049)					int _g_min1 = yIter3->start;
HXDLIN(1049)					int _g_max1 = yIter3->max;
HXDLIN(1049)					while((_g_min1 < _g_max1)){
HXLINE(1049)						_g_min1 = (_g_min1 + 1);
HXDLIN(1049)						int py = (_g_min1 - 1);
HXLINE(1050)						Float pcy = (( (Float)(py) ) - cy);
HXLINE(1051)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE(1052)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE(1053)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE(1054)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE(1055)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE(1056)						bool _hx_tmp4;
HXDLIN(1056)						bool _hx_tmp5;
HXDLIN(1056)						if ((ratioA >= 0)) {
HXLINE(1056)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE(1056)							_hx_tmp5 = false;
            						}
HXDLIN(1056)						if (_hx_tmp5) {
HXLINE(1056)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE(1056)							_hx_tmp4 = false;
            						}
HXDLIN(1056)						if (_hx_tmp4) {
HXLINE(1057)							u = (((au * ratioA) + (bu * ratioB)) + (cu * ratioC));
HXLINE(1058)							v = (((av * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXLINE(1059)							x = ::Std_obj::_hx_int(((u * winA->width) + winA->x));
HXLINE(1060)							y = ::Std_obj::_hx_int(((v * winA->height) + winA->y));
HXLINE(1061)							::Dynamic this23 = textureA->image;
HXDLIN(1061)							int index4;
HXDLIN(1061)							if (textureA->useVirtualPos) {
HXLINE(1061)								index4 = ::Std_obj::_hx_int(((((( (Float)(y) ) - textureA->virtualY) * ( (Float)(textureA->width) )) + x) - textureA->virtualX));
            							}
            							else {
HXLINE(1061)								index4 = ::Std_obj::_hx_int(( (Float)(((y * textureA->width) + x)) ));
            							}
HXDLIN(1061)							int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN(1061)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1061)								colA = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXLINE(1061)								colA = c3;
            							}
HXLINE(1062)							x = ::Std_obj::_hx_int(((u * winB->width) + winB->x));
HXLINE(1063)							y = ::Std_obj::_hx_int(((v * winB->height) + winB->y));
HXLINE(1064)							::Dynamic this24 = textureB->image;
HXDLIN(1064)							int index5;
HXDLIN(1064)							if (textureB->useVirtualPos) {
HXLINE(1064)								index5 = ::Std_obj::_hx_int(((((( (Float)(y) ) - textureB->virtualY) * ( (Float)(textureB->width) )) + x) - textureB->virtualX));
            							}
            							else {
HXLINE(1064)								index5 = ::Std_obj::_hx_int(( (Float)(((y * textureB->width) + x)) ));
            							}
HXDLIN(1064)							int c4 = ::iterMagic::Iimg_obj::get(this24,index5);
HXDLIN(1064)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1064)								colB = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            							}
            							else {
HXLINE(1064)								colB = c4;
            							}
HXLINE(1065)							x = ::Std_obj::_hx_int(((u * winC->width) + winC->x));
HXLINE(1066)							y = ::Std_obj::_hx_int(((v * winC->height) + winC->y));
HXLINE(1067)							::Dynamic this25 = textureC->image;
HXDLIN(1067)							int index6;
HXDLIN(1067)							if (textureC->useVirtualPos) {
HXLINE(1067)								index6 = ::Std_obj::_hx_int(((((( (Float)(y) ) - textureC->virtualY) * ( (Float)(textureC->width) )) + x) - textureC->virtualX));
            							}
            							else {
HXLINE(1067)								index6 = ::Std_obj::_hx_int(( (Float)(((y * textureC->width) + x)) ));
            							}
HXDLIN(1067)							int c5 = ::iterMagic::Iimg_obj::get(this25,index6);
HXDLIN(1067)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1067)								colC = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            							}
            							else {
HXLINE(1067)								colC = c5;
            							}
HXLINE(1070)							int aA = ((colB >> 24) & 255);
HXLINE(1071)							int rA = ((colB >> 16) & 255);
HXLINE(1072)							int gA = ((colB >> 8) & 255);
HXLINE(1073)							int bA = (colB & 255);
HXLINE(1074)							int aB = ((colA >> 24) & 255);
HXLINE(1075)							int rB = ((colA >> 16) & 255);
HXLINE(1076)							int gB = ((colA >> 8) & 255);
HXLINE(1077)							int bB = (colA & 255);
HXLINE(1078)							int aC = ((colC >> 24) & 255);
HXLINE(1079)							int rC = ((colC >> 16) & 255);
HXLINE(1080)							int gC = ((colC >> 8) & 255);
HXLINE(1081)							int bC = (colC & 255);
HXLINE(1082)							int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(1082)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE(1082)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE(1082)							a = i6;
HXLINE(1083)							int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(1083)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE(1083)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE(1083)							r = i7;
HXLINE(1084)							int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(1084)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE(1084)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE(1084)							g = i8;
HXLINE(1085)							int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(1085)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE(1085)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE(1085)							b = i9;
HXLINE(1086)							{
HXLINE(1086)								int location1;
HXDLIN(1086)								if (pixelImage->useVirtualPos) {
HXLINE(1086)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE(1086)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN(1086)								bool _hx_tmp6;
HXDLIN(1086)								if (pixelImage->transparent) {
HXLINE(1086)									_hx_tmp6 = (a < 254);
            								}
            								else {
HXLINE(1086)									_hx_tmp6 = false;
            								}
HXDLIN(1086)								if (_hx_tmp6) {
HXLINE(1086)									int this26 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(1086)									int old;
HXDLIN(1086)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1086)										old = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            									}
            									else {
HXLINE(1086)										old = this26;
            									}
HXDLIN(1086)									int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(1086)									Float a12;
HXDLIN(1086)									int this27 = ((old >> 24) & 255);
HXDLIN(1086)									if ((this27 == 0)) {
HXLINE(1086)										a12 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										a12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float r11;
HXDLIN(1086)									int this28 = ((old >> 16) & 255);
HXDLIN(1086)									if ((this28 == 0)) {
HXLINE(1086)										r11 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float g11;
HXDLIN(1086)									int this29 = ((old >> 8) & 255);
HXDLIN(1086)									if ((this29 == 0)) {
HXLINE(1086)										g11 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float b12;
HXDLIN(1086)									int this30 = (old & 255);
HXDLIN(1086)									if ((this30 == 0)) {
HXLINE(1086)										b12 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float a21;
HXDLIN(1086)									int this31 = ((rhs >> 24) & 255);
HXDLIN(1086)									if ((this31 == 0)) {
HXLINE(1086)										a21 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float r21;
HXDLIN(1086)									int this32 = ((rhs >> 16) & 255);
HXDLIN(1086)									if ((this32 == 0)) {
HXLINE(1086)										r21 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float g21;
HXDLIN(1086)									int this33 = ((rhs >> 8) & 255);
HXDLIN(1086)									if ((this33 == 0)) {
HXLINE(1086)										g21 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float b22;
HXDLIN(1086)									int this34 = (rhs & 255);
HXDLIN(1086)									if ((this34 == 0)) {
HXLINE(1086)										b22 = ((Float)0.);
            									}
            									else {
HXLINE(1086)										b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN(1086)									Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(1086)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(1086)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(1086)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(1086)									int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(1086)									int blended1 = ((((a5 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(1086)									{
HXLINE(1086)										int _hx_tmp7;
HXDLIN(1086)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(1086)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE(1086)											_hx_tmp7 = blended1;
            										}
HXDLIN(1086)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE(1086)									int value;
HXDLIN(1086)									if (pixelImage->isLittle) {
HXLINE(1086)										value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(1086)										value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(1086)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(1090)		if ((hasHit == false)) {
HXLINE(1091)			 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE(1092)			if (hasUndo) {
HXLINE(1093)				v3->undoImage = undoImage;
HXLINE(1094)				v3->undoX = xIter3->start;
HXLINE(1095)				v3->undoY = yIter3->start;
            			}
HXLINE(1097)			return v3;
            		}
            		else {
HXLINE(1099)			return null();
            		}
HXLINE(1090)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC21(TriPixel_Fields__obj,uvTriangleTexture3,return )


TriPixel_Fields__obj::TriPixel_Fields__obj()
{
}

bool TriPixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"uvTriangle") ) { outValue = uvTriangle_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillTriangle") ) { outValue = fillTriangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tileTriangle") ) { outValue = tileTriangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriSoftC") ) { outValue = fillTriSoftC_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriSoft3") ) { outValue = fillTriSoft3_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fillTriUnsafe") ) { outValue = fillTriUnsafe_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriangle2") ) { outValue = fillTriangle2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tileTriUnsafe") ) { outValue = tileTriUnsafe_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"topLeftImgTri") ) { outValue = topLeftImgTri_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriExtra0") ) { outValue = fillTriExtra0_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriExtra1") ) { outValue = fillTriExtra1_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fillTriUnsafe2") ) { outValue = fillTriUnsafe2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillTriTwoSoft") ) { outValue = fillTriTwoSoft_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"uvTriangleFudge") ) { outValue = uvTriangleFudge_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"uvTriangleSoft3") ) { outValue = uvTriangleSoft3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillQuarterSoft") ) { outValue = fillQuarterSoft_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fillGradTriangle") ) { outValue = fillGradTriangle_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"bottomRightImgTri") ) { outValue = bottomRightImgTri_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"uvTriangleTexture3") ) { outValue = uvTriangleTexture3_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"topRightImgTriFudge") ) { outValue = topRightImgTriFudge_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"bottomLeftImgTriFudge") ) { outValue = bottomLeftImgTriFudge_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *TriPixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *TriPixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class TriPixel_Fields__obj::__mClass;

static ::String TriPixel_Fields__obj_sStaticFields[] = {
	HX_("fillTriangle",6b,04,3a,92),
	HX_("fillTriUnsafe",ae,bc,27,9c),
	HX_("fillTriangle2",67,d9,89,60),
	HX_("fillTriUnsafe2",c4,5b,9d,06),
	HX_("tileTriangle",16,24,18,66),
	HX_("tileTriUnsafe",a3,52,a5,2a),
	HX_("fillGradTriangle",d9,1b,d8,4f),
	HX_("topRightImgTriFudge",c4,69,c3,49),
	HX_("bottomLeftImgTriFudge",19,7c,bb,9c),
	HX_("uvTriangleFudge",8a,3a,8d,e4),
	HX_("topLeftImgTri",44,4b,c5,a6),
	HX_("bottomRightImgTri",b9,18,f1,c4),
	HX_("uvTriangle",49,aa,c6,84),
	HX_("uvTriangleSoft3",00,0d,cd,5c),
	HX_("fillTriTwoSoft",0e,ab,69,1f),
	HX_("fillTriSoftC",91,60,46,83),
	HX_("fillTriSoft3",81,60,46,83),
	HX_("fillQuarterSoft",73,09,4d,82),
	HX_("fillTriExtra0",28,dc,29,f9),
	HX_("fillTriExtra1",29,dc,29,f9),
	HX_("uvTriangleTexture3",61,4e,d8,70),
	::String(null())
};

void TriPixel_Fields__obj::__register()
{
	TriPixel_Fields__obj _hx_dummy;
	TriPixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._TriPixel.TriPixel_Fields_",ca,a8,a8,4d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TriPixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TriPixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< TriPixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriPixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriPixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _TriPixel
