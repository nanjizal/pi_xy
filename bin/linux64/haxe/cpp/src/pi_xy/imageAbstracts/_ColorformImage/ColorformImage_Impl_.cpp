// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__ColorformImage_ColorformImage_Impl_
#include <pi_xy/imageAbstracts/_ColorformImage/ColorformImage_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__ScaleImage_ScaleImage_Fields_
#include <pi_xy/transformation/_ScaleImage/ScaleImage_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_19beeba72877b987_10__new,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_","_new",0x35d48b6f,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_._new","pi_xy/imageAbstracts/ColorformImage.hx",10,0xcc878bd9)
HX_LOCAL_STACK_FRAME(_hx_pos_19beeba72877b987_15_greyScale,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_","greyScale",0x7b78a9dd,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_.greyScale","pi_xy/imageAbstracts/ColorformImage.hx",15,0xcc878bd9)
HX_LOCAL_STACK_FRAME(_hx_pos_19beeba72877b987_37_towardsColor,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_","towardsColor",0x8e017875,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_.towardsColor","pi_xy/imageAbstracts/ColorformImage.hx",37,0xcc878bd9)
HX_LOCAL_STACK_FRAME(_hx_pos_19beeba72877b987_58_towardsImage,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_","towardsImage",0x010e266d,"pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_.towardsImage","pi_xy/imageAbstracts/ColorformImage.hx",58,0xcc878bd9)
namespace pi_xy{
namespace imageAbstracts{
namespace _ColorformImage{

void ColorformImage_Impl__obj::__construct() { }

Dynamic ColorformImage_Impl__obj::__CreateEmpty() { return new ColorformImage_Impl__obj; }

void *ColorformImage_Impl__obj::_hx_vtable = 0;

Dynamic ColorformImage_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ColorformImage_Impl__obj > _hx_result = new ColorformImage_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ColorformImage_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1143248a;
}

 ::pi_xy::ImageStruct ColorformImage_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_19beeba72877b987_10__new)
HXLINE(  11)		 ::Dynamic imageType = null();
HXDLIN(  11)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  11)		if (::hx::IsNull( imageType )) {
HXLINE(  11)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  11)		::Dynamic this2;
HXDLIN(  11)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  11)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  11)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  11)				{
HXLINE(  11)					b->width = w;
HXDLIN(  11)					b->height = h;
HXDLIN(  11)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  11)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  11)					{
HXLINE(  11)						int len = b->length;
HXDLIN(  11)						int w1 = 0;
HXDLIN(  11)						{
HXLINE(  11)							int _g = 0;
HXDLIN(  11)							int _g1 = b->height;
HXDLIN(  11)							while((_g < _g1)){
HXLINE(  11)								_g = (_g + 1);
HXDLIN(  11)								int y = (_g - 1);
HXDLIN(  11)								{
HXLINE(  11)									int _g2 = 0;
HXDLIN(  11)									int _g3 = b->width;
HXDLIN(  11)									while((_g2 < _g3)){
HXLINE(  11)										_g2 = (_g2 + 1);
HXDLIN(  11)										int x = (_g2 - 1);
HXDLIN(  11)										{
HXLINE(  11)											w1 = (w1 + 1);
HXDLIN(  11)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  11)										{
HXLINE(  11)											w1 = (w1 + 1);
HXDLIN(  11)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  11)										{
HXLINE(  11)											w1 = (w1 + 1);
HXDLIN(  11)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  11)										{
HXLINE(  11)											w1 = (w1 + 1);
HXDLIN(  11)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  11)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  11)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  11)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  11)				{
HXLINE(  11)					a->width = w;
HXDLIN(  11)					a->height = h;
HXDLIN(  11)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  11)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  11)					{
HXLINE(  11)						int _g4 = 0;
HXDLIN(  11)						int _g5 = a->length;
HXDLIN(  11)						while((_g4 < _g5)){
HXLINE(  11)							_g4 = (_g4 + 1);
HXDLIN(  11)							int i = (_g4 - 1);
HXDLIN(  11)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  11)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  11)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  11)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  11)				{
HXLINE(  11)					b1->width = w;
HXDLIN(  11)					b1->height = h;
HXDLIN(  11)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  11)					int size = (b1->length * 4);
HXDLIN(  11)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  11)					{
HXLINE(  11)						int _g6 = 0;
HXDLIN(  11)						int _g7 = b1->length;
HXDLIN(  11)						while((_g6 < _g7)){
HXLINE(  11)							_g6 = (_g6 + 1);
HXDLIN(  11)							int i1 = (_g6 - 1);
HXDLIN(  11)							{
HXLINE(  11)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  11)								bool this4;
HXDLIN(  11)								if ((i1 >= 0)) {
HXLINE(  11)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  11)									this4 = false;
            								}
HXDLIN(  11)								if (this4) {
HXLINE(  11)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  11)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  11)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  11)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  11)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  11)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  11)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  11)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  11)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  11)				{
HXLINE(  11)					v->width = w;
HXDLIN(  11)					v->height = h;
HXDLIN(  11)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  11)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  11)					{
HXLINE(  11)						int _g8 = 0;
HXDLIN(  11)						int _g9 = v->length;
HXDLIN(  11)						while((_g8 < _g9)){
HXLINE(  11)							_g8 = (_g8 + 1);
HXDLIN(  11)							int i2 = (_g8 - 1);
HXDLIN(  11)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  11)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  11)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  11)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  11)				{
HXLINE(  11)					b2->width = w;
HXDLIN(  11)					b2->height = h;
HXDLIN(  11)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  11)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  11)					{
HXLINE(  11)						int len1 = b2->length;
HXDLIN(  11)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  11)						if (::hx::IsNull( d->head )) {
HXLINE(  11)							int _g10 = 0;
HXDLIN(  11)							int _g11 = len1;
HXDLIN(  11)							while((_g10 < _g11)){
HXLINE(  11)								_g10 = (_g10 + 1);
HXDLIN(  11)								int i3 = (_g10 - 1);
HXDLIN(  11)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  11)							int _g12 = 0;
HXDLIN(  11)							int _g13 = len1;
HXDLIN(  11)							while((_g12 < _g13)){
HXLINE(  11)								_g12 = (_g12 + 1);
HXDLIN(  11)								int i4 = (_g12 - 1);
HXDLIN(  11)								{
HXLINE(  11)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  11)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  11)									{
HXLINE(  11)										int _g14 = 0;
HXDLIN(  11)										int _g15 = i4;
HXDLIN(  11)										while((_g14 < _g15)){
HXLINE(  11)											_g14 = (_g14 + 1);
HXDLIN(  11)											int i5 = (_g14 - 1);
HXDLIN(  11)											prev = l;
HXDLIN(  11)											l = l->next;
            										}
            									}
HXDLIN(  11)									if (::hx::IsNull( prev )) {
HXLINE(  11)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  11)										l = null();
            									}
            									else {
HXLINE(  11)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  11)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  11)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  11)		this1->image = this2;
HXDLIN(  11)		this1->width = w;
HXDLIN(  11)		this1->height = h;
HXDLIN(  11)		this1->imageType = ( (int)(imageType) );
HXLINE(  10)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ColorformImage_Impl__obj,_new,return )

 ::pi_xy::ImageStruct ColorformImage_Impl__obj::greyScale( ::pi_xy::ImageStruct this1,::hx::Null< bool >  __o_useAlpha){
            		bool useAlpha = __o_useAlpha.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_19beeba72877b987_15_greyScale)
HXLINE(  16)		int p = 0;
HXLINE(  17)		int xx = p;
HXLINE(  18)		int q = 0;
HXLINE(  19)		int width = this1->width;
HXDLIN(  19)		int height = this1->height;
HXDLIN(  19)		 ::Dynamic imageType = null();
HXDLIN(  19)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  19)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  19)		::Dynamic _hx_tmp;
HXDLIN(  19)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  19)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  19)				{
HXLINE(  19)					b->width = width;
HXDLIN(  19)					b->height = height;
HXDLIN(  19)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  19)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  19)					{
HXLINE(  19)						int len = b->length;
HXDLIN(  19)						int w = 0;
HXDLIN(  19)						{
HXLINE(  19)							int _g = 0;
HXDLIN(  19)							int _g1 = b->height;
HXDLIN(  19)							while((_g < _g1)){
HXLINE(  19)								_g = (_g + 1);
HXDLIN(  19)								int y = (_g - 1);
HXDLIN(  19)								{
HXLINE(  19)									int _g2 = 0;
HXDLIN(  19)									int _g3 = b->width;
HXDLIN(  19)									while((_g2 < _g3)){
HXLINE(  19)										_g2 = (_g2 + 1);
HXDLIN(  19)										int x = (_g2 - 1);
HXDLIN(  19)										{
HXLINE(  19)											w = (w + 1);
HXDLIN(  19)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w = (w + 1);
HXDLIN(  19)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w = (w + 1);
HXDLIN(  19)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w = (w + 1);
HXDLIN(  19)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  19)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  19)				{
HXLINE(  19)					a->width = width;
HXDLIN(  19)					a->height = height;
HXDLIN(  19)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  19)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  19)					{
HXLINE(  19)						int _g4 = 0;
HXDLIN(  19)						int _g5 = a->length;
HXDLIN(  19)						while((_g4 < _g5)){
HXLINE(  19)							_g4 = (_g4 + 1);
HXDLIN(  19)							int i = (_g4 - 1);
HXDLIN(  19)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  19)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  19)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  19)				{
HXLINE(  19)					b1->width = width;
HXDLIN(  19)					b1->height = height;
HXDLIN(  19)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  19)					int size = (b1->length * 4);
HXDLIN(  19)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  19)					{
HXLINE(  19)						int _g6 = 0;
HXDLIN(  19)						int _g7 = b1->length;
HXDLIN(  19)						while((_g6 < _g7)){
HXLINE(  19)							_g6 = (_g6 + 1);
HXDLIN(  19)							int i1 = (_g6 - 1);
HXDLIN(  19)							{
HXLINE(  19)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  19)								bool _hx_tmp1;
HXDLIN(  19)								if ((i1 >= 0)) {
HXLINE(  19)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  19)									_hx_tmp1 = false;
            								}
HXDLIN(  19)								if (_hx_tmp1) {
HXLINE(  19)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  19)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  19)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  19)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  19)				{
HXLINE(  19)					v->width = width;
HXDLIN(  19)					v->height = height;
HXDLIN(  19)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  19)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  19)					{
HXLINE(  19)						int _g8 = 0;
HXDLIN(  19)						int _g9 = v->length;
HXDLIN(  19)						while((_g8 < _g9)){
HXLINE(  19)							_g8 = (_g8 + 1);
HXDLIN(  19)							int i2 = (_g8 - 1);
HXDLIN(  19)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  19)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  19)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  19)				{
HXLINE(  19)					b2->width = width;
HXDLIN(  19)					b2->height = height;
HXDLIN(  19)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  19)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  19)					{
HXLINE(  19)						int len1 = b2->length;
HXDLIN(  19)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  19)						if (::hx::IsNull( d->head )) {
HXLINE(  19)							int _g10 = 0;
HXDLIN(  19)							int _g11 = len1;
HXDLIN(  19)							while((_g10 < _g11)){
HXLINE(  19)								_g10 = (_g10 + 1);
HXDLIN(  19)								int i3 = (_g10 - 1);
HXDLIN(  19)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  19)							int _g12 = 0;
HXDLIN(  19)							int _g13 = len1;
HXDLIN(  19)							while((_g12 < _g13)){
HXLINE(  19)								_g12 = (_g12 + 1);
HXDLIN(  19)								int i4 = (_g12 - 1);
HXDLIN(  19)								{
HXLINE(  19)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  19)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  19)									{
HXLINE(  19)										int _g14 = 0;
HXDLIN(  19)										int _g15 = i4;
HXDLIN(  19)										while((_g14 < _g15)){
HXLINE(  19)											_g14 = (_g14 + 1);
HXDLIN(  19)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  19)									if (::hx::IsNull( prev )) {
HXLINE(  19)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  19)										l = null();
            									}
            									else {
HXLINE(  19)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  19)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  19)		this2->image = _hx_tmp;
HXDLIN(  19)		this2->width = width;
HXDLIN(  19)		this2->height = height;
HXDLIN(  19)		this2->imageType = ( (int)(imageType) );
HXDLIN(  19)		 ::pi_xy::ImageStruct out = this2;
HXLINE(  20)		 ::pi_xy::ImageStruct here = this1;
HXLINE(  21)		int wid = (this1->width - 1);
HXLINE(  22)		int hi = (this1->height - 1);
HXLINE(  23)		do {
HXLINE(  24)			{
HXLINE(  24)				::Dynamic this4 = here->image;
HXDLIN(  24)				int index;
HXDLIN(  24)				if (here->useVirtualPos) {
HXLINE(  24)					index = ::Std_obj::_hx_int(((((( (Float)(q) ) - here->virtualY) * ( (Float)(here->width) )) + p) - here->virtualX));
            				}
            				else {
HXLINE(  24)					index = ::Std_obj::_hx_int(( (Float)(((q * here->width) + p)) ));
            				}
HXDLIN(  24)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  24)				int color;
HXDLIN(  24)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  24)					color = c;
            				}
HXDLIN(  24)				Float a1 = (( (Float)(((color >> 24) & 255)) ) / ( (Float)(255) ));
HXDLIN(  24)				Float r = (( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) ));
HXDLIN(  24)				Float g = (( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) ));
HXDLIN(  24)				Float b3 = (( (Float)((color & 255)) ) / ( (Float)(255) ));
HXDLIN(  24)				Float c_a = a1;
HXDLIN(  24)				Float c_r = r;
HXDLIN(  24)				Float c_g = g;
HXDLIN(  24)				Float c_b = b3;
HXDLIN(  24)				Float l1 = ((Float)0.);
HXDLIN(  24)				int v1 = 0;
HXDLIN(  24)				int color1;
HXDLIN(  24)				if (useAlpha) {
HXLINE( 143)					l1 = (c_a * (((((Float)0.21) * c_r) + (((Float)0.72) * c_g)) + (((Float)0.07) * c_b)));
HXLINE( 144)					v1 = ::Math_obj::round((l1 * ( (Float)(255) )));
HXLINE(  24)					color1 = (((-16777216 | (v1 << 16)) | (v1 << 8)) | v1);
            				}
            				else {
HXLINE( 147)					l1 = (((((Float)0.21) * c_r) + (((Float)0.72) * c_g)) + (((Float)0.07) * c_b));
HXLINE( 148)					v1 = ::Math_obj::round((l1 * ( (Float)(255) )));
HXLINE(  24)					color1 = ((((::Math_obj::round((c_a * ( (Float)(255) ))) << 24) | (v1 << 16)) | (v1 << 8)) | v1);
            				}
HXDLIN(  24)				int c1 = color1;
HXDLIN(  24)				bool _hx_tmp2;
HXDLIN(  24)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  24)					_hx_tmp2 = out->transparent;
            				}
            				else {
HXLINE(  24)					_hx_tmp2 = false;
            				}
HXDLIN(  24)				if (_hx_tmp2) {
HXLINE(  24)					int location;
HXDLIN(  24)					if (out->useVirtualPos) {
HXLINE(  24)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  24)						location = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  24)					int this5 = ::iterMagic::Iimg_obj::get(out->image,location);
HXDLIN(  24)					int this6;
HXDLIN(  24)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXLINE(  24)						this6 = this5;
            					}
HXDLIN(  24)					Float a11;
HXDLIN(  24)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  24)					if ((this7 == 0)) {
HXLINE(  24)						a11 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						a11 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float r1;
HXDLIN(  24)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  24)					if ((this8 == 0)) {
HXLINE(  24)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float g1;
HXDLIN(  24)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  24)					if ((this9 == 0)) {
HXLINE(  24)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float b11;
HXDLIN(  24)					int this10 = (this6 & 255);
HXDLIN(  24)					if ((this10 == 0)) {
HXLINE(  24)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float a2;
HXDLIN(  24)					int this11 = ((color1 >> 24) & 255);
HXDLIN(  24)					if ((this11 == 0)) {
HXLINE(  24)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float r2;
HXDLIN(  24)					int this12 = ((color1 >> 16) & 255);
HXDLIN(  24)					if ((this12 == 0)) {
HXLINE(  24)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float g2;
HXDLIN(  24)					int this13 = ((color1 >> 8) & 255);
HXDLIN(  24)					if ((this13 == 0)) {
HXLINE(  24)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float b21;
HXDLIN(  24)					int this14 = (color1 & 255);
HXDLIN(  24)					if ((this14 == 0)) {
HXLINE(  24)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  24)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  24)					Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  24)					int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  24)					int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  24)					int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  24)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  24)					int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  24)					{
HXLINE(  24)						int _hx_tmp3;
HXDLIN(  24)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  24)							_hx_tmp3 = blended;
            						}
HXDLIN(  24)						::iterMagic::Iimg_obj::set(out->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  24)					::Dynamic this15 = out->image;
HXDLIN(  24)					int index1;
HXDLIN(  24)					if (out->useVirtualPos) {
HXLINE(  24)						index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  24)						index1 = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  24)					int _hx_tmp4;
HXDLIN(  24)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  24)						_hx_tmp4 = c1;
            					}
HXDLIN(  24)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
HXLINE(  25)			p = (p + 1);
HXLINE(  26)			if ((p > wid)) {
HXLINE(  27)				p = xx;
HXLINE(  28)				q = (q + 1);
            			}
            		} while((q <= hi));
;
HXLINE(  33)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ColorformImage_Impl__obj,greyScale,return )

 ::pi_xy::ImageStruct ColorformImage_Impl__obj::towardsColor( ::pi_xy::ImageStruct this1,int color,Float t){
            	HX_GC_STACKFRAME(&_hx_pos_19beeba72877b987_37_towardsColor)
HXLINE(  38)		int p = 0;
HXLINE(  39)		int xx = p;
HXLINE(  40)		int q = 0;
HXLINE(  41)		int width = this1->width;
HXDLIN(  41)		int height = this1->height;
HXDLIN(  41)		 ::Dynamic imageType = null();
HXDLIN(  41)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  41)		if (::hx::IsNull( imageType )) {
HXLINE(  41)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  41)		::Dynamic _hx_tmp;
HXDLIN(  41)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  41)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  41)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  41)				{
HXLINE(  41)					b->width = width;
HXDLIN(  41)					b->height = height;
HXDLIN(  41)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  41)					{
HXLINE(  41)						int len = b->length;
HXDLIN(  41)						int w = 0;
HXDLIN(  41)						{
HXLINE(  41)							int _g = 0;
HXDLIN(  41)							int _g1 = b->height;
HXDLIN(  41)							while((_g < _g1)){
HXLINE(  41)								_g = (_g + 1);
HXDLIN(  41)								int y = (_g - 1);
HXDLIN(  41)								{
HXLINE(  41)									int _g2 = 0;
HXDLIN(  41)									int _g3 = b->width;
HXDLIN(  41)									while((_g2 < _g3)){
HXLINE(  41)										_g2 = (_g2 + 1);
HXDLIN(  41)										int x = (_g2 - 1);
HXDLIN(  41)										{
HXLINE(  41)											w = (w + 1);
HXDLIN(  41)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  41)										{
HXLINE(  41)											w = (w + 1);
HXDLIN(  41)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  41)										{
HXLINE(  41)											w = (w + 1);
HXDLIN(  41)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  41)										{
HXLINE(  41)											w = (w + 1);
HXDLIN(  41)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  41)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  41)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  41)				{
HXLINE(  41)					a->width = width;
HXDLIN(  41)					a->height = height;
HXDLIN(  41)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  41)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)					{
HXLINE(  41)						int _g4 = 0;
HXDLIN(  41)						int _g5 = a->length;
HXDLIN(  41)						while((_g4 < _g5)){
HXLINE(  41)							_g4 = (_g4 + 1);
HXDLIN(  41)							int i = (_g4 - 1);
HXDLIN(  41)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  41)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  41)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  41)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  41)				{
HXLINE(  41)					b1->width = width;
HXDLIN(  41)					b1->height = height;
HXDLIN(  41)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)					int size = (b1->length * 4);
HXDLIN(  41)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  41)					{
HXLINE(  41)						int _g6 = 0;
HXDLIN(  41)						int _g7 = b1->length;
HXDLIN(  41)						while((_g6 < _g7)){
HXLINE(  41)							_g6 = (_g6 + 1);
HXDLIN(  41)							int i1 = (_g6 - 1);
HXDLIN(  41)							{
HXLINE(  41)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  41)								bool _hx_tmp1;
HXDLIN(  41)								if ((i1 >= 0)) {
HXLINE(  41)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  41)									_hx_tmp1 = false;
            								}
HXDLIN(  41)								if (_hx_tmp1) {
HXLINE(  41)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  41)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  41)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  41)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  41)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  41)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  41)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  41)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  41)				{
HXLINE(  41)					v->width = width;
HXDLIN(  41)					v->height = height;
HXDLIN(  41)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  41)					{
HXLINE(  41)						int _g8 = 0;
HXDLIN(  41)						int _g9 = v->length;
HXDLIN(  41)						while((_g8 < _g9)){
HXLINE(  41)							_g8 = (_g8 + 1);
HXDLIN(  41)							int i2 = (_g8 - 1);
HXDLIN(  41)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  41)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  41)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  41)				{
HXLINE(  41)					b2->width = width;
HXDLIN(  41)					b2->height = height;
HXDLIN(  41)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  41)					{
HXLINE(  41)						int len1 = b2->length;
HXDLIN(  41)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  41)						if (::hx::IsNull( d->head )) {
HXLINE(  41)							int _g10 = 0;
HXDLIN(  41)							int _g11 = len1;
HXDLIN(  41)							while((_g10 < _g11)){
HXLINE(  41)								_g10 = (_g10 + 1);
HXDLIN(  41)								int i3 = (_g10 - 1);
HXDLIN(  41)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  41)							int _g12 = 0;
HXDLIN(  41)							int _g13 = len1;
HXDLIN(  41)							while((_g12 < _g13)){
HXLINE(  41)								_g12 = (_g12 + 1);
HXDLIN(  41)								int i4 = (_g12 - 1);
HXDLIN(  41)								{
HXLINE(  41)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  41)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  41)									{
HXLINE(  41)										int _g14 = 0;
HXDLIN(  41)										int _g15 = i4;
HXDLIN(  41)										while((_g14 < _g15)){
HXLINE(  41)											_g14 = (_g14 + 1);
HXDLIN(  41)											int i5 = (_g14 - 1);
HXDLIN(  41)											prev = l;
HXDLIN(  41)											l = l->next;
            										}
            									}
HXDLIN(  41)									if (::hx::IsNull( prev )) {
HXLINE(  41)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  41)										l = null();
            									}
            									else {
HXLINE(  41)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  41)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  41)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  41)		this2->image = _hx_tmp;
HXDLIN(  41)		this2->width = width;
HXDLIN(  41)		this2->height = height;
HXDLIN(  41)		this2->imageType = ( (int)(imageType) );
HXDLIN(  41)		 ::pi_xy::ImageStruct out = this2;
HXLINE(  42)		 ::pi_xy::ImageStruct here = this1;
HXLINE(  43)		int wid = (this1->width - 1);
HXLINE(  44)		int hi = (this1->height - 1);
HXLINE(  45)		do {
HXLINE(  46)			{
HXLINE(  46)				::Dynamic this4 = here->image;
HXDLIN(  46)				int index;
HXDLIN(  46)				if (here->useVirtualPos) {
HXLINE(  46)					index = ::Std_obj::_hx_int(((((( (Float)(q) ) - here->virtualY) * ( (Float)(here->width) )) + p) - here->virtualX));
            				}
            				else {
HXLINE(  46)					index = ::Std_obj::_hx_int(( (Float)(((q * here->width) + p)) ));
            				}
HXDLIN(  46)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  46)				int a1;
HXDLIN(  46)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)					a1 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  46)					a1 = c;
            				}
HXDLIN(  46)				int color1 = ((((::Math_obj::round((((t * (( (Float)(((a1 >> 24) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((color >> 24) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 24) | (::Math_obj::round((((t * (( (Float)(((a1 >> 16) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((((t * (( (Float)(((a1 >> 8) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((((t * (( (Float)((a1 & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)((color & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))));
HXDLIN(  46)				int c1 = color1;
HXDLIN(  46)				bool _hx_tmp2;
HXDLIN(  46)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  46)					_hx_tmp2 = out->transparent;
            				}
            				else {
HXLINE(  46)					_hx_tmp2 = false;
            				}
HXDLIN(  46)				if (_hx_tmp2) {
HXLINE(  46)					int location;
HXDLIN(  46)					if (out->useVirtualPos) {
HXLINE(  46)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  46)						location = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  46)					int this5 = ::iterMagic::Iimg_obj::get(out->image,location);
HXDLIN(  46)					int this6;
HXDLIN(  46)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXLINE(  46)						this6 = this5;
            					}
HXDLIN(  46)					Float a11;
HXDLIN(  46)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  46)					if ((this7 == 0)) {
HXLINE(  46)						a11 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						a11 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float r1;
HXDLIN(  46)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  46)					if ((this8 == 0)) {
HXLINE(  46)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float g1;
HXDLIN(  46)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  46)					if ((this9 == 0)) {
HXLINE(  46)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float b11;
HXDLIN(  46)					int this10 = (this6 & 255);
HXDLIN(  46)					if ((this10 == 0)) {
HXLINE(  46)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float a2;
HXDLIN(  46)					int this11 = ((color1 >> 24) & 255);
HXDLIN(  46)					if ((this11 == 0)) {
HXLINE(  46)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float r2;
HXDLIN(  46)					int this12 = ((color1 >> 16) & 255);
HXDLIN(  46)					if ((this12 == 0)) {
HXLINE(  46)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float g2;
HXDLIN(  46)					int this13 = ((color1 >> 8) & 255);
HXDLIN(  46)					if ((this13 == 0)) {
HXLINE(  46)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float b21;
HXDLIN(  46)					int this14 = (color1 & 255);
HXDLIN(  46)					if ((this14 == 0)) {
HXLINE(  46)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  46)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  46)					Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  46)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  46)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  46)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  46)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  46)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  46)					{
HXLINE(  46)						int _hx_tmp3;
HXDLIN(  46)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  46)							_hx_tmp3 = blended;
            						}
HXDLIN(  46)						::iterMagic::Iimg_obj::set(out->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  46)					::Dynamic this15 = out->image;
HXDLIN(  46)					int index1;
HXDLIN(  46)					if (out->useVirtualPos) {
HXLINE(  46)						index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  46)						index1 = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  46)					int _hx_tmp4;
HXDLIN(  46)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  46)						_hx_tmp4 = c1;
            					}
HXDLIN(  46)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
HXLINE(  47)			p = (p + 1);
HXLINE(  48)			if ((p > wid)) {
HXLINE(  49)				p = xx;
HXLINE(  50)				q = (q + 1);
            			}
            		} while((q <= hi));
;
HXLINE(  55)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(ColorformImage_Impl__obj,towardsColor,return )

 ::pi_xy::ImageStruct ColorformImage_Impl__obj::towardsImage( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct img,Float t){
            	HX_GC_STACKFRAME(&_hx_pos_19beeba72877b987_58_towardsImage)
HXLINE(  59)		int p = 0;
HXLINE(  60)		int xx = p;
HXLINE(  61)		int q = 0;
HXLINE(  62)		 ::pi_xy::ImageStruct here = this1;
HXLINE(  63)		int width = this1->width;
HXDLIN(  63)		int height = this1->height;
HXDLIN(  63)		 ::Dynamic imageType = null();
HXDLIN(  63)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  63)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  63)		::Dynamic _hx_tmp;
HXDLIN(  63)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  63)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  63)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  63)				{
HXLINE(  63)					b->width = width;
HXDLIN(  63)					b->height = height;
HXDLIN(  63)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  63)					{
HXLINE(  63)						int len = b->length;
HXDLIN(  63)						int w = 0;
HXDLIN(  63)						{
HXLINE(  63)							int _g = 0;
HXDLIN(  63)							int _g1 = b->height;
HXDLIN(  63)							while((_g < _g1)){
HXLINE(  63)								_g = (_g + 1);
HXDLIN(  63)								int y = (_g - 1);
HXDLIN(  63)								{
HXLINE(  63)									int _g2 = 0;
HXDLIN(  63)									int _g3 = b->width;
HXDLIN(  63)									while((_g2 < _g3)){
HXLINE(  63)										_g2 = (_g2 + 1);
HXDLIN(  63)										int x = (_g2 - 1);
HXDLIN(  63)										{
HXLINE(  63)											w = (w + 1);
HXDLIN(  63)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  63)										{
HXLINE(  63)											w = (w + 1);
HXDLIN(  63)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  63)										{
HXLINE(  63)											w = (w + 1);
HXDLIN(  63)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  63)										{
HXLINE(  63)											w = (w + 1);
HXDLIN(  63)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  63)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  63)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  63)				{
HXLINE(  63)					a->width = width;
HXDLIN(  63)					a->height = height;
HXDLIN(  63)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  63)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)					{
HXLINE(  63)						int _g4 = 0;
HXDLIN(  63)						int _g5 = a->length;
HXDLIN(  63)						while((_g4 < _g5)){
HXLINE(  63)							_g4 = (_g4 + 1);
HXDLIN(  63)							int i = (_g4 - 1);
HXDLIN(  63)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  63)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  63)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  63)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  63)				{
HXLINE(  63)					b1->width = width;
HXDLIN(  63)					b1->height = height;
HXDLIN(  63)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)					int size = (b1->length * 4);
HXDLIN(  63)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)					{
HXLINE(  63)						int _g6 = 0;
HXDLIN(  63)						int _g7 = b1->length;
HXDLIN(  63)						while((_g6 < _g7)){
HXLINE(  63)							_g6 = (_g6 + 1);
HXDLIN(  63)							int i1 = (_g6 - 1);
HXDLIN(  63)							{
HXLINE(  63)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  63)								bool _hx_tmp1;
HXDLIN(  63)								if ((i1 >= 0)) {
HXLINE(  63)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  63)									_hx_tmp1 = false;
            								}
HXDLIN(  63)								if (_hx_tmp1) {
HXLINE(  63)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  63)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  63)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  63)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  63)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  63)				{
HXLINE(  63)					v->width = width;
HXDLIN(  63)					v->height = height;
HXDLIN(  63)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  63)					{
HXLINE(  63)						int _g8 = 0;
HXDLIN(  63)						int _g9 = v->length;
HXDLIN(  63)						while((_g8 < _g9)){
HXLINE(  63)							_g8 = (_g8 + 1);
HXDLIN(  63)							int i2 = (_g8 - 1);
HXDLIN(  63)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  63)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  63)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  63)				{
HXLINE(  63)					b2->width = width;
HXDLIN(  63)					b2->height = height;
HXDLIN(  63)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  63)					{
HXLINE(  63)						int len1 = b2->length;
HXDLIN(  63)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  63)						if (::hx::IsNull( d->head )) {
HXLINE(  63)							int _g10 = 0;
HXDLIN(  63)							int _g11 = len1;
HXDLIN(  63)							while((_g10 < _g11)){
HXLINE(  63)								_g10 = (_g10 + 1);
HXDLIN(  63)								int i3 = (_g10 - 1);
HXDLIN(  63)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  63)							int _g12 = 0;
HXDLIN(  63)							int _g13 = len1;
HXDLIN(  63)							while((_g12 < _g13)){
HXLINE(  63)								_g12 = (_g12 + 1);
HXDLIN(  63)								int i4 = (_g12 - 1);
HXDLIN(  63)								{
HXLINE(  63)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  63)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  63)									{
HXLINE(  63)										int _g14 = 0;
HXDLIN(  63)										int _g15 = i4;
HXDLIN(  63)										while((_g14 < _g15)){
HXLINE(  63)											_g14 = (_g14 + 1);
HXDLIN(  63)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  63)									if (::hx::IsNull( prev )) {
HXLINE(  63)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  63)										l = null();
            									}
            									else {
HXLINE(  63)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  63)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  63)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  63)		this2->image = _hx_tmp;
HXDLIN(  63)		this2->width = width;
HXDLIN(  63)		this2->height = height;
HXDLIN(  63)		this2->imageType = ( (int)(imageType) );
HXDLIN(  63)		 ::pi_xy::ImageStruct out = this2;
HXLINE(  64)		 ::pi_xy::ImageStruct here1 = img;
HXDLIN(  64)		 ::pi_xy::ImageStruct imgTarget;
HXDLIN(  64)		bool imgTarget1;
HXDLIN(  64)		if ((here->width == here1->width)) {
HXLINE(  64)			imgTarget1 = (here->height != here1->height);
            		}
            		else {
HXLINE(  64)			imgTarget1 = true;
            		}
HXDLIN(  64)		if (imgTarget1) {
HXLINE(  64)			Float sx = (( (Float)(here1->width) ) / ( (Float)(here->width) ));
HXDLIN(  64)			Float sy = (( (Float)(here1->height) ) / ( (Float)(here->height) ));
HXDLIN(  64)			bool transparent = false;
HXDLIN(  64)			bool includeMask = false;
HXDLIN(  64)			 ::pi_xy::ImageStruct thisImage = here;
HXDLIN(  64)			int scaleW = ::Std_obj::_hx_int(sx);
HXDLIN(  64)			int scaleH = ::Std_obj::_hx_int(sy);
HXDLIN(  64)			bool ifScaleUpInt;
HXDLIN(  64)			bool ifScaleUpInt1;
HXDLIN(  64)			bool ifScaleUpInt2;
HXDLIN(  64)			if ((scaleW == sx)) {
HXLINE(  64)				ifScaleUpInt2 = (sx > ((Float)0.));
            			}
            			else {
HXLINE(  64)				ifScaleUpInt2 = false;
            			}
HXDLIN(  64)			if (ifScaleUpInt2) {
HXLINE(  64)				ifScaleUpInt1 = (scaleH == sy);
            			}
            			else {
HXLINE(  64)				ifScaleUpInt1 = false;
            			}
HXDLIN(  64)			if (ifScaleUpInt1) {
HXLINE(  64)				ifScaleUpInt = (sy > ((Float)0.));
            			}
            			else {
HXLINE(  64)				ifScaleUpInt = false;
            			}
HXDLIN(  64)			if (ifScaleUpInt) {
HXLINE(  64)				bool includeMask1 = false;
HXDLIN(  64)				 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN(  64)				int p1 = 0;
HXDLIN(  64)				int xx1 = p1;
HXDLIN(  64)				int q1 = 0;
HXDLIN(  64)				int wNew = ::Std_obj::_hx_int(( (Float)((thisImage1->width * scaleW)) ));
HXDLIN(  64)				int hNew = ::Std_obj::_hx_int(( (Float)((thisImage1->height * scaleH)) ));
HXDLIN(  64)				 ::Dynamic imageType1 = null();
HXDLIN(  64)				 ::pi_xy::ImageStruct this4 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  64)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  64)				::Dynamic imgTarget2;
HXDLIN(  64)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  64)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::BytesImg b3 = byt1;
HXDLIN(  64)						{
HXLINE(  64)							b3->width = wNew;
HXDLIN(  64)							b3->height = hNew;
HXDLIN(  64)							b3->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  64)							b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN(  64)							{
HXLINE(  64)								int len2 = b3->length;
HXDLIN(  64)								int w1 = 0;
HXDLIN(  64)								{
HXLINE(  64)									int _g16 = 0;
HXDLIN(  64)									int _g17 = b3->height;
HXDLIN(  64)									while((_g16 < _g17)){
HXLINE(  64)										_g16 = (_g16 + 1);
HXDLIN(  64)										int y1 = (_g16 - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g18 = 0;
HXDLIN(  64)											int _g19 = b3->width;
HXDLIN(  64)											while((_g18 < _g19)){
HXLINE(  64)												_g18 = (_g18 + 1);
HXDLIN(  64)												int x1 = (_g18 - 1);
HXDLIN(  64)												{
HXLINE(  64)													w1 = (w1 + 1);
HXDLIN(  64)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w1 = (w1 + 1);
HXDLIN(  64)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w1 = (w1 + 1);
HXDLIN(  64)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w1 = (w1 + 1);
HXDLIN(  64)													b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget2 = b3;
            					}
            					break;
            					case (int)1: {
HXLINE(  64)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN(  64)						{
HXLINE(  64)							a1->width = wNew;
HXDLIN(  64)							a1->height = hNew;
HXDLIN(  64)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  64)							a1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  64)							{
HXLINE(  64)								int _g20 = 0;
HXDLIN(  64)								int _g21 = a1->length;
HXDLIN(  64)								while((_g20 < _g21)){
HXLINE(  64)									_g20 = (_g20 + 1);
HXDLIN(  64)									int i6 = (_g20 - 1);
HXDLIN(  64)									a1->data[i6] = 0;
            								}
            							}
            						}
HXDLIN(  64)						imgTarget2 = a1;
            					}
            					break;
            					case (int)2: {
HXLINE(  64)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN(  64)						{
HXLINE(  64)							b4->width = wNew;
HXDLIN(  64)							b4->height = hNew;
HXDLIN(  64)							b4->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  64)							int size1 = (b4->length * 4);
HXDLIN(  64)							b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  64)							{
HXLINE(  64)								int _g22 = 0;
HXDLIN(  64)								int _g23 = b4->length;
HXDLIN(  64)								while((_g22 < _g23)){
HXLINE(  64)									_g22 = (_g22 + 1);
HXDLIN(  64)									int i7 = (_g22 - 1);
HXDLIN(  64)									{
HXLINE(  64)										 ::haxe::io::ArrayBufferViewImpl this5 = b4->data;
HXDLIN(  64)										bool imgTarget3;
HXDLIN(  64)										if ((i7 >= 0)) {
HXLINE(  64)											imgTarget3 = (i7 < (this5->byteLength >> 2));
            										}
            										else {
HXLINE(  64)											imgTarget3 = false;
            										}
HXDLIN(  64)										if (imgTarget3) {
HXLINE(  64)											 ::haxe::io::Bytes _this1 = this5->bytes;
HXDLIN(  64)											int pos1 = ((i7 << 2) + this5->byteOffset);
HXDLIN(  64)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  64)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget2 = b4;
            					}
            					break;
            					case (int)3: {
HXLINE(  64)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  64)						{
HXLINE(  64)							v1->width = wNew;
HXDLIN(  64)							v1->height = hNew;
HXDLIN(  64)							v1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  64)							v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  64)							{
HXLINE(  64)								int _g24 = 0;
HXDLIN(  64)								int _g25 = v1->length;
HXDLIN(  64)								while((_g24 < _g25)){
HXLINE(  64)									_g24 = (_g24 + 1);
HXDLIN(  64)									int i8 = (_g24 - 1);
HXDLIN(  64)									v1->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN(  64)						imgTarget2 = v1;
            					}
            					break;
            					case (int)4: {
HXLINE(  64)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN(  64)						{
HXLINE(  64)							b5->width = wNew;
HXDLIN(  64)							b5->height = hNew;
HXDLIN(  64)							b5->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  64)							b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  64)							{
HXLINE(  64)								int len3 = b5->length;
HXDLIN(  64)								 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN(  64)								if (::hx::IsNull( d1->head )) {
HXLINE(  64)									int _g26 = 0;
HXDLIN(  64)									int _g27 = len3;
HXDLIN(  64)									while((_g26 < _g27)){
HXLINE(  64)										_g26 = (_g26 + 1);
HXDLIN(  64)										int i9 = (_g26 - 1);
HXDLIN(  64)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  64)									int _g28 = 0;
HXDLIN(  64)									int _g29 = len3;
HXDLIN(  64)									while((_g28 < _g29)){
HXLINE(  64)										_g28 = (_g28 + 1);
HXDLIN(  64)										int i10 = (_g28 - 1);
HXDLIN(  64)										{
HXLINE(  64)											 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN(  64)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  64)											{
HXLINE(  64)												int _g30 = 0;
HXDLIN(  64)												int _g31 = i10;
HXDLIN(  64)												while((_g30 < _g31)){
HXLINE(  64)													_g30 = (_g30 + 1);
HXDLIN(  64)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  64)											if (::hx::IsNull( prev1 )) {
HXLINE(  64)												b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  64)												l1 = null();
            											}
            											else {
HXLINE(  64)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  64)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget2 = b5;
            					}
            					break;
            				}
HXDLIN(  64)				this4->image = imgTarget2;
HXDLIN(  64)				this4->width = wNew;
HXDLIN(  64)				this4->height = hNew;
HXDLIN(  64)				this4->imageType = ( (int)(imageType1) );
HXDLIN(  64)				 ::pi_xy::ImageStruct nextImage = this4;
HXDLIN(  64)				int maxX = wNew;
HXDLIN(  64)				int maxY = hNew;
HXDLIN(  64)				do {
HXLINE(  64)					int x2 = ::Std_obj::_hx_int((( (Float)(p1) ) / ( (Float)(scaleW) )));
HXDLIN(  64)					int y2 = ::Std_obj::_hx_int((( (Float)(q1) ) / ( (Float)(scaleH) )));
HXDLIN(  64)					::Dynamic this6 = thisImage1->image;
HXDLIN(  64)					int index;
HXDLIN(  64)					if (thisImage1->useVirtualPos) {
HXLINE(  64)						index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x2) - thisImage1->virtualX));
            					}
            					else {
HXLINE(  64)						index = ::Std_obj::_hx_int(( (Float)(((y2 * thisImage1->width) + x2)) ));
            					}
HXDLIN(  64)					int c = ::iterMagic::Iimg_obj::get(this6,index);
HXDLIN(  64)					int color;
HXDLIN(  64)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE(  64)						color = c;
            					}
HXDLIN(  64)					{
HXLINE(  64)						p1 = (p1 + 1);
HXDLIN(  64)						int x3 = (p1 - 1);
HXDLIN(  64)						int c1 = color;
HXDLIN(  64)						bool imgTarget4;
HXDLIN(  64)						if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  64)							imgTarget4 = nextImage->transparent;
            						}
            						else {
HXLINE(  64)							imgTarget4 = false;
            						}
HXDLIN(  64)						if (imgTarget4) {
HXLINE(  64)							int location;
HXDLIN(  64)							if (nextImage->useVirtualPos) {
HXLINE(  64)								location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x3) - nextImage->virtualX));
            							}
            							else {
HXLINE(  64)								location = ::Std_obj::_hx_int(( (Float)(((q1 * nextImage->width) + x3)) ));
            							}
HXDLIN(  64)							int this7 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  64)							int this8;
HXDLIN(  64)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)								this8 = ((((((this7 >> 24) & 255) << 24) | ((this7 & 255) << 16)) | (((this7 >> 8) & 255) << 8)) | ((this7 >> 16) & 255));
            							}
            							else {
HXLINE(  64)								this8 = this7;
            							}
HXDLIN(  64)							Float a11;
HXDLIN(  64)							int this9 = ((this8 >> 24) & 255);
HXDLIN(  64)							if ((this9 == 0)) {
HXLINE(  64)								a11 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								a11 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float r1;
HXDLIN(  64)							int this10 = ((this8 >> 16) & 255);
HXDLIN(  64)							if ((this10 == 0)) {
HXLINE(  64)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								r1 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float g1;
HXDLIN(  64)							int this11 = ((this8 >> 8) & 255);
HXDLIN(  64)							if ((this11 == 0)) {
HXLINE(  64)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								g1 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float b11;
HXDLIN(  64)							int this12 = (this8 & 255);
HXDLIN(  64)							if ((this12 == 0)) {
HXLINE(  64)								b11 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								b11 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float a2;
HXDLIN(  64)							int this13 = ((color >> 24) & 255);
HXDLIN(  64)							if ((this13 == 0)) {
HXLINE(  64)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								a2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float r2;
HXDLIN(  64)							int this14 = ((color >> 16) & 255);
HXDLIN(  64)							if ((this14 == 0)) {
HXLINE(  64)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								r2 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float g2;
HXDLIN(  64)							int this15 = ((color >> 8) & 255);
HXDLIN(  64)							if ((this15 == 0)) {
HXLINE(  64)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								g2 = (( (Float)(this15) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float b21;
HXDLIN(  64)							int this16 = (color & 255);
HXDLIN(  64)							if ((this16 == 0)) {
HXLINE(  64)								b21 = ((Float)0.);
            							}
            							else {
HXLINE(  64)								b21 = (( (Float)(this16) ) / ( (Float)(255) ));
            							}
HXDLIN(  64)							Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  64)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)							int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  64)							int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)							int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN(  64)							{
HXLINE(  64)								int imgTarget5;
HXDLIN(  64)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									imgTarget5 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  64)									imgTarget5 = blended;
            								}
HXDLIN(  64)								::iterMagic::Iimg_obj::set(nextImage->image,location,imgTarget5);
            							}
            						}
            						else {
HXLINE(  64)							::Dynamic this17 = nextImage->image;
HXDLIN(  64)							int index1;
HXDLIN(  64)							if (nextImage->useVirtualPos) {
HXLINE(  64)								index1 = ::Std_obj::_hx_int(((((( (Float)(q1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x3) - nextImage->virtualX));
            							}
            							else {
HXLINE(  64)								index1 = ::Std_obj::_hx_int(( (Float)(((q1 * nextImage->width) + x3)) ));
            							}
HXDLIN(  64)							int imgTarget6;
HXDLIN(  64)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)								imgTarget6 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            							}
            							else {
HXLINE(  64)								imgTarget6 = c1;
            							}
HXDLIN(  64)							::iterMagic::Iimg_obj::set(this17,index1,imgTarget6);
            						}
            					}
HXDLIN(  64)					if ((p1 > maxX)) {
HXLINE(  22)						p1 = xx1;
HXLINE(  64)						q1 = (q1 + 1);
            					}
            				} while((q1 <= maxY));
;
HXDLIN(  64)				bool imgTarget7;
HXDLIN(  64)				if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE(  64)					imgTarget7 = includeMask1;
            				}
            				else {
HXLINE(  64)					imgTarget7 = false;
            				}
HXDLIN(  64)				if (imgTarget7) {
HXLINE(  64)					 ::pi_xy::ImageStruct v2 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage1->mask,scaleW,scaleH,thisImage1->mask->transparent,includeMask1);
HXDLIN(  64)					nextImage->useMask = true;
HXDLIN(  64)					nextImage->mask = v2;
            				}
HXDLIN(  64)				imgTarget = nextImage;
            			}
            			else {
HXLINE(  64)				Float w2 = (( (Float)(thisImage->width) ) * sx);
HXDLIN(  64)				Float h = (( (Float)(thisImage->height) ) * sy);
HXDLIN(  64)				int wid = ::Math_obj::ceil(w2);
HXDLIN(  64)				int hi = ::Math_obj::ceil(h);
HXDLIN(  64)				 ::Dynamic imageType2 = null();
HXDLIN(  64)				 ::pi_xy::ImageStruct this18 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  64)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  64)				::Dynamic imgTarget8;
HXDLIN(  64)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE(  64)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::BytesImg b7 = byt2;
HXDLIN(  64)						{
HXLINE(  64)							b7->width = wid;
HXDLIN(  64)							b7->height = hi;
HXDLIN(  64)							b7->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  64)							b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  64)							{
HXLINE(  64)								int len4 = b7->length;
HXDLIN(  64)								int w3 = 0;
HXDLIN(  64)								{
HXLINE(  64)									int _g32 = 0;
HXDLIN(  64)									int _g33 = b7->height;
HXDLIN(  64)									while((_g32 < _g33)){
HXLINE(  64)										_g32 = (_g32 + 1);
HXDLIN(  64)										int y3 = (_g32 - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g34 = 0;
HXDLIN(  64)											int _g35 = b7->width;
HXDLIN(  64)											while((_g34 < _g35)){
HXLINE(  64)												_g34 = (_g34 + 1);
HXDLIN(  64)												int x4 = (_g34 - 1);
HXDLIN(  64)												{
HXLINE(  64)													w3 = (w3 + 1);
HXDLIN(  64)													b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w3 = (w3 + 1);
HXDLIN(  64)													b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w3 = (w3 + 1);
HXDLIN(  64)													b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  64)												{
HXLINE(  64)													w3 = (w3 + 1);
HXDLIN(  64)													b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget8 = b7;
            					}
            					break;
            					case (int)1: {
HXLINE(  64)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::ArrIntImg a5 = arrI2;
HXDLIN(  64)						{
HXLINE(  64)							a5->width = wid;
HXDLIN(  64)							a5->height = hi;
HXDLIN(  64)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  64)							a5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  64)							{
HXLINE(  64)								int _g36 = 0;
HXDLIN(  64)								int _g37 = a5->length;
HXDLIN(  64)								while((_g36 < _g37)){
HXLINE(  64)									_g36 = (_g36 + 1);
HXDLIN(  64)									int i12 = (_g36 - 1);
HXDLIN(  64)									a5->data[i12] = 0;
            								}
            							}
            						}
HXDLIN(  64)						imgTarget8 = a5;
            					}
            					break;
            					case (int)2: {
HXLINE(  64)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::U32ArrImg b8 = u32a2;
HXDLIN(  64)						{
HXLINE(  64)							b8->width = wid;
HXDLIN(  64)							b8->height = hi;
HXDLIN(  64)							b8->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  64)							int size2 = (b8->length * 4);
HXDLIN(  64)							b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  64)							{
HXLINE(  64)								int _g38 = 0;
HXDLIN(  64)								int _g39 = b8->length;
HXDLIN(  64)								while((_g38 < _g39)){
HXLINE(  64)									_g38 = (_g38 + 1);
HXDLIN(  64)									int i13 = (_g38 - 1);
HXDLIN(  64)									{
HXLINE(  64)										 ::haxe::io::ArrayBufferViewImpl this19 = b8->data;
HXDLIN(  64)										bool imgTarget9;
HXDLIN(  64)										if ((i13 >= 0)) {
HXLINE(  64)											imgTarget9 = (i13 < (this19->byteLength >> 2));
            										}
            										else {
HXLINE(  64)											imgTarget9 = false;
            										}
HXDLIN(  64)										if (imgTarget9) {
HXLINE(  64)											 ::haxe::io::Bytes _this2 = this19->bytes;
HXDLIN(  64)											int pos2 = ((i13 << 2) + this19->byteOffset);
HXDLIN(  64)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  64)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget8 = b8;
            					}
            					break;
            					case (int)3: {
HXLINE(  64)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN(  64)						{
HXLINE(  64)							v3->width = wid;
HXDLIN(  64)							v3->height = hi;
HXDLIN(  64)							v3->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  64)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  64)							{
HXLINE(  64)								int _g40 = 0;
HXDLIN(  64)								int _g41 = v3->length;
HXDLIN(  64)								while((_g40 < _g41)){
HXLINE(  64)									_g40 = (_g40 + 1);
HXDLIN(  64)									int i14 = (_g40 - 1);
HXDLIN(  64)									v3->data->__unsafe_set(i14,0);
            								}
            							}
            						}
HXDLIN(  64)						imgTarget8 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE(  64)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)						 ::iterMagic::StackIntImg b9 = sInt2;
HXDLIN(  64)						{
HXLINE(  64)							b9->width = wid;
HXDLIN(  64)							b9->height = hi;
HXDLIN(  64)							b9->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  64)							b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  64)							{
HXLINE(  64)								int len5 = b9->length;
HXDLIN(  64)								 ::haxe::ds::GenericStack_Int d2 = b9->data;
HXDLIN(  64)								if (::hx::IsNull( d2->head )) {
HXLINE(  64)									int _g42 = 0;
HXDLIN(  64)									int _g43 = len5;
HXDLIN(  64)									while((_g42 < _g43)){
HXLINE(  64)										_g42 = (_g42 + 1);
HXDLIN(  64)										int i15 = (_g42 - 1);
HXDLIN(  64)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE(  64)									int _g44 = 0;
HXDLIN(  64)									int _g45 = len5;
HXDLIN(  64)									while((_g44 < _g45)){
HXLINE(  64)										_g44 = (_g44 + 1);
HXDLIN(  64)										int i16 = (_g44 - 1);
HXDLIN(  64)										{
HXLINE(  64)											 ::haxe::ds::GenericCell_Int l2 = b9->data->head;
HXDLIN(  64)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  64)											{
HXLINE(  64)												int _g46 = 0;
HXDLIN(  64)												int _g47 = i16;
HXDLIN(  64)												while((_g46 < _g47)){
HXLINE(  64)													_g46 = (_g46 + 1);
HXDLIN(  64)													int i17 = (_g46 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE(  64)											if (::hx::IsNull( prev2 )) {
HXLINE(  64)												b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  64)												l2 = null();
            											}
            											else {
HXLINE(  64)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  64)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						imgTarget8 = b9;
            					}
            					break;
            				}
HXDLIN(  64)				this18->image = imgTarget8;
HXDLIN(  64)				this18->width = wid;
HXDLIN(  64)				this18->height = hi;
HXDLIN(  64)				this18->imageType = ( (int)(imageType2) );
HXDLIN(  64)				 ::pi_xy::ImageStruct nextImage1 = this18;
HXDLIN(  64)				{
HXLINE(  64)					bool v4 = thisImage->transparent;
HXDLIN(  64)					nextImage1->transparent = v4;
            				}
HXDLIN(  64)				{
HXLINE(  64)					 ::pi_xy::ImageStruct this20 = nextImage1;
HXDLIN(  64)					Float win_x = ( (Float)(0) );
HXDLIN(  64)					Float win_y = ( (Float)(0) );
HXDLIN(  64)					Float win_width = ( (Float)(thisImage->width) );
HXDLIN(  64)					Float win_height = ( (Float)(thisImage->height) );
HXDLIN(  64)					{
HXLINE(  64)						Float bu = ((Float)1.);
HXDLIN(  64)						Float bv = ((Float)0.);
HXDLIN(  64)						Float cu = ((Float)1.);
HXDLIN(  64)						Float cv = ((Float)1.);
HXDLIN(  64)						Float du = ((Float)0.);
HXDLIN(  64)						Float dv = ((Float)1.);
HXDLIN(  64)						Float au = ((Float)0.);
HXDLIN(  64)						Float av = ((Float)0.);
HXDLIN(  64)						Float bu1 = bu;
HXDLIN(  64)						Float bv1 = bv;
HXDLIN(  64)						bool hasUndo = false;
HXDLIN(  64)						Float temp = au;
HXLINE( 422)						au = bu1;
HXLINE( 423)						bu1 = temp;
HXLINE( 424)						temp = av;
HXLINE( 425)						av = bv1;
HXLINE( 426)						bv1 = temp;
HXLINE(  64)						Float bcx = w2;
HXDLIN(  64)						Float bcy = (( (Float)(0) ) - h);
HXDLIN(  64)						Float acx = ( (Float)(0) );
HXDLIN(  64)						Float acy = (( (Float)(0) ) - h);
HXDLIN(  64)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  64)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  64)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  64)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  64)						if ((0 > w2)) {
HXLINE(  64)							int ii_min = ::Math_obj::floor(w2);
HXDLIN(  64)							int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  64)							if ((w2 > 0)) {
HXLINE(  64)								int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)								int ii_max1 = ::Math_obj::ceil(w2);
HXDLIN(  64)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            							else {
HXLINE(  64)								int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  64)								int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            						}
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  64)						if ((0 > h)) {
HXLINE(  64)							int min;
HXDLIN(  64)							if ((0 > h)) {
HXLINE(  64)								min = ::Math_obj::floor(h);
            							}
            							else {
HXLINE(  64)								min = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  64)							int ii_min3 = min;
HXDLIN(  64)							int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            						else {
HXLINE(  64)							int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  64)							int ii_max4 = ::Math_obj::ceil(h);
HXDLIN(  64)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
HXDLIN(  64)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  64)						if (hasUndo) {
HXLINE(  64)							int width1 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)							int height1 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)							 ::Dynamic imageType3 = null();
HXDLIN(  64)							 ::pi_xy::ImageStruct this21 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  64)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  64)							::Dynamic undoImage1;
HXDLIN(  64)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE(  64)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::BytesImg b10 = byt3;
HXDLIN(  64)									{
HXLINE(  64)										b10->width = width1;
HXDLIN(  64)										b10->height = height1;
HXDLIN(  64)										b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  64)										b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  64)										{
HXLINE(  64)											int len6 = b10->length;
HXDLIN(  64)											int w4 = 0;
HXDLIN(  64)											{
HXLINE(  64)												int _g48 = 0;
HXDLIN(  64)												int _g49 = b10->height;
HXDLIN(  64)												while((_g48 < _g49)){
HXLINE(  64)													_g48 = (_g48 + 1);
HXDLIN(  64)													int y4 = (_g48 - 1);
HXDLIN(  64)													{
HXLINE(  64)														int _g50 = 0;
HXDLIN(  64)														int _g51 = b10->width;
HXDLIN(  64)														while((_g50 < _g51)){
HXLINE(  64)															_g50 = (_g50 + 1);
HXDLIN(  64)															int x5 = (_g50 - 1);
HXDLIN(  64)															{
HXLINE(  64)																w4 = (w4 + 1);
HXDLIN(  64)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w4 = (w4 + 1);
HXDLIN(  64)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w4 = (w4 + 1);
HXDLIN(  64)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w4 = (w4 + 1);
HXDLIN(  64)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage1 = b10;
            								}
            								break;
            								case (int)1: {
HXLINE(  64)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::ArrIntImg a6 = arrI3;
HXDLIN(  64)									{
HXLINE(  64)										a6->width = width1;
HXDLIN(  64)										a6->height = height1;
HXDLIN(  64)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  64)										a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  64)										{
HXLINE(  64)											int _g52 = 0;
HXDLIN(  64)											int _g53 = a6->length;
HXDLIN(  64)											while((_g52 < _g53)){
HXLINE(  64)												_g52 = (_g52 + 1);
HXDLIN(  64)												int i18 = (_g52 - 1);
HXDLIN(  64)												a6->data[i18] = 0;
            											}
            										}
            									}
HXDLIN(  64)									undoImage1 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE(  64)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::U32ArrImg b12 = u32a3;
HXDLIN(  64)									{
HXLINE(  64)										b12->width = width1;
HXDLIN(  64)										b12->height = height1;
HXDLIN(  64)										b12->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  64)										int size3 = (b12->length * 4);
HXDLIN(  64)										b12->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  64)										{
HXLINE(  64)											int _g54 = 0;
HXDLIN(  64)											int _g55 = b12->length;
HXDLIN(  64)											while((_g54 < _g55)){
HXLINE(  64)												_g54 = (_g54 + 1);
HXDLIN(  64)												int i19 = (_g54 - 1);
HXDLIN(  64)												{
HXLINE(  64)													 ::haxe::io::ArrayBufferViewImpl this22 = b12->data;
HXDLIN(  64)													bool undoImage2;
HXDLIN(  64)													if ((i19 >= 0)) {
HXLINE(  64)														undoImage2 = (i19 < (this22->byteLength >> 2));
            													}
            													else {
HXLINE(  64)														undoImage2 = false;
            													}
HXDLIN(  64)													if (undoImage2) {
HXLINE(  64)														 ::haxe::io::Bytes _this3 = this22->bytes;
HXDLIN(  64)														int pos3 = ((i19 << 2) + this22->byteOffset);
HXDLIN(  64)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  64)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage1 = b12;
            								}
            								break;
            								case (int)3: {
HXLINE(  64)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::VecIntImg v5 = vec3;
HXDLIN(  64)									{
HXLINE(  64)										v5->width = width1;
HXDLIN(  64)										v5->height = height1;
HXDLIN(  64)										v5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  64)										v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN(  64)										{
HXLINE(  64)											int _g56 = 0;
HXDLIN(  64)											int _g57 = v5->length;
HXDLIN(  64)											while((_g56 < _g57)){
HXLINE(  64)												_g56 = (_g56 + 1);
HXDLIN(  64)												int i20 = (_g56 - 1);
HXDLIN(  64)												v5->data->__unsafe_set(i20,0);
            											}
            										}
            									}
HXDLIN(  64)									undoImage1 = v5;
            								}
            								break;
            								case (int)4: {
HXLINE(  64)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::StackIntImg b13 = sInt3;
HXDLIN(  64)									{
HXLINE(  64)										b13->width = width1;
HXDLIN(  64)										b13->height = height1;
HXDLIN(  64)										b13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  64)										b13->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  64)										{
HXLINE(  64)											int len7 = b13->length;
HXDLIN(  64)											 ::haxe::ds::GenericStack_Int d3 = b13->data;
HXDLIN(  64)											if (::hx::IsNull( d3->head )) {
HXLINE(  64)												int _g58 = 0;
HXDLIN(  64)												int _g59 = len7;
HXDLIN(  64)												while((_g58 < _g59)){
HXLINE(  64)													_g58 = (_g58 + 1);
HXDLIN(  64)													int i21 = (_g58 - 1);
HXDLIN(  64)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE(  64)												int _g60 = 0;
HXDLIN(  64)												int _g61 = len7;
HXDLIN(  64)												while((_g60 < _g61)){
HXLINE(  64)													_g60 = (_g60 + 1);
HXDLIN(  64)													int i22 = (_g60 - 1);
HXDLIN(  64)													{
HXLINE(  64)														 ::haxe::ds::GenericCell_Int l3 = b13->data->head;
HXDLIN(  64)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  64)														{
HXLINE(  64)															int _g62 = 0;
HXDLIN(  64)															int _g63 = i22;
HXDLIN(  64)															while((_g62 < _g63)){
HXLINE(  64)																_g62 = (_g62 + 1);
HXDLIN(  64)																int i23 = (_g62 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE(  64)														if (::hx::IsNull( prev3 )) {
HXLINE(  64)															b13->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  64)															l3 = null();
            														}
            														else {
HXLINE(  64)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  64)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage1 = b13;
            								}
            								break;
            							}
HXDLIN(  64)							this21->image = undoImage1;
HXDLIN(  64)							this21->width = width1;
HXDLIN(  64)							this21->height = height1;
HXDLIN(  64)							this21->imageType = ( (int)(imageType3) );
HXDLIN(  64)							undoImage = this21;
HXDLIN(  64)							{
HXLINE(  64)								int rectLeft = xIter3->start;
HXDLIN(  64)								int rectTop = yIter3->start;
HXDLIN(  64)								int rectRight = xIter3->max;
HXDLIN(  64)								bool forceClear = false;
HXDLIN(  64)								{
HXLINE(  64)									int _g64 = rectTop;
HXDLIN(  64)									int _g65 = yIter3->max;
HXDLIN(  64)									while((_g64 < _g65)){
HXLINE(  64)										_g64 = (_g64 + 1);
HXDLIN(  64)										int dy = (_g64 - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g66 = rectLeft;
HXDLIN(  64)											int _g67 = rectRight;
HXDLIN(  64)											while((_g66 < _g67)){
HXLINE(  64)												_g66 = (_g66 + 1);
HXDLIN(  64)												int dx = (_g66 - 1);
HXDLIN(  64)												::Dynamic this23 = this20->image;
HXDLIN(  64)												int index2;
HXDLIN(  64)												if (this20->useVirtualPos) {
HXLINE(  64)													index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this20->virtualY) * ( (Float)(this20->width) )) + dx) - this20->virtualX));
            												}
            												else {
HXLINE(  64)													index2 = ::Std_obj::_hx_int(( (Float)(((dy * this20->width) + dx)) ));
            												}
HXDLIN(  64)												int c2 = ::iterMagic::Iimg_obj::get(this23,index2);
HXDLIN(  64)												int col;
HXDLIN(  64)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE(  64)													col = c2;
            												}
HXDLIN(  64)												bool imgTarget10;
HXDLIN(  64)												if (this20->useMask) {
HXLINE(  64)													imgTarget10 = ::hx::IsNotNull( this20->mask );
            												}
            												else {
HXLINE(  64)													imgTarget10 = false;
            												}
HXDLIN(  64)												if (imgTarget10) {
HXLINE(  64)													 ::pi_xy::ImageStruct this24 = this20->mask;
HXDLIN(  64)													::Dynamic this25 = this24->image;
HXDLIN(  64)													int index3;
HXDLIN(  64)													if (this24->useVirtualPos) {
HXLINE(  64)														index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this24->virtualY) * ( (Float)(this24->width) )) + dx) - this24->virtualX));
            													}
            													else {
HXLINE(  64)														index3 = ::Std_obj::_hx_int(( (Float)(((dy * this24->width) + dx)) ));
            													}
HXDLIN(  64)													int c3 = ::iterMagic::Iimg_obj::get(this25,index3);
HXDLIN(  64)													int v6;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														v6 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														v6 = c3;
            													}
HXDLIN(  64)													int maskPixel = v6;
HXDLIN(  64)													int this26 = col;
HXDLIN(  64)													if ((maskPixel == 0)) {
HXLINE(  64)														col = this26;
            													}
            													else {
HXLINE(  64)														Float m0;
HXDLIN(  64)														int this27 = ((maskPixel >> 24) & 255);
HXDLIN(  64)														if ((this27 == 0)) {
HXLINE(  64)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m0 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m1;
HXDLIN(  64)														int this28 = ((maskPixel >> 16) & 255);
HXDLIN(  64)														if ((this28 == 0)) {
HXLINE(  64)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m1 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m2;
HXDLIN(  64)														int this29 = ((maskPixel >> 8) & 255);
HXDLIN(  64)														if ((this29 == 0)) {
HXLINE(  64)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m2 = (( (Float)(this29) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m3;
HXDLIN(  64)														int this30 = (maskPixel & 255);
HXDLIN(  64)														if ((this30 == 0)) {
HXLINE(  64)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m3 = (( (Float)(this30) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this26 >> 24) & 255)) )));
HXDLIN(  64)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this26 >> 16) & 255)) )));
HXDLIN(  64)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this26 >> 8) & 255)) )));
HXDLIN(  64)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this26 & 255)) )));
HXDLIN(  64)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  64)												if ((col != 0)) {
HXLINE(  64)													int x6 = (dx - rectLeft);
HXDLIN(  64)													int y5 = (dy - rectTop);
HXDLIN(  64)													int c4 = col;
HXDLIN(  64)													bool imgTarget11;
HXDLIN(  64)													if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  64)														imgTarget11 = undoImage->transparent;
            													}
            													else {
HXLINE(  64)														imgTarget11 = false;
            													}
HXDLIN(  64)													if (imgTarget11) {
HXLINE(  64)														int location1;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															location1 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															location1 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            														}
HXDLIN(  64)														int this31 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  64)														int this32;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this32 = ((((((this31 >> 24) & 255) << 24) | ((this31 & 255) << 16)) | (((this31 >> 8) & 255) << 8)) | ((this31 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this32 = this31;
            														}
HXDLIN(  64)														Float a12;
HXDLIN(  64)														int this33 = ((this32 >> 24) & 255);
HXDLIN(  64)														if ((this33 == 0)) {
HXLINE(  64)															a12 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a12 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r11;
HXDLIN(  64)														int this34 = ((this32 >> 16) & 255);
HXDLIN(  64)														if ((this34 == 0)) {
HXLINE(  64)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r11 = (( (Float)(this34) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g11;
HXDLIN(  64)														int this35 = ((this32 >> 8) & 255);
HXDLIN(  64)														if ((this35 == 0)) {
HXLINE(  64)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g11 = (( (Float)(this35) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b14;
HXDLIN(  64)														int this36 = (this32 & 255);
HXDLIN(  64)														if ((this36 == 0)) {
HXLINE(  64)															b14 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b14 = (( (Float)(this36) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a21;
HXDLIN(  64)														int this37 = ((col >> 24) & 255);
HXDLIN(  64)														if ((this37 == 0)) {
HXLINE(  64)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a21 = (( (Float)(this37) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r21;
HXDLIN(  64)														int this38 = ((col >> 16) & 255);
HXDLIN(  64)														if ((this38 == 0)) {
HXLINE(  64)															r21 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r21 = (( (Float)(this38) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g21;
HXDLIN(  64)														int this39 = ((col >> 8) & 255);
HXDLIN(  64)														if ((this39 == 0)) {
HXLINE(  64)															g21 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g21 = (( (Float)(this39) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b22;
HXDLIN(  64)														int this40 = (col & 255);
HXDLIN(  64)														if ((this40 == 0)) {
HXLINE(  64)															b22 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b22 = (( (Float)(this40) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  64)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  64)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  64)														int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a31) + (b22 * a21))));
HXDLIN(  64)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  64)														int blended1 = ((((a7 << 24) | (r3 << 16)) | (g3 << 8)) | b15);
HXDLIN(  64)														{
HXLINE(  64)															int imgTarget12;
HXDLIN(  64)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																imgTarget12 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE(  64)																imgTarget12 = blended1;
            															}
HXDLIN(  64)															::iterMagic::Iimg_obj::set(undoImage->image,location1,imgTarget12);
            														}
            													}
            													else {
HXLINE(  64)														::Dynamic this41 = undoImage->image;
HXDLIN(  64)														int index4;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															index4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            														}
HXDLIN(  64)														int imgTarget13;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															imgTarget13 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															imgTarget13 = c4;
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this41,index4,imgTarget13);
            													}
            												}
            												else {
HXLINE(  64)													if (forceClear) {
HXLINE(  64)														::Dynamic this42 = undoImage->image;
HXDLIN(  64)														int x7 = (dx - rectLeft);
HXDLIN(  64)														int y6 = (dy - rectTop);
HXDLIN(  64)														int index5;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															index5 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x7) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															index5 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x7)) ));
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this42,index5,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						{
HXLINE(  64)							int _g_min = xIter3->start;
HXDLIN(  64)							int _g_max = xIter3->max;
HXDLIN(  64)							while((_g_min < _g_max)){
HXLINE(  64)								_g_min = (_g_min + 1);
HXDLIN(  64)								int px = (_g_min - 1);
HXDLIN(  64)								Float pcx = ( (Float)(px) );
HXDLIN(  64)								{
HXLINE(  64)									int _g_min1 = yIter3->start;
HXDLIN(  64)									int _g_max1 = yIter3->max;
HXDLIN(  64)									while((_g_min1 < _g_max1)){
HXLINE(  64)										_g_min1 = (_g_min1 + 1);
HXDLIN(  64)										int py = (_g_min1 - 1);
HXDLIN(  64)										Float pcy = (( (Float)(py) ) - h);
HXDLIN(  64)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  64)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  64)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  64)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  64)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  64)										bool imgTarget14;
HXDLIN(  64)										bool imgTarget15;
HXDLIN(  64)										if ((ratioA >= 0)) {
HXLINE(  64)											imgTarget15 = (ratioB >= 0);
            										}
            										else {
HXLINE(  64)											imgTarget15 = false;
            										}
HXDLIN(  64)										if (imgTarget15) {
HXLINE(  64)											imgTarget14 = (ratioC >= 0);
            										}
            										else {
HXLINE(  64)											imgTarget14 = false;
            										}
HXDLIN(  64)										if (imgTarget14) {
HXLINE(  64)											Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  64)											Float v7 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  64)											int x8 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  64)											int y7 = ::Std_obj::_hx_int(((v7 * win_height) + win_y));
HXDLIN(  64)											::Dynamic this43 = thisImage->image;
HXDLIN(  64)											int index6;
HXDLIN(  64)											if (thisImage->useVirtualPos) {
HXLINE(  64)												index6 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x8) - thisImage->virtualX));
            											}
            											else {
HXLINE(  64)												index6 = ::Std_obj::_hx_int(( (Float)(((y7 * thisImage->width) + x8)) ));
            											}
HXDLIN(  64)											int c5 = ::iterMagic::Iimg_obj::get(this43,index6);
HXDLIN(  64)											int col1;
HXDLIN(  64)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)												col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  64)												col1 = c5;
            											}
HXDLIN(  64)											{
HXLINE(  64)												int c6 = col1;
HXDLIN(  64)												bool imgTarget16;
HXDLIN(  64)												if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  64)													imgTarget16 = this20->transparent;
            												}
            												else {
HXLINE(  64)													imgTarget16 = false;
            												}
HXDLIN(  64)												if (imgTarget16) {
HXLINE(  64)													int location2;
HXDLIN(  64)													if (this20->useVirtualPos) {
HXLINE(  64)														location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this20->virtualY) * ( (Float)(this20->width) )) + px) - this20->virtualX));
            													}
            													else {
HXLINE(  64)														location2 = ::Std_obj::_hx_int(( (Float)(((py * this20->width) + px)) ));
            													}
HXDLIN(  64)													int this44 = ::iterMagic::Iimg_obj::get(this20->image,location2);
HXDLIN(  64)													int this45;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														this45 = ((((((this44 >> 24) & 255) << 24) | ((this44 & 255) << 16)) | (((this44 >> 8) & 255) << 8)) | ((this44 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														this45 = this44;
            													}
HXDLIN(  64)													Float a13;
HXDLIN(  64)													int this46 = ((this45 >> 24) & 255);
HXDLIN(  64)													if ((this46 == 0)) {
HXLINE(  64)														a13 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														a13 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float r12;
HXDLIN(  64)													int this47 = ((this45 >> 16) & 255);
HXDLIN(  64)													if ((this47 == 0)) {
HXLINE(  64)														r12 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														r12 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float g12;
HXDLIN(  64)													int this48 = ((this45 >> 8) & 255);
HXDLIN(  64)													if ((this48 == 0)) {
HXLINE(  64)														g12 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														g12 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float b16;
HXDLIN(  64)													int this49 = (this45 & 255);
HXDLIN(  64)													if ((this49 == 0)) {
HXLINE(  64)														b16 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														b16 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float a22;
HXDLIN(  64)													int this50 = ((col1 >> 24) & 255);
HXDLIN(  64)													if ((this50 == 0)) {
HXLINE(  64)														a22 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														a22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float r22;
HXDLIN(  64)													int this51 = ((col1 >> 16) & 255);
HXDLIN(  64)													if ((this51 == 0)) {
HXLINE(  64)														r22 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														r22 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float g22;
HXDLIN(  64)													int this52 = ((col1 >> 8) & 255);
HXDLIN(  64)													if ((this52 == 0)) {
HXLINE(  64)														g22 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														g22 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float b23;
HXDLIN(  64)													int this53 = (col1 & 255);
HXDLIN(  64)													if ((this53 == 0)) {
HXLINE(  64)														b23 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														b23 = (( (Float)(this53) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  64)													int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  64)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  64)													int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a32) + (b23 * a22))));
HXDLIN(  64)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  64)													int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b17);
HXDLIN(  64)													{
HXLINE(  64)														int imgTarget17;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															imgTarget17 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															imgTarget17 = blended2;
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this20->image,location2,imgTarget17);
            													}
            												}
            												else {
HXLINE(  64)													::Dynamic this54 = this20->image;
HXDLIN(  64)													int index7;
HXDLIN(  64)													if (this20->useVirtualPos) {
HXLINE(  64)														index7 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this20->virtualY) * ( (Float)(this20->width) )) + px) - this20->virtualX));
            													}
            													else {
HXLINE(  64)														index7 = ::Std_obj::_hx_int(( (Float)(((py * this20->width) + px)) ));
            													}
HXDLIN(  64)													int imgTarget18;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														imgTarget18 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														imgTarget18 = c6;
            													}
HXDLIN(  64)													::iterMagic::Iimg_obj::set(this54,index7,imgTarget18);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  64)						int v_undoY;
HXDLIN(  64)						int v_undoX;
HXDLIN(  64)						Float v_ty;
HXDLIN(  64)						Float v_tx;
HXDLIN(  64)						Float v_t0;
HXDLIN(  64)						Float v_sy;
HXDLIN(  64)						Float v_sx;
HXDLIN(  64)						Float v_s0;
HXDLIN(  64)						Float v_A;
HXDLIN(  64)						 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  64)						Float bx = w2;
HXDLIN(  64)						Float by = ( (Float)(0) );
HXDLIN(  64)						Float cx = ( (Float)(0) );
HXDLIN(  64)						Float cy = h;
HXDLIN(  64)						bool adjustWinding = (((((( (Float)(0) ) * by) - (bx * ( (Float)(0) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy))) > 0);
HXDLIN(  64)						if (!(adjustWinding)) {
HXLINE(  64)							Float bx_ = bx;
HXDLIN(  64)							Float by_ = by;
HXLINE(  24)							bx = cx;
HXLINE(  25)							by = cy;
HXLINE(  26)							cx = bx_;
HXLINE(  27)							cy = by_;
            						}
HXLINE(  64)						Float v_ax = ( (Float)(0) );
HXDLIN(  64)						Float v_ay = ( (Float)(0) );
HXDLIN(  64)						Float v_bx = bx;
HXDLIN(  64)						Float v_by = by;
HXDLIN(  64)						Float v_cx = cx;
HXDLIN(  64)						Float v_cy = cy;
HXDLIN(  64)						bool v_preCalculated = true;
HXDLIN(  64)						{
HXLINE(  64)							v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  64)							v_sx = (v_cy - v_ay);
HXDLIN(  64)							v_sy = (v_ax - v_cx);
HXDLIN(  64)							v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  64)							v_tx = (v_ay - v_by);
HXDLIN(  64)							v_ty = (v_bx - v_ax);
HXDLIN(  64)							v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  64)							Float a9 = v_ax;
HXDLIN(  64)							Float b18 = v_bx;
HXDLIN(  64)							Float c7 = v_cx;
HXDLIN(  64)							if ((a9 > b18)) {
HXLINE(  64)								if ((a9 > c7)) {
HXLINE(  64)									int min1;
HXDLIN(  64)									if ((b18 > c7)) {
HXLINE(  64)										min1 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE(  64)										min1 = ::Math_obj::floor(b18);
            									}
HXDLIN(  64)									int ii_min5 = min1;
HXDLIN(  64)									int ii_max5 = ::Math_obj::ceil(a9);
HXDLIN(  64)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            								}
            								else {
HXLINE(  64)									int ii_min6 = ::Math_obj::floor(b18);
HXDLIN(  64)									int ii_max6 = ::Math_obj::ceil(c7);
HXDLIN(  64)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            								}
            							}
            							else {
HXLINE(  64)								if ((b18 > c7)) {
HXLINE(  64)									int min2;
HXDLIN(  64)									if ((a9 > c7)) {
HXLINE(  64)										min2 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE(  64)										min2 = ::Math_obj::ceil(a9);
            									}
HXDLIN(  64)									int ii_min7 = min2;
HXDLIN(  64)									int ii_max7 = ::Math_obj::ceil(b18);
HXDLIN(  64)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            								}
            								else {
HXLINE(  64)									int ii_min8 = ::Math_obj::floor(a9);
HXDLIN(  64)									int ii_max8 = ::Math_obj::ceil(c7);
HXDLIN(  64)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            							}
HXDLIN(  64)							Float a10 = v_ay;
HXDLIN(  64)							Float b19 = v_by;
HXDLIN(  64)							Float c8 = v_cy;
HXDLIN(  64)							if ((a10 > b19)) {
HXLINE(  64)								if ((a10 > c8)) {
HXLINE(  64)									int min3;
HXDLIN(  64)									if ((b19 > c8)) {
HXLINE(  64)										min3 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE(  64)										min3 = ::Math_obj::floor(b19);
            									}
HXDLIN(  64)									int ii_min9 = min3;
HXDLIN(  64)									int ii_max9 = ::Math_obj::ceil(a10);
HXDLIN(  64)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            								else {
HXLINE(  64)									int ii_min10 = ::Math_obj::floor(b19);
HXDLIN(  64)									int ii_max10 = ::Math_obj::ceil(c8);
HXDLIN(  64)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            							}
            							else {
HXLINE(  64)								if ((b19 > c8)) {
HXLINE(  64)									int min4;
HXDLIN(  64)									if ((a10 > c8)) {
HXLINE(  64)										min4 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE(  64)										min4 = ::Math_obj::ceil(a10);
            									}
HXDLIN(  64)									int ii_min11 = min4;
HXDLIN(  64)									int ii_max11 = ::Math_obj::ceil(b19);
HXDLIN(  64)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            								else {
HXLINE(  64)									int ii_min12 = ::Math_obj::floor(a10);
HXDLIN(  64)									int ii_max12 = ::Math_obj::ceil(c8);
HXDLIN(  64)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            							}
            						}
HXDLIN(  64)						if (hasUndo) {
HXLINE(  64)							v_undoImage = undoImage;
HXDLIN(  64)							v_undoX = xIter3->start;
HXDLIN(  64)							v_undoY = yIter3->start;
            						}
HXDLIN(  64)						Float au1 = bu;
HXDLIN(  64)						Float av1 = bv;
HXDLIN(  64)						Float bu2 = cu;
HXDLIN(  64)						Float bv2 = cv;
HXDLIN(  64)						bool hasUndo1 = false;
HXDLIN(  64)						Float temp1 = au1;
HXLINE( 422)						au1 = bu2;
HXLINE( 423)						bu2 = temp1;
HXLINE( 424)						temp1 = av1;
HXLINE( 425)						av1 = bv2;
HXLINE( 426)						bv2 = temp1;
HXLINE(  64)						Float bcx1 = w2;
HXDLIN(  64)						Float bcy1 = (h - h);
HXDLIN(  64)						Float acx1 = w2;
HXDLIN(  64)						Float acy1 = (( (Float)(0) ) - h);
HXDLIN(  64)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  64)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  64)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  64)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  64)						if ((w2 > w2)) {
HXLINE(  64)							if ((w2 > 0)) {
HXLINE(  64)								int min5;
HXDLIN(  64)								if ((w2 > 0)) {
HXLINE(  64)									min5 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  64)									min5 = ::Math_obj::floor(w2);
            								}
HXDLIN(  64)								int ii_min13 = min5;
HXDLIN(  64)								int ii_max13 = ::Math_obj::ceil(w2);
HXDLIN(  64)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            							else {
HXLINE(  64)								int ii_min14 = ::Math_obj::floor(w2);
HXDLIN(  64)								int ii_max14 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            						}
            						else {
HXLINE(  64)							if ((w2 > 0)) {
HXLINE(  64)								int min6;
HXDLIN(  64)								if ((w2 > 0)) {
HXLINE(  64)									min6 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  64)									min6 = ::Math_obj::ceil(w2);
            								}
HXDLIN(  64)								int ii_min15 = min6;
HXDLIN(  64)								int ii_max15 = ::Math_obj::ceil(w2);
HXDLIN(  64)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            							else {
HXLINE(  64)								int ii_min16 = ::Math_obj::floor(w2);
HXDLIN(  64)								int ii_max16 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            						}
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  64)						if ((0 > h)) {
HXLINE(  64)							if ((0 > h)) {
HXLINE(  64)								int min7;
HXDLIN(  64)								if ((h > h)) {
HXLINE(  64)									min7 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE(  64)									min7 = ::Math_obj::floor(h);
            								}
HXDLIN(  64)								int ii_min17 = min7;
HXDLIN(  64)								int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  64)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            							else {
HXLINE(  64)								int ii_min18 = ::Math_obj::floor(h);
HXDLIN(  64)								int ii_max18 = ::Math_obj::ceil(h);
HXDLIN(  64)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            						}
            						else {
HXLINE(  64)							if ((h > h)) {
HXLINE(  64)								int min8;
HXDLIN(  64)								if ((0 > h)) {
HXLINE(  64)									min8 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE(  64)									min8 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN(  64)								int ii_min19 = min8;
HXDLIN(  64)								int ii_max19 = ::Math_obj::ceil(h);
HXDLIN(  64)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            							else {
HXLINE(  64)								int ii_min20 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  64)								int ii_max20 = ::Math_obj::ceil(h);
HXDLIN(  64)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            						}
HXDLIN(  64)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  64)						if (hasUndo1) {
HXLINE(  64)							int width2 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  64)							int height2 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  64)							 ::Dynamic imageType4 = null();
HXDLIN(  64)							 ::pi_xy::ImageStruct this55 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  64)							if (::hx::IsNull( imageType4 )) {
HXLINE(  54)								imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  64)							::Dynamic undoImage4;
HXDLIN(  64)							switch((int)(( (int)(imageType4) ))){
            								case (int)0: {
HXLINE(  64)									 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::BytesImg b20 = byt4;
HXDLIN(  64)									{
HXLINE(  64)										b20->width = width2;
HXDLIN(  64)										b20->height = height2;
HXDLIN(  64)										b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  64)										b20->data = ::haxe::io::Bytes_obj::alloc((b20->length * 4));
HXDLIN(  64)										{
HXLINE(  64)											int len8 = b20->length;
HXDLIN(  64)											int w5 = 0;
HXDLIN(  64)											{
HXLINE(  64)												int _g68 = 0;
HXDLIN(  64)												int _g69 = b20->height;
HXDLIN(  64)												while((_g68 < _g69)){
HXLINE(  64)													_g68 = (_g68 + 1);
HXDLIN(  64)													int y8 = (_g68 - 1);
HXDLIN(  64)													{
HXLINE(  64)														int _g70 = 0;
HXDLIN(  64)														int _g71 = b20->width;
HXDLIN(  64)														while((_g70 < _g71)){
HXLINE(  64)															_g70 = (_g70 + 1);
HXDLIN(  64)															int x9 = (_g70 - 1);
HXDLIN(  64)															{
HXLINE(  64)																w5 = (w5 + 1);
HXDLIN(  64)																b20->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w5 = (w5 + 1);
HXDLIN(  64)																b20->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w5 = (w5 + 1);
HXDLIN(  64)																b20->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  64)															{
HXLINE(  64)																w5 = (w5 + 1);
HXDLIN(  64)																b20->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage4 = b20;
            								}
            								break;
            								case (int)1: {
HXLINE(  64)									 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::ArrIntImg a14 = arrI4;
HXDLIN(  64)									{
HXLINE(  64)										a14->width = width2;
HXDLIN(  64)										a14->height = height2;
HXDLIN(  64)										a14->data = ::Array_obj< int >::__new(0);
HXDLIN(  64)										a14->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  64)										{
HXLINE(  64)											int _g72 = 0;
HXDLIN(  64)											int _g73 = a14->length;
HXDLIN(  64)											while((_g72 < _g73)){
HXLINE(  64)												_g72 = (_g72 + 1);
HXDLIN(  64)												int i24 = (_g72 - 1);
HXDLIN(  64)												a14->data[i24] = 0;
            											}
            										}
            									}
HXDLIN(  64)									undoImage4 = a14;
            								}
            								break;
            								case (int)2: {
HXLINE(  64)									 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::U32ArrImg b24 = u32a4;
HXDLIN(  64)									{
HXLINE(  64)										b24->width = width2;
HXDLIN(  64)										b24->height = height2;
HXDLIN(  64)										b24->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  64)										int size4 = (b24->length * 4);
HXDLIN(  64)										b24->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  64)										{
HXLINE(  64)											int _g74 = 0;
HXDLIN(  64)											int _g75 = b24->length;
HXDLIN(  64)											while((_g74 < _g75)){
HXLINE(  64)												_g74 = (_g74 + 1);
HXDLIN(  64)												int i25 = (_g74 - 1);
HXDLIN(  64)												{
HXLINE(  64)													 ::haxe::io::ArrayBufferViewImpl this56 = b24->data;
HXDLIN(  64)													bool undoImage5;
HXDLIN(  64)													if ((i25 >= 0)) {
HXLINE(  64)														undoImage5 = (i25 < (this56->byteLength >> 2));
            													}
            													else {
HXLINE(  64)														undoImage5 = false;
            													}
HXDLIN(  64)													if (undoImage5) {
HXLINE(  64)														 ::haxe::io::Bytes _this4 = this56->bytes;
HXDLIN(  64)														int pos4 = ((i25 << 2) + this56->byteOffset);
HXDLIN(  64)														_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  64)														_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)														_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)														_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage4 = b24;
            								}
            								break;
            								case (int)3: {
HXLINE(  64)									 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::VecIntImg v8 = vec4;
HXDLIN(  64)									{
HXLINE(  64)										v8->width = width2;
HXDLIN(  64)										v8->height = height2;
HXDLIN(  64)										v8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  64)										v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN(  64)										{
HXLINE(  64)											int _g76 = 0;
HXDLIN(  64)											int _g77 = v8->length;
HXDLIN(  64)											while((_g76 < _g77)){
HXLINE(  64)												_g76 = (_g76 + 1);
HXDLIN(  64)												int i26 = (_g76 - 1);
HXDLIN(  64)												v8->data->__unsafe_set(i26,0);
            											}
            										}
            									}
HXDLIN(  64)									undoImage4 = v8;
            								}
            								break;
            								case (int)4: {
HXLINE(  64)									 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  64)									 ::iterMagic::StackIntImg b25 = sInt4;
HXDLIN(  64)									{
HXLINE(  64)										b25->width = width2;
HXDLIN(  64)										b25->height = height2;
HXDLIN(  64)										b25->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  64)										b25->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  64)										{
HXLINE(  64)											int len9 = b25->length;
HXDLIN(  64)											 ::haxe::ds::GenericStack_Int d4 = b25->data;
HXDLIN(  64)											if (::hx::IsNull( d4->head )) {
HXLINE(  64)												int _g78 = 0;
HXDLIN(  64)												int _g79 = len9;
HXDLIN(  64)												while((_g78 < _g79)){
HXLINE(  64)													_g78 = (_g78 + 1);
HXDLIN(  64)													int i27 = (_g78 - 1);
HXDLIN(  64)													d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            												}
            											}
            											else {
HXLINE(  64)												int _g80 = 0;
HXDLIN(  64)												int _g81 = len9;
HXDLIN(  64)												while((_g80 < _g81)){
HXLINE(  64)													_g80 = (_g80 + 1);
HXDLIN(  64)													int i28 = (_g80 - 1);
HXDLIN(  64)													{
HXLINE(  64)														 ::haxe::ds::GenericCell_Int l4 = b25->data->head;
HXDLIN(  64)														 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  64)														{
HXLINE(  64)															int _g82 = 0;
HXDLIN(  64)															int _g83 = i28;
HXDLIN(  64)															while((_g82 < _g83)){
HXLINE(  64)																_g82 = (_g82 + 1);
HXDLIN(  64)																int i29 = (_g82 - 1);
HXLINE( 345)																prev4 = l4;
HXLINE( 346)																l4 = l4->next;
            															}
            														}
HXLINE(  64)														if (::hx::IsNull( prev4 )) {
HXLINE(  64)															b25->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  64)															l4 = null();
            														}
            														else {
HXLINE(  64)															prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  64)															l4 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  64)									undoImage4 = b25;
            								}
            								break;
            							}
HXDLIN(  64)							this55->image = undoImage4;
HXDLIN(  64)							this55->width = width2;
HXDLIN(  64)							this55->height = height2;
HXDLIN(  64)							this55->imageType = ( (int)(imageType4) );
HXDLIN(  64)							undoImage3 = this55;
HXDLIN(  64)							{
HXLINE(  64)								int rectLeft1 = xIter31->start;
HXDLIN(  64)								int rectTop1 = yIter31->start;
HXDLIN(  64)								int rectRight1 = xIter31->max;
HXDLIN(  64)								bool forceClear1 = false;
HXDLIN(  64)								{
HXLINE(  64)									int _g84 = rectTop1;
HXDLIN(  64)									int _g85 = yIter31->max;
HXDLIN(  64)									while((_g84 < _g85)){
HXLINE(  64)										_g84 = (_g84 + 1);
HXDLIN(  64)										int dy1 = (_g84 - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g86 = rectLeft1;
HXDLIN(  64)											int _g87 = rectRight1;
HXDLIN(  64)											while((_g86 < _g87)){
HXLINE(  64)												_g86 = (_g86 + 1);
HXDLIN(  64)												int dx1 = (_g86 - 1);
HXDLIN(  64)												::Dynamic this57 = this20->image;
HXDLIN(  64)												int index8;
HXDLIN(  64)												if (this20->useVirtualPos) {
HXLINE(  64)													index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this20->virtualY) * ( (Float)(this20->width) )) + dx1) - this20->virtualX));
            												}
            												else {
HXLINE(  64)													index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * this20->width) + dx1)) ));
            												}
HXDLIN(  64)												int c9 = ::iterMagic::Iimg_obj::get(this57,index8);
HXDLIN(  64)												int col2;
HXDLIN(  64)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE(  64)													col2 = c9;
            												}
HXDLIN(  64)												bool imgTarget19;
HXDLIN(  64)												if (this20->useMask) {
HXLINE(  64)													imgTarget19 = ::hx::IsNotNull( this20->mask );
            												}
            												else {
HXLINE(  64)													imgTarget19 = false;
            												}
HXDLIN(  64)												if (imgTarget19) {
HXLINE(  64)													 ::pi_xy::ImageStruct this58 = this20->mask;
HXDLIN(  64)													::Dynamic this59 = this58->image;
HXDLIN(  64)													int index9;
HXDLIN(  64)													if (this58->useVirtualPos) {
HXLINE(  64)														index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this58->virtualY) * ( (Float)(this58->width) )) + dx1) - this58->virtualX));
            													}
            													else {
HXLINE(  64)														index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this58->width) + dx1)) ));
            													}
HXDLIN(  64)													int c10 = ::iterMagic::Iimg_obj::get(this59,index9);
HXDLIN(  64)													int v9;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														v9 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														v9 = c10;
            													}
HXDLIN(  64)													int maskPixel1 = v9;
HXDLIN(  64)													int this60 = col2;
HXDLIN(  64)													if ((maskPixel1 == 0)) {
HXLINE(  64)														col2 = this60;
            													}
            													else {
HXLINE(  64)														Float m01;
HXDLIN(  64)														int this61 = ((maskPixel1 >> 24) & 255);
HXDLIN(  64)														if ((this61 == 0)) {
HXLINE(  64)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m01 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m11;
HXDLIN(  64)														int this62 = ((maskPixel1 >> 16) & 255);
HXDLIN(  64)														if ((this62 == 0)) {
HXLINE(  64)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m11 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m21;
HXDLIN(  64)														int this63 = ((maskPixel1 >> 8) & 255);
HXDLIN(  64)														if ((this63 == 0)) {
HXLINE(  64)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m21 = (( (Float)(this63) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m31;
HXDLIN(  64)														int this64 = (maskPixel1 & 255);
HXDLIN(  64)														if ((this64 == 0)) {
HXLINE(  64)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m31 = (( (Float)(this64) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this60 >> 24) & 255)) )));
HXDLIN(  64)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this60 >> 16) & 255)) )));
HXDLIN(  64)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this60 >> 8) & 255)) )));
HXDLIN(  64)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this60 & 255)) )));
HXDLIN(  64)														col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  64)												if ((col2 != 0)) {
HXLINE(  64)													int x10 = (dx1 - rectLeft1);
HXDLIN(  64)													int y9 = (dy1 - rectTop1);
HXDLIN(  64)													int c11 = col2;
HXDLIN(  64)													bool imgTarget20;
HXDLIN(  64)													if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  64)														imgTarget20 = undoImage3->transparent;
            													}
            													else {
HXLINE(  64)														imgTarget20 = false;
            													}
HXDLIN(  64)													if (imgTarget20) {
HXLINE(  64)														int location3;
HXDLIN(  64)														if (undoImage3->useVirtualPos) {
HXLINE(  64)															location3 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  64)															location3 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            														}
HXDLIN(  64)														int this65 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  64)														int this66;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this66 = ((((((this65 >> 24) & 255) << 24) | ((this65 & 255) << 16)) | (((this65 >> 8) & 255) << 8)) | ((this65 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this66 = this65;
            														}
HXDLIN(  64)														Float a15;
HXDLIN(  64)														int this67 = ((this66 >> 24) & 255);
HXDLIN(  64)														if ((this67 == 0)) {
HXLINE(  64)															a15 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a15 = (( (Float)(this67) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r13;
HXDLIN(  64)														int this68 = ((this66 >> 16) & 255);
HXDLIN(  64)														if ((this68 == 0)) {
HXLINE(  64)															r13 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r13 = (( (Float)(this68) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g13;
HXDLIN(  64)														int this69 = ((this66 >> 8) & 255);
HXDLIN(  64)														if ((this69 == 0)) {
HXLINE(  64)															g13 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g13 = (( (Float)(this69) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b110;
HXDLIN(  64)														int this70 = (this66 & 255);
HXDLIN(  64)														if ((this70 == 0)) {
HXLINE(  64)															b110 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b110 = (( (Float)(this70) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a23;
HXDLIN(  64)														int this71 = ((col2 >> 24) & 255);
HXDLIN(  64)														if ((this71 == 0)) {
HXLINE(  64)															a23 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a23 = (( (Float)(this71) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r23;
HXDLIN(  64)														int this72 = ((col2 >> 16) & 255);
HXDLIN(  64)														if ((this72 == 0)) {
HXLINE(  64)															r23 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r23 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g23;
HXDLIN(  64)														int this73 = ((col2 >> 8) & 255);
HXDLIN(  64)														if ((this73 == 0)) {
HXLINE(  64)															g23 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g23 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b26;
HXDLIN(  64)														int this74 = (col2 & 255);
HXDLIN(  64)														if ((this74 == 0)) {
HXLINE(  64)															b26 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b26 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a33 = (a15 * (( (Float)(1) ) - a23));
HXDLIN(  64)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  64)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  64)														int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b26 * a23))));
HXDLIN(  64)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  64)														int blended3 = ((((a16 << 24) | (r5 << 16)) | (g5 << 8)) | b27);
HXDLIN(  64)														{
HXLINE(  64)															int imgTarget21;
HXDLIN(  64)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																imgTarget21 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE(  64)																imgTarget21 = blended3;
            															}
HXDLIN(  64)															::iterMagic::Iimg_obj::set(undoImage3->image,location3,imgTarget21);
            														}
            													}
            													else {
HXLINE(  64)														::Dynamic this75 = undoImage3->image;
HXDLIN(  64)														int index10;
HXDLIN(  64)														if (undoImage3->useVirtualPos) {
HXLINE(  64)															index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  64)															index10 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            														}
HXDLIN(  64)														int imgTarget22;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															imgTarget22 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															imgTarget22 = c11;
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this75,index10,imgTarget22);
            													}
            												}
            												else {
HXLINE(  64)													if (forceClear1) {
HXLINE(  64)														::Dynamic this76 = undoImage3->image;
HXDLIN(  64)														int x11 = (dx1 - rectLeft1);
HXDLIN(  64)														int y10 = (dy1 - rectTop1);
HXDLIN(  64)														int index11;
HXDLIN(  64)														if (undoImage3->useVirtualPos) {
HXLINE(  64)															index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x11) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  64)															index11 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x11)) ));
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this76,index11,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						{
HXLINE(  64)							int _g_min2 = xIter31->start;
HXDLIN(  64)							int _g_max2 = xIter31->max;
HXDLIN(  64)							while((_g_min2 < _g_max2)){
HXLINE(  64)								_g_min2 = (_g_min2 + 1);
HXDLIN(  64)								int px1 = (_g_min2 - 1);
HXDLIN(  64)								Float pcx1 = ( (Float)(px1) );
HXDLIN(  64)								{
HXLINE(  64)									int _g_min3 = yIter31->start;
HXDLIN(  64)									int _g_max3 = yIter31->max;
HXDLIN(  64)									while((_g_min3 < _g_max3)){
HXLINE(  64)										_g_min3 = (_g_min3 + 1);
HXDLIN(  64)										int py1 = (_g_min3 - 1);
HXDLIN(  64)										Float pcy1 = (( (Float)(py1) ) - h);
HXDLIN(  64)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  64)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  64)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  64)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  64)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  64)										bool imgTarget23;
HXDLIN(  64)										bool imgTarget24;
HXDLIN(  64)										if ((ratioA1 >= 0)) {
HXLINE(  64)											imgTarget24 = (ratioB1 >= 0);
            										}
            										else {
HXLINE(  64)											imgTarget24 = false;
            										}
HXDLIN(  64)										if (imgTarget24) {
HXLINE(  64)											imgTarget23 = (ratioC1 >= 0);
            										}
            										else {
HXLINE(  64)											imgTarget23 = false;
            										}
HXDLIN(  64)										if (imgTarget23) {
HXLINE(  64)											Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  64)											Float v10 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  64)											int x12 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  64)											int y11 = ::Std_obj::_hx_int(((v10 * win_height) + win_y));
HXDLIN(  64)											::Dynamic this77 = thisImage->image;
HXDLIN(  64)											int index12;
HXDLIN(  64)											if (thisImage->useVirtualPos) {
HXLINE(  64)												index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x12) - thisImage->virtualX));
            											}
            											else {
HXLINE(  64)												index12 = ::Std_obj::_hx_int(( (Float)(((y11 * thisImage->width) + x12)) ));
            											}
HXDLIN(  64)											int c12 = ::iterMagic::Iimg_obj::get(this77,index12);
HXDLIN(  64)											int col3;
HXDLIN(  64)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)												col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE(  64)												col3 = c12;
            											}
HXDLIN(  64)											{
HXLINE(  64)												int c13 = col3;
HXDLIN(  64)												bool imgTarget25;
HXDLIN(  64)												if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  64)													imgTarget25 = this20->transparent;
            												}
            												else {
HXLINE(  64)													imgTarget25 = false;
            												}
HXDLIN(  64)												if (imgTarget25) {
HXLINE(  64)													int location4;
HXDLIN(  64)													if (this20->useVirtualPos) {
HXLINE(  64)														location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this20->virtualY) * ( (Float)(this20->width) )) + px1) - this20->virtualX));
            													}
            													else {
HXLINE(  64)														location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this20->width) + px1)) ));
            													}
HXDLIN(  64)													int this78 = ::iterMagic::Iimg_obj::get(this20->image,location4);
HXDLIN(  64)													int this79;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														this79 = this78;
            													}
HXDLIN(  64)													Float a17;
HXDLIN(  64)													int this80 = ((this79 >> 24) & 255);
HXDLIN(  64)													if ((this80 == 0)) {
HXLINE(  64)														a17 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														a17 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float r14;
HXDLIN(  64)													int this81 = ((this79 >> 16) & 255);
HXDLIN(  64)													if ((this81 == 0)) {
HXLINE(  64)														r14 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float g14;
HXDLIN(  64)													int this82 = ((this79 >> 8) & 255);
HXDLIN(  64)													if ((this82 == 0)) {
HXLINE(  64)														g14 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float b111;
HXDLIN(  64)													int this83 = (this79 & 255);
HXDLIN(  64)													if ((this83 == 0)) {
HXLINE(  64)														b111 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														b111 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float a24;
HXDLIN(  64)													int this84 = ((col3 >> 24) & 255);
HXDLIN(  64)													if ((this84 == 0)) {
HXLINE(  64)														a24 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float r24;
HXDLIN(  64)													int this85 = ((col3 >> 16) & 255);
HXDLIN(  64)													if ((this85 == 0)) {
HXLINE(  64)														r24 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float g24;
HXDLIN(  64)													int this86 = ((col3 >> 8) & 255);
HXDLIN(  64)													if ((this86 == 0)) {
HXLINE(  64)														g24 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float b28;
HXDLIN(  64)													int this87 = (col3 & 255);
HXDLIN(  64)													if ((this87 == 0)) {
HXLINE(  64)														b28 = ((Float)0.);
            													}
            													else {
HXLINE(  64)														b28 = (( (Float)(this87) ) / ( (Float)(255) ));
            													}
HXDLIN(  64)													Float a34 = (a17 * (( (Float)(1) ) - a24));
HXDLIN(  64)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  64)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  64)													int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b28 * a24))));
HXDLIN(  64)													int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  64)													int blended4 = ((((a18 << 24) | (r6 << 16)) | (g6 << 8)) | b29);
HXDLIN(  64)													{
HXLINE(  64)														int imgTarget26;
HXDLIN(  64)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															imgTarget26 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															imgTarget26 = blended4;
            														}
HXDLIN(  64)														::iterMagic::Iimg_obj::set(this20->image,location4,imgTarget26);
            													}
            												}
            												else {
HXLINE(  64)													::Dynamic this88 = this20->image;
HXDLIN(  64)													int index13;
HXDLIN(  64)													if (this20->useVirtualPos) {
HXLINE(  64)														index13 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this20->virtualY) * ( (Float)(this20->width) )) + px1) - this20->virtualX));
            													}
            													else {
HXLINE(  64)														index13 = ::Std_obj::_hx_int(( (Float)(((py1 * this20->width) + px1)) ));
            													}
HXDLIN(  64)													int imgTarget27;
HXDLIN(  64)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														imgTarget27 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE(  64)														imgTarget27 = c13;
            													}
HXDLIN(  64)													::iterMagic::Iimg_obj::set(this88,index13,imgTarget27);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  64)						 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  64)						int v_undoY1;
HXDLIN(  64)						int v_undoX1;
HXDLIN(  64)						Float v_ty1;
HXDLIN(  64)						Float v_tx1;
HXDLIN(  64)						Float v_t01;
HXDLIN(  64)						Float v_sy1;
HXDLIN(  64)						Float v_sx1;
HXDLIN(  64)						Float v_s01;
HXDLIN(  64)						Float v_A1;
HXDLIN(  64)						Float ax = w2;
HXDLIN(  64)						 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  64)						Float bx1 = w2;
HXDLIN(  64)						Float by1 = h;
HXDLIN(  64)						Float cx1 = ( (Float)(0) );
HXDLIN(  64)						Float cy1 = h;
HXDLIN(  64)						bool adjustWinding1 = (((((ax * by1) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (ax * cy1))) > 0);
HXDLIN(  64)						if (!(adjustWinding1)) {
HXLINE(  64)							Float bx_1 = bx1;
HXDLIN(  64)							Float by_1 = by1;
HXLINE(  24)							bx1 = cx1;
HXLINE(  25)							by1 = cy1;
HXLINE(  26)							cx1 = bx_1;
HXLINE(  27)							cy1 = by_1;
            						}
HXLINE(  64)						Float v_ax1 = ax;
HXDLIN(  64)						Float v_ay1 = ( (Float)(0) );
HXDLIN(  64)						Float v_bx1 = bx1;
HXDLIN(  64)						Float v_by1 = by1;
HXDLIN(  64)						Float v_cx1 = cx1;
HXDLIN(  64)						Float v_cy1 = cy1;
HXDLIN(  64)						bool v_preCalculated1 = true;
HXDLIN(  64)						{
HXLINE(  64)							v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  64)							v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  64)							v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  64)							v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  64)							v_tx1 = (v_ay1 - v_by1);
HXDLIN(  64)							v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  64)							v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  64)							Float a19 = v_ax1;
HXDLIN(  64)							Float b30 = v_bx1;
HXDLIN(  64)							Float c14 = v_cx1;
HXDLIN(  64)							if ((a19 > b30)) {
HXLINE(  64)								if ((a19 > c14)) {
HXLINE(  64)									int min9;
HXDLIN(  64)									if ((b30 > c14)) {
HXLINE(  64)										min9 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE(  64)										min9 = ::Math_obj::floor(b30);
            									}
HXDLIN(  64)									int ii_min21 = min9;
HXDLIN(  64)									int ii_max21 = ::Math_obj::ceil(a19);
HXDLIN(  64)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            								}
            								else {
HXLINE(  64)									int ii_min22 = ::Math_obj::floor(b30);
HXDLIN(  64)									int ii_max22 = ::Math_obj::ceil(c14);
HXDLIN(  64)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            								}
            							}
            							else {
HXLINE(  64)								if ((b30 > c14)) {
HXLINE(  64)									int min10;
HXDLIN(  64)									if ((a19 > c14)) {
HXLINE(  64)										min10 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE(  64)										min10 = ::Math_obj::ceil(a19);
            									}
HXDLIN(  64)									int ii_min23 = min10;
HXDLIN(  64)									int ii_max23 = ::Math_obj::ceil(b30);
HXDLIN(  64)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            								}
            								else {
HXLINE(  64)									int ii_min24 = ::Math_obj::floor(a19);
HXDLIN(  64)									int ii_max24 = ::Math_obj::ceil(c14);
HXDLIN(  64)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            							}
HXDLIN(  64)							Float a20 = v_ay1;
HXDLIN(  64)							Float b31 = v_by1;
HXDLIN(  64)							Float c15 = v_cy1;
HXDLIN(  64)							if ((a20 > b31)) {
HXLINE(  64)								if ((a20 > c15)) {
HXLINE(  64)									int min11;
HXDLIN(  64)									if ((b31 > c15)) {
HXLINE(  64)										min11 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE(  64)										min11 = ::Math_obj::floor(b31);
            									}
HXDLIN(  64)									int ii_min25 = min11;
HXDLIN(  64)									int ii_max25 = ::Math_obj::ceil(a20);
HXDLIN(  64)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            								else {
HXLINE(  64)									int ii_min26 = ::Math_obj::floor(b31);
HXDLIN(  64)									int ii_max26 = ::Math_obj::ceil(c15);
HXDLIN(  64)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            							}
            							else {
HXLINE(  64)								if ((b31 > c15)) {
HXLINE(  64)									int min12;
HXDLIN(  64)									if ((a20 > c15)) {
HXLINE(  64)										min12 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE(  64)										min12 = ::Math_obj::ceil(a20);
            									}
HXDLIN(  64)									int ii_min27 = min12;
HXDLIN(  64)									int ii_max27 = ::Math_obj::ceil(b31);
HXDLIN(  64)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            								else {
HXLINE(  64)									int ii_min28 = ::Math_obj::floor(a20);
HXDLIN(  64)									int ii_max28 = ::Math_obj::ceil(c15);
HXDLIN(  64)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            							}
            						}
HXDLIN(  64)						if (hasUndo1) {
HXLINE(  64)							v_undoImage1 = undoImage3;
HXDLIN(  64)							v_undoX1 = xIter31->start;
HXDLIN(  64)							v_undoY1 = yIter31->start;
            						}
            					}
            				}
HXDLIN(  64)				bool imgTarget28;
HXDLIN(  64)				if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  64)					imgTarget28 = includeMask;
            				}
            				else {
HXLINE(  64)					imgTarget28 = false;
            				}
HXDLIN(  64)				if (imgTarget28) {
HXLINE(  64)					 ::pi_xy::ImageStruct v11 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scalingXY(thisImage->mask,sx,sy,thisImage->mask->transparent,includeMask);
HXDLIN(  64)					nextImage1->useMask = true;
HXDLIN(  64)					nextImage1->mask = v11;
            				}
HXDLIN(  64)				imgTarget = nextImage1;
            			}
            		}
            		else {
HXLINE(  64)			imgTarget = here;
            		}
HXLINE(  65)		int wid1 = (this1->width - 1);
HXLINE(  66)		int hi1 = (this1->height - 1);
HXLINE(  67)		do {
HXLINE(  68)			{
HXLINE(  69)				::Dynamic this89 = here->image;
HXDLIN(  69)				int index14;
HXDLIN(  69)				if (here->useVirtualPos) {
HXLINE(  69)					index14 = ::Std_obj::_hx_int(((((( (Float)(q) ) - here->virtualY) * ( (Float)(here->width) )) + p) - here->virtualX));
            				}
            				else {
HXLINE(  69)					index14 = ::Std_obj::_hx_int(( (Float)(((q * here->width) + p)) ));
            				}
HXDLIN(  69)				int c16 = ::iterMagic::Iimg_obj::get(this89,index14);
HXDLIN(  69)				int a25;
HXDLIN(  69)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  69)					a25 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            				}
            				else {
HXLINE(  69)					a25 = c16;
            				}
HXLINE(  70)				::Dynamic this90 = imgTarget->image;
HXDLIN(  70)				int index15;
HXDLIN(  70)				if (imgTarget->useVirtualPos) {
HXLINE(  70)					index15 = ::Std_obj::_hx_int(((((( (Float)(q) ) - imgTarget->virtualY) * ( (Float)(imgTarget->width) )) + p) - imgTarget->virtualX));
            				}
            				else {
HXLINE(  70)					index15 = ::Std_obj::_hx_int(( (Float)(((q * imgTarget->width) + p)) ));
            				}
HXDLIN(  70)				int c17 = ::iterMagic::Iimg_obj::get(this90,index15);
HXLINE(  69)				int b32;
HXLINE(  70)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  69)					b32 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            				}
            				else {
HXLINE(  69)					b32 = c17;
            				}
HXLINE(  68)				int color1 = ((((::Math_obj::round((((t * (( (Float)(((a25 >> 24) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((b32 >> 24) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 24) | (::Math_obj::round((((t * (( (Float)(((a25 >> 16) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((b32 >> 16) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((((t * (( (Float)(((a25 >> 8) & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)(((b32 >> 8) & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((((t * (( (Float)((a25 & 255)) ) / ( (Float)(255) ))) + ((((Float)1.) - t) * (( (Float)((b32 & 255)) ) / ( (Float)(255) )))) * ( (Float)(255) ))));
HXDLIN(  68)				int c18 = color1;
HXDLIN(  68)				bool _hx_tmp2;
HXDLIN(  68)				if ((((c18 >> 24) & 255) < 254)) {
HXLINE(  68)					_hx_tmp2 = out->transparent;
            				}
            				else {
HXLINE(  68)					_hx_tmp2 = false;
            				}
HXDLIN(  68)				if (_hx_tmp2) {
HXLINE(  68)					int location5;
HXDLIN(  68)					if (out->useVirtualPos) {
HXLINE(  68)						location5 = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  68)						location5 = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  68)					int this91 = ::iterMagic::Iimg_obj::get(out->image,location5);
HXDLIN(  68)					int this92;
HXDLIN(  68)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)						this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            					}
            					else {
HXLINE(  68)						this92 = this91;
            					}
HXDLIN(  68)					Float a110;
HXDLIN(  68)					int this93 = ((this92 >> 24) & 255);
HXDLIN(  68)					if ((this93 == 0)) {
HXLINE(  68)						a110 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						a110 = (( (Float)(this93) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float r15;
HXDLIN(  68)					int this94 = ((this92 >> 16) & 255);
HXDLIN(  68)					if ((this94 == 0)) {
HXLINE(  68)						r15 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						r15 = (( (Float)(this94) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float g15;
HXDLIN(  68)					int this95 = ((this92 >> 8) & 255);
HXDLIN(  68)					if ((this95 == 0)) {
HXLINE(  68)						g15 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						g15 = (( (Float)(this95) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float b112;
HXDLIN(  68)					int this96 = (this92 & 255);
HXDLIN(  68)					if ((this96 == 0)) {
HXLINE(  68)						b112 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						b112 = (( (Float)(this96) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float a26;
HXDLIN(  68)					int this97 = ((color1 >> 24) & 255);
HXDLIN(  68)					if ((this97 == 0)) {
HXLINE(  68)						a26 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						a26 = (( (Float)(this97) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float r25;
HXDLIN(  68)					int this98 = ((color1 >> 16) & 255);
HXDLIN(  68)					if ((this98 == 0)) {
HXLINE(  68)						r25 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						r25 = (( (Float)(this98) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float g25;
HXDLIN(  68)					int this99 = ((color1 >> 8) & 255);
HXDLIN(  68)					if ((this99 == 0)) {
HXLINE(  68)						g25 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						g25 = (( (Float)(this99) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float b210;
HXDLIN(  68)					int this100 = (color1 & 255);
HXDLIN(  68)					if ((this100 == 0)) {
HXLINE(  68)						b210 = ((Float)0.);
            					}
            					else {
HXLINE(  68)						b210 = (( (Float)(this100) ) / ( (Float)(255) ));
            					}
HXDLIN(  68)					Float a35 = (a110 * (( (Float)(1) ) - a26));
HXDLIN(  68)					int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a26))));
HXDLIN(  68)					int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a26))));
HXDLIN(  68)					int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a35) + (b210 * a26))));
HXDLIN(  68)					int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a26)));
HXDLIN(  68)					int blended5 = ((((a27 << 24) | (r7 << 16)) | (g7 << 8)) | b33);
HXDLIN(  68)					{
HXLINE(  68)						int _hx_tmp3;
HXDLIN(  68)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)							_hx_tmp3 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            						}
            						else {
HXLINE(  68)							_hx_tmp3 = blended5;
            						}
HXDLIN(  68)						::iterMagic::Iimg_obj::set(out->image,location5,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  68)					::Dynamic this101 = out->image;
HXDLIN(  68)					int index16;
HXDLIN(  68)					if (out->useVirtualPos) {
HXLINE(  68)						index16 = ::Std_obj::_hx_int(((((( (Float)(q) ) - out->virtualY) * ( (Float)(out->width) )) + p) - out->virtualX));
            					}
            					else {
HXLINE(  68)						index16 = ::Std_obj::_hx_int(( (Float)(((q * out->width) + p)) ));
            					}
HXDLIN(  68)					int _hx_tmp4;
HXDLIN(  68)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)						_hx_tmp4 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            					}
            					else {
HXLINE(  68)						_hx_tmp4 = c18;
            					}
HXDLIN(  68)					::iterMagic::Iimg_obj::set(this101,index16,_hx_tmp4);
            				}
            			}
HXLINE(  72)			p = (p + 1);
HXLINE(  73)			if ((p > wid1)) {
HXLINE(  74)				p = xx;
HXLINE(  75)				q = (q + 1);
            			}
            		} while((q <= hi1));
;
HXLINE(  80)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(ColorformImage_Impl__obj,towardsImage,return )


ColorformImage_Impl__obj::ColorformImage_Impl__obj()
{
}

bool ColorformImage_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"greyScale") ) { outValue = greyScale_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"towardsColor") ) { outValue = towardsColor_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"towardsImage") ) { outValue = towardsImage_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ColorformImage_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ColorformImage_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class ColorformImage_Impl__obj::__mClass;

static ::String ColorformImage_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("greyScale",ab,d2,ba,2c),
	HX_("towardsColor",67,44,b2,8a),
	HX_("towardsImage",5f,f2,be,fd),
	::String(null())
};

void ColorformImage_Impl__obj::__register()
{
	ColorformImage_Impl__obj _hx_dummy;
	ColorformImage_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._ColorformImage.ColorformImage_Impl_",20,a5,ee,94);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ColorformImage_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ColorformImage_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ColorformImage_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ColorformImage_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ColorformImage_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _ColorformImage
